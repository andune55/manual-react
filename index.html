<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Curso React</title>	
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">	
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">    
    
    <!-- <script src="https://unpkg.com/@tailwindcss/browser@4"></script> -->
    <link rel="stylesheet" href="./src/assets/prism.css">
    <link rel="stylesheet" href="./src/index.css">
  
    <script type="module" src="./src/assets/prism.js"></script>
    <script type="module" src="./src/assets/jquery-2.1.4.min.js"></script>
    <script type="module" src="./src/assets/desplegar.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./src/main.jsx"></script>	
    <div>  



      <!-- SECCION 17 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 my-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">

        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between" onclick="$('#seccion17').toggle();">
          <h2>Sección 17: PROYECTO - Cotizador de Criptomonedas en Tiempo Real con ZOD y Zustand</h2>
          <span class="cambiaicono ico_chevron_up mr-2.5" title=""></span>
        </div>

        <div id="seccion17">

          <p>Link para css shadows: <a href="https://getcssscan.com/css-box-shadow-examples" class="underline" target="blank">https://getcssscan.com/css-box-shadow-examples</a> / <a href="https://realfavicongenerator.net/" class="underline" target="blank">Link para generar favicon</a> / <a href="https://developers.coindesk.com/" class="underline" target="blank">Link Crypto compare</a></p>

          <p>Instalamos Zod con <span class="destacado">npm i zod</span> / Instalamos Zustand <span class="destacado">npm i zustand</span> / Instalamos axios <span class="destacado">npm i axios</span> que es una librería que simplifica bastante las llamadas/consultas a APIs externas (es una abstracción sobre fetch api).</p>
          

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion17-281').toggle();">
            <h3>281. El Proyecto que vamos a construir / 282. Creando el Proyecto y Copiando Materiales / 283. Primeros pasos con código CSS</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion17-281" class="hidden">
            <p>Vamos a construir un cotizador de criptomonedas. Este proyecto al igual que el anterior se conecta a una API para obtener el precio de una Criptomoneda en dólares, pesos mexicanos y otras monedas (veremos como añadir la de nuestro país). Este proyecto incluye <strong>Zustand para manejar el estado global</strong> y <strong>Zod para validar las respuestas que obtenemos de nuestra API</strong> (recordemos que TS no puede saber qué tipo de dato es lo que obtenemos como respuesta de una API).</p>

            <p class="naranja">Creando el Proyecto y Copiando Materiales</p>

            <ul class="list-disc my-3">
              <li class="my-1.25"><span class="destacado">npm create vite@latest</span> React,  TS + SWC y nombramos como <strong>cripto-react-typescript</strong>, vamos a la carpeta e instalamos dependencias con <span class="destacado">npm install</span>, arrancamos servidor de desarrollo con <span class="destacado">npm run dev</span> y hacemos la limpieza de siempre (borramos carpeta assets y el App.css. limpiamos App.tsx y index.css. Eliminamos de public el svg de vite y colocamos la imagen de fondo para este proyecto que está en los materiales del curso.)</li>
              <li class="my-1.25">Uso <a href="https://realfavicongenerator.net/" class="underline" target="blank">https://realfavicongenerator.net/</a> para generar icono personalizado de app/favicon y pongo todo lo generado en public y en el index.html el código correspondiente:
              <pre><code class="language-html">
                //index.html
                &lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; href=&quot;/favicon-96x96.png&quot; sizes=&quot;96x96&quot; /&gt;
                &lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/favicon.svg&quot; /&gt;
                &lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico&quot; /&gt;
                &lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;180x180&quot; href=&quot;/apple-touch-icon.png&quot; /&gt;
                &lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;cotizador-cripto&quot; /&gt;
                &lt;link rel=&quot;manifest&quot; href=&quot;/site.webmanifest&quot; /&gt;
              </code></pre>
              </li>             
            </ul>

            <p class="naranja">Primeros pasos con código CSS</p>

            <p>Vamos a hacerlo de la forma tradicional sin css modules ni tailwind. Agregamos estilos y al index.html esta fuente:</p>
            <p>Link para css shadows: <a href="https://getcssscan.com/css-box-shadow-examples" class="underline" target="blank">https://getcssscan.com/css-box-shadow-examples</a></p>

            <pre><code class="language-html">
              //index.html
              &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.googleapis.com&quot;&gt;
              &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot; crossorigin&gt;
              &lt;link href=&quot;https://fonts.googleapis.com/css2?family=Outfit:wght@400;700;900&amp;display=swap&quot; rel=&quot;stylesheet&quot;&gt;
            </code></pre>

            <pre><code class="language-css">
              //index.css(completo)
              :root {
                --white: #FFF;
                --primary: #61ECBC;
                --black: #182339;
              }
              html {
                font-size: 62.5%;
              }
              body {
                background-image: url('/bg.jpg');
                background-position: center;
                background-repeat: no-repeat;
                background-size: cover;
                min-height: 100vh;
                font-family: 'Outfit', sans-serif;
                font-size: 2rem;
              }
              .container {
                max-width: 60rem;
                width: 95%;
                margin: 0 auto;
              }
              .app-title {
                font-size: 3.8rem;
                margin-top: 5rem;
                color: var(--white);
                line-height: .8;
              }
              .app-title span {
                display: block;
                color: var(--primary);
                font-size: 4.4rem;
              }
              .content {
                margin-top: 5rem;
                padding: 6rem 2rem;
                background-color: var(--white);
                border-radius: 1rem;
                box-shadow: rgba(0, 0, 0, 0.1) 0px 4px 12px;
              }
              
              .form,
              .field {
                display: flex;
                flex-direction: column;
                gap: 2rem;
              }
              .form label {
                color: var(--black);
              }
              .form select {
                background-color: #ECEBEB;
                border: none;
                padding: 1rem;
                border-radius: 1rem;
                font-size: 1.8rem;
              }
              .form [type="submit"] {
                background-color: var(--primary);
                color: var(--black);
                border: none;
                padding: 1rem;
                font-weight: 900;
                cursor: pointer;
                text-transform: uppercase;
                margin-top: 2rem;
                transition: background-color 300ms ease;
              }
              .form [type="submit"]:hover {
                background-color: #0CB387;
              }
              
              .result-wrapper {
                margin-top: 5rem;
              }
              .result-wrapper h2 {
                text-align: center;
              }
              .result {
                display: grid;
                grid-template-columns: 1fr 3fr;
                align-items: center;
                gap: 1rem;
              }
              .result img {
                width: 100%;
              }
              .result p {
                margin: 0 0 1rem;
                font-size: 1.6rem;
              }
              .result span {
                font-weight: 700;
              }
            </code></pre>

            <img src="./src/assets/img/283.jpg" alt="img" loading="lazy">

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion17-284').toggle();">
            <h3>284. Creando El Formulario / 285. Agregando las Monedas para Cotizar Criptos / 286. Schema de Zod y Mostrando las Monedas</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion17-284" class="hidden">
            <p>Vamos a crear el formulario que nos va a permitir buscar las criptomendas y cotizarlas. Vamos a src y creamos las carpetas de <span class="file">components, data, schema y types</span></p>

            <p>Nuestro primer componente es este <span class="file">components/CriptoSearchForm.tsx</span> en el que tenemos:
              
              <ul class="list-disc my-3">
                <li class="my-1.25"><p>Un primer div para la moneda con un label con su <strong>htmlFor="currency"</strong> que apunta al <strong>id="currency"</strong> de nuestro select. Ese select también tendrá el mismo <strong>name="currency"</strong>; este name nos va a permitir escribir en el state cuando estemos ya seleccionando lo que queremos cotizar en nuestra API.</p></li>

                <li class="my-1.25"><p>Un segundo div para la criptomoneda con su <strong>htmlFor="criptocurrency"</strong> que apunta al <strong>id="criptocurrency"</strong> de nuestro select. Ese select también tendrá el mismo <strong>name="criptocurrency"</strong>; este name nos va a permitir escribir en el state.</p></li>

                <li class="my-1.25"><p>Un input de <strong>type="submit"</strong> con <strong>value="cotizar"</strong></p></li>
              </ul>

              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre data-line="0"><code class="language-ts">
                    //CriptoSearchForm.tsx
                    export default function CriptoSearchForm() {
                      return (
                        &lt;form className=&quot;form&quot;&gt;
                          &lt;div className=&quot;field&quot;&gt;
                            &lt;label htmlFor=&quot;currency&quot;&gt;Moneda:&lt;/label&gt;
                            &lt;select name=&quot;currency&quot; id=&quot;currency&quot;&gt;
                                &lt;option value=&quot;&quot;&gt;-- Seleccione --&lt;/option&gt;
                            &lt;/select&gt;
                          &lt;/div&gt;
                
                          &lt;div className=&quot;field&quot;&gt;
                            &lt;label htmlFor=&quot;criptocurrency&quot;&gt;Criptomoneda:&lt;/label&gt;
                            &lt;select name=&quot;criptocurrency&quot; id=&quot;criptocurrency&quot;&gt;
                                &lt;option value=&quot;&quot;&gt;-- Seleccione --&lt;/option&gt;
                            &lt;/select&gt;
                          &lt;/div&gt;
                
                          &lt;input type=&quot;submit&quot; value=&quot;cotizar&quot;/&gt;
                        &lt;/form&gt;
                      )
                    }
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%] ml-2">
                  <img src="./src/assets/img/285.png" alt="img" loading="lazy">
                </div>
              </div>

            <p class="naranja">Agregando las Monedas para Cotizar Criptos - <a href="https://gist.github.com/codigoconjuan/19cf022c1e657e85150c8ef7ff0aefe3" class="underline" target="blank">Gist Monedas para cotizar cripto</a> / Schema de Zod y Mostrando las Monedas</p>
          
            <p>Tenemos dos selects. Veamos como agregar en el primero las monedas que vamos a cotizar en criptomonedas y en el segundo, veremos como consultarlo desde una API. Creemos el type <span class="bg-[#4ec9b0] text-white">Currency</span> utilizando Zod para ello: instalamos Zod con <span class="destacado">npm i zod</span></p>

            <ul class="list-disc my-3">
              <li class="my-1.25">Creamos <span class="file">data/index.ts</span> donde metemos el gist con las 4 monedas que hay (La APi no soporta todas las monedas existentes pero si queremos agregar la de nuestro país solo tenemos que buscar nuestra moneda y encontrar el código de 3 dígitos.)
                <pre data-line="0"><code class="language-ts">
                  //data/index.ts
                  import { Currency } from "../types";

                  export const currencies : Currency[] = [
                    { code: 'USD', name: 'Dolar de Estados Unidos'},
                    { code: 'MXN', name: 'Peso Mexicano'},
                    { code: 'EUR', name: 'Euro'},
                    { code: 'GBP', name: 'Libra Esterlina'},
                  ]
                </code></pre>
              </li>

              <li class="my-1.25">Creamos <span class="file">schema/crypto-schema.ts</span> donde generamos el schema para el type currency. Importamos la 'z' de Zod y diseñamos nuestro schema para el type de currency (que como vemos es el type que se utiliza en nuestros datos, en el Gist de nuestras monedas para cotizar cryptos); vemos en los datos que tenemos un code (string) y un name (string) por tanto:
                <pre data-line="0"><code class="language-ts">
                  //schema/crypto-schema.ts
                  import { z } from 'zod'
                  export const CurrencySchema = z.object({
                      code: z.string(),
                      name: z.string()
                  })
                </code></pre>
              </li>

              <li class="my-1.25">Creamos <span class="file">types/index.ts</span> donde importamos la z de Zod (usaremos la función infer) y nuestro schema y creamos (y exportamos) el type <span class="bg-[#4ec9b0] text-white">Currency</span> usando el método z.infer de Zod y el schema creado. 
                <pre data-line="0"><code class="language-ts">
                  //types/index.ts
                  import { z } from 'zod'
                  import { CurrencySchema} from '../schema/crypto-schema'
                  export type Currency = z.infer&lt;typeof CurrencySchema&gt;
                </code></pre>
              </li>

              <li class="my-1.25">Así queda nuestro componente de formulario <span class="file">components/CriptoSearchForm.tsx</span> donde importamos nuestros datos y utilizamos ese objeto currencies importado para mapearlo y rellenar el primer select con esos datos:
                <pre data-line="0,1,9-11"><code class="language-ts">
                  //CriptoSearchForm.tsx
                  import { currencies } from '../data/index.ts';
                  export default function CriptoSearchForm() {
                      return (
                        &lt;form className=&quot;form&quot;&gt;
                          &lt;div className=&quot;field&quot;&gt;
                            &lt;label htmlFor=&quot;currency&quot;&gt;Moneda:&lt;/label&gt;
                            &lt;select name=&quot;currency&quot; id=&quot;currency&quot;&gt;
                                &lt;option value=&quot;&quot;&gt;-- Seleccione --&lt;/option&gt;
                                {currencies.map( currency =&gt; (
                                    &lt;option key={currency.code} value={currency.code}&gt;{currency.name}&lt;/option&gt;
                                ))}
                            &lt;/select&gt;
                          &lt;/div&gt;
              
                          &lt;div className=&quot;field&quot;&gt;
                            &lt;label htmlFor=&quot;criptocurrency&quot;&gt;Criptomoneda:&lt;/label&gt;
                            &lt;select name=&quot;criptocurrency&quot; id=&quot;criptocurrency&quot;&gt;
                                &lt;option value=&quot;&quot;&gt;-- Seleccione --&lt;/option&gt;                    
                            &lt;/select&gt;
                          &lt;/div&gt;
              
                          &lt;input type=&quot;submit&quot; value=&quot;cotizar&quot;/&gt;
                        &lt;/form&gt;
                      )
                  }
                </code></pre>
              
              </li>

              <li class="my-1.25">El segundo select que presenta las criptomendas las recupera desde una API y las vamos a colocar en un store de Zustand para poder tener acceso a esa información de forma global.</li>
            </ul>
            

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion17-287').toggle();">
            <h3>287. Creando el Store de Zustand - <a href="https://developers.coindesk.com/" class="underline" target="blank">Enlace Crypto compare</a></h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion17-287" class="hidden">
            <p>Vamos a ver la API que vamos a utilizar <a href="https://developers.coindesk.com/" class="underline" target="blank">Crypto compare</a> y también configurar nuestro store.</p>

            <p>Si vamos a este link (ha cambiado con respecto al vídeo) <a href="https://developers.coindesk.com/documentation/data-api/asset_v1_top_list" class="underline" target="blank">https://developers.coindesk.com/documentation/data-api/asset_v1_top_list</a> vemos un montón de endpoints que podemos utilizar. El que vamos a usar está en toplist en su vídeo: <strong>TopList by Market Cap Full Data</strong> aunque en la actual interfaz de la API que ha cambiado mucho de momento no lo encuentro así que <span class="destacado">pico a mano este endpoint:</span> <a href="https://min-api.cryptocompare.com/data/top/mktcapfull?limit=20&tsym=EUR" class="underline" target="blank">https://min-api.cryptocompare.com/data/top/mktcapfull?limit=20&tsym=EUR</a> donde se ve el JSON devuelto en respuesta a especificar ese <strong>limit=20</strong> (las 20 criptos que tienen más valor hoy en día en cuanto a volumen de transacciones) cotizado en <strong>EUR</strong>.</p>
              
            <p>Si lo vemos en chrome, vemos que ese JSON es muy grande y no lo requerimos todo, pero básicamente es lo que requerimos para rellenar el segundo select de nuestro formulario, porque <strong>cuando coticemos una criptomoneda requerimos pasarle el código de 3 dígitos de la cripto (eso ya viene en ese JSON: "Name": "BTC"). Además, como son las 20 criptos, digamos, más valiosas, con el paso del tiempo si alguna cripto eleva su valor esa lista se va a actualizar en automático con lo cual tiene sus ventajas.</strong></p>

            <pre data-line="0,12" class="max-h-[400px] overflow-auto"><code class="language-ts">
              //https://min-api.cryptocompare.com/data/top/mktcapfull?limit=20&tsym=EUR
              {
                "Message": "Success",
                "Type": 100,
                "MetaData": {
                    "Count": 846
                },
                "SponsoredData": [],
                "Data": [
                    {
                      "CoinInfo": {
                          "Id": "1182",
                          "Name": "BTC",
                          "FullName": "Bitcoin",
                          "Internal": "BTC",
                          "ImageUrl": "/media/37746251/btc.png",
                          "Url": "/coins/btc/overview",
                          "Algorithm": "SHA-256",
                          "ProofType": "PoW",
                          "Rating": {
                              "Weiss": {
                                  "Rating": "B+",
                                  "TechnologyAdoptionRating": "A-",
                                  "MarketPerformanceRating": "D"
                              }
                          },
                          "NetHashesPerSecond": "791871604565720800000",
                          "BlockNumber": 890101,
                          "BlockTime": 447,
                          "BlockReward": 3.125,
                          "AssetLaunchDate": "2009-01-03",
                          "MaxSupply": 20999999.9769,
                          "Type": 1,
                          "DocumentType": "Webpagecoinp"
                      },
                      "RAW": {
                          "EUR": {
                              "TYPE": "5",
                              "MARKET": "CCCAGG",
                              "FROMSYMBOL": "BTC",
                              "TOSYMBOL": "EUR",
                              "FLAGS": "1",
                              "LASTMARKET": "CCCAGG",
                              "MEDIAN": 76895.7535701053,
                              "TOPTIERVOLUME24HOUR": 892.63259069,
                              "TOPTIERVOLUME24HOURTO": 68213713.8471543,
                              "LASTTRADEID": "98954660",
                              "PRICE": 76895.7535701053,
                              "LASTUPDATE": 1743333001,
                              "LASTVOLUME": 0.02308,
                              "LASTVOLUMETO": 1776.4138236,
                              "VOLUMEHOUR": 14.45578055,
                              "VOLUMEHOURTO": 1111032.97889921,
                              "OPENHOUR": 76834.2564036766,
                              "HIGHHOUR": 76896.4345706239,
                              "LOWHOUR": 76813.4973879916,
                              "VOLUMEDAY": 357.18943215,
                              "VOLUMEDAYTO": 27451231.4808115,
                              "OPENDAY": 76372.6985992196,
                              "HIGHDAY": 77205.9689519402,
                              "LOWDAY": 76256.8479553021,
                              "VOLUME24HOUR": 892.63259069,
                              "VOLUME24HOURTO": 68213713.8471543,
                              "OPEN24HOUR": 75971.7997263603,
                              "HIGH24HOUR": 77205.9689519402,
                              "LOW24HOUR": 75458.109523385,
                              "CHANGE24HOUR": 923.9538437449955,
                              "CHANGEPCT24HOUR": 1.2161800129428904,
                              "CHANGEDAY": 523.0549708856997,
                              "CHANGEPCTDAY": 0.6848716628837893,
                              "CHANGEHOUR": 61.49716642870044,
                              "CHANGEPCTHOUR": 0.08003873442283713,
                              "CONVERSIONTYPE": "direct",
                              "CONVERSIONSYMBOL": "",
                              "CONVERSIONLASTUPDATE": 1743333001,
                              "SUPPLY": 19844050,
                              "MKTCAP": 1525923178632.8481,
                              "MKTCAPPENALTY": 0,
                              "CIRCULATINGSUPPLY": 19844050,
                              "CIRCULATINGSUPPLYMKTCAP": 1525923178632.8481,
                              "TOTALVOLUME24H": 106121.590191332,
                              "TOTALVOLUME24HTO": 8159873705.945181,
                              "TOTALTOPTIERVOLUME24H": 59625.266290882704,
                              "TOTALTOPTIERVOLUME24HTO": 4584503841.380434,
                              "IMAGEURL": "/media/37746251/btc.png"
                          }
                        },
                        "DISPLAY": {
                            "EUR": {
                                "FROMSYMBOL": "Ƀ",
                                "TOSYMBOL": "€",
                                "MARKET": "CryptoCompare Index",
                                "LASTMARKET": "CCCAGG",
                                "TOPTIERVOLUME24HOUR": "Ƀ 892.63",
                                "TOPTIERVOLUME24HOURTO": "€ 68,213,713.8",
                                "LASTTRADEID": "98954660",
                                "PRICE": "€ 76,895.8",
                                "LASTUPDATE": "Just now",
                                "LASTVOLUME": "Ƀ 0.02308",
                                "LASTVOLUMETO": "€ 1,776.41",
                                "VOLUMEHOUR": "Ƀ 14.46",
                                "VOLUMEHOURTO": "€ 1,111,033.0",
                                "OPENHOUR": "€ 76,834.3",
                                "HIGHHOUR": "€ 76,896.4",
                                "LOWHOUR": "€ 76,813.5",
                                "VOLUMEDAY": "Ƀ 357.19",
                                "VOLUMEDAYTO": "€ 27,451,231.5",
                                "OPENDAY": "€ 76,372.7",
                                "HIGHDAY": "€ 77,206.0",
                                "LOWDAY": "€ 76,256.8",
                                "VOLUME24HOUR": "Ƀ 892.63",
                                "VOLUME24HOURTO": "€ 68,213,713.8",
                                "OPEN24HOUR": "€ 75,971.8",
                                "HIGH24HOUR": "€ 77,206.0",
                                "LOW24HOUR": "€ 75,458.1",
                                "CHANGE24HOUR": "€ 923.95",
                                "CHANGEPCT24HOUR": "1.22",
                                "CHANGEDAY": "€ 523.05",
                                "CHANGEPCTDAY": "0.68",
                                "CHANGEHOUR": "€ 61.50",
                                "CHANGEPCTHOUR": "0.08",
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": "Just now",
                                "SUPPLY": "Ƀ 19,844,050.0",
                                "MKTCAP": "€ 1,525.92 B",
                                "MKTCAPPENALTY": "0 %",
                                "CIRCULATINGSUPPLY": "Ƀ 19,844,050.0",
                                "CIRCULATINGSUPPLYMKTCAP": "€ 1,525.92 B",
                                "TOTALVOLUME24H": "Ƀ 106.12 K",
                                "TOTALVOLUME24HTO": "€ 8.16 B",
                                "TOTALTOPTIERVOLUME24H": "Ƀ 59.63 K",
                                "TOTALTOPTIERVOLUME24HTO": "€ 4.58 B",
                                "IMAGEURL": "/media/37746251/btc.png"
                            }
                        }
                    },
                    {
                        "CoinInfo": {
                            "Id": "7605",
                            "Name": "ETH",
                            "FullName": "Ethereum",
                            "Internal": "ETH",
                            "ImageUrl": "/media/37746238/eth.png",
                            "Url": "/coins/eth/overview",
                            "Algorithm": "Ethash",
                            "ProofType": "PoS",
                            "Rating": {
                                "Weiss": {
                                    "Rating": "B-",
                                    "TechnologyAdoptionRating": "B",
                                    "MarketPerformanceRating": "D"
                                }
                            },
                            "NetHashesPerSecond": 0,
                            "BlockNumber": 22159231,
                            "BlockTime": 12,
                            "BlockReward": 2.044338104121828,
                            "AssetLaunchDate": "2015-07-30",
                            "MaxSupply": -1,
                            "Type": 1,
                            "DocumentType": "Webpagecoinp"
                        },
                        "RAW": {
                            "EUR": {
                                "TYPE": "5",
                                "MARKET": "CCCAGG",
                                "FROMSYMBOL": "ETH",
                                "TOSYMBOL": "EUR",
                                "FLAGS": "1",
                                "LASTMARKET": "CCCAGG",
                                "MEDIAN": 1694.30728395784,
                                "TOPTIERVOLUME24HOUR": 32144.59582677,
                                "TOPTIERVOLUME24HOURTO": 54310623.3676413,
                                "LASTTRADEID": "59746632",
                                "PRICE": 1694.30728395784,
                                "LASTUPDATE": 1743333005,
                                "LASTVOLUME": 0.02364152,
                                "LASTVOLUMETO": 40.0577186576,
                                "VOLUMEHOUR": 189.86211777,
                                "VOLUMEHOURTO": 321361.318930532,
                                "OPENHOUR": 1691.65330453031,
                                "HIGHHOUR": 1694.30728395784,
                                "LOWHOUR": 1691.31509799771,
                                "VOLUMEDAY": 8920.19732111,
                                "VOLUMEDAYTO": 15139252.2655218,
                                "OPENDAY": 1689.18241841159,
                                "HIGHDAY": 1708.18109673839,
                                "LOWDAY": 1675.66776980908,
                                "VOLUME24HOUR": 32144.59582677,
                                "VOLUME24HOURTO": 54310623.3676413,
                                "OPEN24HOUR": 1702.85262563368,
                                "HIGH24HOUR": 1720.84963524357,
                                "LOW24HOUR": 1661.59308200996,
                                "CHANGE24HOUR": -8.545341675840064,
                                "CHANGEPCT24HOUR": -0.5018250873389645,
                                "CHANGEDAY": 5.124865546249794,
                                "CHANGEPCTDAY": 0.3033932564292803,
                                "CHANGEHOUR": 2.6539794275299755,
                                "CHANGEPCTHOUR": 0.15688672261760261,
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": 1743333005,
                                "SUPPLY": 120654458.547835,
                                "MKTCAP": 204425727959.58612,
                                "MKTCAPPENALTY": 0,
                                "CIRCULATINGSUPPLY": 120654458.547835,
                                "CIRCULATINGSUPPLYMKTCAP": 204425727959.58612,
                                "TOTALVOLUME24H": 3180855.98895283,
                                "TOTALVOLUME24HTO": 5389195271.822162,
                                "TOTALTOPTIERVOLUME24H": 2162261.5823681,
                                "TOTALTOPTIERVOLUME24HTO": 3663383349.3469405,
                                "IMAGEURL": "/media/37746238/eth.png"
                            }
                        },
                        "DISPLAY": {
                            "EUR": {
                                "FROMSYMBOL": "Ξ",
                                "TOSYMBOL": "€",
                                "MARKET": "CryptoCompare Index",
                                "LASTMARKET": "CCCAGG",
                                "TOPTIERVOLUME24HOUR": "Ξ 32,144.6",
                                "TOPTIERVOLUME24HOURTO": "€ 54,310,623.4",
                                "LASTTRADEID": "59746632",
                                "PRICE": "€ 1,694.31",
                                "LASTUPDATE": "Just now",
                                "LASTVOLUME": "Ξ 0.02364",
                                "LASTVOLUMETO": "€ 40.06",
                                "VOLUMEHOUR": "Ξ 189.86",
                                "VOLUMEHOURTO": "€ 321,361.3",
                                "OPENHOUR": "€ 1,691.65",
                                "HIGHHOUR": "€ 1,694.31",
                                "LOWHOUR": "€ 1,691.32",
                                "VOLUMEDAY": "Ξ 8,920.20",
                                "VOLUMEDAYTO": "€ 15,139,252.3",
                                "OPENDAY": "€ 1,689.18",
                                "HIGHDAY": "€ 1,708.18",
                                "LOWDAY": "€ 1,675.67",
                                "VOLUME24HOUR": "Ξ 32,144.6",
                                "VOLUME24HOURTO": "€ 54,310,623.4",
                                "OPEN24HOUR": "€ 1,702.85",
                                "HIGH24HOUR": "€ 1,720.85",
                                "LOW24HOUR": "€ 1,661.59",
                                "CHANGE24HOUR": "€ -8.55",
                                "CHANGEPCT24HOUR": "-0.50",
                                "CHANGEDAY": "€ 5.12",
                                "CHANGEPCTDAY": "0.30",
                                "CHANGEHOUR": "€ 2.65",
                                "CHANGEPCTHOUR": "0.16",
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": "Just now",
                                "SUPPLY": "Ξ 120,654,458.5",
                                "MKTCAP": "€ 204.43 B",
                                "MKTCAPPENALTY": "0 %",
                                "CIRCULATINGSUPPLY": "Ξ 120,654,458.5",
                                "CIRCULATINGSUPPLYMKTCAP": "€ 204.43 B",
                                "TOTALVOLUME24H": "Ξ 3.18 M",
                                "TOTALVOLUME24HTO": "€ 5.39 B",
                                "TOTALTOPTIERVOLUME24H": "Ξ 2.16 M",
                                "TOTALTOPTIERVOLUME24HTO": "€ 3.66 B",
                                "IMAGEURL": "/media/37746238/eth.png"
                            }
                        }
                    },
                    {
                        "CoinInfo": {
                            "Id": "5031",
                            "Name": "XRP",
                            "FullName": "XRP",
                            "Internal": "XRP",
                            "ImageUrl": "/media/38553096/xrp.png",
                            "Url": "/coins/xrp/overview",
                            "Algorithm": "N/A",
                            "ProofType": "XRP LCP",
                            "Rating": {
                                "Weiss": {
                                    "Rating": "B-",
                                    "TechnologyAdoptionRating": "B-",
                                    "MarketPerformanceRating": "C-"
                                }
                            },
                            "NetHashesPerSecond": 0,
                            "BlockNumber": 95118393,
                            "BlockTime": 0,
                            "BlockReward": 0,
                            "AssetLaunchDate": "2012-09-26",
                            "MaxSupply": 100000000000,
                            "Type": 1,
                            "DocumentType": "Webpagecoinp"
                        },
                        "RAW": {
                            "EUR": {
                                "TYPE": "5",
                                "MARKET": "CCCAGG",
                                "FROMSYMBOL": "XRP",
                                "TOSYMBOL": "EUR",
                                "FLAGS": "1",
                                "LASTMARKET": "CCCAGG",
                                "MEDIAN": 2.00425078237658,
                                "TOPTIERVOLUME24HOUR": 19160311.9832586,
                                "TOPTIERVOLUME24HOURTO": 37869967.303051,
                                "LASTTRADEID": "28899165",
                                "PRICE": 2.00425078237658,
                                "LASTUPDATE": 1743333006,
                                "LASTVOLUME": 2,
                                "LASTVOLUMETO": 4.006,
                                "VOLUMEHOUR": 270968.16377469,
                                "VOLUMEHOURTO": 541922.827578376,
                                "OPENHOUR": 1.99634549302565,
                                "HIGHHOUR": 2.00427837942756,
                                "LOWHOUR": 1.9963062750624,
                                "VOLUMEDAY": 7890265.18086796,
                                "VOLUMEDAYTO": 15866682.7787643,
                                "OPENDAY": 1.97251979979156,
                                "HIGHDAY": 2.04540101896933,
                                "LOWDAY": 1.9562820397931,
                                "VOLUME24HOUR": 19160311.9832586,
                                "VOLUME24HOURTO": 37869967.303051,
                                "OPEN24HOUR": 1.92351599431083,
                                "HIGH24HOUR": 2.04540101896933,
                                "LOW24HOUR": 1.91466895244715,
                                "CHANGE24HOUR": 0.08073478806574985,
                                "CHANGEPCT24HOUR": 4.197250675561762,
                                "CHANGEDAY": 0.03173098258501983,
                                "CHANGEPCTDAY": 1.6086521711149822,
                                "CHANGEHOUR": 0.007905289350929934,
                                "CHANGEPCTHOUR": 0.39598803806993965,
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": 1743333006,
                                "SUPPLY": 99986282177.8299,
                                "MKTCAP": 200397584281.841,
                                "MKTCAPPENALTY": 0,
                                "CIRCULATINGSUPPLY": 58205697378,
                                "CIRCULATINGSUPPLYMKTCAP": 116658814508.63094,
                                "TOTALVOLUME24H": 1176135376.53573,
                                "TOTALVOLUME24HTO": 2356738145.6225357,
                                "TOTALTOPTIERVOLUME24H": 716643541.9900404,
                                "TOTALTOPTIERVOLUME24HTO": 1435801276.7386875,
                                "IMAGEURL": "/media/38553096/xrp.png"
                            }
                        },
                        "DISPLAY": {
                            "EUR": {
                                "FROMSYMBOL": "XRP",
                                "TOSYMBOL": "€",
                                "MARKET": "CryptoCompare Index",
                                "LASTMARKET": "CCCAGG",
                                "TOPTIERVOLUME24HOUR": "XRP 19,160,312.0",
                                "TOPTIERVOLUME24HOURTO": "€ 37,869,967.3",
                                "LASTTRADEID": "28899165",
                                "PRICE": "€ 2.00",
                                "LASTUPDATE": "Just now",
                                "LASTVOLUME": "XRP 2.00",
                                "LASTVOLUMETO": "€ 4.01",
                                "VOLUMEHOUR": "XRP 270,968.2",
                                "VOLUMEHOURTO": "€ 541,922.8",
                                "OPENHOUR": "€ 2.00",
                                "HIGHHOUR": "€ 2.00",
                                "LOWHOUR": "€ 2.00",
                                "VOLUMEDAY": "XRP 7,890,265.2",
                                "VOLUMEDAYTO": "€ 15,866,682.8",
                                "OPENDAY": "€ 1.97",
                                "HIGHDAY": "€ 2.05",
                                "LOWDAY": "€ 1.96",
                                "VOLUME24HOUR": "XRP 19,160,312.0",
                                "VOLUME24HOURTO": "€ 37,869,967.3",
                                "OPEN24HOUR": "€ 1.92",
                                "HIGH24HOUR": "€ 2.05",
                                "LOW24HOUR": "€ 1.91",
                                "CHANGE24HOUR": "€ 0.081",
                                "CHANGEPCT24HOUR": "4.20",
                                "CHANGEDAY": "€ 0.032",
                                "CHANGEPCTDAY": "1.61",
                                "CHANGEHOUR": "€ 0.0079",
                                "CHANGEPCTHOUR": "0.40",
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": "Just now",
                                "SUPPLY": "XRP 99,986,282,177.8",
                                "MKTCAP": "€ 200.40 B",
                                "MKTCAPPENALTY": "0 %",
                                "CIRCULATINGSUPPLY": "XRP 58,205,697,378.0",
                                "CIRCULATINGSUPPLYMKTCAP": "€ 116.66 B",
                                "TOTALVOLUME24H": "XRP 1.18 B",
                                "TOTALVOLUME24HTO": "€ 2.36 B",
                                "TOTALTOPTIERVOLUME24H": "XRP 716.64 M",
                                "TOTALTOPTIERVOLUME24HTO": "€ 1.44 B",
                                "IMAGEURL": "/media/38553096/xrp.png"
                            }
                        }
                    },
                    {
                        "CoinInfo": {
                            "Id": "171986",
                            "Name": "USDT",
                            "FullName": "Tether",
                            "Internal": "USDT",
                            "ImageUrl": "/media/37746338/usdt.png",
                            "Url": "/coins/usdt/overview",
                            "Algorithm": "N/A",
                            "ProofType": "N/A",
                            "Rating": {
                                "Weiss": {
                                    "Rating": "",
                                    "TechnologyAdoptionRating": "",
                                    "MarketPerformanceRating": ""
                                }
                            },
                            "NetHashesPerSecond": 0,
                            "BlockNumber": 0,
                            "BlockTime": 0,
                            "BlockReward": 0,
                            "AssetLaunchDate": "2014-10-06",
                            "MaxSupply": -1,
                            "Type": 1,
                            "DocumentType": "Webpagecoinp"
                        },
                        "RAW": {
                            "EUR": {
                                "TYPE": "5",
                                "MARKET": "CCCAGG",
                                "FROMSYMBOL": "USDT",
                                "TOSYMBOL": "EUR",
                                "FLAGS": "2",
                                "LASTMARKET": "CCCAGG",
                                "MEDIAN": 0.92433686882227,
                                "TOPTIERVOLUME24HOUR": 26568479.9995615,
                                "TOPTIERVOLUME24HOURTO": 24553388.6419313,
                                "LASTTRADEID": "89196040",
                                "PRICE": 0.92433686882227,
                                "LASTUPDATE": 1743333005,
                                "LASTVOLUME": 1000,
                                "LASTVOLUMETO": 924.04,
                                "VOLUMEHOUR": 363921.271945405,
                                "VOLUMEHOURTO": 336434.271063821,
                                "OPENHOUR": 0.924621906706507,
                                "HIGHHOUR": 0.924756073234941,
                                "LOWHOUR": 0.924302782613197,
                                "VOLUMEDAY": 9160673.29408372,
                                "VOLUMEDAYTO": 8468202.48706929,
                                "OPENDAY": 0.924309699396123,
                                "HIGHDAY": 0.924756073234941,
                                "LOWDAY": 0.923989302606001,
                                "VOLUME24HOUR": 26568479.9995615,
                                "VOLUME24HOURTO": 24553388.6419313,
                                "OPEN24HOUR": 0.923448926791114,
                                "HIGH24HOUR": 0.924756073234941,
                                "LOW24HOUR": 0.923335377852067,
                                "CHANGE24HOUR": 0.0008879420311559416,
                                "CHANGEPCT24HOUR": 0.0961549692024057,
                                "CHANGEDAY": 0.00002716942614700013,
                                "CHANGEPCTDAY": 0.002939428869430957,
                                "CHANGEHOUR": -0.00028503788423706045,
                                "CHANGEPCTHOUR": -0.030827507132332847,
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": 1743333005,
                                "SUPPLY": 151269622595.6422,
                                "MKTCAP": 139824089297.98242,
                                "MKTCAPPENALTY": 0,
                                "CIRCULATINGSUPPLY": 144182349120.78696,
                                "CIRCULATINGSUPPLYMKTCAP": 133273061125.74759,
                                "TOTALVOLUME24H": 131956030.004115,
                                "TOTALVOLUME24HTO": 121966986.62599067,
                                "TOTALTOPTIERVOLUME24H": 130083856.65124026,
                                "TOTALTOPTIERVOLUME24HTO": 120236467.77110195,
                                "IMAGEURL": "/media/37746338/usdt.png"
                            }
                        },
                        "DISPLAY": {
                            "EUR": {
                                "FROMSYMBOL": "₮",
                                "TOSYMBOL": "€",
                                "MARKET": "CryptoCompare Index",
                                "LASTMARKET": "CCCAGG",
                                "TOPTIERVOLUME24HOUR": "₮ 26,568,480.0",
                                "TOPTIERVOLUME24HOURTO": "€ 24,553,388.6",
                                "LASTTRADEID": "89196040",
                                "PRICE": "€ 0.9243",
                                "LASTUPDATE": "Just now",
                                "LASTVOLUME": "₮ 1,000.00",
                                "LASTVOLUMETO": "€ 924.04",
                                "VOLUMEHOUR": "₮ 363,921.3",
                                "VOLUMEHOURTO": "€ 336,434.3",
                                "OPENHOUR": "€ 0.9246",
                                "HIGHHOUR": "€ 0.9248",
                                "LOWHOUR": "€ 0.9243",
                                "VOLUMEDAY": "₮ 9,160,673.3",
                                "VOLUMEDAYTO": "€ 8,468,202.5",
                                "OPENDAY": "€ 0.9243",
                                "HIGHDAY": "€ 0.9248",
                                "LOWDAY": "€ 0.9240",
                                "VOLUME24HOUR": "₮ 26,568,480.0",
                                "VOLUME24HOURTO": "€ 24,553,388.6",
                                "OPEN24HOUR": "€ 0.9234",
                                "HIGH24HOUR": "€ 0.9248",
                                "LOW24HOUR": "€ 0.9233",
                                "CHANGE24HOUR": "€ 0.00089",
                                "CHANGEPCT24HOUR": "0.10",
                                "CHANGEDAY": "€ 0.000027",
                                "CHANGEPCTDAY": "0.00",
                                "CHANGEHOUR": "€ -0.00029",
                                "CHANGEPCTHOUR": "-0.03",
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": "Just now",
                                "SUPPLY": "₮ 151,269,622,595.6",
                                "MKTCAP": "€ 139.82 B",
                                "MKTCAPPENALTY": "0 %",
                                "CIRCULATINGSUPPLY": "₮ 144,182,349,120.8",
                                "CIRCULATINGSUPPLYMKTCAP": "€ 133.27 B",
                                "TOTALVOLUME24H": "₮ 131.96 M",
                                "TOTALVOLUME24HTO": "€ 121.97 M",
                                "TOTALTOPTIERVOLUME24H": "₮ 130.08 M",
                                "TOTALTOPTIERVOLUME24HTO": "€ 120.24 M",
                                "IMAGEURL": "/media/37746338/usdt.png"
                            }
                        }
                    },
                    {
                        "CoinInfo": {
                            "Id": "204788",
                            "Name": "BNB",
                            "FullName": "Binance Coin",
                            "Internal": "BNB",
                            "ImageUrl": "/media/40485170/bnb.png",
                            "Url": "/coins/bnb/overview",
                            "Algorithm": "BEP-2",
                            "ProofType": "PoSA",
                            "Rating": {
                                "Weiss": {
                                    "Rating": "C",
                                    "TechnologyAdoptionRating": "C",
                                    "MarketPerformanceRating": "C-"
                                }
                            },
                            "NetHashesPerSecond": 0,
                            "BlockNumber": 47916670,
                            "BlockTime": 3,
                            "BlockReward": 0,
                            "AssetLaunchDate": "2019-04-18",
                            "MaxSupply": 100000000,
                            "Type": 1,
                            "DocumentType": "Webpagecoinp"
                        },
                        "RAW": {
                            "EUR": {
                                "TYPE": "5",
                                "MARKET": "CCCAGG",
                                "FROMSYMBOL": "BNB",
                                "TOSYMBOL": "EUR",
                                "FLAGS": "1",
                                "LASTMARKET": "CCCAGG",
                                "MEDIAN": 560.04,
                                "TOPTIERVOLUME24HOUR": 1097.231,
                                "TOPTIERVOLUME24HOURTO": 614225.11425,
                                "LASTTRADEID": "6826318",
                                "PRICE": 560.04,
                                "LASTUPDATE": 1743332978,
                                "LASTVOLUME": 0.313,
                                "LASTVOLUMETO": 175.29252,
                                "VOLUMEHOUR": 5.092,
                                "VOLUMEHOURTO": 2853.01372,
                                "OPENHOUR": 561,
                                "HIGHHOUR": 561,
                                "LOWHOUR": 559.66,
                                "VOLUMEDAY": 453.128,
                                "VOLUMEDAYTO": 254981.25505,
                                "OPENDAY": 557.52,
                                "HIGHDAY": 566.9,
                                "LOWDAY": 555.31,
                                "VOLUME24HOUR": 1097.231,
                                "VOLUME24HOURTO": 614225.11425,
                                "OPEN24HOUR": 555.33,
                                "HIGH24HOUR": 566.9,
                                "LOW24HOUR": 551.96,
                                "CHANGE24HOUR": 4.709999999999923,
                                "CHANGEPCT24HOUR": 0.8481443466047076,
                                "CHANGEDAY": 2.519999999999982,
                                "CHANGEPCTDAY": 0.45200172191131827,
                                "CHANGEHOUR": -0.9600000000000364,
                                "CHANGEPCTHOUR": -0.1711229946524129,
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": 1743332978,
                                "SUPPLY": 142471988.79,
                                "MKTCAP": 79790012601.95158,
                                "MKTCAPPENALTY": 0,
                                "CIRCULATINGSUPPLY": 142471988.79,
                                "CIRCULATINGSUPPLYMKTCAP": 79790012601.95158,
                                "TOTALVOLUME24H": 703201.691740162,
                                "TOTALVOLUME24HTO": 393820807.3071703,
                                "TOTALTOPTIERVOLUME24H": 446459.60734,
                                "TOTALTOPTIERVOLUME24HTO": 250034970.35970357,
                                "IMAGEURL": "/media/40485170/bnb.png"
                            }
                        },
                        "DISPLAY": {
                            "EUR": {
                                "FROMSYMBOL": "BNB",
                                "TOSYMBOL": "€",
                                "MARKET": "CryptoCompare Index",
                                "LASTMARKET": "CCCAGG",
                                "TOPTIERVOLUME24HOUR": "BNB 1,097.23",
                                "TOPTIERVOLUME24HOURTO": "€ 614,225.1",
                                "LASTTRADEID": "6826318",
                                "PRICE": "€ 560.04",
                                "LASTUPDATE": "Just now",
                                "LASTVOLUME": "BNB 0.3130",
                                "LASTVOLUMETO": "€ 175.29",
                                "VOLUMEHOUR": "BNB 5.09",
                                "VOLUMEHOURTO": "€ 2,853.01",
                                "OPENHOUR": "€ 561.00",
                                "HIGHHOUR": "€ 561.00",
                                "LOWHOUR": "€ 559.66",
                                "VOLUMEDAY": "BNB 453.13",
                                "VOLUMEDAYTO": "€ 254,981.3",
                                "OPENDAY": "€ 557.52",
                                "HIGHDAY": "€ 566.90",
                                "LOWDAY": "€ 555.31",
                                "VOLUME24HOUR": "BNB 1,097.23",
                                "VOLUME24HOURTO": "€ 614,225.1",
                                "OPEN24HOUR": "€ 555.33",
                                "HIGH24HOUR": "€ 566.90",
                                "LOW24HOUR": "€ 551.96",
                                "CHANGE24HOUR": "€ 4.71",
                                "CHANGEPCT24HOUR": "0.85",
                                "CHANGEDAY": "€ 2.52",
                                "CHANGEPCTDAY": "0.45",
                                "CHANGEHOUR": "€ -0.96",
                                "CHANGEPCTHOUR": "-0.17",
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": "Just now",
                                "SUPPLY": "BNB 142,471,988.8",
                                "MKTCAP": "€ 79.79 B",
                                "MKTCAPPENALTY": "0 %",
                                "CIRCULATINGSUPPLY": "BNB 142,471,988.8",
                                "CIRCULATINGSUPPLYMKTCAP": "€ 79.79 B",
                                "TOTALVOLUME24H": "BNB 703.20 K",
                                "TOTALVOLUME24HTO": "€ 393.82 M",
                                "TOTALTOPTIERVOLUME24H": "BNB 446.46 K",
                                "TOTALTOPTIERVOLUME24HTO": "€ 250.03 M",
                                "IMAGEURL": "/media/40485170/bnb.png"
                            }
                        }
                    },
                    {
                        "CoinInfo": {
                            "Id": "934443",
                            "Name": "SOL",
                            "FullName": "Solana",
                            "Internal": "SOL",
                            "ImageUrl": "/media/37747734/sol.png",
                            "Url": "/coins/sol/overview",
                            "Algorithm": "N/A",
                            "ProofType": "PoH",
                            "Rating": {
                                "Weiss": {
                                    "Rating": "D+",
                                    "TechnologyAdoptionRating": "D",
                                    "MarketPerformanceRating": "C"
                                }
                            },
                            "NetHashesPerSecond": 0,
                            "BlockNumber": 308395818,
                            "BlockTime": 0.637,
                            "BlockReward": 0,
                            "AssetLaunchDate": "2020-03-31",
                            "MaxSupply": -1,
                            "Type": 1,
                            "DocumentType": "Webpagecoinp"
                        },
                        "RAW": {
                            "EUR": {
                                "TYPE": "5",
                                "MARKET": "CCCAGG",
                                "FROMSYMBOL": "SOL",
                                "TOSYMBOL": "EUR",
                                "FLAGS": "1",
                                "LASTMARKET": "CCCAGG",
                                "MEDIAN": 115.904743593744,
                                "TOPTIERVOLUME24HOUR": 117683.50831998,
                                "TOPTIERVOLUME24HOURTO": 13613828.9879079,
                                "LASTTRADEID": "29905763",
                                "PRICE": 115.904743593744,
                                "LASTUPDATE": 1743332997,
                                "LASTVOLUME": 0.331,
                                "LASTVOLUMETO": 38.38276,
                                "VOLUMEHOUR": 1124.36441412,
                                "VOLUMEHOURTO": 129957.409647387,
                                "OPENHOUR": 115.523800330296,
                                "HIGHHOUR": 115.904743593744,
                                "LOWHOUR": 115.491963073318,
                                "VOLUMEDAY": 44418.99532305,
                                "VOLUMEDAYTO": 5155337.57941949,
                                "OPENDAY": 115.0972657772,
                                "HIGHDAY": 116.970429996381,
                                "LOWDAY": 114.170070471079,
                                "VOLUME24HOUR": 117683.50831998,
                                "VOLUME24HOURTO": 13613828.9879079,
                                "OPEN24HOUR": 115.658017320706,
                                "HIGH24HOUR": 117.109649843048,
                                "LOW24HOUR": 113.469374784205,
                                "CHANGE24HOUR": 0.2467262730380071,
                                "CHANGEPCT24HOUR": 0.213323969019687,
                                "CHANGEDAY": 0.807477816544008,
                                "CHANGEPCTDAY": 0.7015612500361967,
                                "CHANGEHOUR": 0.3809432634480032,
                                "CHANGEPCTHOUR": 0.32975305725646326,
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": 1743332997,
                                "SUPPLY": 597387834.4574867,
                                "MKTCAP": 69240083778.81699,
                                "MKTCAPPENALTY": 0,
                                "CIRCULATINGSUPPLY": 512294057.1058842,
                                "CIRCULATINGSUPPLYMKTCAP": 59377311333.45635,
                                "TOTALVOLUME24H": 11222545.1014315,
                                "TOTALVOLUME24HTO": 1300719964.5815141,
                                "TOTALTOPTIERVOLUME24H": 7825406.070246365,
                                "TOTALTOPTIERVOLUME24HTO": 906975436.2197012,
                                "IMAGEURL": "/media/37747734/sol.png"
                            }
                        },
                        "DISPLAY": {
                            "EUR": {
                                "FROMSYMBOL": "SOL",
                                "TOSYMBOL": "€",
                                "MARKET": "CryptoCompare Index",
                                "LASTMARKET": "CCCAGG",
                                "TOPTIERVOLUME24HOUR": "SOL 117,683.5",
                                "TOPTIERVOLUME24HOURTO": "€ 13,613,829.0",
                                "LASTTRADEID": "29905763",
                                "PRICE": "€ 115.90",
                                "LASTUPDATE": "Just now",
                                "LASTVOLUME": "SOL 0.3310",
                                "LASTVOLUMETO": "€ 38.38",
                                "VOLUMEHOUR": "SOL 1,124.36",
                                "VOLUMEHOURTO": "€ 129,957.4",
                                "OPENHOUR": "€ 115.52",
                                "HIGHHOUR": "€ 115.90",
                                "LOWHOUR": "€ 115.49",
                                "VOLUMEDAY": "SOL 44,419.0",
                                "VOLUMEDAYTO": "€ 5,155,337.6",
                                "OPENDAY": "€ 115.10",
                                "HIGHDAY": "€ 116.97",
                                "LOWDAY": "€ 114.17",
                                "VOLUME24HOUR": "SOL 117,683.5",
                                "VOLUME24HOURTO": "€ 13,613,829.0",
                                "OPEN24HOUR": "€ 115.66",
                                "HIGH24HOUR": "€ 117.11",
                                "LOW24HOUR": "€ 113.47",
                                "CHANGE24HOUR": "€ 0.25",
                                "CHANGEPCT24HOUR": "0.21",
                                "CHANGEDAY": "€ 0.81",
                                "CHANGEPCTDAY": "0.70",
                                "CHANGEHOUR": "€ 0.38",
                                "CHANGEPCTHOUR": "0.33",
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": "Just now",
                                "SUPPLY": "SOL 597,387,834.5",
                                "MKTCAP": "€ 69.24 B",
                                "MKTCAPPENALTY": "0 %",
                                "CIRCULATINGSUPPLY": "SOL 512,294,057.1",
                                "CIRCULATINGSUPPLYMKTCAP": "€ 59.38 B",
                                "TOTALVOLUME24H": "SOL 11.22 M",
                                "TOTALVOLUME24HTO": "€ 1.30 B",
                                "TOTALTOPTIERVOLUME24H": "SOL 7.83 M",
                                "TOTALTOPTIERVOLUME24HTO": "€ 906.98 M",
                                "IMAGEURL": "/media/37747734/sol.png"
                            }
                        }
                    },
                    {
                        "CoinInfo": {
                            "Id": "925809",
                            "Name": "USDC",
                            "FullName": "USD Coin",
                            "Internal": "USDC",
                            "ImageUrl": "/media/34835941/usdc.png",
                            "Url": "/coins/usdc/overview",
                            "Algorithm": "N/A",
                            "ProofType": "N/A",
                            "Rating": {
                                "Weiss": {
                                    "Rating": "",
                                    "TechnologyAdoptionRating": "",
                                    "MarketPerformanceRating": ""
                                }
                            },
                            "NetHashesPerSecond": 0,
                            "BlockNumber": 0,
                            "BlockTime": 0,
                            "BlockReward": 0,
                            "AssetLaunchDate": "2018-09-10",
                            "MaxSupply": -1,
                            "Type": 1,
                            "DocumentType": "Webpagecoinp"
                        },
                        "RAW": {
                            "EUR": {
                                "TYPE": "5",
                                "MARKET": "CCCAGG",
                                "FROMSYMBOL": "USDC",
                                "TOSYMBOL": "EUR",
                                "FLAGS": "1",
                                "LASTMARKET": "CCCAGG",
                                "MEDIAN": 0.924278742978527,
                                "TOPTIERVOLUME24HOUR": 28538892.7345341,
                                "TOPTIERVOLUME24HOURTO": 26378072.7415648,
                                "LASTTRADEID": "24534261",
                                "PRICE": 0.924278742978527,
                                "LASTUPDATE": 1743333013,
                                "LASTVOLUME": 110.2824,
                                "LASTVOLUMETO": 102,
                                "VOLUMEHOUR": 402351.86647941,
                                "VOLUMEHOURTO": 372003.49991748,
                                "OPENHOUR": 0.924782085203237,
                                "HIGHHOUR": 0.924827761581407,
                                "LOWHOUR": 0.924242006237299,
                                "VOLUMEDAY": 9764571.13502301,
                                "VOLUMEDAYTO": 9027154.95300744,
                                "OPENDAY": 0.924369930885074,
                                "HIGHDAY": 0.924831801348185,
                                "LOWDAY": 0.924121172728835,
                                "VOLUME24HOUR": 28538892.7345341,
                                "VOLUME24HOURTO": 26378072.7415648,
                                "OPEN24HOUR": 0.923727467277785,
                                "HIGH24HOUR": 0.924831801348185,
                                "LOW24HOUR": 0.923690960331079,
                                "CHANGE24HOUR": 0.0005512757007419822,
                                "CHANGEPCT24HOUR": 0.059679474766143506,
                                "CHANGEDAY": -0.00009118790654705222,
                                "CHANGEPCTDAY": -0.009864871573628623,
                                "CHANGEHOUR": -0.0005033422247100461,
                                "CHANGEPCTHOUR": -0.054428198033207774,
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": 1743333013,
                                "SUPPLY": 60242801966.24085,
                                "MKTCAP": 55681141274.86143,
                                "MKTCAPPENALTY": 0,
                                "CIRCULATINGSUPPLY": 60242801966.24085,
                                "CIRCULATINGSUPPLYMKTCAP": 55681141274.86143,
                                "TOTALVOLUME24H": 903576941.904435,
                                "TOTALVOLUME24HTO": 835157140.8867033,
                                "TOTALTOPTIERVOLUME24H": 588355568.2527996,
                                "TOTALTOPTIERVOLUME24HTO": 543804725.8880051,
                                "IMAGEURL": "/media/34835941/usdc.png"
                            }
                        },
                        "DISPLAY": {
                            "EUR": {
                                "FROMSYMBOL": "USDC",
                                "TOSYMBOL": "€",
                                "MARKET": "CryptoCompare Index",
                                "LASTMARKET": "CCCAGG",
                                "TOPTIERVOLUME24HOUR": "USDC 28,538,892.7",
                                "TOPTIERVOLUME24HOURTO": "€ 26,378,072.7",
                                "LASTTRADEID": "24534261",
                                "PRICE": "€ 0.9243",
                                "LASTUPDATE": "Just now",
                                "LASTVOLUME": "USDC 110.28",
                                "LASTVOLUMETO": "€ 102.00",
                                "VOLUMEHOUR": "USDC 402,351.9",
                                "VOLUMEHOURTO": "€ 372,003.5",
                                "OPENHOUR": "€ 0.9248",
                                "HIGHHOUR": "€ 0.9248",
                                "LOWHOUR": "€ 0.9242",
                                "VOLUMEDAY": "USDC 9,764,571.1",
                                "VOLUMEDAYTO": "€ 9,027,155.0",
                                "OPENDAY": "€ 0.9244",
                                "HIGHDAY": "€ 0.9248",
                                "LOWDAY": "€ 0.9241",
                                "VOLUME24HOUR": "USDC 28,538,892.7",
                                "VOLUME24HOURTO": "€ 26,378,072.7",
                                "OPEN24HOUR": "€ 0.9237",
                                "HIGH24HOUR": "€ 0.9248",
                                "LOW24HOUR": "€ 0.9237",
                                "CHANGE24HOUR": "€ 0.00055",
                                "CHANGEPCT24HOUR": "0.06",
                                "CHANGEDAY": "€ -0.000091",
                                "CHANGEPCTDAY": "-0.01",
                                "CHANGEHOUR": "€ -0.00050",
                                "CHANGEPCTHOUR": "-0.05",
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": "Just now",
                                "SUPPLY": "USDC 60,242,801,966.2",
                                "MKTCAP": "€ 55.68 B",
                                "MKTCAPPENALTY": "0 %",
                                "CIRCULATINGSUPPLY": "USDC 60,242,801,966.2",
                                "CIRCULATINGSUPPLYMKTCAP": "€ 55.68 B",
                                "TOTALVOLUME24H": "USDC 903.58 M",
                                "TOTALVOLUME24HTO": "€ 835.16 M",
                                "TOTALTOPTIERVOLUME24H": "USDC 588.36 M",
                                "TOTALTOPTIERVOLUME24HTO": "€ 543.80 M",
                                "IMAGEURL": "/media/34835941/usdc.png"
                            }
                        }
                    },
                    {
                        "CoinInfo": {
                            "Id": "321992",
                            "Name": "ADA",
                            "FullName": "Cardano",
                            "Internal": "ADA",
                            "ImageUrl": "/media/37746235/ada.png",
                            "Url": "/coins/ada/overview",
                            "Algorithm": "Ouroboros",
                            "ProofType": "PoS",
                            "Rating": {
                                "Weiss": {
                                    "Rating": "B-",
                                    "TechnologyAdoptionRating": "B",
                                    "MarketPerformanceRating": "D-"
                                }
                            },
                            "NetHashesPerSecond": 0,
                            "BlockNumber": 11670382,
                            "BlockTime": 0,
                            "BlockReward": 0,
                            "AssetLaunchDate": "2017-09-23",
                            "MaxSupply": 45000000000,
                            "Type": 1,
                            "DocumentType": "Webpagecoinp"
                        },
                        "RAW": {
                            "EUR": {
                                "TYPE": "5",
                                "MARKET": "CCCAGG",
                                "FROMSYMBOL": "ADA",
                                "TOSYMBOL": "EUR",
                                "FLAGS": "1",
                                "LASTMARKET": "CCCAGG",
                                "MEDIAN": 0.626730418810958,
                                "TOPTIERVOLUME24HOUR": 6462711.35198712,
                                "TOPTIERVOLUME24HOURTO": 4036606.90503426,
                                "LASTTRADEID": "13046300",
                                "PRICE": 0.626730418810958,
                                "LASTUPDATE": 1743333007,
                                "LASTVOLUME": 328.49253621,
                                "LASTVOLUMETO": 205.929999994832,
                                "VOLUMEHOUR": 22035.78063112,
                                "VOLUMEHOURTO": 13802.6903039372,
                                "OPENHOUR": 0.625483272805506,
                                "HIGHHOUR": 0.626730418810958,
                                "LOWHOUR": 0.625443568013295,
                                "VOLUMEDAY": 3322835.29045999,
                                "VOLUMEDAYTO": 2093297.56868249,
                                "OPENDAY": 0.622145085901783,
                                "HIGHDAY": 0.63513846050651,
                                "LOWDAY": 0.618125759461405,
                                "VOLUME24HOUR": 6462711.35198712,
                                "VOLUME24HOURTO": 4036606.90503426,
                                "OPEN24HOUR": 0.615387393190984,
                                "HIGH24HOUR": 0.63513846050651,
                                "LOW24HOUR": 0.609260191822721,
                                "CHANGE24HOUR": 0.011343025619974023,
                                "CHANGEPCT24HOUR": 1.8432333430096353,
                                "CHANGEDAY": 0.004585332909175066,
                                "CHANGEPCTDAY": 0.7370198709403525,
                                "CHANGEHOUR": 0.00124714600545206,
                                "CHANGEPCTHOUR": 0.19938918587833446,
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": 1743333007,
                                "SUPPLY": 45000000000,
                                "MKTCAP": 28202868846.49311,
                                "MKTCAPPENALTY": 0,
                                "CIRCULATINGSUPPLY": 35980357573.5154,
                                "CIRCULATINGSUPPLYMKTCAP": 22549984571.017334,
                                "TOTALVOLUME24H": 497202339.606246,
                                "TOTALVOLUME24HTO": 311598059.64795977,
                                "TOTALTOPTIERVOLUME24H": 214698870.2710309,
                                "TOTALTOPTIERVOLUME24HTO": 134544541.9959518,
                                "IMAGEURL": "/media/37746235/ada.png"
                            }
                        },
                        "DISPLAY": {
                            "EUR": {
                                "FROMSYMBOL": "ADA",
                                "TOSYMBOL": "€",
                                "MARKET": "CryptoCompare Index",
                                "LASTMARKET": "CCCAGG",
                                "TOPTIERVOLUME24HOUR": "ADA 6,462,711.4",
                                "TOPTIERVOLUME24HOURTO": "€ 4,036,606.9",
                                "LASTTRADEID": "13046300",
                                "PRICE": "€ 0.6267",
                                "LASTUPDATE": "Just now",
                                "LASTVOLUME": "ADA 328.49",
                                "LASTVOLUMETO": "€ 205.93",
                                "VOLUMEHOUR": "ADA 22,035.8",
                                "VOLUMEHOURTO": "€ 13,802.7",
                                "OPENHOUR": "€ 0.6255",
                                "HIGHHOUR": "€ 0.6267",
                                "LOWHOUR": "€ 0.6254",
                                "VOLUMEDAY": "ADA 3,322,835.3",
                                "VOLUMEDAYTO": "€ 2,093,297.6",
                                "OPENDAY": "€ 0.6221",
                                "HIGHDAY": "€ 0.6351",
                                "LOWDAY": "€ 0.6181",
                                "VOLUME24HOUR": "ADA 6,462,711.4",
                                "VOLUME24HOURTO": "€ 4,036,606.9",
                                "OPEN24HOUR": "€ 0.6154",
                                "HIGH24HOUR": "€ 0.6351",
                                "LOW24HOUR": "€ 0.6093",
                                "CHANGE24HOUR": "€ 0.011",
                                "CHANGEPCT24HOUR": "1.84",
                                "CHANGEDAY": "€ 0.0046",
                                "CHANGEPCTDAY": "0.74",
                                "CHANGEHOUR": "€ 0.0012",
                                "CHANGEPCTHOUR": "0.20",
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": "Just now",
                                "SUPPLY": "ADA 45,000,000,000.0",
                                "MKTCAP": "€ 28.20 B",
                                "MKTCAPPENALTY": "0 %",
                                "CIRCULATINGSUPPLY": "ADA 35,980,357,573.5",
                                "CIRCULATINGSUPPLYMKTCAP": "€ 22.55 B",
                                "TOTALVOLUME24H": "ADA 497.20 M",
                                "TOTALVOLUME24HTO": "€ 311.60 M",
                                "TOTALTOPTIERVOLUME24H": "ADA 214.70 M",
                                "TOTALTOPTIERVOLUME24HTO": "€ 134.54 M",
                                "IMAGEURL": "/media/37746235/ada.png"
                            }
                        }
                    },
                    {
                        "CoinInfo": {
                            "Id": "4432",
                            "Name": "DOGE",
                            "FullName": "Dogecoin",
                            "Internal": "DOGE",
                            "ImageUrl": "/media/37746339/doge.png",
                            "Url": "/coins/doge/overview",
                            "Algorithm": "Scrypt",
                            "ProofType": "PoW",
                            "Rating": {
                                "Weiss": {
                                    "Rating": "C+",
                                    "TechnologyAdoptionRating": "B-",
                                    "MarketPerformanceRating": "E+"
                                }
                            },
                            "NetHashesPerSecond": 3048145634055243,
                            "BlockNumber": 5647009,
                            "BlockTime": 62,
                            "BlockReward": 10000,
                            "AssetLaunchDate": "2013-12-08",
                            "MaxSupply": -1,
                            "Type": 1,
                            "DocumentType": "Webpagecoinp"
                        },
                        "RAW": {
                            "EUR": {
                                "TYPE": "5",
                                "MARKET": "CCCAGG",
                                "FROMSYMBOL": "DOGE",
                                "TOSYMBOL": "EUR",
                                "FLAGS": "1",
                                "LASTMARKET": "CCCAGG",
                                "MEDIAN": 0.156731213462141,
                                "TOPTIERVOLUME24HOUR": 18136253.067982,
                                "TOPTIERVOLUME24HOURTO": 2844351.19318786,
                                "LASTTRADEID": "15602390",
                                "PRICE": 0.156731213462141,
                                "LASTUPDATE": 1743332999,
                                "LASTVOLUME": 510,
                                "LASTVOLUMETO": 80.1159,
                                "VOLUMEHOUR": 63891.38773175,
                                "VOLUMEHOURTO": 10009.4786650162,
                                "OPENHOUR": 0.156346316255652,
                                "HIGHHOUR": 0.156731213462141,
                                "LOWHOUR": 0.156346316255652,
                                "VOLUMEDAY": 6821748.60989957,
                                "VOLUMEDAYTO": 1076506.29062024,
                                "OPENDAY": 0.156681470818761,
                                "HIGHDAY": 0.159313486208965,
                                "LOWDAY": 0.155295928471432,
                                "VOLUME24HOUR": 18136253.067982,
                                "VOLUME24HOURTO": 2844351.19318786,
                                "OPEN24HOUR": 0.156812499467999,
                                "HIGH24HOUR": 0.159490089932565,
                                "LOW24HOUR": 0.153409407528318,
                                "CHANGE24HOUR": -0.0000812860058579945,
                                "CHANGEPCT24HOUR": -0.051836432767645976,
                                "CHANGEDAY": 0.000049742643380007445,
                                "CHANGEPCTDAY": 0.03174762345545411,
                                "CHANGEHOUR": 0.00038489720648898773,
                                "CHANGEPCTHOUR": 0.24618245936771374,
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": 1743332999,
                                "SUPPLY": 148642586383.705,
                                "MKTCAP": 23296932936.0692,
                                "MKTCAPPENALTY": 0,
                                "CIRCULATINGSUPPLY": 148642586383.705,
                                "CIRCULATINGSUPPLYMKTCAP": 23296932936.0692,
                                "TOTALVOLUME24H": 4520030313.52255,
                                "TOTALVOLUME24HTO": 708431670.1662375,
                                "TOTALTOPTIERVOLUME24H": 2765141168.6660843,
                                "TOTALTOPTIERVOLUME24HTO": 433385765.0013446,
                                "IMAGEURL": "/media/37746339/doge.png"
                            }
                        },
                        "DISPLAY": {
                            "EUR": {
                                "FROMSYMBOL": "DOGE",
                                "TOSYMBOL": "€",
                                "MARKET": "CryptoCompare Index",
                                "LASTMARKET": "CCCAGG",
                                "TOPTIERVOLUME24HOUR": "DOGE 18,136,253.1",
                                "TOPTIERVOLUME24HOURTO": "€ 2,844,351.2",
                                "LASTTRADEID": "15602390",
                                "PRICE": "€ 0.1567",
                                "LASTUPDATE": "Just now",
                                "LASTVOLUME": "DOGE 510.00",
                                "LASTVOLUMETO": "€ 80.12",
                                "VOLUMEHOUR": "DOGE 63,891.4",
                                "VOLUMEHOURTO": "€ 10,009.5",
                                "OPENHOUR": "€ 0.1563",
                                "HIGHHOUR": "€ 0.1567",
                                "LOWHOUR": "€ 0.1563",
                                "VOLUMEDAY": "DOGE 6,821,748.6",
                                "VOLUMEDAYTO": "€ 1,076,506.3",
                                "OPENDAY": "€ 0.1567",
                                "HIGHDAY": "€ 0.1593",
                                "LOWDAY": "€ 0.1553",
                                "VOLUME24HOUR": "DOGE 18,136,253.1",
                                "VOLUME24HOURTO": "€ 2,844,351.2",
                                "OPEN24HOUR": "€ 0.1568",
                                "HIGH24HOUR": "€ 0.1595",
                                "LOW24HOUR": "€ 0.1534",
                                "CHANGE24HOUR": "€ -0.000081",
                                "CHANGEPCT24HOUR": "-0.05",
                                "CHANGEDAY": "€ 0.000050",
                                "CHANGEPCTDAY": "0.03",
                                "CHANGEHOUR": "€ 0.00038",
                                "CHANGEPCTHOUR": "0.25",
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": "Just now",
                                "SUPPLY": "DOGE 148,642,586,383.7",
                                "MKTCAP": "€ 23.30 B",
                                "MKTCAPPENALTY": "0 %",
                                "CIRCULATINGSUPPLY": "DOGE 148,642,586,383.7",
                                "CIRCULATINGSUPPLYMKTCAP": "€ 23.30 B",
                                "TOTALVOLUME24H": "DOGE 4.52 B",
                                "TOTALVOLUME24HTO": "€ 708.43 M",
                                "TOTALTOPTIERVOLUME24H": "DOGE 2.77 B",
                                "TOTALTOPTIERVOLUME24HTO": "€ 433.39 M",
                                "IMAGEURL": "/media/37746339/doge.png"
                            }
                        }
                    },
                    {
                        "CoinInfo": {
                            "Id": "953119",
                            "Name": "SUI",
                            "FullName": "Sui",
                            "Internal": "SUI",
                            "ImageUrl": "/media/44082045/sui.png",
                            "Url": "/coins/sui/overview",
                            "Algorithm": "N/A",
                            "ProofType": "N/A",
                            "Rating": {
                                "Weiss": {
                                    "Rating": "",
                                    "TechnologyAdoptionRating": "",
                                    "MarketPerformanceRating": ""
                                }
                            },
                            "NetHashesPerSecond": 0,
                            "BlockNumber": 0,
                            "BlockTime": 0,
                            "BlockReward": 0,
                            "AssetLaunchDate": "2023-04-01",
                            "MaxSupply": -1,
                            "Type": 1,
                            "DocumentType": "Webpagecoinp"
                        },
                        "RAW": {
                            "EUR": {
                                "TYPE": "5",
                                "MARKET": "CCCAGG",
                                "FROMSYMBOL": "SUI",
                                "TOSYMBOL": "EUR",
                                "FLAGS": "2",
                                "LASTMARKET": "CCCAGG",
                                "MEDIAN": 2.19868477929006,
                                "TOPTIERVOLUME24HOUR": 629811.39298,
                                "TOPTIERVOLUME24HOURTO": 1356758.39624252,
                                "LASTTRADEID": "2371767",
                                "PRICE": 2.19868477929006,
                                "LASTUPDATE": 1743332988,
                                "LASTVOLUME": 5.38,
                                "LASTVOLUMETO": 11.845684,
                                "VOLUMEHOUR": 473.00934,
                                "VOLUMEHOURTO": 1041.165879353,
                                "OPENHOUR": 2.19718809224785,
                                "HIGHHOUR": 2.20239894271615,
                                "LOWHOUR": 2.19717044534147,
                                "VOLUMEDAY": 256614.84978,
                                "VOLUMEDAYTO": 565638.595762543,
                                "OPENDAY": 2.13842093786427,
                                "HIGHDAY": 2.26038937484238,
                                "LOWDAY": 2.11454157706326,
                                "VOLUME24HOUR": 629811.39298,
                                "VOLUME24HOURTO": 1356758.39624252,
                                "OPEN24HOUR": 2.12997347186723,
                                "HIGH24HOUR": 2.26038937484238,
                                "LOW24HOUR": 2.08118237427352,
                                "CHANGE24HOUR": 0.06871130742283027,
                                "CHANGEPCT24HOUR": 3.2259231549299474,
                                "CHANGEDAY": 0.06026384142579033,
                                "CHANGEPCTDAY": 2.8181468091113224,
                                "CHANGEHOUR": 0.0014966870422101763,
                                "CHANGEPCTHOUR": 0.06811829389986268,
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": 1743332988,
                                "SUPPLY": 10000000000,
                                "MKTCAP": 21986847792.9006,
                                "MKTCAPPENALTY": 0,
                                "CIRCULATINGSUPPLY": 3169845047.4838877,
                                "CIRCULATINGSUPPLYMKTCAP": 6969490058.610802,
                                "TOTALVOLUME24H": 270386779.439957,
                                "TOTALVOLUME24HTO": 594467298.148566,
                                "TOTALTOPTIERVOLUME24H": 158444653.10393903,
                                "TOTALTOPTIERVOLUME24HTO": 348341848.8121982,
                                "IMAGEURL": "/media/44082045/sui.png"
                            }
                        },
                        "DISPLAY": {
                            "EUR": {
                                "FROMSYMBOL": "SUI",
                                "TOSYMBOL": "€",
                                "MARKET": "CryptoCompare Index",
                                "LASTMARKET": "CCCAGG",
                                "TOPTIERVOLUME24HOUR": "SUI 629,811.4",
                                "TOPTIERVOLUME24HOURTO": "€ 1,356,758.4",
                                "LASTTRADEID": "2371767",
                                "PRICE": "€ 2.20",
                                "LASTUPDATE": "Just now",
                                "LASTVOLUME": "SUI 5.38",
                                "LASTVOLUMETO": "€ 11.85",
                                "VOLUMEHOUR": "SUI 473.01",
                                "VOLUMEHOURTO": "€ 1,041.17",
                                "OPENHOUR": "€ 2.20",
                                "HIGHHOUR": "€ 2.20",
                                "LOWHOUR": "€ 2.20",
                                "VOLUMEDAY": "SUI 256,614.8",
                                "VOLUMEDAYTO": "€ 565,638.6",
                                "OPENDAY": "€ 2.14",
                                "HIGHDAY": "€ 2.26",
                                "LOWDAY": "€ 2.11",
                                "VOLUME24HOUR": "SUI 629,811.4",
                                "VOLUME24HOURTO": "€ 1,356,758.4",
                                "OPEN24HOUR": "€ 2.13",
                                "HIGH24HOUR": "€ 2.26",
                                "LOW24HOUR": "€ 2.08",
                                "CHANGE24HOUR": "€ 0.069",
                                "CHANGEPCT24HOUR": "3.23",
                                "CHANGEDAY": "€ 0.060",
                                "CHANGEPCTDAY": "2.82",
                                "CHANGEHOUR": "€ 0.0015",
                                "CHANGEPCTHOUR": "0.07",
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": "Just now",
                                "SUPPLY": "SUI 10,000,000,000.0",
                                "MKTCAP": "€ 21.99 B",
                                "MKTCAPPENALTY": "0 %",
                                "CIRCULATINGSUPPLY": "SUI 3,169,845,047.5",
                                "CIRCULATINGSUPPLYMKTCAP": "€ 6.97 B",
                                "TOTALVOLUME24H": "SUI 270.39 M",
                                "TOTALVOLUME24HTO": "€ 594.47 M",
                                "TOTALTOPTIERVOLUME24H": "SUI 158.44 M",
                                "TOTALTOPTIERVOLUME24HTO": "€ 348.34 M",
                                "IMAGEURL": "/media/44082045/sui.png"
                            }
                        }
                    },
                    {
                        "CoinInfo": {
                            "Id": "310829",
                            "Name": "TRX",
                            "FullName": "TRON",
                            "Internal": "TRX",
                            "ImageUrl": "/media/37746879/trx.png",
                            "Url": "/coins/trx/overview",
                            "Algorithm": "N/A",
                            "ProofType": "DPoS",
                            "Rating": {
                                "Weiss": {
                                    "Rating": "C",
                                    "TechnologyAdoptionRating": "C",
                                    "MarketPerformanceRating": "D+"
                                }
                            },
                            "NetHashesPerSecond": 0,
                            "BlockNumber": 70892813,
                            "BlockTime": 0,
                            "BlockReward": 16,
                            "AssetLaunchDate": "2018-06-25",
                            "MaxSupply": -1,
                            "Type": 1,
                            "DocumentType": "Webpagecoinp"
                        },
                        "RAW": {
                            "EUR": {
                                "TYPE": "5",
                                "MARKET": "CCCAGG",
                                "FROMSYMBOL": "TRX",
                                "TOSYMBOL": "EUR",
                                "FLAGS": "1",
                                "LASTMARKET": "CCCAGG",
                                "MEDIAN": 0.213048399627087,
                                "TOPTIERVOLUME24HOUR": 2685737.67866298,
                                "TOPTIERVOLUME24HOURTO": 577865.190372665,
                                "LASTTRADEID": "3656221",
                                "PRICE": 0.213048399627087,
                                "LASTUPDATE": 1743333009,
                                "LASTVOLUME": 1058.784888,
                                "LASTVOLUMETO": 225.520122359112,
                                "VOLUMEHOUR": 7411.72902,
                                "VOLUMEHOURTO": 1578.98506167078,
                                "OPENHOUR": 0.213388766375443,
                                "HIGHHOUR": 0.213389541864464,
                                "LOWHOUR": 0.213008076820029,
                                "VOLUMEDAY": 873382.53735967,
                                "VOLUMEDAYTO": 186415.244044372,
                                "OPENDAY": 0.214291382693003,
                                "HIGHDAY": 0.215113269469407,
                                "LOWDAY": 0.212235186518799,
                                "VOLUME24HOUR": 2685737.67866298,
                                "VOLUME24HOURTO": 577865.190372665,
                                "OPEN24HOUR": 0.215146750311249,
                                "HIGH24HOUR": 0.217850601929073,
                                "LOW24HOUR": 0.212235186518799,
                                "CHANGE24HOUR": -0.0020983506841620037,
                                "CHANGEPCT24HOUR": -0.9753113542855548,
                                "CHANGEDAY": -0.001242983065915998,
                                "CHANGEPCTDAY": -0.5800434204564884,
                                "CHANGEHOUR": -0.0003403667483559969,
                                "CHANGEPCTHOUR": -0.1595054670109226,
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": 1743333009,
                                "SUPPLY": 94994759515.91003,
                                "MKTCAP": 20238481487.824627,
                                "MKTCAPPENALTY": 0,
                                "CIRCULATINGSUPPLY": 94994759515.91003,
                                "CIRCULATINGSUPPLYMKTCAP": 20238481487.824627,
                                "TOTALVOLUME24H": 1462616336.29677,
                                "TOTALVOLUME24HTO": 311613742.7925755,
                                "TOTALTOPTIERVOLUME24H": 512470160.0642234,
                                "TOTALTOPTIERVOLUME24HTO": 109186620.53443526,
                                "IMAGEURL": "/media/37746879/trx.png"
                            }
                        },
                        "DISPLAY": {
                            "EUR": {
                                "FROMSYMBOL": "TRX",
                                "TOSYMBOL": "€",
                                "MARKET": "CryptoCompare Index",
                                "LASTMARKET": "CCCAGG",
                                "TOPTIERVOLUME24HOUR": "TRX 2,685,737.7",
                                "TOPTIERVOLUME24HOURTO": "€ 577,865.2",
                                "LASTTRADEID": "3656221",
                                "PRICE": "€ 0.2130",
                                "LASTUPDATE": "Just now",
                                "LASTVOLUME": "TRX 1,058.78",
                                "LASTVOLUMETO": "€ 225.52",
                                "VOLUMEHOUR": "TRX 7,411.73",
                                "VOLUMEHOURTO": "€ 1,578.99",
                                "OPENHOUR": "€ 0.2134",
                                "HIGHHOUR": "€ 0.2134",
                                "LOWHOUR": "€ 0.2130",
                                "VOLUMEDAY": "TRX 873,382.5",
                                "VOLUMEDAYTO": "€ 186,415.2",
                                "OPENDAY": "€ 0.2143",
                                "HIGHDAY": "€ 0.2151",
                                "LOWDAY": "€ 0.2122",
                                "VOLUME24HOUR": "TRX 2,685,737.7",
                                "VOLUME24HOURTO": "€ 577,865.2",
                                "OPEN24HOUR": "€ 0.2151",
                                "HIGH24HOUR": "€ 0.2179",
                                "LOW24HOUR": "€ 0.2122",
                                "CHANGE24HOUR": "€ -0.0021",
                                "CHANGEPCT24HOUR": "-0.98",
                                "CHANGEDAY": "€ -0.0012",
                                "CHANGEPCTDAY": "-0.58",
                                "CHANGEHOUR": "€ -0.00034",
                                "CHANGEPCTHOUR": "-0.16",
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": "Just now",
                                "SUPPLY": "TRX 94,994,759,515.9",
                                "MKTCAP": "€ 20.24 B",
                                "MKTCAPPENALTY": "0 %",
                                "CIRCULATINGSUPPLY": "TRX 94,994,759,515.9",
                                "CIRCULATINGSUPPLYMKTCAP": "€ 20.24 B",
                                "TOTALVOLUME24H": "TRX 1.46 B",
                                "TOTALVOLUME24HTO": "€ 311.61 M",
                                "TOTALTOPTIERVOLUME24H": "TRX 512.47 M",
                                "TOTALTOPTIERVOLUME24HTO": "€ 109.19 M",
                                "IMAGEURL": "/media/37746879/trx.png"
                            }
                        }
                    },
                    {
                        "CoinInfo": {
                            "Id": "945129",
                            "Name": "TON",
                            "FullName": "Toncoin",
                            "Internal": "TON",
                            "ImageUrl": "/media/43957906/toncoin.png",
                            "Url": "/coins/ton/overview",
                            "Algorithm": "N/A",
                            "ProofType": "N/A",
                            "Rating": {
                                "Weiss": {
                                    "Rating": "",
                                    "TechnologyAdoptionRating": "",
                                    "MarketPerformanceRating": ""
                                }
                            },
                            "NetHashesPerSecond": 0,
                            "BlockNumber": 0,
                            "BlockTime": 0,
                            "BlockReward": 0,
                            "AssetLaunchDate": "2021-08-19",
                            "MaxSupply": -1,
                            "Type": 1,
                            "DocumentType": "Webpagecoinp"
                        },
                        "RAW": {
                            "EUR": {
                                "TYPE": "5",
                                "MARKET": "CCCAGG",
                                "FROMSYMBOL": "TON",
                                "TOSYMBOL": "EUR",
                                "FLAGS": "2",
                                "LASTMARKET": "CCCAGG",
                                "MEDIAN": 3.53542656134716,
                                "TOPTIERVOLUME24HOUR": 66928.33208,
                                "TOPTIERVOLUME24HOURTO": 232170.64798881,
                                "LASTTRADEID": "1334772",
                                "PRICE": 3.53542656134716,
                                "LASTUPDATE": 1743332998,
                                "LASTVOLUME": 1.32,
                                "LASTVOLUMETO": 4.66092,
                                "VOLUMEHOUR": 435.88146,
                                "VOLUMEHOURTO": 1542.29903632,
                                "OPENHOUR": 3.5292846270881,
                                "HIGHHOUR": 3.54174458810969,
                                "LOWHOUR": 3.52742362316579,
                                "VOLUMEDAY": 32485.72369,
                                "VOLUMEDAYTO": 114008.66829508,
                                "OPENDAY": 3.41862836318652,
                                "HIGHDAY": 3.59044521655872,
                                "LOWDAY": 3.37006734193362,
                                "VOLUME24HOUR": 66928.33208,
                                "VOLUME24HOURTO": 232170.64798881,
                                "OPEN24HOUR": 3.39472699913798,
                                "HIGH24HOUR": 3.59044521655872,
                                "LOW24HOUR": 3.37006734193362,
                                "CHANGE24HOUR": 0.14069956220918023,
                                "CHANGEPCT24HOUR": 4.144650283952375,
                                "CHANGEDAY": 0.11679819816064008,
                                "CHANGEPCTDAY": 3.4165222350104156,
                                "CHANGEHOUR": 0.006141934259059845,
                                "CHANGEPCTHOUR": 0.17402773955716228,
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": 1743332998,
                                "SUPPLY": 5125901199.77751,
                                "MKTCAP": 18122247252.534683,
                                "MKTCAPPENALTY": 0,
                                "CIRCULATINGSUPPLY": 2484467129.77082,
                                "CIRCULATINGSUPPLYMKTCAP": 8783651081.385698,
                                "TOTALVOLUME24H": 34393692.9115934,
                                "TOTALVOLUME24HTO": 121591925.90751137,
                                "TOTALTOPTIERVOLUME24H": 19215659.5936688,
                                "TOTALTOPTIERVOLUME24HTO": 67931103.76630858,
                                "IMAGEURL": "/media/43957906/toncoin.png"
                            }
                        },
                        "DISPLAY": {
                            "EUR": {
                                "FROMSYMBOL": "TON",
                                "TOSYMBOL": "€",
                                "MARKET": "CryptoCompare Index",
                                "LASTMARKET": "CCCAGG",
                                "TOPTIERVOLUME24HOUR": "TON 66,928.3",
                                "TOPTIERVOLUME24HOURTO": "€ 232,170.6",
                                "LASTTRADEID": "1334772",
                                "PRICE": "€ 3.54",
                                "LASTUPDATE": "Just now",
                                "LASTVOLUME": "TON 1.32",
                                "LASTVOLUMETO": "€ 4.66",
                                "VOLUMEHOUR": "TON 435.88",
                                "VOLUMEHOURTO": "€ 1,542.30",
                                "OPENHOUR": "€ 3.53",
                                "HIGHHOUR": "€ 3.54",
                                "LOWHOUR": "€ 3.53",
                                "VOLUMEDAY": "TON 32,485.7",
                                "VOLUMEDAYTO": "€ 114,008.7",
                                "OPENDAY": "€ 3.42",
                                "HIGHDAY": "€ 3.59",
                                "LOWDAY": "€ 3.37",
                                "VOLUME24HOUR": "TON 66,928.3",
                                "VOLUME24HOURTO": "€ 232,170.6",
                                "OPEN24HOUR": "€ 3.39",
                                "HIGH24HOUR": "€ 3.59",
                                "LOW24HOUR": "€ 3.37",
                                "CHANGE24HOUR": "€ 0.14",
                                "CHANGEPCT24HOUR": "4.14",
                                "CHANGEDAY": "€ 0.12",
                                "CHANGEPCTDAY": "3.42",
                                "CHANGEHOUR": "€ 0.0061",
                                "CHANGEPCTHOUR": "0.17",
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": "Just now",
                                "SUPPLY": "TON 5,125,901,199.8",
                                "MKTCAP": "€ 18.12 B",
                                "MKTCAPPENALTY": "0 %",
                                "CIRCULATINGSUPPLY": "TON 2,484,467,129.8",
                                "CIRCULATINGSUPPLYMKTCAP": "€ 8.78 B",
                                "TOTALVOLUME24H": "TON 34.39 M",
                                "TOTALVOLUME24HTO": "€ 121.59 M",
                                "TOTALTOPTIERVOLUME24H": "TON 19.22 M",
                                "TOTALTOPTIERVOLUME24HTO": "€ 67.93 M",
                                "IMAGEURL": "/media/43957906/toncoin.png"
                            }
                        }
                    },
                    {
                        "CoinInfo": {
                            "Id": "938193",
                            "Name": "STETH",
                            "FullName": "Staked Ether",
                            "Internal": "STETH",
                            "ImageUrl": "/media/37621928/steth.png",
                            "Url": "/coins/steth/overview",
                            "Algorithm": "N/A",
                            "ProofType": "N/A",
                            "Rating": {
                                "Weiss": {
                                    "Rating": "",
                                    "TechnologyAdoptionRating": "",
                                    "MarketPerformanceRating": ""
                                }
                            },
                            "NetHashesPerSecond": 0,
                            "BlockNumber": 0,
                            "BlockTime": 0,
                            "BlockReward": 0,
                            "AssetLaunchDate": "2020-12-18",
                            "MaxSupply": -1,
                            "Type": 1,
                            "DocumentType": "Webpagecoinp"
                        },
                        "RAW": {
                            "EUR": {
                                "TYPE": "5",
                                "MARKET": "CCCAGG",
                                "FROMSYMBOL": "STETH",
                                "TOSYMBOL": "EUR",
                                "FLAGS": "4",
                                "PRICE": 1693.968422501048,
                                "LASTUPDATE": 1743332405,
                                "MEDIAN": 1693.968422501048,
                                "LASTVOLUME": 0,
                                "LASTVOLUMETO": 0,
                                "LASTTRADEID": "768955",
                                "VOLUMEDAY": 3.434818,
                                "VOLUMEDAYTO": 5818.473229038205,
                                "VOLUME24HOUR": 142.365342,
                                "VOLUME24HOURTO": 241162.3938065622,
                                "OPENDAY": 1688.844581927908,
                                "HIGHDAY": 1707.839460519042,
                                "LOWDAY": 1675.165069478137,
                                "OPEN24HOUR": 1702.512055108553,
                                "HIGH24HOUR": 1720.677550280046,
                                "LOW24HOUR": 1660.928444777156,
                                "LASTMARKET": "CCCAGG",
                                "VOLUMEHOUR": 0,
                                "VOLUMEHOURTO": 0,
                                "OPENHOUR": 1691.314973869404,
                                "HIGHHOUR": 1693.968422501048,
                                "LOWHOUR": 1690.97683497811,
                                "TOPTIERVOLUME24HOUR": 142.365342,
                                "TOPTIERVOLUME24HOURTO": 241162.3938065622,
                                "CHANGE24HOUR": -8.54363260750506,
                                "CHANGEPCT24HOUR": -0.5018250873389741,
                                "CHANGEDAY": 5.123840573140114,
                                "CHANGEPCTDAY": 0.30339325642925485,
                                "CHANGEHOUR": 2.653448631644096,
                                "CHANGEPCTHOUR": 0.15688672261758052,
                                "CONVERSIONTYPE": "multiply",
                                "CONVERSIONSYMBOL": "ETH",
                                "CONVERSIONLASTUPDATE": 1743333005,
                                "SUPPLY": 9371779.95372459,
                                "MKTCAP": 15875499304.237787,
                                "MKTCAPPENALTY": 0,
                                "CIRCULATINGSUPPLY": 9371779.95372459,
                                "CIRCULATINGSUPPLYMKTCAP": 15875499304.237787,
                                "TOTALVOLUME24H": 3326.32544041589,
                                "TOTALVOLUME24HTO": 5634690.259026409,
                                "TOTALTOPTIERVOLUME24H": 1404.603222093853,
                                "TOTALTOPTIERVOLUME24HTO": 2379353.5043702135,
                                "IMAGEURL": "/media/37621928/steth.png"
                            }
                        },
                        "DISPLAY": {
                            "EUR": {
                                "FROMSYMBOL": "STETH",
                                "TOSYMBOL": "€",
                                "MARKET": "CryptoCompare Index",
                                "PRICE": "€ 1,693.97",
                                "LASTUPDATE": "10 min ago",
                                "LASTVOLUME": "STETH 0",
                                "LASTVOLUMETO": "€ 0",
                                "LASTTRADEID": "768955",
                                "VOLUMEDAY": "STETH 3.43",
                                "VOLUMEDAYTO": "€ 5,818.47",
                                "VOLUME24HOUR": "STETH 142.37",
                                "VOLUME24HOURTO": "€ 241,162.4",
                                "OPENDAY": "€ 1,688.84",
                                "HIGHDAY": "€ 1,707.84",
                                "LOWDAY": "€ 1,675.17",
                                "OPEN24HOUR": "€ 1,702.51",
                                "HIGH24HOUR": "€ 1,720.68",
                                "LOW24HOUR": "€ 1,660.93",
                                "LASTMARKET": "CCCAGG",
                                "VOLUMEHOUR": "STETH 0",
                                "VOLUMEHOURTO": "€ 0",
                                "OPENHOUR": "€ 1,691.31",
                                "HIGHHOUR": "€ 1,693.97",
                                "LOWHOUR": "€ 1,690.98",
                                "TOPTIERVOLUME24HOUR": "STETH 142.37",
                                "TOPTIERVOLUME24HOURTO": "€ 241,162.4",
                                "CHANGE24HOUR": "€ -8.54",
                                "CHANGEPCT24HOUR": "-0.50",
                                "CHANGEDAY": "€ 5.12",
                                "CHANGEPCTDAY": "0.30",
                                "CHANGEHOUR": "€ 2.65",
                                "CHANGEPCTHOUR": "0.16",
                                "CONVERSIONTYPE": "multiply",
                                "CONVERSIONSYMBOL": "ETH",
                                "CONVERSIONLASTUPDATE": "Just now",
                                "SUPPLY": "STETH 9,371,780.0",
                                "MKTCAP": "€ 15.88 B",
                                "MKTCAPPENALTY": "0 %",
                                "CIRCULATINGSUPPLY": "STETH 9,371,780.0",
                                "CIRCULATINGSUPPLYMKTCAP": "€ 15.88 B",
                                "TOTALVOLUME24H": "STETH 3.33 K",
                                "TOTALVOLUME24HTO": "€ 5.63 M",
                                "TOTALTOPTIERVOLUME24H": "STETH 1.40 K",
                                "TOTALTOPTIERVOLUME24HTO": "€ 2.38 M",
                                "IMAGEURL": "/media/37621928/steth.png"
                            }
                        }
                    },
                    {
                        "CoinInfo": {
                            "Id": "309621",
                            "Name": "LINK",
                            "FullName": "Chainlink",
                            "Internal": "LINK",
                            "ImageUrl": "/media/37746242/link.png",
                            "Url": "/coins/link/overview",
                            "Algorithm": "N/A",
                            "ProofType": "N/A",
                            "Rating": {
                                "Weiss": {
                                    "Rating": "B",
                                    "TechnologyAdoptionRating": "B+",
                                    "MarketPerformanceRating": "D+"
                                }
                            },
                            "NetHashesPerSecond": 0,
                            "BlockNumber": 0,
                            "BlockTime": 0,
                            "BlockReward": 0,
                            "AssetLaunchDate": "2017-09-16",
                            "MaxSupply": -1,
                            "Type": 1,
                            "DocumentType": "Webpagecoinp"
                        },
                        "RAW": {
                            "EUR": {
                                "TYPE": "5",
                                "MARKET": "CCCAGG",
                                "FROMSYMBOL": "LINK",
                                "TOSYMBOL": "EUR",
                                "FLAGS": "1",
                                "LASTMARKET": "CCCAGG",
                                "MEDIAN": 12.651712531779,
                                "TOPTIERVOLUME24HOUR": 75774.8899042,
                                "TOPTIERVOLUME24HOURTO": 954480.248784311,
                                "LASTTRADEID": "7388815",
                                "PRICE": 12.651712531779,
                                "LASTUPDATE": 1743333008,
                                "LASTVOLUME": 0.47,
                                "LASTVOLUMETO": 5.9549,
                                "VOLUMEHOUR": 440.39860705,
                                "VOLUMEHOURTO": 5570.90006971665,
                                "OPENHOUR": 12.6540036878414,
                                "HIGHHOUR": 12.6547166177421,
                                "LOWHOUR": 12.6347919236262,
                                "VOLUMEDAY": 36046.47056504,
                                "VOLUMEDAYTO": 456113.497096066,
                                "OPENDAY": 12.5112250986581,
                                "HIGHDAY": 12.8255229964941,
                                "LOWDAY": 12.4138360460302,
                                "VOLUME24HOUR": 75774.8899042,
                                "VOLUME24HOURTO": 954480.248784311,
                                "OPEN24HOUR": 12.567367694719,
                                "HIGH24HOUR": 12.8255229964941,
                                "LOW24HOUR": 12.3744057792146,
                                "CHANGE24HOUR": 0.08434483705999973,
                                "CHANGEPCT24HOUR": 0.6711416352960113,
                                "CHANGEDAY": 0.1404874331208994,
                                "CHANGEPCTDAY": 1.1228910998969035,
                                "CHANGEHOUR": -0.002291156062399935,
                                "CHANGEPCTHOUR": -0.018106175080392875,
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": 1743333008,
                                "SUPPLY": 1000000000,
                                "MKTCAP": 12651712531.779,
                                "MKTCAPPENALTY": 0,
                                "CIRCULATINGSUPPLY": 657099970.452787,
                                "CIRCULATINGSUPPLYMKTCAP": 8313439930.809136,
                                "TOTALVOLUME24H": 12773476.352542,
                                "TOTALVOLUME24HTO": 161602148.9684275,
                                "TOTALTOPTIERVOLUME24H": 6509367.937946771,
                                "TOTALTOPTIERVOLUME24HTO": 82350450.03907076,
                                "IMAGEURL": "/media/37746242/link.png"
                            }
                        },
                        "DISPLAY": {
                            "EUR": {
                                "FROMSYMBOL": "LINK",
                                "TOSYMBOL": "€",
                                "MARKET": "CryptoCompare Index",
                                "LASTMARKET": "CCCAGG",
                                "TOPTIERVOLUME24HOUR": "LINK 75,774.9",
                                "TOPTIERVOLUME24HOURTO": "€ 954,480.2",
                                "LASTTRADEID": "7388815",
                                "PRICE": "€ 12.65",
                                "LASTUPDATE": "Just now",
                                "LASTVOLUME": "LINK 0.4700",
                                "LASTVOLUMETO": "€ 5.95",
                                "VOLUMEHOUR": "LINK 440.40",
                                "VOLUMEHOURTO": "€ 5,570.90",
                                "OPENHOUR": "€ 12.65",
                                "HIGHHOUR": "€ 12.65",
                                "LOWHOUR": "€ 12.63",
                                "VOLUMEDAY": "LINK 36,046.5",
                                "VOLUMEDAYTO": "€ 456,113.5",
                                "OPENDAY": "€ 12.51",
                                "HIGHDAY": "€ 12.83",
                                "LOWDAY": "€ 12.41",
                                "VOLUME24HOUR": "LINK 75,774.9",
                                "VOLUME24HOURTO": "€ 954,480.2",
                                "OPEN24HOUR": "€ 12.57",
                                "HIGH24HOUR": "€ 12.83",
                                "LOW24HOUR": "€ 12.37",
                                "CHANGE24HOUR": "€ 0.084",
                                "CHANGEPCT24HOUR": "0.67",
                                "CHANGEDAY": "€ 0.14",
                                "CHANGEPCTDAY": "1.12",
                                "CHANGEHOUR": "€ -0.0023",
                                "CHANGEPCTHOUR": "-0.02",
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": "Just now",
                                "SUPPLY": "LINK 1,000,000,000.0",
                                "MKTCAP": "€ 12.65 B",
                                "MKTCAPPENALTY": "0 %",
                                "CIRCULATINGSUPPLY": "LINK 657,099,970.5",
                                "CIRCULATINGSUPPLYMKTCAP": "€ 8.31 B",
                                "TOTALVOLUME24H": "LINK 12.77 M",
                                "TOTALVOLUME24HTO": "€ 161.60 M",
                                "TOTALTOPTIERVOLUME24H": "LINK 6.51 M",
                                "TOTALTOPTIERVOLUME24HTO": "€ 82.35 M",
                                "IMAGEURL": "/media/37746242/link.png"
                            }
                        }
                    },
                    {
                        "CoinInfo": {
                            "Id": "4614",
                            "Name": "XLM",
                            "FullName": "Stellar",
                            "Internal": "XLM",
                            "ImageUrl": "/media/37746346/xlm.png",
                            "Url": "/coins/xlm/overview",
                            "Algorithm": "N/A",
                            "ProofType": "SCP",
                            "Rating": {
                                "Weiss": {
                                    "Rating": "B-",
                                    "TechnologyAdoptionRating": "B",
                                    "MarketPerformanceRating": "D"
                                }
                            },
                            "NetHashesPerSecond": 0,
                            "BlockNumber": 56385793,
                            "BlockTime": 0,
                            "BlockReward": 0,
                            "AssetLaunchDate": "2014-07-31",
                            "MaxSupply": -1,
                            "Type": 1,
                            "DocumentType": "Webpagecoinp"
                        },
                        "RAW": {
                            "EUR": {
                                "TYPE": "5",
                                "MARKET": "CCCAGG",
                                "FROMSYMBOL": "XLM",
                                "TOSYMBOL": "EUR",
                                "FLAGS": "1",
                                "LASTMARKET": "CCCAGG",
                                "MEDIAN": 0.248587482478759,
                                "TOPTIERVOLUME24HOUR": 2031382.96846693,
                                "TOPTIERVOLUME24HOURTO": 501988.876320708,
                                "LASTTRADEID": "3444848",
                                "PRICE": 0.248587482478759,
                                "LASTUPDATE": 1743332982,
                                "LASTVOLUME": 286,
                                "LASTVOLUMETO": 71.214,
                                "VOLUMEHOUR": 11946.29964476,
                                "VOLUMEHOURTO": 2965.90389019306,
                                "OPENHOUR": 0.248320886114743,
                                "HIGHHOUR": 0.248587482478759,
                                "LOWHOUR": 0.24806900349957,
                                "VOLUMEDAY": 779293.52299386,
                                "VOLUMEDAYTO": 194501.17417502,
                                "OPENDAY": 0.24694231057294,
                                "HIGHDAY": 0.25158728994268,
                                "LOWDAY": 0.245513935448374,
                                "VOLUME24HOUR": 2031382.96846693,
                                "VOLUME24HOURTO": 501988.876320708,
                                "OPEN24HOUR": 0.244824228239182,
                                "HIGH24HOUR": 0.25158728994268,
                                "LOW24HOUR": 0.242060465196141,
                                "CHANGE24HOUR": 0.003763254239576991,
                                "CHANGEPCT24HOUR": 1.5371249269906673,
                                "CHANGEDAY": 0.001645171905819004,
                                "CHANGEPCTDAY": 0.6662171022867567,
                                "CHANGEHOUR": 0.00026659636401599185,
                                "CHANGEPCTHOUR": 0.10735962173266578,
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": 1743332982,
                                "SUPPLY": 50001786892.817924,
                                "MKTCAP": 12429818323.125017,
                                "MKTCAPPENALTY": 0,
                                "CIRCULATINGSUPPLY": 30787179407.61554,
                                "CIRCULATINGSUPPLYMKTCAP": 7653307421.561038,
                                "TOTALVOLUME24H": 282858302.194694,
                                "TOTALVOLUME24HTO": 70312045.7390343,
                                "TOTALTOPTIERVOLUME24H": 131268737.6447841,
                                "TOTALTOPTIERVOLUME24HTO": 32628777.517520864,
                                "IMAGEURL": "/media/37746346/xlm.png"
                            }
                        },
                        "DISPLAY": {
                            "EUR": {
                                "FROMSYMBOL": "XLM",
                                "TOSYMBOL": "€",
                                "MARKET": "CryptoCompare Index",
                                "LASTMARKET": "CCCAGG",
                                "TOPTIERVOLUME24HOUR": "XLM 2,031,383.0",
                                "TOPTIERVOLUME24HOURTO": "€ 501,988.9",
                                "LASTTRADEID": "3444848",
                                "PRICE": "€ 0.2486",
                                "LASTUPDATE": "Just now",
                                "LASTVOLUME": "XLM 286.00",
                                "LASTVOLUMETO": "€ 71.21",
                                "VOLUMEHOUR": "XLM 11,946.3",
                                "VOLUMEHOURTO": "€ 2,965.90",
                                "OPENHOUR": "€ 0.2483",
                                "HIGHHOUR": "€ 0.2486",
                                "LOWHOUR": "€ 0.2481",
                                "VOLUMEDAY": "XLM 779,293.5",
                                "VOLUMEDAYTO": "€ 194,501.2",
                                "OPENDAY": "€ 0.2469",
                                "HIGHDAY": "€ 0.2516",
                                "LOWDAY": "€ 0.2455",
                                "VOLUME24HOUR": "XLM 2,031,383.0",
                                "VOLUME24HOURTO": "€ 501,988.9",
                                "OPEN24HOUR": "€ 0.2448",
                                "HIGH24HOUR": "€ 0.2516",
                                "LOW24HOUR": "€ 0.2421",
                                "CHANGE24HOUR": "€ 0.0038",
                                "CHANGEPCT24HOUR": "1.54",
                                "CHANGEDAY": "€ 0.0016",
                                "CHANGEPCTDAY": "0.67",
                                "CHANGEHOUR": "€ 0.00027",
                                "CHANGEPCTHOUR": "0.11",
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": "Just now",
                                "SUPPLY": "XLM 50,001,786,892.8",
                                "MKTCAP": "€ 12.43 B",
                                "MKTCAPPENALTY": "0 %",
                                "CIRCULATINGSUPPLY": "XLM 30,787,179,407.6",
                                "CIRCULATINGSUPPLYMKTCAP": "€ 7.65 B",
                                "TOTALVOLUME24H": "XLM 282.86 M",
                                "TOTALVOLUME24HTO": "€ 70.31 M",
                                "TOTALTOPTIERVOLUME24H": "XLM 131.27 M",
                                "TOTALTOPTIERVOLUME24HTO": "€ 32.63 M",
                                "IMAGEURL": "/media/37746346/xlm.png"
                            }
                        }
                    },
                    {
                        "CoinInfo": {
                            "Id": "936181",
                            "Name": "OM",
                            "FullName": "MANTRA",
                            "Internal": "OM",
                            "ImageUrl": "/media/43717810/om.png",
                            "Url": "/coins/om/overview",
                            "Algorithm": "N/A",
                            "ProofType": "N/A",
                            "Rating": {
                                "Weiss": {
                                    "Rating": "",
                                    "TechnologyAdoptionRating": "",
                                    "MarketPerformanceRating": ""
                                }
                            },
                            "NetHashesPerSecond": 0,
                            "BlockNumber": 0,
                            "BlockTime": 0,
                            "BlockReward": 0,
                            "AssetLaunchDate": "2020-12-17",
                            "MaxSupply": -1,
                            "Type": 1,
                            "DocumentType": "Webpagecoinp"
                        },
                        "RAW": {
                            "EUR": {
                                "TYPE": "5",
                                "MARKET": "CCCAGG",
                                "FROMSYMBOL": "OM",
                                "TOSYMBOL": "EUR",
                                "FLAGS": "2",
                                "LASTMARKET": "CCCAGG",
                                "MEDIAN": 5.8548,
                                "TOPTIERVOLUME24HOUR": 224.58579,
                                "TOPTIERVOLUME24HOURTO": 1313.335407896,
                                "LASTTRADEID": "1341",
                                "PRICE": 5.8548,
                                "LASTUPDATE": 1743332864,
                                "LASTVOLUME": 8.92693,
                                "LASTVOLUMETO": 52.265389764,
                                "VOLUMEHOUR": 153.18537,
                                "VOLUMEHOURTO": 896.843021459,
                                "OPENHOUR": 5.8826,
                                "HIGHHOUR": 5.8826,
                                "LOWHOUR": 5.8466,
                                "VOLUMEDAY": 206.6403,
                                "VOLUMEDAYTO": 1211.115125428,
                                "OPENDAY": 5.6585,
                                "HIGHDAY": 5.8826,
                                "LOWDAY": 5.6585,
                                "VOLUME24HOUR": 224.58579,
                                "VOLUME24HOURTO": 1313.335407896,
                                "OPEN24HOUR": 5.7412,
                                "HIGH24HOUR": 5.8826,
                                "LOW24HOUR": 5.6585,
                                "CHANGE24HOUR": 0.11359999999999992,
                                "CHANGEPCT24HOUR": 1.9786804152441984,
                                "CHANGEDAY": 0.19629999999999992,
                                "CHANGEPCTDAY": 3.4691172572236444,
                                "CHANGEHOUR": -0.027800000000000047,
                                "CHANGEPCTHOUR": -0.47258015163363215,
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": 1743332864,
                                "SUPPLY": 1814026663.67,
                                "MKTCAP": 10620763310.455116,
                                "MKTCAPPENALTY": 0,
                                "CIRCULATINGSUPPLY": 986284750.78,
                                "CIRCULATINGSUPPLYMKTCAP": 5774499958.866744,
                                "TOTALVOLUME24H": 5590111.0301304,
                                "TOTALVOLUME24HTO": 32728980.489732075,
                                "TOTALTOPTIERVOLUME24H": 2851084.3737608674,
                                "TOTALTOPTIERVOLUME24HTO": 16692527.22201973,
                                "IMAGEURL": "/media/43717810/om.png"
                            }
                        },
                        "DISPLAY": {
                            "EUR": {
                                "FROMSYMBOL": "OM",
                                "TOSYMBOL": "€",
                                "MARKET": "CryptoCompare Index",
                                "LASTMARKET": "CCCAGG",
                                "TOPTIERVOLUME24HOUR": "OM 224.59",
                                "TOPTIERVOLUME24HOURTO": "€ 1,313.34",
                                "LASTTRADEID": "1341",
                                "PRICE": "€ 5.85",
                                "LASTUPDATE": "2 min ago",
                                "LASTVOLUME": "OM 8.93",
                                "LASTVOLUMETO": "€ 52.27",
                                "VOLUMEHOUR": "OM 153.19",
                                "VOLUMEHOURTO": "€ 896.84",
                                "OPENHOUR": "€ 5.88",
                                "HIGHHOUR": "€ 5.88",
                                "LOWHOUR": "€ 5.85",
                                "VOLUMEDAY": "OM 206.64",
                                "VOLUMEDAYTO": "€ 1,211.12",
                                "OPENDAY": "€ 5.66",
                                "HIGHDAY": "€ 5.88",
                                "LOWDAY": "€ 5.66",
                                "VOLUME24HOUR": "OM 224.59",
                                "VOLUME24HOURTO": "€ 1,313.34",
                                "OPEN24HOUR": "€ 5.74",
                                "HIGH24HOUR": "€ 5.88",
                                "LOW24HOUR": "€ 5.66",
                                "CHANGE24HOUR": "€ 0.11",
                                "CHANGEPCT24HOUR": "1.98",
                                "CHANGEDAY": "€ 0.20",
                                "CHANGEPCTDAY": "3.47",
                                "CHANGEHOUR": "€ -0.028",
                                "CHANGEPCTHOUR": "-0.47",
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": "2 min ago",
                                "SUPPLY": "OM 1,814,026,663.7",
                                "MKTCAP": "€ 10.62 B",
                                "MKTCAPPENALTY": "0 %",
                                "CIRCULATINGSUPPLY": "OM 986,284,750.8",
                                "CIRCULATINGSUPPLYMKTCAP": "€ 5.77 B",
                                "TOTALVOLUME24H": "OM 5.59 M",
                                "TOTALVOLUME24HTO": "€ 32.73 M",
                                "TOTALTOPTIERVOLUME24H": "OM 2.85 M",
                                "TOTALTOPTIERVOLUME24HTO": "€ 16.69 M",
                                "IMAGEURL": "/media/43717810/om.png"
                            }
                        }
                    },
                    {
                        "CoinInfo": {
                            "Id": "928761",
                            "Name": "WBTC",
                            "FullName": "Wrapped Bitcoin",
                            "Internal": "WBTC",
                            "ImageUrl": "/media/35309588/wbtc.png",
                            "Url": "/coins/wbtc/overview",
                            "Algorithm": "N/A",
                            "ProofType": "N/A",
                            "Rating": {
                                "Weiss": {
                                    "Rating": "",
                                    "TechnologyAdoptionRating": "",
                                    "MarketPerformanceRating": ""
                                }
                            },
                            "NetHashesPerSecond": 0,
                            "BlockNumber": 0,
                            "BlockTime": 0,
                            "BlockReward": 0,
                            "AssetLaunchDate": "2018-11-27",
                            "MaxSupply": -1,
                            "Type": 1,
                            "DocumentType": "Webpagecoinp"
                        },
                        "RAW": {
                            "EUR": {
                                "TYPE": "5",
                                "MARKET": "CCCAGG",
                                "FROMSYMBOL": "WBTC",
                                "TOSYMBOL": "EUR",
                                "FLAGS": "1",
                                "PRICE": 76822.85050119857,
                                "LASTUPDATE": 1743332999,
                                "MEDIAN": 76822.85050119857,
                                "LASTVOLUME": 0.0001,
                                "LASTVOLUMETO": 7.682285050119857,
                                "LASTTRADEID": "15841394",
                                "VOLUMEDAY": 32.67054302,
                                "VOLUMEDAYTO": 2509844.242218436,
                                "VOLUME24HOUR": 62.19843815,
                                "VOLUME24HOURTO": 4778261.315405495,
                                "OPENDAY": 76310.30495445876,
                                "HIGHDAY": 77182.05907047362,
                                "LOWDAY": 76172.9804602976,
                                "OPEN24HOUR": 75917.37001307154,
                                "HIGH24HOUR": 77222.53653919432,
                                "LOW24HOUR": 75375.12048314548,
                                "LASTMARKET": "CCCAGG",
                                "VOLUMEHOUR": 0.75509,
                                "VOLUMEHOURTO": 58008.16618495003,
                                "OPENHOUR": 76754.6199040296,
                                "HIGHHOUR": 76823.58055738559,
                                "LOWHOUR": 76733.46935597851,
                                "TOPTIERVOLUME24HOUR": 62.19843815,
                                "TOPTIERVOLUME24HOURTO": 4778261.315405495,
                                "CHANGE24HOUR": 905.4804881270247,
                                "CHANGEPCT24HOUR": 1.1927184621531517,
                                "CHANGEDAY": 512.5455467398133,
                                "CHANGEPCTDAY": 0.6716596756436702,
                                "CHANGEHOUR": 68.23059716896387,
                                "CHANGEPCTHOUR": 0.08889444994226565,
                                "CONVERSIONTYPE": "multiply",
                                "CONVERSIONSYMBOL": "BTC",
                                "CONVERSIONLASTUPDATE": 1743333001,
                                "SUPPLY": 128915.05657878,
                                "MKTCAP": 9903622118.90517,
                                "MKTCAPPENALTY": 0,
                                "CIRCULATINGSUPPLY": 128915.05657878,
                                "CIRCULATINGSUPPLYMKTCAP": 9903622118.90517,
                                "TOTALVOLUME24H": 696.841232511952,
                                "TOTALVOLUME24HTO": 53533329.828336634,
                                "TOTALTOPTIERVOLUME24H": 563.88965013,
                                "TOTALTOPTIERVOLUME24HTO": 43319610.29111015,
                                "IMAGEURL": "/media/35309588/wbtc.png"
                            }
                        },
                        "DISPLAY": {
                            "EUR": {
                                "FROMSYMBOL": "wɃ",
                                "TOSYMBOL": "€",
                                "MARKET": "CryptoCompare Index",
                                "PRICE": "€ 76,822.9",
                                "LASTUPDATE": "Just now",
                                "LASTVOLUME": "wɃ 0.0001000",
                                "LASTVOLUMETO": "€ 7.68",
                                "LASTTRADEID": "15841394",
                                "VOLUMEDAY": "wɃ 32.67",
                                "VOLUMEDAYTO": "€ 2,509,844.2",
                                "VOLUME24HOUR": "wɃ 62.20",
                                "VOLUME24HOURTO": "€ 4,778,261.3",
                                "OPENDAY": "€ 76,310.3",
                                "HIGHDAY": "€ 77,182.1",
                                "LOWDAY": "€ 76,173.0",
                                "OPEN24HOUR": "€ 75,917.4",
                                "HIGH24HOUR": "€ 77,222.5",
                                "LOW24HOUR": "€ 75,375.1",
                                "LASTMARKET": "CCCAGG",
                                "VOLUMEHOUR": "wɃ 0.7551",
                                "VOLUMEHOURTO": "€ 58,008.2",
                                "OPENHOUR": "€ 76,754.6",
                                "HIGHHOUR": "€ 76,823.6",
                                "LOWHOUR": "€ 76,733.5",
                                "TOPTIERVOLUME24HOUR": "wɃ 62.20",
                                "TOPTIERVOLUME24HOURTO": "€ 4,778,261.3",
                                "CHANGE24HOUR": "€ 905.48",
                                "CHANGEPCT24HOUR": "1.19",
                                "CHANGEDAY": "€ 512.55",
                                "CHANGEPCTDAY": "0.67",
                                "CHANGEHOUR": "€ 68.23",
                                "CHANGEPCTHOUR": "0.09",
                                "CONVERSIONTYPE": "multiply",
                                "CONVERSIONSYMBOL": "BTC",
                                "CONVERSIONLASTUPDATE": "Just now",
                                "SUPPLY": "wɃ 128,915.1",
                                "MKTCAP": "€ 9.90 B",
                                "MKTCAPPENALTY": "0 %",
                                "CIRCULATINGSUPPLY": "wɃ 128,915.1",
                                "CIRCULATINGSUPPLYMKTCAP": "€ 9.90 B",
                                "TOTALVOLUME24H": "wɃ 696.84",
                                "TOTALVOLUME24HTO": "€ 53.53 M",
                                "TOTALTOPTIERVOLUME24H": "wɃ 563.89",
                                "TOTALTOPTIERVOLUME24HTO": "€ 43.32 M",
                                "IMAGEURL": "/media/35309588/wbtc.png"
                            }
                        }
                    },
                    {
                        "CoinInfo": {
                            "Id": "929418",
                            "Name": "CRO",
                            "FullName": "Cronos",
                            "Internal": "CRO",
                            "ImageUrl": "/media/34478435/mco.png",
                            "Url": "/coins/cro/overview",
                            "Algorithm": "N/A",
                            "ProofType": "PoS",
                            "Rating": {
                                "Weiss": {
                                    "Rating": "B-",
                                    "TechnologyAdoptionRating": "B-",
                                    "MarketPerformanceRating": "C-"
                                }
                            },
                            "NetHashesPerSecond": 0,
                            "BlockNumber": 0,
                            "BlockTime": 6,
                            "BlockReward": 0,
                            "AssetLaunchDate": "2019-11-14",
                            "MaxSupply": 100000000000,
                            "Type": 1,
                            "DocumentType": "Webpagecoinp"
                        },
                        "RAW": {
                            "EUR": {
                                "TYPE": "5",
                                "MARKET": "CCCAGG",
                                "FROMSYMBOL": "CRO",
                                "TOSYMBOL": "EUR",
                                "FLAGS": "1",
                                "LASTMARKET": "CCCAGG",
                                "MEDIAN": 0.0977388832538823,
                                "TOPTIERVOLUME24HOUR": 533114.136,
                                "TOPTIERVOLUME24HOURTO": 50793.08780405,
                                "LASTTRADEID": "160820",
                                "PRICE": 0.0977388832538823,
                                "LASTUPDATE": 1743332837,
                                "LASTVOLUME": 644.923,
                                "LASTVOLUMETO": 63.20890323,
                                "VOLUMEHOUR": 9693.82,
                                "VOLUMEHOURTO": 950.0912982,
                                "OPENHOUR": 0.0975236828330678,
                                "HIGHHOUR": 0.0977388832538823,
                                "LOWHOUR": 0.0975236828330678,
                                "VOLUMEDAY": 276536.287,
                                "VOLUMEDAYTO": 27036.20319396,
                                "OPENDAY": 0.0930821595668771,
                                "HIGHDAY": 0.10037081597233,
                                "LOWDAY": 0.092738320255433,
                                "VOLUME24HOUR": 533114.136,
                                "VOLUME24HOURTO": 50793.08780405,
                                "OPEN24HOUR": 0.0920140857392546,
                                "HIGH24HOUR": 0.10037081597233,
                                "LOW24HOUR": 0.0913074293006708,
                                "CHANGE24HOUR": 0.005724797514627705,
                                "CHANGEPCT24HOUR": 6.221653422553565,
                                "CHANGEDAY": 0.004656723687005204,
                                "CHANGEPCTDAY": 5.002810107407822,
                                "CHANGEHOUR": 0.00021520042081450697,
                                "CHANGEPCTHOUR": 0.2206647806593477,
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": 1743332837,
                                "SUPPLY": 97543210869,
                                "MKTCAP": 9533764499.334015,
                                "MKTCAPPENALTY": 0,
                                "CIRCULATINGSUPPLY": 26571560696,
                                "CIRCULATINGSUPPLYMKTCAP": 2597074668.7397914,
                                "TOTALVOLUME24H": 587900822.055075,
                                "TOTALVOLUME24HTO": 57459456.91920696,
                                "TOTALTOPTIERVOLUME24H": 449669594.304152,
                                "TOTALTOPTIERVOLUME24HTO": 43948891.088018686,
                                "IMAGEURL": "/media/34478435/mco.png"
                            }
                        },
                        "DISPLAY": {
                            "EUR": {
                                "FROMSYMBOL": "CRO",
                                "TOSYMBOL": "€",
                                "MARKET": "CryptoCompare Index",
                                "LASTMARKET": "CCCAGG",
                                "TOPTIERVOLUME24HOUR": "CRO 533,114.1",
                                "TOPTIERVOLUME24HOURTO": "€ 50,793.1",
                                "LASTTRADEID": "160820",
                                "PRICE": "€ 0.09774",
                                "LASTUPDATE": "2 min ago",
                                "LASTVOLUME": "CRO 644.92",
                                "LASTVOLUMETO": "€ 63.21",
                                "VOLUMEHOUR": "CRO 9,693.82",
                                "VOLUMEHOURTO": "€ 950.09",
                                "OPENHOUR": "€ 0.09752",
                                "HIGHHOUR": "€ 0.09774",
                                "LOWHOUR": "€ 0.09752",
                                "VOLUMEDAY": "CRO 276,536.3",
                                "VOLUMEDAYTO": "€ 27,036.2",
                                "OPENDAY": "€ 0.09308",
                                "HIGHDAY": "€ 0.1004",
                                "LOWDAY": "€ 0.09274",
                                "VOLUME24HOUR": "CRO 533,114.1",
                                "VOLUME24HOURTO": "€ 50,793.1",
                                "OPEN24HOUR": "€ 0.09201",
                                "HIGH24HOUR": "€ 0.1004",
                                "LOW24HOUR": "€ 0.09131",
                                "CHANGE24HOUR": "€ 0.0057",
                                "CHANGEPCT24HOUR": "6.22",
                                "CHANGEDAY": "€ 0.0047",
                                "CHANGEPCTDAY": "5.00",
                                "CHANGEHOUR": "€ 0.00022",
                                "CHANGEPCTHOUR": "0.22",
                                "CONVERSIONTYPE": "direct",
                                "CONVERSIONSYMBOL": "",
                                "CONVERSIONLASTUPDATE": "2 min ago",
                                "SUPPLY": "CRO 97,543,210,869.0",
                                "MKTCAP": "€ 9.53 B",
                                "MKTCAPPENALTY": "0 %",
                                "CIRCULATINGSUPPLY": "CRO 26,571,560,696.0",
                                "CIRCULATINGSUPPLYMKTCAP": "€ 2.60 B",
                                "TOTALVOLUME24H": "CRO 587.90 M",
                                "TOTALVOLUME24HTO": "€ 57.46 M",
                                "TOTALTOPTIERVOLUME24H": "CRO 449.67 M",
                                "TOTALTOPTIERVOLUME24HTO": "€ 43.95 M",
                                "IMAGEURL": "/media/34478435/mco.png"
                            }
                        }
                    },
                    {
                        "CoinInfo": {
                            "Id": "950493",
                            "Name": "WBT",
                            "FullName": "WhiteBIT Token",
                            "Internal": "WBT",
                            "ImageUrl": "/media/40485147/wbt.png",
                            "Url": "/coins/wbt/overview",
                            "Algorithm": "N/A",
                            "ProofType": "N/A",
                            "Rating": {
                                "Weiss": {
                                    "Rating": "",
                                    "TechnologyAdoptionRating": "",
                                    "MarketPerformanceRating": ""
                                }
                            },
                            "NetHashesPerSecond": 0,
                            "BlockNumber": 0,
                            "BlockTime": 0,
                            "BlockReward": 0,
                            "AssetLaunchDate": "2022-08-05",
                            "MaxSupply": 400000000,
                            "Type": 1,
                            "DocumentType": "Webpagecoinp"
                        },
                        "RAW": {
                            "EUR": {
                                "TYPE": "5",
                                "MARKET": "CCCAGG",
                                "FROMSYMBOL": "WBT",
                                "TOSYMBOL": "EUR",
                                "FLAGS": "4",
                                "PRICE": 26.16762493990683,
                                "LASTUPDATE": 1743332968,
                                "MEDIAN": 26.16762493990683,
                                "LASTVOLUME": 3.3,
                                "LASTVOLUMETO": 86.35316230169254,
                                "LASTTRADEID": "20747988",
                                "VOLUMEDAY": 11988.5,
                                "VOLUMEDAYTO": 313710.571592073,
                                "VOLUME24HOUR": 40235.9,
                                "VOLUME24HOURTO": 1052877.940319597,
                                "OPENDAY": 26.1194629209331,
                                "HIGHDAY": 26.45076496293471,
                                "LOWDAY": 25.85107145684741,
                                "OPEN24HOUR": 26.2102709055943,
                                "HIGH24HOUR": 26.7287064511617,
                                "LOW24HOUR": 25.58029912842752,
                                "LASTMARKET": "CCCAGG",
                                "VOLUMEHOUR": 174.6,
                                "VOLUMEHOURTO": 4568.867314507732,
                                "OPENHOUR": 26.13901402853078,
                                "HIGHHOUR": 26.18323597129744,
                                "LOWHOUR": 26.13195181139474,
                                "TOPTIERVOLUME24HOUR": 40235.9,
                                "TOPTIERVOLUME24HOURTO": 1052877.940319597,
                                "CHANGE24HOUR": -0.04264596568746981,
                                "CHANGEPCT24HOUR": -0.16270707708849924,
                                "CHANGEDAY": 0.048162018973730625,
                                "CHANGEPCTDAY": 0.18439130666477757,
                                "CHANGEHOUR": 0.028610911376048875,
                                "CHANGEPCTHOUR": 0.10945673522658511,
                                "CONVERSIONTYPE": "multiply",
                                "CONVERSIONSYMBOL": "BTC",
                                "CONVERSIONLASTUPDATE": 1743333001,
                                "SUPPLY": 328380962,
                                "MKTCAP": 8592949851.021797,
                                "MKTCAPPENALTY": 0,
                                "CIRCULATINGSUPPLY": 182380962,
                                "CIRCULATINGSUPPLYMKTCAP": 4772476609.7954,
                                "TOTALVOLUME24H": 460241.1123,
                                "TOTALVOLUME24HTO": 12043416.80859194,
                                "TOTALTOPTIERVOLUME24H": 0,
                                "TOTALTOPTIERVOLUME24HTO": 0,
                                "IMAGEURL": "/media/40485147/wbt.png"
                            }
                        },
                        "DISPLAY": {
                            "EUR": {
                                "FROMSYMBOL": "WBT",
                                "TOSYMBOL": "€",
                                "MARKET": "CryptoCompare Index",
                                "PRICE": "€ 26.17",
                                "LASTUPDATE": "Just now",
                                "LASTVOLUME": "WBT 3.30",
                                "LASTVOLUMETO": "€ 86.35",
                                "LASTTRADEID": "20747988",
                                "VOLUMEDAY": "WBT 11,988.5",
                                "VOLUMEDAYTO": "€ 313,710.6",
                                "VOLUME24HOUR": "WBT 40,235.9",
                                "VOLUME24HOURTO": "€ 1,052,877.9",
                                "OPENDAY": "€ 26.12",
                                "HIGHDAY": "€ 26.45",
                                "LOWDAY": "€ 25.85",
                                "OPEN24HOUR": "€ 26.21",
                                "HIGH24HOUR": "€ 26.73",
                                "LOW24HOUR": "€ 25.58",
                                "LASTMARKET": "CCCAGG",
                                "VOLUMEHOUR": "WBT 174.60",
                                "VOLUMEHOURTO": "€ 4,568.87",
                                "OPENHOUR": "€ 26.14",
                                "HIGHHOUR": "€ 26.18",
                                "LOWHOUR": "€ 26.13",
                                "TOPTIERVOLUME24HOUR": "WBT 40,235.9",
                                "TOPTIERVOLUME24HOURTO": "€ 1,052,877.9",
                                "CHANGE24HOUR": "€ -0.043",
                                "CHANGEPCT24HOUR": "-0.16",
                                "CHANGEDAY": "€ 0.048",
                                "CHANGEPCTDAY": "0.18",
                                "CHANGEHOUR": "€ 0.029",
                                "CHANGEPCTHOUR": "0.11",
                                "CONVERSIONTYPE": "multiply",
                                "CONVERSIONSYMBOL": "BTC",
                                "CONVERSIONLASTUPDATE": "Just now",
                                "SUPPLY": "WBT 328,380,962.0",
                                "MKTCAP": "€ 8.59 B",
                                "MKTCAPPENALTY": "0 %",
                                "CIRCULATINGSUPPLY": "WBT 182,380,962.0",
                                "CIRCULATINGSUPPLYMKTCAP": "€ 4.77 B",
                                "TOTALVOLUME24H": "WBT 460.24 K",
                                "TOTALVOLUME24HTO": "€ 12.04 M",
                                "TOTALTOPTIERVOLUME24H": "WBT 0",
                                "TOTALTOPTIERVOLUME24HTO": "€ 0",
                                "IMAGEURL": "/media/40485147/wbt.png"
                            }
                        }
                    },
                    {
                        "CoinInfo": {
                            "Id": "930571",
                            "Name": "LEO",
                            "FullName": "LEO Token",
                            "Internal": "LEO",
                            "ImageUrl": "/media/35650675/leo.png",
                            "Url": "/coins/leo/overview",
                            "Algorithm": "N/A",
                            "ProofType": "N/A",
                            "Rating": {
                                "Weiss": {
                                    "Rating": "D",
                                    "TechnologyAdoptionRating": "D-",
                                    "MarketPerformanceRating": "C-"
                                }
                            },
                            "NetHashesPerSecond": 0,
                            "BlockNumber": 0,
                            "BlockTime": 0,
                            "BlockReward": 0,
                            "AssetLaunchDate": "2019-05-21",
                            "MaxSupply": -1,
                            "Type": 1,
                            "DocumentType": "Webpagecoinp"
                        },
                        "RAW": {
                            "EUR": {
                                "TYPE": "5",
                                "MARKET": "CCCAGG",
                                "FROMSYMBOL": "LEO",
                                "TOSYMBOL": "EUR",
                                "FLAGS": "4",
                                "PRICE": 8.699929041666717,
                                "LASTUPDATE": 1743307200,
                                "MEDIAN": 8.699929041666717,
                                "LASTVOLUME": 0,
                                "LASTVOLUMETO": 0,
                                "LASTTRADEID": "260078",
                                "VOLUMEDAY": 0.61441216,
                                "VOLUMEDAYTO": 5.345342194337178,
                                "VOLUME24HOUR": 1.7842213,
                                "VOLUME24HOURTO": 15.52259870463034,
                                "OPENDAY": 8.548614383097375,
                                "HIGHDAY": 8.771168295532284,
                                "LOWDAY": 8.480219449449791,
                                "OPEN24HOUR": 8.701917487513231,
                                "HIGH24HOUR": 8.836218707048683,
                                "LOW24HOUR": 8.408990269436005,
                                "LASTMARKET": "CCCAGG",
                                "VOLUMEHOUR": 0,
                                "VOLUMEHOURTO": 0,
                                "OPENHOUR": 8.686301388102235,
                                "HIGHHOUR": 8.699929041666717,
                                "LOWHOUR": 8.68456476519864,
                                "TOPTIERVOLUME24HOUR": 1.7842213,
                                "TOPTIERVOLUME24HOURTO": 15.52259870463034,
                                "CHANGE24HOUR": -0.001988445846514253,
                                "CHANGEPCT24HOUR": -0.02285066307934501,
                                "CHANGEDAY": 0.15131465856934234,
                                "CHANGEPCTDAY": 1.7700489434700328,
                                "CHANGEHOUR": 0.013627653564482145,
                                "CHANGEPCTHOUR": 0.15688672261761671,
                                "CONVERSIONTYPE": "multiply",
                                "CONVERSIONSYMBOL": "ETH",
                                "CONVERSIONLASTUPDATE": 1743333005,
                                "SUPPLY": 923836969.9,
                                "MKTCAP": 8037316084.198391,
                                "MKTCAPPENALTY": 0,
                                "CIRCULATINGSUPPLY": 923836969.9,
                                "CIRCULATINGSUPPLYMKTCAP": 8037316084.198391,
                                "TOTALVOLUME24H": 220217.52940956,
                                "TOTALVOLUME24HTO": 1915876.8795943253,
                                "TOTALTOPTIERVOLUME24H": 19713.6078291204,
                                "TOTALTOPTIERVOLUME24HTO": 171506.98926859294,
                                "IMAGEURL": "/media/35650675/leo.png"
                            }
                        },
                        "DISPLAY": {
                            "EUR": {
                                "FROMSYMBOL": "LEO",
                                "TOSYMBOL": "€",
                                "MARKET": "CryptoCompare Index",
                                "PRICE": "€ 8.70",
                                "LASTUPDATE": "7 hours ago",
                                "LASTVOLUME": "LEO 0",
                                "LASTVOLUMETO": "€ 0",
                                "LASTTRADEID": "260078",
                                "VOLUMEDAY": "LEO 0.6144",
                                "VOLUMEDAYTO": "€ 5.35",
                                "VOLUME24HOUR": "LEO 1.78",
                                "VOLUME24HOURTO": "€ 15.52",
                                "OPENDAY": "€ 8.55",
                                "HIGHDAY": "€ 8.77",
                                "LOWDAY": "€ 8.48",
                                "OPEN24HOUR": "€ 8.70",
                                "HIGH24HOUR": "€ 8.84",
                                "LOW24HOUR": "€ 8.41",
                                "LASTMARKET": "CCCAGG",
                                "VOLUMEHOUR": "LEO 0",
                                "VOLUMEHOURTO": "€ 0",
                                "OPENHOUR": "€ 8.69",
                                "HIGHHOUR": "€ 8.70",
                                "LOWHOUR": "€ 8.68",
                                "TOPTIERVOLUME24HOUR": "LEO 1.78",
                                "TOPTIERVOLUME24HOURTO": "€ 15.52",
                                "CHANGE24HOUR": "€ -0.0020",
                                "CHANGEPCT24HOUR": "-0.02",
                                "CHANGEDAY": "€ 0.15",
                                "CHANGEPCTDAY": "1.77",
                                "CHANGEHOUR": "€ 0.014",
                                "CHANGEPCTHOUR": "0.16",
                                "CONVERSIONTYPE": "multiply",
                                "CONVERSIONSYMBOL": "ETH",
                                "CONVERSIONLASTUPDATE": "Just now",
                                "SUPPLY": "LEO 923,836,969.9",
                                "MKTCAP": "€ 8.04 B",
                                "MKTCAPPENALTY": "0 %",
                                "CIRCULATINGSUPPLY": "LEO 923,836,969.9",
                                "CIRCULATINGSUPPLYMKTCAP": "€ 8.04 B",
                                "TOTALVOLUME24H": "LEO 220.22 K",
                                "TOTALVOLUME24HTO": "€ 1.92 M",
                                "TOTALTOPTIERVOLUME24H": "LEO 19.71 K",
                                "TOTALTOPTIERVOLUME24HTO": "€ 171.51 K",
                                "IMAGEURL": "/media/35650675/leo.png"
                            }
                        }
                    }
                ],
                "RateLimit": {},
                "HasWarning": false
            }
            </code></pre>

            <p>Instalamos Zustand <span class="destacado">npm i zustand</span> para tener un estado global y estaremos viendo como en Zustand tenemos o podemos consumir una API externa.</p>

            <ul class="list-disc my-3">
              <li class="my-1.25">
                En src generamos el archivo store.ts, en el cual importamos la función <strong>create</strong> de Zustand que nos permite crear nuestro store. Lo creamos con create y su callback que, recordemos, usa paréntesis y dentro llaves <code class="language-ts">create (() => ({...}))</code>. Dentro creamos una función que nombramos como fetchCryptos <code class="language-ts">fetchCryptos: () => {...}</code>. Recordemos que aquí es donde tenemos la función que modifica el state. <strong>Zustand tiene state y funciones que lo modifican juntas, a diferencia de lo que veíamos con useReducer donde en la parte superior definíamos las acciones y su payload y en la parte inferior ya manejábamos toda la lógica.</strong>
                <pre data-line="0"><code class="language-ts">
                  //store.ts
                  import { create } from "zustand"
                  export const useCryptoStore = create(() => ({
                      fetchCryptos: () => {
                          console.log('desde fetchCryptos')
                      }
                  }))
                </code></pre>
              </li>
              <li class="my-1.25">Esta función va a mandar llamar este JSON que acabamos de ver para traerse las 20 criptomonedas más valiosas pero ¿cuando/donde la vamos a mandar llamar? Pongamosle un console.log("desde FetchCryptos"). Vamos a colocar esa llamada en nuestro compo ppal <span class="file">App.tsx</span> porque queremos que esa función se mande llamar tan pronto como nuestra app esté lista, para lo cual importamos nuestro store, lo usamos en un nuevo objeto 'fetchCryptos' que mandamos 'observar' con un useEffect y vemos nuestra consola:

                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre data-line="0-3,6-9"><code class="language-ts">
                      //App.tsx
                      import { useEffect } from 'react';
                      import CriptoSearchForm from './components/CriptoSearchForm';
                      import { useCryptoStore } from './store'
                      
                      function App() {
                        const fetchCryptos = useCryptoStore((state) => state.fetchCryptos)
                        useEffect(() => {
                          fetchCryptos()
                        }, [])
                      
                        return (
                          &lt;&gt;
                            &lt;div className=&quot;container&quot;&gt;
                                &lt;h1 className=&quot;app-title&quot;&gt;
                                    Cotizador de &lt;span&gt;Criptomonedas&lt;/span&gt;
                                &lt;/h1&gt;
                      
                                &lt;div className=&quot;content&quot;&gt;
                                    &lt;CriptoSearchForm /&gt;
                                &lt;/div&gt;
                            &lt;/div&gt;
                          &lt;/&gt;
                        )
                      }                    
                      export default App
                    </code></pre>
                  </div>
                  <div class="w-[50%] max-sm:w-[100%]">
                    <img src="./src/assets/img/287.png" alt="img" loading="lazy">

                    <p>Como vemos desde Zustand podemos también hacer llamadas/consulta hacia una API sin ningún problema. Lo ideal va a ser colocar esa consulta en nuesto state, para lo cual vamos a crear un state cryptocurrencies o criptomonedas que va a ser un arreglo y vamos a hacer la llamada utilizando actios y traernos toda la información.</p>
                  </div>
                </div>             
              </li>
            </ul>

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion17-288').toggle();">
            <h3>288. Obteniendo las Criptomonedas en Zustand</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion17-288" class="hidden">
            <p>Comencemos con la llamada a nuestra API. Nuestro endpoint va a ser este: <a href="https://min-api.cryptocompare.com/data/top/mktcapfull?limit=20&tsym=EUR" class="underline" target="blank">https://min-api.cryptocompare.com/data/top/mktcapfull?limit=20&tsym=EUR</a>.</p>

            <p>Instalamos axios <span class="destacado">npm i axios</span> que simplifica bastante las llamadas a APIs.</p>

            <p>Vimos que cuando queremos escribir en el state, se le pasa como parámetro una función llamada set que usaríamos aquí....</p>
            <pre data-line="2,5"><code class="language-ts">
              //store.ts
              import { create } from "zustand"
              export const useCryptoStore = create((set) => ({
                  fetchCryptos: () => {
                      console.log('desde fetchCryptos')
                      set(...)
                  }
              }))
            </code></pre>

            <p>Antes de ese set puedes escribir toda la lógica que quramos pero como ya vimos, cuando trabajamos con llamadas hacia APIs ese código suele ser muy largo. Pero quiero que mis acciones sean más limpias (las funciones que están dentro del store de Zustand, aunque se definen de forma diferente a las que vimos en useReducer y como tal no es que en Zustand haya acciones con payload, al ser funciones, son acciones).</p>

            <p>Creamos la acción/función <strong>getCryptos()</strong> donde vamos a escribir toda la lógica:</p>

            <ul class="list-disc my-3">
              <li class="my-1.25">importamos axios <code class="language-ts">import axios from 'axios'</code></li>
              <li class="my-1.25">Creamos variable <strong>url</strong> para la url <code class="language-ts">const url = 'https://min-api.cryptocompare.com/data/top/mktcapfull?limit=20&tsym=EUR'</code></li>
              <li class="my-1.25">creamos otra variable <strong>data</strong> usamos await axios hacia nuestra url <code class="language-ts">const data = await axios(url)</code> y mandamos a la consola ese data para ver qué estamos obteniendo.
              
              <div class="flex max-sm:flex-col mt-2">
                
                <div class="w-[50%] max-sm:w-[100%]">
                  <p>En <span class="file">App.tsx</span> cuando nuestra App está lista, con el useEffect mandamos llamar a nuestro store <strong>useCryptoStore</strong> </p>
                  <pre data-line="0, 6-9"><code class="language-ts">
                    //App.tsx
                    import { useEffect } from 'react';
                    import CriptoSearchForm from './components/CriptoSearchForm';
                    import { useCryptoStore } from './store'

                    function App() {
                      const fetchCryptos = useCryptoStore((state) => state.fetchCryptos)
                      useEffect(() => {
                        fetchCryptos()
                      }, [])

                      return (
                        &lt;&gt;
                          &lt;div className=&quot;container&quot;&gt;
                              &lt;h1 className=&quot;app-title&quot;&gt;
                                  Cotizador de &lt;span&gt;Criptomonedas&lt;/span&gt;
                              &lt;/h1&gt;

                              &lt;div className=&quot;content&quot;&gt;
                                  &lt;CriptoSearchForm /&gt;
                              &lt;/div&gt;
                          &lt;/div&gt;
                        &lt;/&gt;
                      )
                    }
                    export default App

                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <p><br>...y nuestro store se encarga de mandar llamar esta otra función <strong>getCryptos()</strong></p>
                  <pre data-line="0,4-8,12"><code class="language-ts">
                    //store.ts
                    import { create } from "zustand"
                    import axios from 'axios'
                    
                    async function getCryptos(){
                        const url = 'https://min-api.cryptocompare.com/data/top/mktcapfull?limit=20&tsym=EUR'
                        //const data = await axios(url)
                        const {data: {Data}} = await axios(url)
                        console.log(data)
                    }
                    
                    export const useCryptoStore = create(() => ({
                        fetchCryptos: () => {
                            getCryptos()
                        }
                    }))              
                  </code></pre>

                  <p>y vemos que aparece esta respuesta; sabemos que la llamada fue correcta viendo <strong>statusText: "OK"</strong></p>
                  <img src="./src/assets/img/288.png" alt="img" loading="lazy">
                </div>                
              </div>

              <div class="flex max-sm:flex-col border p-5">
                <div class="w-[50%] max-sm:w-[100%]">
                  <p class="mt-2">Si despegamos el Data dentro de data vemos que ahí están todas las criptos:</p>
                  <img src="./src/assets/img/288-2.png" alt="img" loading="lazy">
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <p>Podemos entrar al primer data si en vez de <code class="language-ts">const data = await axios(url)</code> ponemos esto: <code class="language-ts">const {data} = await axios(url)</code> <code class="language-ts">console.log(data)</code></p>
                  <img src="./src/assets/img/288-3.png" alt="img" loading="lazy">
                  <p>¿Y acceder al Data dentro de data? sí, poniendo esto <code class="language-ts">const {data: {Data}} = await axios(url)</code> y enviamos <strong>Data a la consola <code class="language-ts">console.log(Data)</code></strong></p>
                  <img src="./src/assets/img/288-4.png" alt="img" loading="lazy">
                </div>
              </div>
              </li>
              <li class="my-1.25">Si expandimos por ejemplo el primero, vemos en <strong>CoinInfo</strong> que tenemos información sobre esa moneda, de hecho la primera es un Bitcoin como vemos en <strong>FullName</strong>(que es el nombre que quremos mostrar en nuestro segundo select) y requerimos el valor de 3 dígitos (Name) que es el que vamos a enviar como petición a la API para generar ese segundo select de nuestro formulario:
              <img src="./src/assets/img/288-5.png" alt="img" loading="lazy">             
              </li>              
            </ul> 
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion17-289').toggle();">
            <h3>289. Validando la respuesta de la API con Zod</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion17-289" class="hidden">
            <p>Estamos consultando la API de cryto compare y obteniendo las 20 criptos de mayor valor.  Si recordamos vamos a usar Zod para asegurarnos y revisar que la respuesta que estamos obteniendo de la API tiene la forma, el schema que nosotros deseamos.</p>

            <ul class="list-disc my-3">
              <li class="my-1.25">En <span class="file">crypto-schema.ts</span> creamos una nueva variable <code class="language-ts">export const CryptoCurrencyResponseSchema = z.object({ ... })</code> que es la respuesta de nuestra API. Y dentro de ese objeto, de toda esa lista que nos pasa el backend como decimos solo requerimos <strong>FullName</strong> y <strong>Name</strong> siendo ambos strings:
              <pre data-line="0, 7-12"><code class="language-ts">
                //crypto-schema.ts
                import { z } from 'zod'

                export const CurrencySchema = z.object({
                  code: z.string(),
                  name: z.string()
                })
                export const CryptoCurrencyResponseSchema = z.object({
                  CoinInfo : z.object({
                    FullName: z.string(),
                    Name: z.string()
                  }) 
                })
              </code></pre>
              </li>
              <li class="my-1.25">Volvemos a nuestro <span class="file">store.ts</span> y como tenemos que validar nuestro Data <code class="language-ts">const {data: {Data}} = await axios(url)</code> utilizando ese schema que acabamos de crear; eliminamos el <code class="language-ts">console.log(Data)</code> y en su lugar añadimos la nueva variable <strong>result</strong> en la que usando el nuevo schema y la función safeParse (para validar la respuesta porque TS ni puede, recordemos) le pasamos ese Data y ponemos <code class="language-ts">console.log(result)</code> a esta nueva variable para ver qué obtenemos y vemos que obtenemos un <strong>succes: false</strong>:
                <pre data-line="0"><code class="language-ts">
                  //store.ts
                  ...
                  const result = CryptoCurrencyResponseSchema.safeParse(Data)
                  console.log(result)
                </code></pre>
                <img src="./src/assets/img/289-1.png" alt="img" loading="lazy">
                
                <p>¿Por qué, si era la respuesta que esperábamos?. Si hacemos un console.log(Data) antes, podemos ver que lo que nos devuelve es un arreglo</p>
                <pre data-line="0"><code class="language-ts">
                  //store.ts
                  async function getCryptos(){
                    const url = 'https://min-api.cryptocompare.com/data/top/mktcapfull?limit=20&tsym=EUR'
                    const {data: {Data}} = await axios(url)
                    console.log(Data)
                    const result = CryptoCurrencyResponseSchema.safeParse(Data)
                    console.log(result)
                }
                </code></pre>
                <img src="./src/assets/img/289-2.png" alt="img" loading="lazy">
                <p>¿Como lo solucionamos? En <span class="file">crypto-schema.ts</span> retocamos la nueva variable del nuevo schema indicándole que es un array y ya de esa forma va a esperar un arreglo:</p>
                <pre data-line="0,6,12"><code class="language-ts">
                  //crypto-schema.ts
                  import { z } from 'zod'
                  export const CurrencySchema = z.object({
                      code: z.string(),
                      name: z.string()
                  })
                  export const CryptoCurrencyResponseSchema = z.array(
                    z.object({
                      CoinInfo : z.object({
                        FullName: z.string(),
                        Name: z.string()
                      }) 
                  }))
                </code></pre>
                <p>Si recargamos vemos que ya nos aparece el <strong>success: true</strong></p>
                <img src="./src/assets/img/289-3.png" alt="img" loading="lazy">
                <p>Estos son los beneficios de utilizar Zod, porque va a comprobar con el JSON, con los datos reales, que estamos obteniendo.</p>              
              </li>
              <li class="my-1.25">Una recomendación que nos da en lugar de tener así los schemas que contienen arrays (z.array() y dentro z.object()) es tener, digamos, una forma en singular y una forma en plural para que se aun poco más reutilizable. Creamos una nueva variable para "schema arrray" <strong>CryptoCurrenciesResponseSchema</strong> y le pasamos como argumento nuestro primer eschema <strong>CryptoCurrencyResponseSchema</strong>. Lo único que hace es tomar el esquema <strong>CryptoCurrencyResponseSchema</strong> que le pasamos como argumento y convertirlo a arreglo (como si tuviéramos un type por ejemplo de Product y después le pusiéramos arreglo Product[])

                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre class="rojo" data-line="6-12"><code class="language-ts">
                      //crypto-schema.ts
                      import { z } from 'zod'
                      export const CurrencySchema = z.object({
                          code: z.string(),
                          name: z.string()
                      })
                      export const CryptoCurrencyResponseSchema = z.array(
                        z.object({
                          CoinInfo : z.object({
                            FullName: z.string(),
                            Name: z.string()
                          }) 
                      }))
                    </code></pre>
                  
                  </div>
                  <div class="w-[50%] max-sm:w-[100%]">
                    
                    <pre class="verde" data-line="6-11,13"><code class="language-ts">
                      //crypto-schema.ts
                      import { z } from 'zod'
                      export const CurrencySchema = z.object({
                          code: z.string(),
                          name: z.string()
                      })
                      export const CryptoCurrencyResponseSchema = z.object({
                          CoinInfo : z.object({
                            FullName: z.string(),
                            Name: z.string()
                        }) 
                      })

                      export const CryptoCurrenciesResponseSchema = z.array(CryptoCurrencyResponseSchema)
                    </code></pre>
                  </div>
                </div>

                <p>Volvamos al store y utilicemos este nuevo schema para array (eliminamos la importanción del otro también)</p>
                <p>Seguimos viendo que nos devuelve un <strong>success: true</strong> porque funciona correctamente:</p>

                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre data-line="0,3,9"><code class="language-ts">
                      //store.ts
                      import { create } from "zustand"
                      import axios from 'axios'
                      import { CryptoCurrenciesResponseSchema } from './schema/crypto-schema'
                      
                      async function getCryptos(){
                        const url = 'https://min-api.cryptocompare.com/data/top/mktcapfull?limit=20&tsym=EUR'
                        const {data: {Data}} = await axios(url)
                        console.log(Data)
                        const result = CryptoCurrenciesResponseSchema.safeParse(Data)
                        console.log(result)
                      }                      
                      export const useCryptoStore = create(() => ({
                        fetchCryptos: () => {
                          getCryptos()
                        }
                      }))
                    </code></pre>
                  </div>
                  <div class="w-[50%] max-sm:w-[100%]">                    
                    <img src="./src/assets/img/289-4.png" alt="img" loading="lazy">                    
                  </div>
                </div>
                <p>Coloquemos en el state esta respuesta que estamos obteniendo porque esta ya viene bien formateada, ya tiene todo lo que necesitamos para componer ese segundo select de nuestro formulario: el <strong>FullName</strong> y el <strong>Name</strong></p>
              </li>
            </ul>
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion17-290').toggle();">
            <h3>290. Finalizando la función que obtiene las Criptos</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion17-290" class="hidden">
            <p>Vamos a finalizar la función <code class="language-ts">async function getCryptos(){...}</code> de nuestro <span class="file">store.ts</span>. Como vimos ya tenemos un resultado satisfactorio, ese <strong>success: true</strong> nos confirma que se está validando la respuesta correctamente. Metemos un if para que si result.success retorne result.data y así esos datos van a nuestra función <strong>getCryptos()</strong> que tenemos en nuestro store. Probemos a meter la llamada a getCryptos en una variable que vemos con console.log y vemos que nos aparece un <span class="rojo">Promise {&lt;Pending&gt;}</span> </p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="0,7-9,14-15"><code class="language-ts">
                  //store.ts
                  async function getCryptos(){
                    const url = 'https://min-api.cryptocompare.com/data/top/mktcapfull?limit=20&tsym=EUR'
                    const {data: {Data}} = await axios(url)
                    console.log(Data)
                    const result = CryptoCurrenciesResponseSchema.safeParse(Data)
                    //console.log(result)
                    if(result.success){
                        return result.data
                    }
                  }
                  export const useCryptoStore = create(() => ({
                    fetchCryptos: () => {
                        //getCryptos()
                        const cryptocurrencies = getCryptos()
                        console.log(cryptocurrencies)
                    }
                  }))
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%] ml-2">
                <img src="./src/assets/img/290-1.png" alt="img" loading="lazy">
              </div>
            </div>  

            <p>¿Por qué nos pasa esto si nos estaba funcionando bien pero ahora con el nuevo console.log vemos eso? porque <span class="destacado">nuestra función getCryptos() es asíncrona (tiene el async y el await) y por tanto se alcanza a resolver correctamente</span> sin embargo en la parte inferior, <strong>la acción de nuestro store es otra función aparte</strong> y, aunque estamos llamando en el código a getCryptos no estamos esperando a que se resuelva esa función antes de continuar con la ejecución de nuestro código, con ese console log (estamos intentando hacer un console.log de algo que aún no se ha ejecutado, esa llamada a getCryptos que hemos metido en una variable). <span class="destacado">Recordemos que lo que hace ese await es: "en lo que voy y obtengo la información de los datos detengo la ejecución del código"</span>. Si, como en la parte inferior (la acción de nuestra store), no hacemos nuestra función asíncrona, la va a tratar como una función normal, no va a bloquear la ejecución del código y va a ejecutar todo de arriba hacia a abajo y por eso obtenemos ese <span class="rojo">Promise {&lt;Pending&gt;}</span> </p>
            <p>¿Cómo convertimos esa acción en asíncroma? <span class="destacado">le añadimos la palabra async aquí, y la palabra await aquí para bloquear la ejecución del console.log(cryptocurrencies) hasta que getCryptos() haya finalizado su ejecución</span>. Y ahora sí vemos que aparece el resultado correctamente:</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="0,1,3,12,14"><code class="language-ts">
                  //store.ts
                  async function getCryptos(){
                    const url = 'https://min-api.cryptocompare.com/data/top/mktcapfull?limit=20&tsym=EUR'
                    const {data: {Data}} = await axios(url)
                    console.log(Data)
                    const result = CryptoCurrenciesResponseSchema.safeParse(Data)
                    //console.log(result)
                    if(result.success){
                        return result.data
                    }
                  }
                  export const useCryptoStore = create(() => ({
                    fetchCryptos: async () => {
                        //getCryptos()
                        const cryptocurrencies = await getCryptos()
                        console.log(cryptocurrencies)
                    }
                  }))
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <img src="./src/assets/img/290-2.png" alt="img" loading="lazy">
              </div>
            </div>

            <p>Como queremos colocar todo lo de nuestra respuesta en un state y aún no tenemos uno, lo creamos (en vez de <code class="language-ts">cryptocurrencies : cryptocurrencies</code> podríamos poner <code class="language-ts">cryptocurrencies</code> porque se llaman igual pero yo prefiero dejarlo así para entender que seteamos nuestro state cryptocurrencies (inicializado vacío en nuestro store) con lo que recuperamos del await getCryptos() que guardamos en la variable cryptocurrencies):</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="0,2,3,8-10"><code class="language-ts">
                  //store.ts
                  ...                
                  export const useCryptoStore = create((set) => ({
                    cryptocurrencies: [],
                    fetchCryptos: async () => {
                      //getCryptos()
                      const cryptocurrencies = await getCryptos()
                      //console.log(cryptocurrencies)
                      set(() => ({
                          cryptocurrencies : cryptocurrencies
                      }))
                    }
                  }))
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
               
              </div>
            </div>



            <p>Inmediatamente al guardar cambios vemos que nos da un aviso en <span class="file">App.tsx</span> de que ese state es de tipo unknown: <span class="bg-amber-950 text-amber-300">"state" es de tipo "unknown".</span></p>

            <img src="./src/assets/img/290-3.png" alt="img" loading="lazy">

            <p>Y es porque en el store aún no hemos definido qué forma va a tener el state de este store, el type, lo hacemos:</p>
              
            <p><span class="destacado">Creamos el type en <span class="file">types/index.ts</span> para a su vez poder tipar en nuestro store el state y la acción con la que recuperamos las cryptos y seteamos el state. Podemos usar cualquiera de los dos schemas siguientes pero es preferible el "singular" para que al tipar en el store quede más claro que se tratra de un array:</span></p>
              <ul class="list-disc my-3">
                <li class="my-1.25">Usar el schema singular de <span class="file">schema/crypto-schema.ts</span> <code class="language-ts">CryptoCurrencyResponseSchema</code> <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                </svg>
                <span class="file">types/index.ts</span>
                <code class="language-ts">export type Cryptocurrency = z.infer&lt;typeof CryptoCurrencyResponseSchema&gt;</code>
                <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                </svg>
                <pre data-line="0,2"><code class="language-ts">
                  //store.ts
                  type CryptoStore = {
                    cryptocurrencies: Cryptocurrency[]
                    fetchCryptos: () => Promise&lt;void&gt; 
                  }
                </code></pre>
                </li>
                <li class="my-1.25">Usar el otro schema de array de <span class="file">schema/crypto-schema.ts</span> <code class="language-ts">CryptoCurrenciesResponseSchema</code> <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                </svg>
                <span class="file">types/index.ts</span>
                <code class="language-ts">export type Cryptocurrencies = z.infer&lt;typeof CryptoCurrenciesResponseSchema&gt;</code>
                <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                </svg>
                <pre data-line="0,2"><code class="language-ts">
                  //store.ts
                  type CryptoStore = {
                    cryptocurrencies: Cryptocurrencies
                    fetchCryptos: () => Promise&lt;void&gt; 
                  }
                </code></pre>
                </li>
              </ul>
           
            <pre data-line="0"><code class="language-ts">
              //schema/crypto-schema.ts
              import { z } from 'zod'

              export const CurrencySchema = z.object({
                  code: z.string(),
                  name: z.string()
              })              
              export const CryptoCurrencyResponseSchema = z.object({
                  CoinInfo : z.object({
                      FullName: z.string(),
                      Name: z.string()
                  }) 
              })              
              export const CryptoCurrenciesResponseSchema = z.array(CryptoCurrencyResponseSchema)
            </code></pre>
          

            <pre data-line="0,2,5"><code class="language-ts">
              //types/index.ts
              import { z } from 'zod'
              import { CurrencySchema, CryptoCurrencyResponseSchema } from '../schema/crypto-schema'
              
              export type Currency = z.infer&lt;typeof CurrencySchema&gt;
              export type Cryptocurrency = z.infer&lt;typeof CryptoCurrencyResponseSchema&gt;
            </code></pre>
          
            <pre data-line="1-4,15"><code class="language-ts">
              //store.ts
              type CryptoStore = {
                cryptocurrencies: Cryptocurrency[]
                fetchCryptos: () => Promise&lt;void&gt; 
              }
              async function getCryptos(){
                  const url = 'https://min-api.cryptocompare.com/data/top/mktcapfull?limit=20&tsym=EUR'
                  const {data: {Data}} = await axios(url)
                  console.log(Data)
                  const result = CryptoCurrenciesResponseSchema.safeParse(Data)
                  //console.log(result)
                  if(result.success){
                      return result.data
                  }
              }
              export const useCryptoStore = create&lt;CryptoStore&gt;((set) => ({
                  cryptocurrencies: [],
                  fetchCryptos: async () => {
                      //getCryptos()
                      const cryptocurrencies = await getCryptos()
                      //console.log(cryptocurrencies)
                      set(() => ({
                          cryptocurrencies : cryptocurrencies
                      }))
                  }
              }))                  
            </code></pre>             
              
            <p>Veamos como utilizar Redux Dev Tools pra visualizar los datos del Store</p>


          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion17-291').toggle();">
            <h3>291. Agregando Redux Dev Tools para visualizar los datos del Store</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion17-291" class="hidden">

            <p>En <span class="file">store.ts</span> importamos <code class="language-ts">import { devtools } from 'zustand/middleware'</code> y añadimos en la línea indicada <strong>()(devtools....)</strong>. <span class="destacado">En la pestaña de Redux ya podemos ver nuestro state cryptocurrencies</span></p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="0,2,21,31"><code class="language-ts">
                  //store.ts
                  import { create } from "zustand"
                  import { devtools } from 'zustand/middleware' 
                  import axios from 'axios'
                  import { CryptoCurrenciesResponseSchema } from './schema/crypto-schema'
                  import { Cryptocurrency } from "./types"
                  
                  type CryptoStore = {
                    cryptocurrencies: Cryptocurrency[]
                    fetchCryptos: () => Promise&lt;void&gt; 
                  }
                  async function getCryptos(){
                    const url = 'https://min-api.cryptocompare.com/data/top/mktcapfull?limit=20&tsym=EUR'
                    const {data: {Data}} = await axios(url)
                    console.log(Data)
                    const result = CryptoCurrenciesResponseSchema.safeParse(Data)
                    //console.log(result)
                    if(result.success){
                      return result.data
                    }
                  }
                  export const useCryptoStore = create&lt;CryptoStore&gt;()(devtools((set) => ({
                    cryptocurrencies: [],
                    fetchCryptos: async () => {
                      //getCryptos()
                      const cryptocurrencies = await getCryptos()
                      //console.log(cryptocurrencies)
                      set(() => ({
                          cryptocurrencies : cryptocurrencies
                      }))
                    }
                  })))
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <img src="./src/assets/img/291.png" alt="img" loading="lazy">
              </div>
            </div>

            <p>La función de nuestro store <code class="language-ts">async function getCryptos(){...} </code> vamos a colocarla en una carpeta o en su propio archivo donde tengamos todos los servicios o conexiones hacia nuestras APIS.</p>

          </div>


          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion17-292').toggle();">
            <h3>292. Moviendo la función que obtiene la API hacia otro archivo</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion17-292" class="hidden">
            <p>La función de nuestro store <code class="language-ts">async function getCryptos(){...}</code> no tiene nada que ver con nuestro store. Lo que hace es hacer la llamada a la API y validar la respuesta. Así que para no hacer tan "pesado" el store.ts creamos este fichero donde estarán nuestros servicios <span class="file">services/CryptoService.ts</span></p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="0"><code class="language-ts">
                  //services/CryptoService.ts
                  import axios from 'axios'
                  import { CryptoCurrenciesResponseSchema } from '../schema/crypto-schema'
                  
                  export async function getCryptos(){
                      const url = 'https://min-api.cryptocompare.com/data/top/mktcapfull?limit=20&tsym=EUR'
                      const {data: {Data}} = await axios(url)
                      console.log(Data)
                      const result = CryptoCurrenciesResponseSchema.safeParse(Data)
                      //console.log(result)
                      if(result.success){
                          return result.data
                      }
                  }
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="0"><code class="language-ts">
                  //store.ts
                  import { create } from "zustand"
                  import { devtools } from 'zustand/middleware' 
                  import { Cryptocurrency } from "./types"
                  import { getCryptos } from "./services/CryptoService"
                  
                  type CryptoStore = {
                      cryptocurrencies: Cryptocurrency[]
                      fetchCryptos: () => Promise&lt;void&gt; 
                  }
                  
                  export const useCryptoStore = create&lt;CryptoStore&gt;()(devtools((set) => ({
                      cryptocurrencies: [],
                      fetchCryptos: async () => {
                          //getCryptos()
                          const cryptocurrencies = await getCryptos()
                          //console.log(cryptocurrencies)
                          set(() => ({
                              cryptocurrencies : cryptocurrencies
                          }))
                      }
                  })))        
                </code></pre>
              </div>
            </div>

            <p>Por tanto <strong>getCryptos(){...}</strong> es un servicio que va a conectarse con una API y tiene la validación y todo lo demás.</p>

            <p>Como vemos nuestro store queda más limpio dejando fuera las funciones que se comunican con la API (así son más reutilizables) mientras que el store.ts ya solo tiene states y acciones que los modifican.</p>

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion17-293').toggle();">
            <h3>293. Mostrando las Criptomonedas en el Formulario</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion17-293" class="">
            <p>Ya teniendo nuestras monedas en el state es momento de mostrarlas en el segundo select. Abrimos nuestro formulario <span class="file">components/CriptoSearchForm.tsx</span> e importamos nuestro hook <code class="language-ts">import { useCryptoStore } from '../store'</code>:</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="0"><code class="language-ts">
                  //store.ts
                  import { create } from "zustand"
                  import { devtools } from 'zustand/middleware' 
                  import { Cryptocurrency } from "./types"
                  import { getCryptos } from "./services/CryptoService"
                  
                  type CryptoStore = {
                      cryptocurrencies: Cryptocurrency[]
                      fetchCryptos: () => Promise&lt;void&gt; 
                  }
                  
                  export const useCryptoStore = create&lt;CryptoStore&gt;()(devtools((set) => ({
                      cryptocurrencies: [],
                      fetchCryptos: async () => {
                          //getCryptos()
                          const cryptocurrencies = await getCryptos()
                          //console.log(cryptocurrencies)
                          set(() => ({
                              cryptocurrencies : cryptocurrencies
                          }))
                      }
                  })))        
                </code></pre>                
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="1,4,21-26"><code class="language-ts">
                  //components/CriptoSearchForm.tsx
                  import { useCryptoStore } from '../store'
                  import { currencies } from '../data/index'
                  export default function CriptoSearchForm() {
                      const cryptocurrencies = useCryptoStore((state) => state.cryptocurrencies )
                      return (
                          &lt;form className=&quot;form&quot;&gt;
                              &lt;div className=&quot;field&quot;&gt;
                                  &lt;label htmlFor=&quot;currency&quot;&gt;Moneda:&lt;/label&gt;
                                  &lt;select name=&quot;currency&quot; id=&quot;currency&quot;&gt;
                                      &lt;option value=&quot;&quot;&gt;-- Seleccione --&lt;/option&gt;
                                      {currencies.map( currency =&gt; (
                                          &lt;option key={currency.code} value={currency.code}&gt;{currency.name}&lt;/option&gt;
                                      ))}
                                  &lt;/select&gt;
                              &lt;/div&gt;
                  
                              &lt;div className=&quot;field&quot;&gt;
                                  &lt;label htmlFor=&quot;criptocurrency&quot;&gt;Criptomoneda:&lt;/label&gt;
                                  &lt;select name=&quot;criptocurrency&quot; id=&quot;criptocurrency&quot;&gt;
                                      &lt;option value=&quot;&quot;&gt;-- Seleccione --&lt;/option&gt;   
                                      { cryptocurrencies.map(crypto =&gt; (
                                          &lt;option 
                                              key={crypto.CoinInfo.FullName}
                                              value={crypto.CoinInfo.Name}
                                          &gt;{crypto.CoinInfo.FullName}&lt;/option&gt;
                                      ))}                 
                                  &lt;/select&gt;
                              &lt;/div&gt;
                  
                              &lt;input type=&quot;submit&quot; value=&quot;cotizar&quot;/&gt;
                          &lt;/form&gt;
                      )
                  }
                </code></pre>
              </div>              
            </div>

            <p>La ventaja de implementar esta API, consumir desde este servicio, es que siempre nos va a mostrar las 20 cryptos que tengan mayor volumen de transacción y mayor valor; si el mercado va cambiando (unas ganan y/o pierden valor) este listado nuestro siempre se va a ir actualizando. La respuesta además queda totalmente tipada y comprobamos que la respuesta tenga la forma que hemos definido en nuestro schema.</p>

            <img src="./src/assets/img/294.png" alt="img" loading="lazy">

            <p>Vamos a continuación a colocar en un state estos dos valores de los dos selects <strong>Moneda</strong> y <strong>Criptomoneda</strong> a cotizar.</p>

          </div>

<!-- Bloque desplegable interior-->
<div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion17-294').toggle();">
  <h3>294. Creando State para Moneda y Criptomoneda a Cotizar</h3>
  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
</div>
<div id="seccion17-294" class="">
  <p>Vamos a crear un state local para almacenar las opciones que seleccionamos con los select. En este caso no hay necesidad de pasarlo a Zustand. Creamos el state local <strong>pair</strong> y podemos añadirle al useState un generic para indicarle el type a utilizar. Para ello definimos un schema nuevo para ese state <strong>pair</strong> que importamos en types:</p>

  <div class="flex max-sm:flex-col">
   
    <div class="w-[30%] max-sm:w-[100%]">
      <pre data-line="0,2-5"><code class="language-ts">
        //schema/crypto-schema.ts
        ...
        export const PairSchema = z.object({
          currency: z.string(),
          criptocurrency: z.string()
        })
      </code></pre>
    </div>   
    <div class="w-[70%] max-sm:w-[100%]">
      <pre data-line="0,6"><code class="language-ts">
        //types/index.ts
        import { z } from 'zod'
        import { CurrencySchema, CryptoCurrencyResponseSchema, PairSchema } from '../schema/crypto-schema'

        export type Currency = z.infer&lt;typeof CurrencySchema&gt;
        export type Cryptocurrency = z.infer&lt;typeof CryptoCurrencyResponseSchema&gt;
        export type Pair = z.infer&lt;typeof PairSchema&gt;
      </code></pre>
    </div> 

  </div>

  <p>El tipo del parámetro e que recibe handleChange lo inferimos, recordar, poniéndonos en el onChange del select y como arrow function ponemos una e y copiamos lo que nos indica el IS (le quitamos el react. previo importando ChangeEvent)</p>

  <pre data-line="0,3,4,8-17,25,38"><code class="language-ts">
    //CriptoSearchForm.tsx
    import { useCryptoStore } from '../store'
    import { currencies } from '../data/index'
    import { ChangeEvent, useState } from 'react'
    import { Pair } from '../types'
    
    export default function CriptoSearchForm() {
        const cryptocurrencies = useCryptoStore((state) => state.cryptocurrencies )
        const [pair, setPair] = useState&lt;Pair&gt;({
            currency: '',
            criptocurrency: ''
        })
        const handleChange = (e: ChangeEvent&lt;HTMLSelectElement&gt;) => {
            setPair({
                ...pair,
                [e.target.name]: e.target.value
            })
        }
        return (
            &lt;form className=&quot;form&quot;&gt;
                &lt;div className=&quot;field&quot;&gt;
                    &lt;label htmlFor=&quot;currency&quot;&gt;Moneda:&lt;/label&gt;
                    &lt;select 
                        name=&quot;currency&quot; 
                        id=&quot;currency&quot;
                        onChange={handleChange}
                    &gt;
                        &lt;option value=&quot;&quot;&gt;-- Seleccione --&lt;/option&gt;
                        {currencies.map( currency =&gt; (
                            &lt;option key={currency.code} value={currency.code}&gt;{currency.name}&lt;/option&gt;
                        ))}
                    &lt;/select&gt;
                &lt;/div&gt;    
                &lt;div className=&quot;field&quot;&gt;
                    &lt;label htmlFor=&quot;criptocurrency&quot;&gt;Criptomoneda:&lt;/label&gt;
                    &lt;select 
                        name=&quot;criptocurrency&quot; 
                        id=&quot;criptocurrency&quot;
                        onChange={handleChange}
                    &gt;
                        &lt;option value=&quot;&quot;&gt;-- Seleccione --&lt;/option&gt;   
                        { cryptocurrencies.map(crypto =&gt; (
                            &lt;option 
                                key={crypto.CoinInfo.FullName}
                                value={crypto.CoinInfo.Name}
                            &gt;{crypto.CoinInfo.FullName}&lt;/option&gt;
                        ))}                 
                    &lt;/select&gt;
                &lt;/div&gt;
    
                &lt;input type=&quot;submit&quot; value=&quot;cotizar&quot;/&gt;
            &lt;/form&gt;
        )
    }
  </code></pre>

</div>

<!-- Bloque desplegable interior-->
<div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion17-295').toggle();">
  <h3>295. Agregando Validación</h3>
  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
</div>
<div id="seccion17-295" class="hidden">


</div>

<!-- Bloque desplegable interior-->
<div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion17-296').toggle();">
  <h3>296. Obteniendo la Moneda y Cripto a Cotizar</h3>
  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
</div>
<div id="seccion17-296" class="hidden">


</div>

<!-- Bloque desplegable interior-->
<div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion17-297').toggle();">
  <h3>297. Llamando la API para obtener la cotización Actual</h3>
  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
</div>
<div id="seccion17-297" class="hidden">


</div>

<!-- Bloque desplegable interior-->
<div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion17-298').toggle();">
  <h3>298. Validando la Respuesta de la API con ZOD</h3>
  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
</div>
<div id="seccion17-298" class="hidden">


</div>

<!-- Bloque desplegable interior-->
<div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion17-299').toggle();">
  <h3>299. Colocando la Respuesta en el State</h3>
  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
</div>
<div id="seccion17-299" class="hidden">


</div>

<!-- Bloque desplegable interior-->
<div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion17-300').toggle();">
  <h3>300. Mostrando el Resultado de la cotización</h3>
  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
</div>
<div id="seccion17-300" class="hidden">


</div>

<!-- Bloque desplegable interior-->
<div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion17-301').toggle();">
  <h3>301. Agregando CSS al resultado de la cotización</h3>
  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
</div>
<div id="seccion17-301" class="hidden">


</div>

<!-- Bloque desplegable interior-->
<div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion17-302').toggle();">
  <h3>302. Agregando un spinner de Carga y Deployment</h3>
  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
</div>
<div id="seccion17-302" class="hidden">


</div>

        </div>
        <!-- Fin div colapsable-->

      </div>
      <!-- FIN SECCION 17 -->


       <!-- SECCION 16 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 my-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">

        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between" onclick="$('#seccion16').toggle();">
          <h2>Sección 16: PROYECTO - Aplicación de Clima que obtiene el Clima en tiempo real con una API</h2>
          <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
        </div>

        <div id="seccion16" class="hidden">

          <p>Trabajo con <span class="destacado">CSS modules</span>, <span class="destacado">API externa</span>, veremos como <strong>enviar peticiones hacia API</strong> <a href="https://openweathermap.org/" class="underline" target="blank">https://openweathermap.org/</a> -  <a href="https://openweathermap.org/api/geocoding-api" class="underline" target="blank">Geocoding API</a>, como <strong>leer las respuestas de una API</strong>, como <strong>validarlas=tiparlas</strong>:</p>
          <ul class="list-disc my-3">
            <li class="my-1.25"><span class="destacado">TYPE GUARD O ASSERTION</span></li>
            <li class="my-1.25">Libería Zod para tipar respuestas de una API: <span class="destacado">npm i zod</span></li>
            <li class="my-1.25">Libería Valibot para tipar respuestas de una API: <span class="destacado">npm i valibot</span></li>
          </ul>
          
          <p>... y como <strong>mostrar esa información</strong>. <span class="destacado">La parte de APIS es muy importante en el mundo de React</span>.</p>
          <p>Escribiremos css con <span class="destacado">Módulos CSS</span>. Instalamos <srong>axios</srong> <span class="destacado">npm i axios</span> que es una librería para consultar APIs externas, es una abstracción sobre fetch api. Vemos qué son <span class="destacado">Variables de entorno</span>.</p> 
          <p>Veremos <span class="destacado">como utilizar un spinner de carga</span> - <a href="https://tobiasahlin.com/spinkit/" class="underline" target="blank">https://tobiasahlin.com/spinkit/</a></p>
         


          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion16-ficheros').toggle();">
            <h3>FICHEROS FINALES</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion16-ficheros" class="hidden">
            <div class="flex max-sm:flex-col">
              <div class="w-[25%] max-sm:w-[100%]">
                <span class="destacado">App.tsx, index.css, main.tsx</span><br>

                <code class="cursor-pointer" onclick="$('#16-app').toggle();">App.tsx</code>
                <pre data-line="0" id="16-app" class="hidden"><code class="language-ts">
                  //App.tsx
                  import styles from "./App.module.css"
                  import Form from './components/Form/Form'
                  import useWeather from "./hooks/useWeather"
                  import WeatherDetail from './components/WeatherDetail/WeatherDetail';
                  import Spinner from "./components/Spinner/Spinner";
                  import Alert from "./components/Alert/Alert";
                  
                  function App() {
                    
                    const { weather, loading, notFound, fetchWeather, hasWeatherData } = useWeather()
                    //console.log(import.meta.env)
                  
                    return (
                      &lt;&gt;
                        &lt;h1 className={styles.title}&gt;Buscador de clima&lt;/h1&gt;
                  
                        &lt;div className={styles.container}&gt;
                          &lt;Form fetchWeather = {fetchWeather}/&gt;        
                          {loading &amp;&amp; &lt;Spinner /&gt;}
                          {hasWeatherData &amp;&amp; &lt;WeatherDetail weather = {weather}/&gt;}
                          {notFound &amp;&amp; &lt;Alert&gt;Ciudad No encontrada&lt;/Alert&gt;}        
                        &lt;/div&gt;
                      &lt;/&gt;
                    )
                  }
                  
                  export default App
                </code></pre>

                <code class="cursor-pointer" onclick="$('#16-indexcss').toggle();">index.css</code>
                <pre data-line="0" id="16-indexcss" class="hidden"><code class="language-css">
                  //index.css
                  :root {
                    --white: #ffffff;
                    --primary: #f59e0b;
                  } 
                  /* // &lt;weight&gt;: Use a value from 100 to 900
                  // &lt;uniquifier&gt;: Use a unique and descriptive class name */
                  html{
                      font-size: 62.5%;
                  }
                  body {
                      font-family: "Outfit", sans-serif;
                      background-image: url(/bg_clima.jpg);
                      height: 100vh;
                      background-size: cover;
                      background-repeat: no-repeat;
                      color: var(--white);
                      font-size: 2rem;
                  }
                </code></pre>

                <code class="cursor-pointer" onclick="$('#16-maintsx').toggle();">main.tsx</code>
                <pre data-line="0" id="16-maintsx" class="hidden"><code class="language-js">
                  //main.tsx
                  import { StrictMode } from 'react'
                  import { createRoot } from 'react-dom/client'
                  import './index.css'
                  import App from './App.tsx'
                  
                  createRoot(document.getElementById('root')!).render(
                    &lt;StrictMode&gt;
                      &lt;App /&gt;
                    &lt;/StrictMode&gt;,
                  )
                </code></pre>                
              </div>

              <div class="w-[40%] max-sm:w-[100%]">
                <span class="destacado">data, hooks, types, utils</span><br>

                <code class="cursor-pointer" onclick="$('#16-data').toggle();">data/countries.ts</code>
                <pre data-line="0" id="16-data" class="hidden"><code class="language-ts">
                  //data/countries.ts
                  import type { Country } from "../Types"

                  export const countries: Country[] = [
                    { code: 'US', name: 'Estados Unidos' },
                    { code: 'MX', name: 'México' },
                    { code: 'AR', name: 'Argentina' },
                    { code: 'CO', name: 'Colombia' },
                    { code: 'CR', name: 'Costa Rica' },
                    { code: 'ES', name: 'España' },
                    { code: 'PE', name: 'Perú' }
                  ]
                </code></pre>                

                <code class="cursor-pointer" onclick="$('#16-customhook').toggle();">hooks/useWeather.ts</code>
                <pre data-line="0" id="16-customhook" class="hidden"><code class="language-ts">
                  //hooks/useWeather.ts
                  import axios from "axios"
                  import { z } from 'zod'
                  //import { object, string, number, InferOutput, parse } from 'valibot'
                  import { SearchType } from "../Types"
                  import { useState, useMemo } from "react"
                                   
                  //ZOD
                  const WeatherSchema = z.object({
                      name: z.string(),
                      main: z.object({
                          temp: z.number(),
                          temp_max: z.number(),
                          temp_min: z.number()
                      })
                  })
                  export type Weather = z.infer&lt;typeof WeatherSchema&gt;
                                    
                  const initialState = {
                      name: '',
                      main: {
                          temp: 0,
                          temp_max: 0, 
                          temp_min: 0
                      }
                  }
                  
                  export default function useWeather(){
                  
                      const [weather, setWeather] = useState&lt;Weather&gt;(initialState)
                      const [loading, setLoading] = useState(false)
                      const [notFound, setNotFound] = useState(false)
                  
                      const fetchWeather = async (search: SearchType) => {
                          const appId = import.meta.env.VITE_API_KEY
                          setLoading(true)
                          setWeather(initialState)
                          try {
                            const geoUrl = `https://api.openweathermap.org/geo/1.0/direct?q=${search.city},${search.country}&appid=${appId}`  
                            //console.log(geoUrl)
                            const {data} = await axios.get(geoUrl)
                
                            //Comprobar si existe
                            if(!data[0]){
                                setNotFound(true)
                                return
                            }
                            //console.log(data)
                            const lat= data[0].lat
                            const lon= data[0].lon
                            
                            const weatherUrl = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${appId}`
                            //console.log(weatherUrl)
                                              
                            //3. Zod
                            const{data: weatherResult} = await axios(weatherUrl)
                            const result = WeatherSchema.safeParse(weatherResult)
                            //console.log(result)
                            if(result.success){
                                //console.log(result.data.name)
                                //console.log(result.data.main.temp)
                                setWeather(result.data)
                            }else {
                                console.log('Respuesta mal formada...')
                            }                           
                          } catch (error) {
                              console.log(error)
                          } finally {
                              setLoading(false)
                          }    
                      }                  
                      const hasWeatherData = useMemo(() => weather.name , [weather])
                  
                      return {
                          weather,
                          loading,
                          notFound,
                          fetchWeather,
                          hasWeatherData
                      }
                  }
                </code></pre>

                <code class="cursor-pointer" onclick="$('#16-types').toggle();">Types/index.ts</code>
                <pre data-line="0" id="16-types" class="hidden"><code class="language-ts">
                  //Types/index.ts
                  export type SearchType = {
                    city: string
                    country: string
                  }
                  export type Country = {
                    code: string
                    name: string
                  }
                  export type Weather = {
                    name:string
                    main: {
                      temp: number,
                      temp_max: number,
                      temp_min: number
                    }
                  }
                </code></pre>

                <code class="cursor-pointer" onclick="$('#16-utils').toggle();">utils/index.ts</code>
                <pre data-line="0" id="16-utils" class="hidden"><code class="language-ts">
                  //utils/index.ts
                  export const formatTemperature = (temperature: number) : number =>{
                    const Kelvin = 273.15
                    return parseInt((temperature - Kelvin).toString())
                  }
                </code></pre>
              </div>

              <div class="w-[35%] max-sm:w-[100%]">
                <span class="destacado">Componentes</span><br>
                <code class="cursor-pointer" onclick="$('#16-alertmodulecss').toggle();">Alert.module.css</code>
                <pre data-line="0" id="16-alertmodulecss" class="hidden"><code class="language-ts">
                  //Alert/Alert.module.css
                  .alert{
                    text-align: center;
                    margin-bottom: 2rem;
                    text-transform: uppercase;
                    font-weight: 900;
                    font-size: 1.8rem;
                  }
                </code></pre>
                <code class="cursor-pointer" onclick="$('#16-alert').toggle();">Alert.tsx</code>
                <pre data-line="0" id="16-alert" class="hidden"><code class="language-ts">
                  //Alert/Alert.tsx
                  import { ReactNode } from "react"
                  import styles from './Alert.module.css'
                  
                  export default function Alert({children} : {children : ReactNode}) {
                      return (
                      &lt;div className={styles.alert}&gt; 
                          {children}
                      &lt;/div&gt;
                      )
                  }
                </code></pre>

                <code class="cursor-pointer" onclick="$('#16-Formmodulecss').toggle();">Form.module.css</code>
                <pre data-line="0" id="16-Formmodulecss" class="hidden"><code class="language-ts">
                  //Form/Form.modulecss
                  .form, .field{
                    display: flex;
                    flex-direction: column;
                    gap: 2rem;
                }
                .form input[type='text'],.form select{
                    padding: 1rem;
                    background-color: transparent;
                    border: .3rem solid var(--white);
                    color: var(--white);
                    font-size: 1.8rem;
                    font-weight: 400;
                    border-radius: 1rem;
                }
                .form select option{
                    color: #000000;
                }
                .field ::placeholder{
                    color: var(--white);
                }
                .submit{
                    background-color: var(--primary);
                    border: none;
                    color: var(--white);
                    font-weight: 700;
                    font-size: 1.4rem;
                    text-transform: uppercase;
                    cursor: cursor-pointer;
                    padding: 1rem;
                }
                </code></pre>
                <code class="cursor-pointer" onclick="$('#16-Form').toggle();">Form.tsx</code>
                <pre data-line="0" id="16-Form" class="hidden"><code class="language-ts">
                  // Form.tsx
                  import { useState, ChangeEvent, FormEvent } from "react"
                  import type { SearchType } from "../../Types"
                  import { countries } from "../../data/countries"
                  import styles from "./Form.module.css"
                  import Alert from "../Alert/Alert"
                  
                  type FormProps = {
                      fetchWeather: (search: SearchType) =&gt; Promise&lt;void&gt;
                  }
                  export default function Form({fetchWeather}:FormProps) {
                  
                      const [search, setSearch] = useState&lt;SearchType&gt;({
                          city: &#39;&#39;,
                          country: &#39;&#39;
                      })
                      const [alert, setAlert] = useState(&#39;&#39;)
                  
                      const handleChange = (e: ChangeEvent&lt;HTMLInputElement&gt; | ChangeEvent&lt;HTMLSelectElement&gt;) =&gt;{
                          setSearch({
                              ...search,
                              [e.target.name] : e.target.value //escribimos en el campo en el cual estamos modificando
                          })
                      }
                      const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =&gt; {
                          e.preventDefault()
                          if(Object.values(search).includes(&#39;&#39;)){
                              //console.log(&#39;Sí hay campos vacíos...&#39;)
                              setAlert(&#39;Todos los campos son obligatorios&#39;)
                              return
                          }
                          fetchWeather(search)
                      }
                      return (
                          &lt;form 
                              className={styles.form}
                              onSubmit={handleSubmit}
                          &gt;
                              {alert &amp;&amp; &lt;Alert&gt;{alert}&lt;/Alert&gt;}
                  
                              &lt;div className={styles.field}&gt;
                                  &lt;label htmlFor=&quot;city&quot;&gt;Ciudad:&lt;/label&gt;
                                  &lt;input 
                                      id=&quot;city&quot;
                                      type=&quot;text&quot;
                                      name=&quot;city&quot;
                                      placeholder=&quot;Ciudad&quot;
                                      value={search.city}
                                      onChange={handleChange}
                                  /&gt;
                              &lt;/div&gt;
                  
                              &lt;div className={styles.field}&gt;
                                  &lt;label htmlFor=&quot;country&quot;&gt;Pais:&lt;/label&gt;
                                  &lt;select 
                                      id=&quot;country&quot;
                                      name=&quot;country&quot;
                                      value={search.country}  
                                      onChange={handleChange}              
                                  &gt;
                                  &lt;option value=&quot;&quot;&gt;-- Seleccione un País --&lt;/option&gt;
                                      {countries.map(country =&gt; (
                                          &lt;option 
                                              key={country.code}
                                              value={country.code}
                                          &gt;
                                              {country.name}
                                          &lt;/option&gt;
                                      ))}
                                  &lt;/select&gt;
                              &lt;/div&gt;
                  
                              &lt;input type=&quot;submit&quot; className={styles.submit} value=&quot;Consultar clima&quot; /&gt;
                  
                          &lt;/form&gt;
                      )
                  }
                  
                </code></pre>

                <code class="cursor-pointer" onclick="$('#16-Spinnermodulecss').toggle();">Spinner.module.css</code>
                <pre data-line="0" id="16-Spinnermodulecss" class="hidden"><code class="language-ts">
                  //Spinner/Spinner.modulecss
                  .spinner {
                    margin: 100px auto 0;
                    width: 70px;
                    text-align: center;
                  }
                  .spinner>div {
                      width: 18px;
                      height: 18px;
                      background-color: #fff;
                      border-radius: 100%;
                      display: inline-block;
                      -webkit-animation: sk-bouncedelay 1.4s infinite ease-in-out both;
                      animation: sk-bouncedelay 1.4s infinite ease-in-out both;
                  }
                  .spinner .bounce1 {
                      -webkit-animation-delay: -0.32s;
                      animation-delay: -0.32s;
                  }
                  .spinner .bounce2 {
                      -webkit-animation-delay: -0.16s;
                      animation-delay: -0.16s;
                  }
                  @-webkit-keyframes sk-bouncedelay {
                      0%,
                      80%,
                      100% {
                          -webkit-transform: scale(0)
                      }
                      40% {
                          -webkit-transform: scale(1.0)
                      }
                  }
                  @keyframes sk-bouncedelay {
                      0%,
                      80%,
                      100% {
                          -webkit-transform: scale(0);
                          transform: scale(0);
                      }
                      40% {
                          -webkit-transform: scale(1.0);
                          transform: scale(1.0);
                      }
                  }
                </code></pre>
                <code class="cursor-pointer" onclick="$('#16-Spinner').toggle();">Spinner.tsx</code>
                <pre data-line="0" id="16-Spinner" class="hidden"><code class="language-ts">
                  // Spinner.tsx
                  import './Spinner.css'
                  export default function Spinner() {
                    return (
                      &lt;div className=&quot;spinner&quot;&gt;
                        &lt;div className=&quot;bounce1&quot;&gt;&lt;/div&gt;
                        &lt;div className=&quot;bounce2&quot;&gt;&lt;/div&gt;
                        &lt;div className=&quot;bounce3&quot;&gt;&lt;/div&gt;
                      &lt;/div&gt;
                    )
                  }
                </code></pre>

                <code class="cursor-pointer" onclick="$('#16-WeatherDetailmodulecss').toggle();">WeatherDetail.module.css</code>
                <pre data-line="0" id="16-WeatherDetailmodulecss" class="hidden"><code class="language-ts">
                  //WeatherDetail/WeatherDetail.modulecss
                  .container{
                    background-color: var(--white);
                    color: #000000;
                    border-radius: 1rem;
                    text-align: center;
                    padding: 1rem;
                  }
                  .current{
                      font-size: 6rem;
                      font-weight: 900;
                      margin: 0;
                  }
                  .temperatures{
                      display: flex;
                      justify-content: center;
                      gap: 5rem;
                  } 
                  .temperatures p{
                      font-weight:900;
                  }
                  .temperatures span{
                      font-weight:400;
                  }
                </code></pre>
                <code class="cursor-pointer" onclick="$('#16-WeatherDetail').toggle();">WeatherDetail.tsx</code>
                <pre data-line="0" id="16-WeatherDetail" class="hidden"><code class="language-ts">
                  //WeatherDetail.tsx
                  import { Weather } from "../../hooks/useWeather"
                  import { formatTemperature } from "../../utils"
                  import styles from './WeatherDetail.module.css'
                  
                  type WeatherDetailProps = {
                      weather: Weather 
                  }                  
                  export default function WeatherDetail({weather} : WeatherDetailProps) {
                    return (
                      &lt;div className={styles.container}&gt;
                        &lt;h2&gt;Clima de: {weather.name}&lt;/h2&gt;
                        &lt;p className={styles.current}&gt; {formatTemperature(weather.main.temp)}&amp;deg;C&lt;/p&gt;
                        &lt;div className={styles.temperatures}&gt;
                          &lt;p&gt;Min: &lt;span&gt;{formatTemperature(weather.main.temp_min)}&amp;deg;C&lt;/span&gt;&lt;/p&gt;
                          &lt;p&gt;Max: &lt;span&gt;{formatTemperature(weather.main.temp_max)}&amp;deg;C&lt;/span&gt;&lt;/p&gt;
                        &lt;/div&gt;
                      &lt;/div&gt;
                    )
                  }
                </code></pre>

              </div>
            </div>

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion16-258').toggle();">
            <h3>258. El Proyecto que vamos a construir</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion16-258" class="hidden">   
            <p>Este proyecto, <strong>Buscador de clima</strong>, será nuestra primera aplicación que obtiene datos de una <span class="destacado">API externa</span>. Como React Developer vamos a trabajar en muchos proyectos que incluyen API's; conectaremos a una API externa y envía unas credenciales para permitirnos acceder a los recursos de esa API.</p>

            <p>Veremos como enviar peticiones hacia API, como leer las respuestas, como validarlas y como mostrar esa información. La parte de APIS es muy importante en el mundo de React.</p>
            
            <p>Una vez que trabajas con APIS la parte de TS se hace un poco más complicada. TS funciona muy bien en nuestro código, pero no tanto cuando tiene que conectarse y validar una respuesta de una REST API, simplemente no puede hacerlo. Estaremos viendo diferentes formas de validar esa respuesta que obtiene de la REST API: <strong>TYPE GUARD O ASSERTION</strong>, <strong>Zod</strong> y con <strong>Valibot</strong> y asegurarnos así de que nuestro código no tiene ningún error. Una vez que mandamos una consulta a un servidor externo y obtenemos una respuesta, ahí TS ya no sabe qué es lo que está obteniendo, pero nosotros lo vamos a apoyar con estas herramientas.</p>

            <img class="my-2.5 mx-auto" src="./src/assets/img/s1-06.jpg" width="" height="" alt="">
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion16-259').toggle();">
            <h3>259. Creando el Proyecto y la API que estaremos utilizando / 260. Creando un API Key y Que es una API?</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion16-259" class="hidden">
            <p>Vamos a comenzar con nuestro primer proyecto que ya consume datos desde una API. Hasta ahora hemos visto formularios, interacciones con clicks y todo almacenado en memoria, pero normalmente conforme tengamos un proyecto más grande, vamos a requerir información que venga desde una base de datos. <strong>Como tal, React no nos permite consultar directamente una base de datos, lo podemos hacer con frameworks como Next.js o como Remix. Pero la versión que estamos aprendiendo, la versión de cliente de React, directamente no puede hacerlo</strong>. Vamos a hacerlo por medio de una API. Muchas pruebas técnicas tratan de esto precisamente, consumir una API y crear algunas interacciones con esa API, por lo que es importante ver cómo trabajar en esa parte. Como veíamos, en Typescript cuando trabajamos con APIS hay ciertas cosas que tenemos que tener en cuenta. <strong>Van a ser proyectos muy interesantes.</strong></p>

            <p>Vamos a crear nuestro proyecto de vite <span class="destacado">npm create vite@latest</span> y lo nombramos como <strong>clima-react-typescript</strong>, vamos a esa carpeta e instalamos dependencias: <span class="destacado">npm install</span>. Ejecutamos el servidor de desarrollo <span class="destacado">npm run dev</span>. Cogemos el background de los materiales del curso '<strong>bg_clima.jpg</strong>' y lo llevamos a public. Hacemos limpieza (borramos carpeta assets, logo vite.svg de public y fichero <span class="file">App.css</span> (escribiremos el código como <span class="destacado">css modules</span>) Limpiamos todo el contenido de <span class="file">App.tsx</span> donde solo dejamos un h1 <code class="language-ts">&lt;h1&gt;Buscador de clima&lt;/h1&gt;</code> y limpiamos el <span class="file">index.css</span>. En el <span class="file">index.html</span> cambiamos el title a <code class="language-ts">&lt;title&gt;React / Typescript - CSS Modules y API&#39;s&lt;/title&gt;</code>. Vamos a generar nuestra API key para este proyecto.</p>

            <p class="naranja">Creando un API Key y Que es una API?</p>

            <p>En este proyecto estaremos utilizando la API de clima de <span class="destacado">Weather API</span> <a href="https://openweathermap.org/" class="underline" target="blank">https://openweathermap.org/</a> - <a href="https://openweathermap.org/api" class="underline" target="blank">https://openweathermap.org/api</a>.</p>

            <ul class="list-disc my-3">
              <li class="my-1.25">Vamos a <a href="https://openweathermap.org/api" class="underline" target="blank">https://openweathermap.org/api</a> y presionamos en <strong>Sign In</strong> y creamos una cuenta para iniciar sesión.</li>
              <li class="my-1.25">Vamos a "For Business" <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
              </svg>Pestaña API keys <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
              </svg> campo Create Key le damos un nombre y pulsamos en Generate. Nos aparecerá aquí, no lo copiamos, lo tenemos a mano. Tarda entre 10-15 min en registrarse en su base de datos.
              <img src="./src/assets/img/260.png" alt="img" loading="lazy">
            </li>
              <li class="my-1.25">Ya con nuestra API key listo, veamos <span class="destacado">qué son las APIS</span>:
                <ul class="list-disc my-3">
                  <li class="my-1.25"><strong>API: Application Programming Interface</strong></li>
                  <li class="my-1.25"><strong>Son funciones, métodos que ofrece una librería para ser utilizada por otro software como una capa de abstracción:</strong> lo que acabamos de hacer es generar nuestro API Key y eso nos va a permitir interactuar con los datos que tienen ellos almacenados</li>
                  <li class="my-1.25"><strong>Una API pone a disposición recursos que están alojados en otro servidor o una base de datos:</strong> es una forma segura de acceder a esa información. Podemos pensar en ello también como Google Maps: queremos llegar a algún lugar y escribimos la ubicación a la que queremos llegar. Colocamos donde estamos y nos dice cómo llegar a ese lugar. Están poniendo a disposición recursos y esos recursos están alojados en un servidor y tienen una base de datos.</li>
                  <li class="my-1.25"><strong>Usualmente hay que enviar una petición estructurada:</strong> en el caso por ejemplo de Google Maps, tienes una API muy sencilla, una interfaz muy sencilla donde dice dónde estás y a dónde quieres llegar. Esa información es la que ellos requieren para poder procesar tu petición y entonces decirte hacia dónde tienes que dirigirte.</li>
                  <li class="my-1.25"><strong>Utilizando React en el cliente con Vite, no se puede consultar una base de datos directamente (sí lo podríamos hacer con Remix y también con Next.js), por lo tanto, consultar una API es una forma de obtener datos dinámicos, ya sea de un servidor o de una base de datos.</strong></li>
                  <li class="my-1.25"><strong>La API, si somos un back end Developer, puede ser creada en cualquier lenguaje o framework:</strong> Python, en Django, en Java, en Netcore, .net, Express, Node.js, en Laravel, PHP...</li>
                  <li class="my-1.25"><strong>... siempre y cuando la forma en que entregue los recursos sea una respuesta de tipo JSON</strong>. También puede ser xml aunque el stándard hoy día son respuestas de tipo JSON. Y entonces ya lo podemos consumir con React!!</li>
                </ul>
              </li>
              <li class="my-1.25"><span class="destacado">Consultar una API con React</span>
                <ul class="list-disc my-3">
                  <li class="my-1.25">Al ser JavaScript puedes utilizar <strong>Fetch API</strong> (nativo de Javascript), <strong>Axios</strong> (librería) o librerías como <strong>SWR</strong> (librería optimizada para React y consultar y consumir APIs externas) para obtener los datos y mostrarlos en pantalla.</li>
                  <li class="my-1.25">Algunas APIs requieren un <strong>key</strong> como hicimos anteriormente y otras, una forma de protegerlas es por medio de algo llamado <strong>CORS</strong>.</li>
                  <li class="my-1.25"></li>
                </ul>
              </li>
            </ul>
            <p>Vamos a llamar a la API de clima. Así que vamos a comenzar con el código de nuestro proyecto.</p>
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion16-261').toggle();">
            <h3>261. Introducción a CSS Modules</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion16-261" class="hidden">
            <p>Empezamos con la interfaz del proyecto. Vamos a agregar la fuente <strong>Outfit</strong> de google fonts (400,700 y 900): <a href="https://fonts.google.com/specimen/Outfit" class="underline" target="blank">https://fonts.google.com/specimen/Outfit</a>. Copiamos el código de link y lo pegamos en nuestro <spd>index.html</spd> después del title para agregar esta fuente, y en el <span class="file">index.css</span> pegamos el estilo que google fonts nos da para esa fuente. En ese mismo css registramos un par de colores en lo que va a ser nuestra css global de proyecto y damos mas estilos al body y en el html reseteamos el font-size:</p>

            <pre data-line="0"><code class="language-html">
              //index.html
              ...
              &lt;title&gt;React / Typescript - CSS Modules y API&#39;s&lt;/title&gt;
              &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.googleapis.com&quot;&gt;
              &lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot; crossorigin&gt;
              &lt;link href=&quot;https://fonts.googleapis.com/css2?family=Outfit:wght@100..900&amp;display=swap&quot; rel=&quot;stylesheet&quot;&gt;

              //index.css 
              :root {
                --white: #ffffff;
                --primary: #f59e0b;
              }             
              html{
                font-size: 62.5%;
              }
              body {
                  font-family: "Outfit", sans-serif;
                  background-image: url(/bg_clima.jpg);
                  height: 100vh;
                  background-size: cover;
                  background-repeat: no-repeat;
                  color: var(--white);
                  font-size: 2rem;
              }
            </code></pre>

            <p>Cerramos ya el index.css y vamos al App.tsx a darle estilos al h1. No usamos tailwind porque vemos otra forma de escribir css. De todas las formas que vimos anteriormente (CSS plano, Styled Components, Framework CSS, SASS, Módulos CSS, Componentes) usamos <span class="destacado">Módulos CSS</span>. Nuestro componente se llama App.tsx, cuando trabajamos con módulos css lo nombramos con el mismo nombre y agregamos <strong>.module.css</strong> por tanto <span class="file">App.module.css</span>. Va a contener en exclusiva los estilso de ese componente no podemos hacer mezclas. En el componente lo tenemos que importar pero vemos que si lo intentamos importar así <code class="language-ts">import "./App.module.css"</code> no aplica el estilo (sí lo hace si lo especificamos con el tag h1, pero no es plan) ¿como lo hacemos?</p>
            <div class="flex max-sm:flex-col">
              <div class="w-[33%] max-sm:w-[100%]">
                <pre data-line="0"><code class="language-ts">
                  //App.module.css
                  .title{
                    text-align: center;
                    font-size: 3rem;
                    margin-top: 5rem;
                }
                </code></pre>
              </div>

              <div class="w-[33%] max-sm:w-[100%]">
                <pre class="rojo" data-line="1,7"><code class="language-js">
                  //App.tsx
                  import "./App.module.css"

                  function App() {                  
                  
                    return (
                      &lt;&gt;
                       &lt;h1 className=&quot;title&quot;&gt;Buscador de clima&lt;/h1&gt;
                      &lt;/&gt;
                    )
                  }
                  
                  export default App
                </code></pre>
              </div>
              <div class="w-[33%] max-sm:w-[100%]">
                <pre class="verde" data-line="1,7"><code class="language-js">
                  //App.tsx
                  import styles from "./App.module.css"

                  function App() {                  
                  
                    return (
                      &lt;&gt;
                       &lt;h1 className={styles.title}Buscador de clima&lt;/h1&gt;
                      &lt;/&gt;
                    )
                  }
                  
                  export default App
                </code></pre>
              </div>
            </div>
           
            <p>Si inspeccionamos el código vemos que aplica una serie de transformaciones y vemos que el class se renderiza con estos caracteres. Si alguna vez vemos esto al inspeccionar (como por ejemplo de la url de airbnb) sabremos que usa <strong>Módulos CSS: es una forma, quizás la más optimizada, de escribir código css para React</strong>. Hay que tener una css por cada componente eso sí.</p>

            <img src="./src/assets/img/261.png" alt="img" loading="lazy">
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion16-262').toggle();">
            <h3>262. Agregando los formularios para consultar el Clima - <a href="https://gist.github.com/codigoconjuan/e5266150032120f10bbf69394d7b8861" class="underline text-white" target="blank">Gist de countries</a> / 263. CSS para los Formularios</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion16-262" class="hidden">
            <p>Vamos a crear un formulario porque requerimos pasarle hacia nuestra API la ciudad y el país del cual queremos obtener el clima. Creamos nuestra carpeta de components y como cada componente requiere su hoja de estilos vamos a ir agrupando por elementos de nuestra interfaz, creamos carpeta Form y dentro de ella <span class="file">Form.tsx</span> y <span class="file">Form.module.css</span> (otras personas crean aquí dentro carpeta css/styles/modules donde meten las hojas de estilo).</p>

            <ul class="list-disc my-3">
              <li class="my-1.25">Creamos un form sin action y dentro un div que agrupa el label y el input.</li>
              <li class="my-1.25">En otro div metemos el país que va a ser un select y las opciones vienen del código que hay en este <a href="https://gist.github.com/codigoconjuan/e5266150032120f10bbf69394d7b8861" class="underline" target="blank">Gist de countries</a> que incluimos en nuevo fichero dentro de la carpeta <span class="file">data/countries.ts</span> En este segundo div metemos un select y un primer option vacío para validación "-- Seleccione un país --" seguido de una iteracción sobre nuestros datos (countries) con un .map() para acceder a cada país de forma individual.
              </li>
              <li class="my-1.25">Incluimos un input de tipo submit</li>
              <li class="my-1.25">En nuestro compo ppal <span class="file">App.tsx</span> sustituimos el primer párrafo por el nuevo componente <code class="language-ts">&lt;Form/&gt;</code>
              
              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre data-line="0"><code class="language-ts">
                    //data/countries.ts
                    export const countries = [
                    { code: 'US', name: 'Estados Unidos' },
                    { code: 'MX', name: 'México' },
                    { code: 'AR', name: 'Argentina' },
                    { code: 'CO', name: 'Colombia' },
                    { code: 'CR', name: 'Costa Rica' },
                    { code: 'ES', name: 'España' },
                    { code: 'PE', name: 'Perú' }
                  ]
                  </code></pre>  
                </div>
                <div class="w-[50%] max-sm:w-[100%]">                
                  <pre data-line="0"><code class="language-js">
                    //App.tsx
                    import styles from "./App.module.css"
                    import Form from './components/Form/Form';                  
                    function App() {
                      return (
                        &lt;&gt;
                          &lt;h1 className={styles.title}&gt;Buscador de clima&lt;/h1&gt;
                    
                          &lt;div className={styles.container}&gt;
                            &lt;Form/&gt;
                            &lt;p&gt;2&lt;/p&gt;
                          &lt;/div&gt;
                        &lt;/&gt;
                      )
                    }                  
                    export default App
                  </code></pre>
                </div>
              </div>
              
              </li>
              <li class="my-1.25">Para escribir los estilos para el formulario dividimos vista en MVSC para ir viendo paso a paso junto con el Form a qué elemento vamos aplicando estilos:
                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre data-line="0,5,15,29"><code class="language-js">
                      //components/Form/Form.tsx
                      import { countries } from "../../data/countries"
                      import styles from "./Form.module.css"                  
                      export default function Form() {
                        return (
                          &lt;form className={styles.form}&gt;              
                            &lt;div className={styles.field}&gt;
                              &lt;label htmlFor=&quot;city&quot;&gt;Ciudad:&lt;/label&gt;
                              &lt;input 
                                  id=&quot;city&quot;
                                  type=&quot;text&quot;
                                  name=&quot;city&quot;
                                  placeholder=&quot;Ciudad&quot;
                              /&gt;
                            &lt;/div&gt;              
                            &lt;div className={styles.field}&gt;
                              &lt;label htmlFor=&quot;country&quot;&gt;Pais:&lt;/label&gt;
                              &lt;select 
                                id=&quot;country&quot; 
                                name=&quot;country&quot;            
                              &gt;
                              &lt;option value=&quot;&quot;&gt;-- Seleccione un País --&lt;/option&gt;
                                  {countries.map(country =&gt; (
                                      &lt;option 
                                          key={country.code}
                                          value={country.code}
                                      &gt;
                                          {country.name}
                                      &lt;/option&gt;
                                  ))}
                                &lt;/select&gt;
                            &lt;/div&gt;              
                            &lt;input type=&quot;submit&quot; className={styles.submit} value=&quot;Consultar clima&quot; /&gt;              
                          &lt;/form&gt;
                        )
                      }
                    </code></pre>
                  </div>             
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre data-line="0"><code class="language-js">
                      //components/Form/Form.module.css
                      .form, .field{
                        display: flex;
                        flex-direction: column;
                        gap: 2rem;
                      }
    
                      .form input[type='text'],.form select{
                          padding: 1rem;
                          background-color: transparent;
                          border: .3rem solid var(--white);
                          color: var(--white);
                          font-size: 1.8rem;
                          font-weight: 400;
                          border-radius: 1rem;
                      }
    
                      .field ::placeholder{
                          color: var(--white);
                      }
    
                      .submit{
                          background-color: var(--primary);
                          border: none;
                          color: var(--white);
                          font-weight: 700;
                          font-size: 1.4rem;
                          text-transform: uppercase;
                          cursor: cursor-pointer;
                          padding: 1rem;
                      }
                    </code></pre>
                  </div>              
                </div>
              </li>
            </ul>
            
            <p><strong>Sigamos avanzando en la dirección de ponder enviar una petición estructurada a nuestra API, para lo cual colocaremos en el state la ciudad y país de la que queremos consultar el clima.</strong></p>
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion16-264').toggle();">
            <h3>264. Colocando en el State la ciudad y pais a consultar el Clima</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion16-264" class="hidden">

            <ul class="list-disc my-3">
              <li class="my-1.25"><span class="destacado">Definimos nuestro state:</span> colocamos tanto ciudad como país en el state.  En <span class="file">Form.tsx</span> importamos useState de React y creamos un objeto que llamamos search, con su método setSearch y va a tener 2 propiedades city y country.</li>
              <li class="my-1.25"><span class="destacado">Creamos type SearchType y tipamos el state con generic:</span> como search es un objeto creamos nuestro fichero de types <span class="file">Data/index.ts</span> y el type <strong>SearchType</strong> que exportamos desde ahí e importamos en nuestro compo <span class="file">Form.tsx</span> para poder tipar nuestro objeto search mediante un generic.</li>
              <li class="my-1.25"><span class="destacado">Creamos type Country para nuestros datos:</span> Aprovechemos y definamos también un type para los países que tenemos en <span class="file">Data/countries.ts</span>. Cada pais tiene un código y un nombre y ambos son strings. Creamos el type Country y lo asignamos al objeto countries de Data pero de tipo arreglo <strong>Country[]</strong></li>
              <li class="my-1.25"><span class="destacado">Asignamos con 'value'</span> las propiedades 'city' y 'country' de nuestro state a cada uno de los dos campos que tenemos en el form.</li>
              <li class="my-1.25"><span class="destacado">Crear la función de handleChange: es la que va a ir escribiendo en el state, en city y en country:</span> 
                <ul class="list-disc my-3">
                  <li class="my-1.25">Si en el input de ciudad ponemos un onChange y dentro esto, inferimos para saber el type que usar: <code class="language-ts">onChange={e =&gt;}</code> <span class="bg-amber-950 text-amber-300">(parameter) e: ChangeEvent&lt;HTMLInputElement&gt;</span>.</li>
                  <li class="my-1.25">Si en el select de country ponemos un onChange y dentro esto, inferimos para saber el type que usar: <code class="language-ts">onChange={e =&gt;}</code> <span class="bg-amber-950 text-amber-300">(parameter) e: ChangeEvent&lt;HTMLSelectElement&gt;</span>.</li>
                </ul>
                Con const creamos un objeto que es la función handleChange en la que tomamos como parámetro el evento (e) que es donde va a estar la información que se va a leer del name del input <code>name="city"</code> o del name del select <code>name="country"</code> y lo tipamos (puede serHTMLInputElement o HTMLSelectElement) <code class="language-ts">const handleChange = (e: ChangeEvent&lt;HTMLInputElement&gt; | ChangeEvent&lt;HTMLSelectElement&gt;) =&gt; {...}</code>. Como ambos elementos son strings no requerimos mucha lógica. Con setSearch tomamos una copia de lo que tengamos en el state y escribimos en el campo en el que estemos modificando con <code>[e.target.name]: e.target.value</code> ( en vez de usar e.target.name también podríamos usar id como hicimos anteriormente). <strong>Para que funcione esta técnica usando el name lo que tengamos en el name de cada input ha de llamarse exactamente igual que las propiedades del state.</strong>
              </li>
            </ul>
          
            <div class="flex max-sm:flex-col">
              <div class="w-[25%] max-sm:w-[100%]">
                <pre data-line="0"><code class="language-js">
                  //Types/index.ts
                  export type SearchType = {
                    city: string,
                    country: string
                  }
                  export type Country = {
                    code: string,
                    name: string
                  }
                </code></pre>
              </div>
              <div class="w-[25%] max-sm:w-[100%]">
                <pre data-line="0"><code class="language-js">
                  //Data/countries.ts
                  export const countries: Country[] = [
                  { code: 'US', name: 'Estados Unidos' },
                  { code: 'MX', name: 'México' },
                  { code: 'AR', name: 'Argentina' },
                  { code: 'CO', name: 'Colombia' },
                  { code: 'CR', name: 'Costa Rica' },
                  { code: 'ES', name: 'España' },
                  { code: 'PE', name: 'Perú' }
                ]        
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="0"><code class="language-ts">
                //Form.tsx
                import { ChangeEvent, useState } from "react"
                import type { SearchType } from "../../Types"
                import { countries } from "../../data/countries"
                import styles from "./Form.module.css"
                
                export default function Form() {
                
                    const [search, setSearch] = useState&lt;SearchType&gt;({
                        city: &#39;&#39;,
                        country: &#39;&#39;
                    })
                
                    const handleChange = (e: ChangeEvent&lt;HTMLInputElement&gt; | ChangeEvent&lt;HTMLSelectElement&gt;) =&gt;{
                        setSearch({
                            ...search,
                            [e.target.name] : e.target.value //escribimos en el campo en el cual estamos modificando
                        })
                    }
                    return (
                        &lt;form className={styles.form}&gt;
                
                            &lt;div className={styles.field}&gt;
                              &lt;label htmlFor=&quot;city&quot;&gt;Ciudad:&lt;/label&gt;
                              &lt;input 
                                id=&quot;city&quot;
                                type=&quot;text&quot;
                                name=&quot;city&quot;
                                placeholder=&quot;Ciudad&quot;
                                value={search.city}
                                onChange={handleChange}
                              /&gt;
                            &lt;/div&gt;
                
                            &lt;div className={styles.field}&gt;
                              &lt;label htmlFor=&quot;country&quot;&gt;Pais:&lt;/label&gt;
                              &lt;select 
                                id=&quot;country&quot;
                                name=&quot;country&quot;
                                value={search.country}  
                                onChange={handleChange}              
                              &gt;
                              &lt;option value=&quot;&quot;&gt;-- Seleccione un País --&lt;/option&gt;
                                {countries.map(country =&gt; (
                                    &lt;option 
                                        key={country.code}
                                        value={country.code}
                                    &gt;
                                        {country.name}
                                    &lt;/option&gt;
                                ))}
                              &lt;/select&gt;
                            &lt;/div&gt;
                
                            &lt;input type=&quot;submit&quot; className={styles.submit} value=&quot;Consultar clima&quot; /&gt;
                
                        &lt;/form&gt;
                    )
                }
                
                </code></pre>
              </div>
            </div>

          <p>A continuación veamos la parte del submit, ya estaremos comunicándonos con nuestra API. Sin embargo nuestra APi requiere que estos dos campos requieran algo, en la presentación de APIS vimos que requieren una <strong>petición estructurada</strong> es decir pasarle ciertos datos, veamos cómo validar este formulario.</p>
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion16-265').toggle();">
            <h3>265. Validando el Formulario</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion16-265" class="hidden">
            <p><span class="destacado">Para poder obtener la información que deseas de una API o de un proyecto tenemos que enviarle ciertos datos, que es lo que se conoce como una petición</span> y normalmente tiene que tener cierta estructura. Por ejemplo en Google Maps tenemos que pasarle dos cosas: "donde estamos" y "dónde queremos ir" (y requiere las dos). Si queremos pedir un taxi desde una app hay que decirle "a donde vamos" para que nos diga "cuanto nos va a costar".</p>
            
            <p>En nuestro caso, la API de OpenWeather requiere ciudad y pais por lo que <span class="destacado">vamos a implementar validación para asegurarnos de que ambos están presentes</span> y entonces poder obtener el clima.</p>

            <p><span class="destacado">Creamos la función handleSubmit y la llamamos desde el onSubmit del form</span> <code class="language-ts">onSubmit={handleSubmit}</code></p>

            <ul class="list-disc my-3">
              <li class="my-1.25"><strong>Con const creamos un objeto que es la función handleSubmit </strong>en la que tomamos como parámetro el evento (e) que es XXXXXXXXXXXX y lo tipamos  usando el mismo "truqui" de siempre <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
              </svg> <br>
              Si en el onSubmit del form ponemos e y callback <code class="language-ts">onSubmit={e =&gt;}</code>, inferimos para saber el type que usar y lo copiamos <span class="bg-amber-950 text-amber-300">(parameter) e: React.FormEvent&lt;HTMLFormElement&gt;</span>.<br>
              para tipar el parámetro e que recibe nuestro handleSubmit() que queda así: <code class="language-ts">const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) => {...}</code>. </strong>      
              </li>
              
              <li class="my-1.25"><strong>añadimos e.preventDefault()</strong> porque nosotros somos los que vamos a manejar el código (lo que incluye llamar a nuestra API, pero primero terminamos la validación)</li>
              
              <li class="my-1.25"><strong>validamos mirando si alguno está vacío</strong> con <code class="language-ts">if(Object.values(search).includes(''))</code> y sacamos un console.log de momento para informar de ello: 
                <pre data-line="0"><code class="language-ts">
                  //Form.tsx
                  const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) => {
                    e.preventDefault()
                    if(Object.values(search).includes('')){
                      console.log('Sí hay campos vacíos...')
                    }
                }
                </code></pre>
                Como vemos es una validación sencilla. Si queremos algo más robusto, usaremos <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                </svg> <strong>React Hook Form:</strong> - 
                <a class="underline" href="https://react-hook-form.com/" target="_blank">https://react-hook-form.com/</a> - recordemos, librería para para la parte de validación y procesamiento de nuestros formularios sencilla y robusta. Nos lo pondremos como ejercicio al finalizar el proyecto, tomando los ejemplos hechos con esta librería y adaptar este que estamos haciendo. Se instala con <span class="destacado">npm i react-hook-form</span>.
              </li>

              <li class="my-1.25">Como vamos a querer mostrar un mensaje de error, una alerta. <strong>Creamos un componente (carpeta Alert con su componente Alert.tsx y su css Alert.module.css)</strong>. Y también <strong>vamos a crear en nuestro Form.tsx un nuevo state para esta alerta que iniciamos como string vacío</strong> <code class="language-ts">const [alert, setAlert] = useState('')</code>. No colocamos type porque es un string y solo es ese. Modificamos nuestra validación y sustituimos el console.log por la llamada a nuestro state, seteando el string que quremos mostrar y a continuación un return para que no se ejecuten las siguientes líneas de código. A continuación del tag form metemos un código para decirle que si hay algo en el state Alert renderice el componente Alert que de momento lo escribimos con esta sintaxis pasándole un children para escribir dentro el estado alert <code class="language-ts">{alert && &lt;Alert&gt;{alert}&lt;/Alert&gt;}</code>
              <div class="flex max-sm:flex-col">      
                <div class="w-[33%] max-sm:w-[100%]">
                  <pre data-line="0"><code class="language-ts">
                    //Form.tsx
                    const [alert, setAlert] = useState('')
                    ...
                    const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) => {
                      e.preventDefault()
                      if(Object.values(search).includes('')){
                        setAlert('Todos los campos son obligatorios')
                        return
                      }
                    }
                    ...
                    &lt;form 
                      className={styles.form}
                      onSubmit={handleSubmit}
                    &gt;
                      {alert &amp;&amp; &lt;Alert&gt;{alert}&lt;/Alert&gt;}
                  </code></pre>
                </div>
                <div class="w-[33%] max-sm:w-[100%]">
                  <pre data-line="0"><code class="language-js">
                    //Alert.tsx
                    import { ReactNode } from "react"
                    import styles from './Alert.module.css'

                    export default function Alert({children} : {children : ReactNode}) {
                        return (
                        &lt;div className={styles.alert}&gt; 
                            {children}
                        &lt;/div&gt;
                        )
                    }
                  </code></pre>
                </div>    
                <div class="w-[33%] max-sm:w-[100%]">
                  <pre data-line="0"><code class="language-js">
                    //Alert.module.css
                    .alert{
                      text-align: center;
                      margin-bottom: 2rem;
                      text-transform: uppercase;
                      font-weight: 900;
                      font-size: 1.8rem;
                    }
                  </code></pre>
                </div>
              </div> 
              </li>    
            </ul>
            <p>Ya con la validación lista entonces podemos enviar una petición hacia nuestra API. Vamos a crear un custom hook que va a tomar tanto la ciudad como el país, va a hacer la consulta y va a devolvernos un resultado</p>
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion16-266').toggle();">
            <h3>266. Creando un Hook para Consultar el Clima</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion16-266" class="hidden">
            <p>Vamos a crear un custom hook que se va a encargar de toda la lógica y de consultar nuestra APi de clima, así lo separamos un poco y tenemos un código más limpio y fácil de mantener.</p>


            <ul class="list-disc my-3">
              <li class="my-1.25"><strong>Creamos nuestro custom hook: <span class="file">hooks/useWeather.ts</span>. En el return de dentro de la función irán todos los datos que nos irá retornando este custom hook.</strong></li>
            
              <li class="my-1.25"><strong>Creamos función para consultar clima 'fetchWeather' y la exportamos en el return para hacerla disponible a nuestros componentes.</strong> En esta función es donde vamos a estar escribiendo buena parte de nuestra lógica, tenemos mucho que ver y aprender relacionado con consulta de API y Typescript.</li>
              
              <li class="my-1.25">Importamos nuestro custom hook en el <span class="file">App.tsx</span>. Extraemos con destructuring la función de obtener clima fetchWeather y lo pasamos hacia el formulario como prop nombrándolo exactamente igual. Vemos ya el "error/aviso" que nos da VSC en donde podemos inferir ahí el type que ha de tener esta función que estamos pasando como prop al componente Form <span class="bg-amber-950 text-amber-300">(property) fetchWeather: () => void</span>) </li>
                
              <li class="my-1.25"><strong>Comunicamos nuestro custom hook y nuestro formulario:</strong> en el compo <span class="file">Form.tsx</span> creamos un type para las props que le pasemos al Form <strong>FormProps</strong> en el que especificamos esta primera propiedad y su tipo. Añadimos ese prop como parámetro en la función de nuestro compo y tipamo el parámetro con el tipo que hemos añadido en el type de las props. Mandamos llamar esa función nada más pasar la validación. Si probamos ahora la aplicación y ponemos una ciudad y país y le damos al botón de consultar clima, vemos que en consola nos saca lo que, de momento en console.log le hemos puesto a esa función.
                <div class="flex max-sm:flex-col">      
                  <div class="w-[25%] max-sm:w-[100%]">
                    <pre data-line="0"><code class="language-js">
                      //hooks/useWeather.ts
                      export default function useWeather(){
                        const fetchWeather = () => {
                            console.log('Consultando...')
                        }        
                        return {
                            fetchWeather
                        }
                      }
                    </code></pre>
                  </div>
                  <div class="w-[37%] max-sm:w-[100%]">
                    <pre data-line="0,2,5,12"><code class="language-js">
                      //App.tsx
                      ...
                      import useWeather from "./hooks/useWeather"
                      
                      function App() {            
                        const { fetchWeather } = useWeather()            
                        return (
                          &lt;&gt;
                            &lt;h1 className={styles.title}&gt;Buscador de clima&lt;/h1&gt;
                      
                            &lt;div className={styles.container}&gt;
                              &lt;Form
                                fetchWeather = {fetchWeather}
                              /&gt;
                    </code></pre>
                  </div>
                  <div class="w-[37%] max-sm:w-[100%]">
                    <pre data-line="0,13"><code class="language-js">
                      //components/Form.tsx
                      type FormProps = {
                        fetchWeather: () => void
                      }
                      export default function Form({fetchWeather}:FormProps) {
                        ...
                        const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) => {
                          e.preventDefault()
                          if(Object.values(search).includes('')){
                            //console.log('Sí hay campos vacíos...')
                            setAlert('Todos los campos son obligatorios')
                            return
                          }
                          fetchWeather()
                      }
                    </code></pre>
                  </div>
                </div>
              </li>
            </ul>
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion16-267').toggle();">
            <h3>267. Primer Llamado hacia la API - <a href="https://openweathermap.org/" class="underline text-white" target="blank">https://openweathermap.org/</a> -  <a href="https://openweathermap.org/api/geocoding-api" class="underline text-white" target="blank">Geocoding API</a></h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion16-267" class="hidden">
            <p>Vamos a estar consumiendo una API que es "curiosa" porque antes solamente había que hacer una llamada para una consulta de clima, pero tras una actualización que hicieron hay que hacer 2 llamadas para consultar clima (en el plan gratuito te dan 3000 llamadas). Antes era ciudad y país, ahora hay que ponerle latitud y longitud y ellos mismos te dicen como obtenerlos, utilizando <strong>la API de geocoding</strong>.</p>
            
            <p>En <a href="https://openweathermap.org/" class="underline" target="blank">https://openweathermap.org/</a> pulsamos arriba en "API", scrolleamos un poco en la nueva url hasta "Current Weather Data" y pulsamos en "API doc" donde vamos a tener el ejemplo del código y podemos ver la latitud y longitud {lat} y {lon} pero ¿cómo vamos a obtener esos valores? Lo explican un poco más abajo, hay que ir a <a href="https://openweathermap.org/api/geocoding-api" class="underline" target="blank">Geocoding API</a> y ahí ya sí vemos que en esa llamada a la API toma el nombre de la ciudad y el país, y esta llamada ya sí retorna la latitud y la longitud que utilizamos para la segunda llamada.</p> 

              <img src="./src/assets/img/266.png" alt="img" loading="lazy">
              
            <p>Como vimos en la presentación de APIS, tenemos que enviar una petición estructurada, básicamente hacer lo que ellos te piden que hagas. Una prueba muy común como Junior Developer es decirte "tenemos esta API nosotros, consúmela, envíale información". Es algo que vamos a estar haciendo continuamente.</p>

            <p class="naranja">Aquí empieza el 267</p>

            <p>Vamos a consultar el primer endpoint de nuestra API que es el de Geocoding API porque requerimos latitud y longitud pero en nuestro formulario solo le estamos poniendo el nombre de la ciudad y del país.</p>

            <ul class="list-disc my-3">
              <li class="my-1.25">Instalamos axios <span class="destacado">npm i axios</span> es una librería para consultar APIs externas que es una abstracción sobre fetch api, simplifica un poco las llamadas cuando consumimos datos. Fetch aPI está bien, pero esa parte del doble await, ya para un código final es otra historia.</li>
              <li class="my-1.25">en nuestro custom hook importamos axios y empleamos la palabra <strong>async</strong> para hacer nuestra función asíncrona porque va a ser un llamado hacia una API y no sabemos cuánto tiempo puede tomar, así que con esto 'bloqueamos' el código hasta tener cierta respuesta. Usualmente cuando trabajamos con async/await, su mejor aliado es <strong>try/catch</strong> que nos va a permitir que en caso de que haya un error lo podamos debugear. El try/catch intenta llevar a cabo, línea por línea, todo el código que esté en el try y en caso de uqe haya un error salta directamente a la parte del catch. Esto es importante porque requerimos que se realicen todos estos pasos: que se haga la conexión, que nos traiga los datos y en caso de que haya un error (que no escribamos bien la url, que no l estemos pasando el id que generamos para la API (la key)...), de momento lo tenemos en la consola.
              
                <pre data-line="0"><code class="language-js">
                  //useWeather.ts
                  import axios from "axios"
                  export default function useWeather(){
                      const fetchWeather = async () => {
                        try {
                      
                        } catch (error) {
                            console.log(error)
                        }
                      }
                      return {
                          fetchWeather
                      }
                  }
                </code></pre>
              </li>
              <li class="my-1.25"><p>Vamos a Geocoding API y copiamos la API call <code class="language-ts">http://api.openweathermap.org/geo/1.0/direct?q={city name},{state code},{country code}&limit={limit}&appid={API key}</code>. Lo metemos en una nueva variable geoUrl con un template string, puesto que vemos que en la url tenemos ciertas variables como nuestra API key y el nombre de la ciudad.</p>
                
              <p>Si nos fijamos en la estructura de la url viene q={city name} que es el nombre de la ciudad que tenemos en nuestra interfaz, luego {state code} y {country code}. Tenemos que, desde nuestro formulario en Form.tsx, en la llamada a la función fetchWeather(), pasarle nuestra búsqueda: <code class="language-ts">fetchWeather(search)</code> y entonces en nuestro custom hook tomar ese parámetro que es una búsqueda de tipo <span class="bg-[#4ec9b0] text-white">SearchType</span>  <code class="language-ts">const fetchWeather = async (search: SearchType) => {</code>.</p>

              <p>Vemos que nos aparecen muchos errores. Sigámoslos. En App.tsx nos marca error en el prop que le pasamos al Form, recordemos que en principio habíamos tipado ese prop en el <span class="bg-[#4ec9b0] text-white">FormProps</span> del Form.tsx como una función que no retorna nada, pero le estamos pasando una búsqueda, así que ya esa Firma está mal, tenemos que ajustarla. Si vemos el aviso de App.tsx nos inidica que el tipo search debe retornar un promise <span class="bg-amber-950 text-amber-300">El tipo '(search: SearchType) => Promise<void>' no se puede asignar al tipo '() => void'. La firma de destino proporciona muy pocos argumentos. Se esperaba 1 o más, pero se obtuvo 0.</span> Async Await es una abstracción de promises API, una versión un poco más corta, pero siguen siendo promises. Por tanto copiamos ese valor del IS y lo usamos para modificar nuestra anterior firma de <code class="language-ts">fetchWeather: () => void</code> por <code class="language-ts">fetchWeather: (search: SearchType) => Promise</code> Y eso ya lo soluciona <strong>antes solo era una función, pero ahora es una función asíncrona que toma una búsqueda de tipo SearchType y no retorna nada aún y no sabemos si va a retornar algo o solo vamos a escribir en el state, por eso requerimos el promise.</strong></p>

              <p>Cambiamos de nuestra url <code class="language-ts">{city name}</code> por <code class="language-ts">${search.city}</code>. Eliminamos el parámetro {state code}. Sustituimos <code class="language-ts">{country code}</code> por <code class="language-ts">${search.country}</code>. Eliminamos el parámetro limit. El parámetro <code class="language-ts">{API Key}</code> lo sustituimos por esta variable que creamos con el código que generamos anteriormente: <code class="language-ts">const appI = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'</code>. !Claro! si ponemos esto en github cualquiera puede verlo <span class="destacado">hemos de ocultarlo ya hora en seguida veremos como hacerlo.</span> Podemos hacer un <code class="language-ts">console.log(geoUrl)</code> para ver toda la estructura de la url una vez inyectados los valores. Si probamos nuestra app y copiamos la url de la consola y la pegamos en el navegador, vemos que nos aparece esta información, donde están los valores de latitud y longitud que son los que necesitamos para consultar nuestra API de clima:
              <pre><code class="language-ts">
                [
                  {
                    "name": "Tres Cantos",
                    "local_names": {
                      "ru": "Трес-Кантос",
                      "uk": "Трес-Кантос"
                    },
                    "lat": 40.6065826,
                    "lon": -3.7065333,
                    "country": "ES",
                    "state": "Community of Madrid"
                  }
                ]
              </code></pre>
              </p>

              <p><strong>¿Cómo hacemos para consultarlo aquí en nuestro código?</strong> creamos una nueva variable: <code class="language-ts">const data = await axios(geoUrl)</code>. Si dejáramos el código como está va a hacer una petición de tipo get (que es la que obtiene datos) y como es lo que queremos en este caso, pues bien. <span class="destacado">Podríamos especificarlo de estas dos maneras distintas adicionales: <code class="language-ts">const data = await axios.get(geoUrl)</code> o <code class="language-ts">const data = await axios(geoUrl, {method: 'get'})</code>. Pero como get es el default, no es necesario.</span>. Hacemos un <code class="language-ts">console.log(data)</code>, guardamos cambios y vemos la respuesta que obtenemos:</p>
                <ul class="list-disc my-3">
                  <li class="my-1.25">statusText: OK significa que se conectó correctamente</li>
                  <li class="my-1.25">data: es la url que visitamos antes (la proveniente de nuestra geoUrl). como quiero acceder directamente a data, puedo aplicar destructuring desde mi código: en vez de <code class="language-ts">const data = await axios.get(geoUrl)</code> aplicando destructuring: <code class="language-ts">const {data} = await axios.get(geoUrl)</code> ya entra directamente a esa información:
                    <div class="flex max-sm:flex-col">
                      <div class="w-[50%] max-sm:w-[100%]">
                        <pre data-line="0"><code class="language-ts">
                          const data = await axios.get(geoUrl)
                        </code></pre>
                        <img src="./src/assets/img/267.png" alt="img" loading="lazy">
                      </div>
                      <div class="w-[50%] max-sm:w-[100%]">
                        <pre data-line="0"><code class="language-ts">
                          const {data} = await axios.get(geoUrl)
                        </code></pre>
                        <img src="./src/assets/img/267-2.png" alt="img" loading="lazy">
                      </div>
                    </div>        
                  </li>     
                </ul>
              </li>
          </ul>

            <p>Ya tenemos esa información (que tiene latitud y longitud) en nuestro código. Ya hemos hecho nuestra primera llamada y es correcta, estamos obteniendo información de Internet. Pero antes de seguir hemos de:</p>
            <ul class="list-disc my-3">
              <li class="my-1.25">ocultar nuestro API Key que tenemos almacenado en la variable appId</li>
              <li class="my-1.25">si vemos nuestro data destructurado <code class="language-ts">const {data} = await axios.get(geoUrl)</code>, vemos que es de tipo any <span class="bg-amber-950 text-amber-300">const data: any</span>. Cuando llamamos a una API es prácticamente imposible para TypeScript saber qué es lo que está obteniendo porque eso está en Internet no está en nuestro código. Más adelante veremos técnicas para evitar esto, tener tipos any cuando hacemos llamadas a APIS.</li>
            </ul>

                <div class="flex max-sm:flex-col">
                  <div class="w-[33%] max-sm:w-[100%]">
                    <pre data-line="0,2,13"><code class="language-js">
                      //App.tsx
                      &lt;Form
                        fetchWeather = {fetchWeather}
                      /&gt;
                    </code></pre>
                  </div>
                  <div class="w-[33%] max-sm:w-[100%]">
                    <pre data-line="0,2,13"><code class="language-js">
                      //Form.tsx
                      type FormProps = {
                        fetchWeather: (search: SearchType) => Promise<void>
                      }    
                      export default function Form({fetchWeather}:FormProps) {
                        ...
                        const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) => {
                          e.preventDefault()
                          if(Object.values(search).includes('')){
                              //console.log('Sí hay campos vacíos...')
                              setAlert('Todos los campos son obligatorios')
                              return
                          }
                          fetchWeather(search)
                        }     
                  
                    </code></pre>
                  </div>
                  <div class="w-[33%] max-sm:w-[100%]">
                    <pre data-line="0"><code class="language-js">
                      //useWeather.ts
                      import axios from "axios"
                      export default function useWeather(){
                        const fetchWeather = async (search: SearchType) => {
                          const appId = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'
                          try {
                            const geoUrl = `https://api.openweathermap.org/geo/1.0/direct?q=${search.city},${search.country}&appid=${appId}` 
                            //console.log(geoUrl)
                            const data = await axios(geoUrl)
                            console.log(data)
                          } catch (error) {
                            console.log(error)
                          }
                        }
                        return {
                          fetchWeather
                        }
                      }
                    </code></pre>
                  </div>
                </div> 

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion16-268').toggle();">
            <h3>268. ¿Qué son las variables de Entorno? <a href="https://vite.dev/guide/env-and-mode" class="underline text-white" target="blank">Vite Env Variables and Modes</a></h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion16-268" class="hidden">
            <p>Tenemos que ocultar nuesta API key. Siempre es recomendable ocultar este tipo de información sensible. No es algo de React, es algo más bien de Vite. Vamos a ver qué son <span class="destacado">las variables de entorno</span>. <strong>Nos van a permitir fijar valores diferentes en función del entorno en el que estemos (DESARROLLO vs PRODUCCIÓN)</strong>. Actualmente estamos en el entorno de desarrollo, cuando yo haga el build el entorno se convierte a producción porque ese proyecto ya va a estar hospedado en un servidor. Ejemplo: conexión a una BBDD. En desarrollo puede que tengamos una BBDD de pruebas, de DESA que en vez de 100000 de clientes solo tiene 5 para hacer pruebas, no puedes estar probando en la BBDD del negocio. Otro ejemplo: probando un servicio de email, vamos a utilizar un smtp, un servicio de email de pruebas como <a href="https://mailtrap.io/es/" class="underline" target="blank">https://mailtrap.io/es/</a> pero una vez que tengamos nuestro código usaremos un servicio de pago para que envíe los emails a producción.</p>

            <p>Nosotros vamos a ocultar el valor de nuestra API Key colocándolo en una variable de entorno, para que funcione localmente pero si lo subimos a github ese código o esas variables no tienen que estar visibles, y en un hosting tenemos que agregarlas en un panel que, a día de hoy, casi todos los hostings tienen.</p>

            <p>Veamos que vite ya tiene algunas variables de entorno. En nuestro App.tsx añadamos este <code class="language-ts">  console.log(import.meta.env)</code> antes del return. Guardamos, recargamos y vemos en consola que ahora mismoa hay 5: </p>
            <img src="./src/assets/img/268.png" alt="img" loading="lazy">

            <p>Esta es la forma en que vamos a obtener las variables de entorno <strong>(con node es con process but con vite es con import.meta.env)</strong> No podemos nombrar nuevas variables de entorno con ninguno de esos nombres, de hecho hay una forma de hacerlo. En este link <a href="https://vite.dev/guide/env-and-mode" class="underline text-white" target="blank">Vite Env Variables and Modes</a> vemos algunas variables de entorno y cómo acceder a ellas, es un objeto, y si scrolleamos un poco hacia abajo se nos explica que <span class="destacado">tenemos que crear el archivo .env</span>. Vemos cómo debemos nombrar nuestras variables de entorno: para vite se requiere que inicen con <span class="destacado">VITE_</span> <span class="destacado">Creamos nuestro archivo <span class="file">.env.local</span> en la raíz del proyecto</span>  y si vemos esto significa que env.local es ignorado por git por lo que cuando yo suba este código, no se va a subir ese archivo que tiene información sensible:</p>

            <pre><code class="language-ts">
              .env                # loaded in all cases
              .env.local          # loaded in all cases, ignored by git
              .env.[mode]         # only loaded in specified mode
              .env.[mode].local   # only loaded in specified mode, ignored by git
            </code></pre>

            <p>Supongamos que en nuestro fichero de variables de entorno metemos una que sí cumple con el requisito de nomenclatura (en la que metemos nuestro API KEY) y creamos otra que no cumple con el requisito de nomenclatura:</p>
            <pre><code class="language-ts">
              //.env.local
              VITE_API_KEY=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
              EMAIL_PASSWORD=123456
            </code></pre>

            <p>Si mandamos a la consola <code class="language-ts">console.log(import.meta.env)</code> vemos que sí aparece la que cumple con el requisito de que el nombre empieza por VITE_ sin embargo la otra no</p>
            <p>Así ya queda oculto, cuando yo suba este código este archivo va a ser ignorado y nadie va  apoder ver mi API key. </p>
            <p>En nuestro custom hook reemplazamos esto: <code class="language-ts">const appId = 'xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx'</code> por esto: <code class="language-ts">const appId = import.meta.env.VITE_API_KEY</code> (cuando alguien visite nuestro código va a ver esto, en vez de nuestra API KEY)</p>

            <p><strong>Algo importante es que cuando tenemos variables en código local, nos tenemos que asegurar que esas variables tambiéne existan en producción, eso lo vamos a ver en cuanto hagamos el deployment (más adelante veremos como llevar este proyecto a producción y registrar las variables de entorno en Netlify que tiene un panel especial para ello)</strong></p>

            <p>Una vez oculta la api key podemos continuar con nuestro código, de este data requerimos latitud y longitud. Y tenemos que hacer una segunda llamada que es la que obtiene el clima: <a href="https://openweathermap.org/current" class="underline" target="blank">Call current weather data</a> - How to make an API call: <code class="language-ts">https://api.openweathermap.org/data/2.5/weather?lat={lat}&lon={lon}&appid={API key}</code></p>

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion16-269').toggle();">
            <h3>269. Segundo llamado hacia la API para obtener el Clima</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion16-269" class="hidden">
            <p>En nuestra variable geoUrl tenemos la url de geocoding. En el destructuring que hacemos del data que obtenemos con <code class="language-ts">const {data} = await axios.get(geoUrl)</code> veíamos que ya tenemos latitud y longitud que es lo que necesitamos para obtener el clima actual. Cuando buscamos una ciudad vemos con el <code class="language-ts"> console.log(data)</code> que, si encuentra algo, siempre nos va a retornar el arreglo y posición 0. </p>

            <ul class="list-disc my-3">
              <li class="my-1.25">En nuestro try, justo despues del destructuring const {data} (en el que ya tenemos esa primera llamada con lat y lon) creamos 2 variables nuevas para almacenar esos valores (vemos tras el [0] que no tenemos autocompletado porque data es any como decíamos; más adelante veremos como tiparlo. por el console log de dat vemos que en cada caso es lat y lon). Hacemos un console.log a ambos y podemos ver esos valores en consola. Mas adelante también contemplaremos la opción de que no encuentre esos valores, mostraremos un mensaje:
              <pre><code class="language-ts">
                const lat= data[0].lat
                const lon= data[0].lon
              </code></pre>
              </li>
              <li class="my-1.25">Tomamos la url de <a href="https://openweathermap.org/current" class="underline" target="blank">Call current weather data</a> - How to make an API call: <code class="language-ts">https://api.openweathermap.org/data/2.5/weather?lat={lat}&lon={lon}&appid={API key}</code> y creamos una segunda variable para esta segunda url: 'weatherUrl' <code class="language-ts">const weatherUrl = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${appId}`</code>  y hacemos un
                console.log(weatherUrl). En consola vemos esa url y al presionarla vemos toda la información que nos devuelve la api. Vemos que en main aparecen temperaturas, pero en grados Kelvin, haremos la conversión a centígrados.

                <div class="flex max-sm:flex-col m2.5-5">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre><code class="language-ts">
                      {
                        "coord": {
                            "lon": -3.7065,
                            "lat": 40.6066
                        },
                        "weather": [
                            {
                                "id": 801,
                                "main": "Clouds",
                                "description": "few clouds",
                                "icon": "02d"
                            }
                        ],
                        "base": "stations",
                        "main": {
                            "temp": 282.76,
                            "feels_like": 280.66,
                            "temp_min": 281.73,
                            "temp_max": 284.09,
                            "pressure": 1014,
                            "humidity": 58,
                            "sea_level": 1014,
                            "grnd_level": 925
                        },
                        "visibility": 10000,
                        "wind": {
                            "speed": 4.02,
                            "deg": 281,
                            "gust": 7.15
                        },
                        "clouds": {
                            "all": 20
                        },
                        "dt": 1742141210,
                        "sys": {
                            "type": 2,
                            "id": 2003930,
                            "country": "ES",
                            "sunrise": 1742106289,
                            "sunset": 1742149329
                        },
                        "timezone": 3600,
                        "id": 6359405,
                        "name": "Tres Cantos",
                        "cod": 200
                    }
                    </code></pre>   
                  </div>
                  <div class="w-[50%] max-sm:w-[100%]">
                    <ul class="list-disc my-3">
                      <li class="my-1.25"> Almacenamos en una variable destructurando esta segunda url. Como esto <code class="language-ts">const{data} = await axios.get(weatherUrl)</code> nos marca error porque ya teníamos un data destructurado con la primera llamada, podemos utilizar esta sintaxis para renombrar este segundo data; aplicándole aquí en el destructuring los ":" hace que a la variable data se le asigne el nombre weatherResult:<br> <code class="language-ts">const{data: weatherResult} = await axios.get(weatherUrl)</code> y hacemos un <code class="language-ts">console.log(weatherResult)</code>
                
                        <p>Lo único que nos interesa de aquí es el name y lo que está en main (incluída temperatura que como decíamos convertiremos de Kelvin a Centígrados)</p>
                        <img src="./src/assets/img/269.png" alt="img" loading="lazy">
                      </li>
                    </ul>                  

                    
                  </div>
                </div>
               
              </li>              
            </ul>

            <div class="flex max-sm:flex-col">
              <div class="w-[35%] max-sm:w-[100%]">
                <pre data-line="0"><code class="language-js">
                  //App.tsx
                  &lt;Form
                    fetchWeather = {fetchWeather}
                  /&gt;
                </code></pre>    
                <pre data-line="0"><code class="language-js">
                  //Form.tsx
                  type FormProps = {
                    fetchWeather: (search: SearchType) => Promise<void>
                  }    
                  export default function Form({fetchWeather}:FormProps) {
                    ...
                    const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) => {
                      e.preventDefault()
                      if(Object.values(search).includes('')){
                          //console.log('Sí hay campos vacíos...')
                          setAlert('Todos los campos son obligatorios')
                          return
                      }
                      fetchWeather(search)
                    }  
                </code></pre>
                <pre data-line="0"><code class="language-ts">
                  //.env.local
                  VITE_API_KEY=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
                </code></pre>
              </div>
              <div class="w-[65%] max-sm:w-[100%]">
                <pre data-line="0"><code class="language-js">
                  //useWeather.ts
                  import axios from "axios"
                  export default function useWeather(){
                    const fetchWeather = async (search: SearchType) => {
                      const appId = import.meta.env.VITE_API_KEY
                      try {
                        const geoUrl = `https://api.openweathermap.org/geo/1.0/direct?q=${search.city},${search.country}&appid=${appId}` 
                        //console.log(geoUrl)
                        const data = await axios(geoUrl)
                        //console.log(data)
                        const lat= data[0].lat
                        const lon= data[0].lon
                        const weatherUrl = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${appId}`
                        //console.log(weatherUrl)
                        const{data: weatherResult} = await axios.get(weatherUrl)
                        console.log(weatherResult)
                      } catch (error) {
                        console.log(error)
                      }
                    }
                    return {
                      fetchWeather
                    }
                  }
                </code></pre>
              </div>
            </div> 

            <p>Ambas variables obtenidas con destructuring (data y weatherResult) son de tipo any. TS funciona en nuestro código pero antes consultas a una API TS no se puede conectar "hacia allí" y saber qué está obteniendo. <strong>Veamos varias opciones para tipar las respuestas de una API, desde la peor hasta la mejor.</strong></p>
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion16-270').toggle();">
            <h3>Tipar Resultados de una API: 270. Asignar Type / 271. Type Guards = Assertion / 272. Validar con ZOD / 273. Validar con Valivot</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion16-270" class="hidden">
            <p>Veamos algunas opciones para tipar este resultado (veremos desde la peor hasta la mejor) porque como podemos ver en el IS weatherResult es de tipo any <span class="bg-amber-950 text-amber-300">const weatherResult: any</span> y si yo quisiera un console.log a algunos de los valores (por ejemplo ciudad y temperatura de las que está en el main) podemos ver que no tenemos ninguna ayuda con la notación del punto.</p>

            <ul class="list-disc my-3">
              <li class="my-1.25"><strong>1. Tipar Resultados de una API - Asignar Type:</strong> solo casteamos el type que queremos asignar a la respuesta: <code class="language-ts">const{data: weatherResult} = await axios&lt;Weather&gt;(weatherUrl)</code>. <strong>¿Desventaja?</strong> no escanea el objeto real para saber si hay un error o no.</li>
              <li class="my-1.25"><strong>2. Type guard o assertion:</strong> es mucho mejor que la anterior porque sí revisa el JSON que estamos obteniendo. Pero difícil de mantener si tenemos múltiples objetos, múltiples endpoints=APIS no va a ser tan simple. <strong>¿Desventaja?</strong> Si tenemos una respuesta muy grande vamos a tener funciones también muy grandes. Además si tenemos múltiples APIS=endpoints, tendremos que crear una función por cada endpoint, lo cual es difícilmente mantenible.</li>
              <li class="my-1.25"><strong>3. Validar con ZOD:</strong> ha ganado mucha popularidad implementar una librería llamada ZOD. La instalamos con <span class="destacado">npm i zod</span>. Código sencillo y que revisa que el JSON que recibimos cumpla con el esquema que definimos. <strong>¿Desventaja?</strong> No es modular, importamos una única función z que llama a todo ahí mismo.</li>
              <li class="my-1.25"><strong>4. Validar con Valibot:</strong> <span class="destacado">npm i valibot</span></li>
            </ul>


      <p class="naranja">1. Tipar Resultados de una API: Asignar Type</p>

            <p>Esta es la peor forma: (veo en la consola la respuesta que se está obteniendo y entonces creo un type que tenga esa forma): Crear un type en <span class="file">types/index.ts</span> llamado <span class="bg-[#4ec9b0] text-white">Weather</span> donde vamos a tipar solo lo que nos interesa (name y 3 temperaturas), no todo lo que devuelve. De esa información me gustaría extraer el nombre y las 3 temperaturas. Hacemos lo siguiente y tendríamos un objeto con esa información.</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="0"><code class="language-ts">
                  //types/index.ts
                  export type Weather = {
                    name:string
                    main: {
                      temp: number,
                      temp_max: number,
                      temp_min: number
                    }
                  }                  
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <p>En nuestro hook usaríamos este type vía generic indicando así que "la respuesta que vamos a obtener en este llamado va a ser un type de tipo <span class="bg-[#4ec9b0] text-white">Weather</span>. Con el IS ya veríamos que aparece con ese type y también funciona ya la notación del punto para acceder a esos valores:</p>
                <pre data-line="0"><code class="language-ts">
                  //useWeather.ts
                  ...
                  const{data: weatherResult} = await axios&lt;Weather&gt;(weatherUrl)
                  console.log(weatherResult.name)
                  console.log(weatherResult.main.temp_max)
                </code></pre>
              </div>
            </div>

            <p>Si aquí <code class="language-ts">console.log(weatherResult.main.temp_max)</code> le quitáramos el main <code class="language-ts">console.log(weatherResult.temp_max)</code> nos daría un undefined), porque <strong>no escanea el objeto para poder decir "ok es correcto lo que estás asignando"</strong>. El código de TS reside aquí, pero no puede ir a la respuesta de la API e identificar si lo que le estamos asignando es correcto, si asignamos algo que no va o es incorrecto, TS no nos puede decir "oye ahí hay un error". Con esto <code class="language-ts">const{data: weatherResult} = await axios&lt;Weather&gt;(weatherUrl)</code> lo que estamos haciendo es castear el type que queremos asignar a la respuesta (asignarle el valor nosotros), pero existen otras formas de comprobar si lo que le estamos pasando es correcto. Veámoslas.</p>

      <p class="naranja">2. Tipar Resultados de una API: Type Guards = Assetions</p>          

            <p>Nuestro problema está siendo que no sabemos exactamente qué estamos obteniendo. Con un type guard podemos garantizar que sí es de esa forma. La función 'isWeatherResponse(weather) va a revisar que tenga todo lo que tenemos definido en el type. Creamos una variable result en la que asignamos la llamada a nuestra nueva función isWeatherResponse que vamos a crear pasándole como argumento nuestro weatherResult. Vemos que, al crear la función, el parámetro weather nos lo marca como any; <span class="destacado">existe una alternativa en TS para tipar que es 'unknown', en TS se usa para tipar un valor cuyo tipo no conocemos aún (en el tiempo de compilación), pero es una manera de decirle al compilador de TS que no estamos seguros de qué tipo de dato podemos recibir, como en este caso el llamado a una API, pero aún así queremos asegurarnos de que se realicen ciertas verificaciones de tipo antes de operar con ese valor</span>. Y ya comenzamos a escribir las verificaciones, verificar que este clima que le estamos pasando en la llamada tenga la forma de un name y un objeto main con 3 temperaturas, todos del tipo que hemos especificado en nuestro <span class="file">types/index.ts</span>.</p>

            <p> En nuestra función escribimos return() y dentro cada una de esas comprobaciones. <strong>typeof</strong> nos va a retornar el tipo de dato que tiene una variable. Ponemos todos estos <strong>&&</strong> porque <strong>las siguientes condiciones se tienen que cumplir para describir correctamente el tipo weather que estamos obteniendo desde axios</strong> (este código toma esa respuesta, la pasa como objeto y aplicamos comprobaciones de forma individual):</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[25%] max-sm:w-[100%]">
                <pre data-line="0"><code class="language-ts">
                  //types/index.ts
                  export type Weather = {
                    name:string
                    main: {
                      temp: number,
                      temp_max: number,
                      temp_min: number
                    }
                  }
                </code></pre>
              </div>
              <div class="w-[75%] max-sm:w-[100%]">
                <pre data-line="0"><code class="language-ts">
                  //useWeather.ts
                  ...
                  // TYPE GUARD O ASSERTION
                  function isWeatherResponse(weather : unknown) : weather is Weather{
                    return(        
                      Boolean(weather) && //que weather exista, que le hayamos pasado algo
                      typeof weather === 'object' && //que sea un objeto
                      typeof (weather as Weather).name === 'string' && //accedemos a cada uno de los elementos revisando que el nombre sea un string, que las 3 temepraturas sean números
                      typeof (weather as Weather).main.temp === 'number' &&
                      typeof (weather as Weather).main.temp_min === 'number' &&
                      typeof (weather as Weather).main.temp_max === 'number' 
                    )
                  }
                  ...
                  //Type Guards
                  const{data: weatherResult} = await axios(weatherUrl)
                  const result = isWeatherResponse(weatherResult)
                  //console.log(result)
                  if(result){
                    console.log(weatherResult.name)
                  } else {
                    console.log('Respuesta mal formada')
                  }
                </code></pre>
              </div>
            </div>

            <p>El console.log(result) nos devuelve un true (porque se están cumpliendo todas esas condiciones) así que en vez de ese console.log ya le podemos poner un if para acceder a weatherResult. pero vemos que, con la notación del punto aún no tenemos autocompletado, tendríamos que completar la función tipándola así <code class="language-ts">function isWeatherResponse(weather : unknown) : weather is Weather{ ... }</code> y una vez que tenemos ese assertion que se cumple ya tenemos autocompletado.</p>

            <p>Estamos seguros así de que la respuesta que estamos obteniendo cumple con ese objeto. ¿Cual es el problema de este código? pues que obviamente no es un código mantenible. Si tenemos una respuesta muy grande vamos a tener funciones también muy grandes. Además si tenemos múltiples APIS=endpoints, tendremos que crear una función por cada endpoint, lo cual es difícilmente mantenible. No obstante garantiza que la respuesta que estamos obteniendo (recordemos es desconocida para typescript, unkown) cumpla con todas estas comprobaciones. Esta forma, a diferencia de la anterior donde lo casteábamos, comprueba la respuesta real, el JSON que estamos obteniendo. De esto tratan estos <strong>type guard o assertions</strong>: van a comprobar el objeto real y no solamente el type que hemos definido, o no solamente forzarlo como hicimos en el caso anterior cuando casteamos el type (que teníamos buen autocompletado, el código no tenía problemas, aunque era la peor forma de tipar una respuesta). Como vemos el problema que tienen los type guard o assertions es que no son mantenibles si teneos mas de 1 o 2 objetos.</p>

            <p>Por tanto ante una pregunta técnica de cómo comprobar una respuesta de una API sin usar librerías, usar un type guard = assertion, pero de forma profesional vamos a querer utilzar algo que simplifique esto porque es muy complicado de mantener.</p>

            <p>¿Qué opciones nos quedan? podríamos utilizar una librería como ZOD que nos va a permitir definir un esquema fácilmente y comprobar si el objeto cumple con esa condición</p>

      <p class="naranja">3. Tipar Resultados de una API: validar con ZOD</p>

            <p>Veamos una tercera opción para tipar las respuestas de nuestra API: instalamos la libreria ZOD <span class="destacado">npm i zod</span>. La importamos después de axios:</p>

            <pre data-line="0"><code class="language-ts">
              //useweather.ts
              import axios from "axios"
              import { z } from 'zod'
            </code></pre>            

            <p>Hemos definido nuestro type <span class="bg-[#4ec9b0] text-white">Weather</span> pero con Zod podemos definir un esquema e inferir el type que se generaría en base a ese esquema. Quitamos de nuestro custom hook la importación de nuestro type <span class="bg-[#4ec9b0] text-white">Weather</span> del cual copiamos su esquema, y teniendo este presente:</p>

            <pre><code class="language-ts">
              name:string
              main: {
                  temp: number,
                  temp_max: number,
                  temp_min: number
              }
            </code></pre>

            <p><strong>En Zod vamos a crear nuestro esquema con la forma que queremos que tenga nuestro type:</strong> creamos la constante WeatherSchema (aunque es con mayúscula no es un type) y le asignamos el objeto=función principal de la librería Zod que es una "z" y con la notación del punto vemos la gran cantidad de métodos que podemos acceder. En este caso como nuestra respuesta es un objeto usamos el método object, colocando paréntesis y después sintaxis de objeto ({}) <code class="language-ts">const WeatherSchema = z.object({...})</code>.</p>

            <p>ponemos name que es el nombre de la propiedad que queremos agregar a este type pero para especificarle string usamos "z.string" <code class="language-ts">name: z.string()</code>. Y así sucesivamente con todas las propiedades de nuestro esquema, en este caso el name y las 3 temperaturas dentro del objeto main. <code class="language-ts">main: z.object({...})</code></p>

            <p>A continuación creamos nuestro type de la siguiente manera: <code class="language-ts">type Weather = z.infer&lt;typeof WeatherSchema&gt;</code>. <strong>infer</strong> va a inferir en base a ese esquema el type, básicamente va a ser nuestro anterior type <span class="bg-[#4ec9b0] text-white">Weather</span> de index.ts, así que le ponemos typeof y le pasamos la variable que contiene esa información que va a ser la que acabamos de crear con el nombre 'WeatherSchema'. De hecho si nos colocamos encima del type Weather, el IS nos muestra la misma estructura que si nosotros lo hubiéramos hecho.</p>
           
            <pre data-line="0"><code class="language-ts">
              //useWeather.ts
              const WeatherSchema = z.object({
                name: z.string(),
                main: z.object({
                    temp: z.number(),
                    temp_max: z.number(),
                    temp_min: z.number()
                })
            })
            type Weather = z.infer&lt;typeof WeatherSchema&gt;
            </code></pre>           

            <p>No es solo eso lo que tiene Zod, también la parte que hemos visto anteriormente de escribir el Guard lo tiene incluido y lo hace muy sencillo:</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <p>hacemos el llamado hacia la API <code class="language-ts">const{data: weatherResult} = await axios(weatherUrl)</code></p>
                <p>creamos la variable result y utilizamos la variable que acabamos de crear 'WeatherSchema' y la aplicamos el método <strong>safeParse</strong> al que le pasamos como argumento el resultado de la consulta que tenemos en nuestra API 'weatherResult'; <code class="language-ts">const result = WeatherSchema.safeParse(weatherResult)</code> <strong>este método va a revisar: "¿estas propiedades que estoy obteniendo en el JSON corresponden al esquema que yo definí? si es así retorna un true</strong>; si no es así, si no tienen esa forma, si diseñamos mal nuestro objeto y es algo diferente a lo que obtiene nuestro objeto nos va a retornar un false. Básicamente ese safeParse es lo mismo que hacía la función isWeatherResponse del caso 2 anterior para tipar con Typeguard = Assertion pero de una forma muy sencilla gracias a Zod. </p>

                <pre data-line="0"><code class="language-ts">
                  //useWeather.ts
                  ...
                  //Zod
                  const{data: weatherResult} = await axios(weatherUrl)
                  const result = WeatherSchema.safeParse(weatherResult)
                  //console.log(result)
                  if(result.success){
                    console.log(result.data.name)
                    console.log(result.data.main.temp)
                  }
                </code></pre>
              </div>

              <div class="w-[50%] max-sm:w-[100%]">
                <p>Si hacemos un console.log(result) veremos en consola que aparece success: true y si lo expandimos además viene data y toda nuestra información con los datos, ya no nos quedamos con el JSON como respuesta, sino que nos extrae lo que hemos definido en nuestro esquema:</p>
                <img src="./src/assets/img/272.png" alt="img" loading="lazy">
              </div>
            </div>

            <p>podemos ver ya el autocompletado que tenemos:</p>

            <img src="./src/assets/img/272-2.png" alt="img" loading="lazy">

            <p>Si probamos esto ahora vemos que tenemos la ciudad y la temperatura. Lo estamos extrayendo desde este result y safeParse, no tanto desde weatherResult (el result, lo vemos con el IS, va a tener la información que nosotros le hemos definido en el esquema y por eso tenemos un buen autocompletado).</p>

            <p>Imaginemos que yo diseño mal ese objeto, digamos que no le pongo el 'main'. <strong>Yo pongo mi esquema de cierta forma pero ese esquema no corresponde con la respuesta JSON que estoy obteniendo, nos indica que la respuesta no está bien formada:</strong></p>

            <div class="flex max-sm:flex-col">
              <div class="w-[30%] max-sm:w-[100%]">
                <pre class="rojo" data-line="0,3-5"><code class="language-ts">
                  //useWeather.ts
                  ...
                  const WeatherSchema = z.object({
                    name: z.string(),
                    main: z.object({
                        temp: z.number(),
                        temp_max: z.number(),
                        temp_min: z.number()
                    })
                  })
                  type Weather = z.infer&lt;typeof WeatherSchema&gt;
                </code></pre>    
              </div>
              <div class="w-[30%] max-sm:w-[100%]">
                <pre class="rojo" data-line="0,8"><code class="language-ts">
                  //useWeather.ts
                  ...
                  //3. Zod
                  const{data: weatherResult} = await axios(weatherUrl)
                  const result = WeatherSchema.safeParse(weatherResult)
                  //console.log(result)
                  if(result.success){
                      console.log(result.data.name)
                      console.log(result.data.main.temp)
                  }else {
                      console.log('Respuesta mal formada...')
                  }
                </code></pre>
              </div>
              <div class="w-[40%] max-sm:w-[100%]">
                <img src="./src/assets/img/272-3.png" alt="img" loading="lazy">
              </div>
            </div>

            <p>Nuestro código de por sí no puede hacerlo pero si escribimos este tipo de funciones o usamos Zod vamos a poder verificar que las respuestas son correctas, comparando y revisando el type que hemos definido con el JSON obtenido como respuesta.</p>

            <p>¿Cual es la desventaja de Zod? que no es modular. Importamos una única función <strong>z</strong> y vamos agregando todo ahí mismo. Existe una opción que es modular y se llama Valibot</p>
            
      <p class="naranja">4. Tipar Resultados de una API: Validar con Valibot</p>
  
            <p>Es una alternativa a Zod y hace prácticamente lo mismo. Lo instalamos con <span class="destacado">npm i valibot</span></p>  
            <p>Importamos de manera individual lo que antes utilizábamos en nuestro esquema con Zod: object, string, number, lo cual lo hace modular y más ligero. Incluimos también <strong>InferOutput</strong>, que es una función que nos va a permitir inferir el tipo de dato y parse (para comprobar el JSON que obtenemos como respuesta): <code class="language-ts">import { object, string, number, InferOutput, parse } from 'valibot'</code></p>  

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="0"><code class="language-ts">
                  //useWeather.ts
                  import axios from "axios"
                  import { object, string, number, InferOutput, parse } from 'valibot'
                  ...
                  //Valibot
                  const WeatherSchema = object({
                    name: string(),
                    main: object({
                        temp: number(),
                        temp_max: number(),
                        temp_min: number()
                    })
                  })
                  type Weather = InferOutput&lt;typeof WeatherSchema&gt;
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                usamos la función <strong>parse</strong> de valibot para comprobar el JSON de respuesta. parse() requiere dos argumentos, nuestro schema <strong>weatherSchema</strong> y el resultado de nuestra consulta:  <strong>weatherResult</strong>. Ponemso un console.log(result)
                <pre data-line="0"><code class="language-ts">
                  //4. Valibot
                  const{data: weatherResult} = await axios(weatherUrl)
                  const result = parse(WeatherSchema, weatherResult)
                  //console.log(result)
                  if(result){
                    console.log(result.name)
                    console.log(result.main.temp)
                  }else {
                      console.log('Respuesta mal formada...')
                  }
                </code></pre>
              </div>
            </div>

            <p>Vemos la información en consola: extrae del JSON y genera un objeto nuevo en base a nuestro Schema:</p>

            <img src="./src/assets/img/273.png" alt="img" loading="lazy">

            <p>Al igual que antes, si nuestro schema está mal formado con respecto a lo que se obtiene en la respuesta, nos aparece en consola el error, aunque en este caso de Valivot cae en la parte del catch.</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[30%] max-sm:w-[100%]">
                <pre class="rojo" data-line="0,4,8"><code class="language-ts">
                  //useWeather.ts
                  ...
                  const WeatherSchema = object({
                    name: string(),
                    main: object({
                        temp: number(),
                        temp_max: number(),
                        temp_min: number()
                    })
                  })
                  type Weather = InferOutput&lt;typeof WeatherSchema&gt;
                </code></pre>    
              </div>
              <div class="w-[30%] max-sm:w-[100%]">
                <pre class="rojo" data-line="0,8"><code class="language-ts">
                  //useWeather.ts
                  ...
                  //4. Valibot
                  const{data: weatherResult} = await axios(weatherUrl)
                  const result = parse(WeatherSchema, weatherResult)
                  //console.log(result)
                  if(result){
                    console.log(result.name)
                    console.log(result.temp)
                  }else {
                      console.log('Respuesta mal formada...')
                  }
                </code></pre>
              </div>
              <div class="w-[40%] max-sm:w-[100%]">
                <img src="./src/assets/img/273-2.png" alt="img" loading="lazy">
              </div>
            </div>
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion16-274').toggle();">
            <h3>274. Colocando el Resultado de la API en el State</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion16-274" class="hidden">
            <p>Utilizamos Zod. Vamos a colocar el resultado en el state.:</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <p>Definimos nuestro nuevo state weather <span class="destacado">OJO! aquí es donde usamos nuestro type que infiere del Schema!!!! <code class="language-ts">const [weather, setWeather] = useState&lt;Weather&gt;({...})</code></span>y en la parte del código de Zod, como toda la info que requerimos está en ese data, seteamos nuestro state así: <code class="language-ts">if(result.success){setWeather(result.data)}</code>.</p>
                <pre data-line="0"><code class="language-ts">
                  //useWeather.ts
                  import axios from "axios"
                  import { z } from 'zod' 
                  //3. Zod
                  const WeatherSchema = z.object({
                      name: z.string(),
                      main: z.object({
                          temp: z.number(),
                          temp_max: z.number(),
                          temp_min: z.number()
                      })
                  })
                  export type Weather = z.infer&lt;typeof WeatherSchema&gt;
                  ...
                  const [weather, setWeather] = useState&lt;Weather&gt;({
                    name: '',
                    main: {
                      temp: 0,
                      temp_max: 0, 
                      temp_min: 0
                    }
                  })
                  ...
                  //3. Zod
                  const{data: weatherResult} = await axios(weatherUrl)
                  const result = WeatherSchema.safeParse(weatherResult)     
                  if(result.success){
                    //console.log(result)
                    //console.log(result.data.name)
                    setWeather(result.data)
                  }else {
                    console.log('Respuesta mal formada...')
                  }
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <p>Podemos ver en la pestaña components de RDT, en nuestra App.tsx nuestro state weather inicializado con los valores iniciales que hemos definido y en cuanto lanzamos una consulta vemos como, una vez que se valida el schema que hemos definido contra el JSON de la respuesta, se agrega en el state.</p>
                <img src="./src/assets/img/274.png" alt="img" loading="lazy">
                <p>Como queremos mostrar ya ese clima en su componente, lo exportamos:</p>
                <pre data-line="0,3"><code class="language-ts">
                  //useWeather.ts
                  ...
                  return {
                    weather,
                    fetchWeather
                }
                </code></pre>
              </div>
            </div>
              

              <div class="flex max-sm:flex-col mt-5">
                <div class="w-[50%] max-sm:w-[100%]">
                  <p>En nuestro compo ppal <span class="file">App.tsx</span> vamos a extraer ese weather en la destructuración que hacemos del custom hook y lo mostramos en la parte de la derecha de nuestra interfaz, donde teníamos ese <code class="language-ts">&lt;p&gt;2&lt;/p&gt;</code></p>
                  <pre data-line="0,2,6,16-18"><code class="language-ts">
                    //App.tsx
                    ...
                    import useWeather from "./hooks/useWeather"
                    import WeatherDetail from './components/WeatherDetail/WeatherDetail';
                    
                    function App() {            
                      const { fetchWeather, weather } = useWeather()                    
                      return (
                        &lt;&gt;
                          &lt;h1 className={styles.title}&gt;Buscador de clima&lt;/h1&gt;
                    
                          &lt;div className={styles.container}&gt;
                            &lt;Form
                              fetchWeather = {fetchWeather}
                            /&gt;
                            
                            &lt;WeatherDetail
                              weather = {weather}
                            /&gt;          
                          &lt;/div&gt;
                        &lt;/&gt;
                      )
                    }
                    
                    export default App
                  </code></pre>
                </div>

                <div class="w-[50%] max-sm:w-[100%]">
                  <p>Generamos un componente nuevo <span class="file">components/WeatherDetail/WeatherDetail.tsx</span> y su css <span class="file">components/WeatherDetail/WeatherDetai.module.css</span></p>

                  <p>En nuestro nuevo componente hemos de tipar esa prop <span class="destacado">ojo! usando no el type que teníamos en nuestro <span class="file">types/index.ts</span> sino el de nuestro custom hook que está sincronizado con lo que Zod nos da para lo cual desde nuestro custom hook hemos de exportarlo <code class="language-ts"> export type Weather = z.infer&lt;typeof WeatherSchema&gt;</code></span>. Así que en nuestro nuevo componente importamos el type que exportamos de nuestro custom hook:</p>
                  
                  <img src="./src/assets/img/274-2.png" alt="img" loading="lazy">

                  <pre data-line="0"><code class="language-ts">
                    //components/WeatherDetail/WeatherDetail.tsx
                    import { Weather } from "../../hooks/useWeather"
                    type WeatherDetailProps = {
                      weather: Weather // ojo! este no el que teníamos en nuestro types/index.ts sino el de 
                      // nuestro custom hook que está sincronizado con lo que Zod nos da para lo cual desde 
                      // nuestro custom hook hemos de exportarlo
                    }
                    export default function WeatherDetail({weather} : WeatherDetailProps) {
                      return (
                        &lt;div&gt;
                          WeatherDetail
                        &lt;/div&gt;
                      )
                    }
                  </code></pre>
                </div> 
              </div>

              <p>De momento este nuevo componente se muestra siempre. Metamos una comprobación para que no se muestre si por ejemplo el name del estado está vacío.</p>
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion16-275').toggle();">
            <h3>275. Mostrando los Resultados del Clima</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion16-275" class="hidden">

            <div class="flex max-sm:flex-col">
              <div class="w-[33%] max-sm:w-[100%]">
                <p>Vamos a nuestro custom hook <span class="file">hooks/useWeather.ts</span> y creemos una función nueva para revisar que nuestro estado tenga algo para, así, renderizar el componente WeatherDetail.tsx. Se puede hacer de varias formas, quizás lo más sencillo sea ver que name no tenga nada. Usamos useMemo() con la dependencia del state weather y exportamos la función.</p>

                <pre data-line="0,2,6"><code class="language-ts">
                  //hooks/useWeather.ts
                  ...
                  const hasWeatherData = useMemo(() => weather.name , [weather])
                  return {
                      weather,
                      fetchWeather,
                      hasWeatherData
                  }
                </code></pre>
              </div>
              <div class="w-[33%] max-sm:w-[100%]">
                <p>En nuestra <span class="file">App.tsx</span> extraemos esa función y la usamos para renderizar el componente si en name hay algo</p>
                <pre data-line="0,2,6-10"><code class="language-ts">
                  //App.tsx
                  ...
                  const { fetchWeather, weather, hasWeatherData } = useWeather()
                  return (
                    &lt;&gt;
                    ...        
                      {hasWeatherData &amp;&amp;
                        &lt;WeatherDetail
                          weather = {weather}
                        /&gt;
                      }
                </code></pre>
              </div>
              <div class="w-[33%] max-sm:w-[100%]">
                <p>En nuestro componente <span class="file">WeatherDetail.tsx</span> ya vamos renderizando los datos que queremos mostrar tras una consulta, <strong>teniendo ya el autocompletado resultado del trabajo previo que hemos hecho con nuestro schema y esa validación contra el JSON de respuesta usando Zod</strong>.</p>

                <pre data-line="0"><code class="language-ts">
                  //WeatherDetail.tsx
                  import { Weather } from "../../hooks/useWeather"
              
                  type WeatherDetailProps = {
                      weather: Weather 
                  }
                  
                  export default function WeatherDetail({weather} : WeatherDetailProps) {
                    return (
                      &lt;div&gt;
                        &lt;h2&gt;Clima de: {weather.name}&lt;/h2&gt;
                        &lt;p&gt;{weather.main.temp}&lt;/p&gt;
                      &lt;/div&gt;
                    )
                  }
                </code></pre>
              </div>
            </div> 

            <p>Vemos que la temperatura viene en grados Kelvin. Creemos una carpeta de helpers, esta vez la llamaremos <span class="file">utils/index.ts</span></p>

            <div class="flex max-sm:flex-col">        
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="0"><code class="language-ts">
                  //utils/index.ts
                  export const formatTemperature = (temperature: number) : number =>{
                    const Kelvin = 273.15
                    return parseInt((temperature - Kelvin).toString())
                }
                </code></pre>
                <img src="./src/assets/img/276.png" alt="img" loading="lazy">
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="0,2,11"><code class="language-ts">
                  //WeatherDetail.tsx
                  import { Weather } from "../../hooks/useWeather"
                  import { formatTemperature } from "../../utils"
                  
                  type WeatherDetailProps = {
                      weather: Weather 
                  }        
                  export default function WeatherDetail({weather} : WeatherDetailProps) {
                    return (
                      &lt;div&gt;
                        &lt;h2&gt;Clima de: {weather.name}&lt;/h2&gt;
                        &lt;p&gt;{formatTemperature(weather.main.temp)}&deg;C&lt;/p&gt;
                        &lt;div&gt;
                          &lt;p&gt;Min: &lt;span&gt;{formatTemperature(weather.main.temp_min)}&amp;deg;C&lt;/span&gt;&lt;/p&gt;
                          &lt;p&gt;Max: &lt;span&gt;{formatTemperature(weather.main.temp_max)}&amp;deg;C&lt;/span&gt;&lt;/p&gt;
                        &lt;/div&gt;
                      &lt;/div&gt;
                    )
                  }
                </code></pre>
              </div>
            </div>

            <p class="naranja">Finalizando el Componente de Clima</p>

            <p>Escribamos un poco de css para el componente. En <span class="file">WeatherDetail.tsx</span> importamos la hoja de estilos <code class="language-ts">import styles from './WeatherDetail.module.css'</code></p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="0,3,11,13,14"><code class="language-ts">
                  //WeatherDetail.tsx
                  import { Weather } from "../../hooks/useWeather"
                  import { formatTemperature } from "../../utils"
                  import styles from './WeatherDetail.module.css'
                  
                  type WeatherDetailProps = {
                    weather: Weather 
                  }
                  
                  export default function WeatherDetail({weather} : WeatherDetailProps) {
                    return (
                      &lt;div className={styles.container}&gt;
                        &lt;h2&gt;Clima de: {weather.name}&lt;/h2&gt;
                        &lt;p className={styles.current}&gt; {formatTemperature(weather.main.temp)}&amp;deg;C&lt;/p&gt;
                        &lt;div className={styles.temperatures}&gt;
                          &lt;p&gt;Min: &lt;span&gt;{formatTemperature(weather.main.temp_min)}&amp;deg;C&lt;/span&gt;&lt;/p&gt;
                          &lt;p&gt;Max: &lt;span&gt;{formatTemperature(weather.main.temp_max)}&amp;deg;C&lt;/span&gt;&lt;/p&gt;
                        &lt;/div&gt;
                      &lt;/div&gt;
                    )
                  }
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="0"><code class="language-ts">
                  //WeatherDetail.module.css
                  .container{
                    background-color: var(--white);
                    color: #000000;
                    border-radius: 1rem;
                    text-align: center;
                    padding: 1rem;
                  }
                  .current{
                    font-size: 6rem;
                    font-weight: 900;
                    margin: 0;
                  }
                  .temperatures{
                    display: flex;
                    justify-content: center;
                    gap: 5rem;
                  } 
                  .temperatures p{
                    font-weight:900;
                  }
                  .temperatures span{
                    font-weight:400;
                  }
                </code></pre>
              </div> 
            </div>
            <img src="./src/assets/img/276-2.png" alt="img" loading="lazy"> 
          </div>


          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion16-277').toggle();">
            <h3>277. Agregando un Spinner de Carga <a href="https://tobiasahlin.com/spinkit/" class="underline text-white" target="blank">https://tobiasahlin.com/spinkit/</a> / 278. Reiniciar el Estado después de cada consulta</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion16-277" class="hidden">
            <p>Como tarda un poco en renderizar la información desde que enviamos, veamos como mostrar un spinner de carga. Es algo muy común cuando trabajas con APIs:</p>
            <ul class="list-disc my-3">
              <li class="my-1.25">En nuestro custom hook, bajo nuestro state weather, creamos una nueva variable: <code class="language-ts">const [loading, setLoading] = useState(false)</code> ¿Cual va a ser su lógica? Inicia como false. Cuando el usuario pulsa el botón "consultar clima" cambia a true en lo que obtiene los datos</li>
              <li class="my-1.25">Antes del try seteamos loading a true <code class="language-ts">setLoading(true)</code></li>
              <li class="my-1.25">¿Cuando lo seteamos a false de nuevo? 
                
                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <p>Podríamos hacerlo justo aquí pero solo se ejecutaría cuando la llamada es correcta (de hecho a continuación veremos como trabajar cuando no se encuentra la ciudad en el país que el usuario está buscando, por tanto en ese caso se quedaría en true todo el tiempo):</p>
                    <pre data-line="0,5,10"><code class="language-ts">
                      //useWeather.ts
                      const [loading, setLoading] = useState(false)

                      const fetchWeather = async (search: SearchType) => {
                        const appId = import.meta.env.VITE_API_KEY
                        setLoading(true)
                        try {
                          ...
                          if(result.success){
                            setWeather(result.data)
                            setLoading(false)
                          }else {
                              console.log('Respuesta mal formada...')
                          }
                        } catch (error) {
                          console.log(error)
                        }
                      }
                    </code></pre>
                  </div>
                  <div class="w-[50%] max-sm:w-[100%]">
                    <p>pero gracias al try / catch tenemos acceso a algo llamado <span class="destacado">finally{}</span> ¿qué  hace? pues independientemente de que se ejcute el código del try o el código del catch{} el código del finally{} siempre se ejecuta y es un buen lugar para regresar un loader o un spinner a su estado inicial.</p>
                    <pre data-line="0,5,15-17"><code class="language-ts">
                      //useWeather.ts
                      const [loading, setLoading] = useState(false)

                      const fetchWeather = async (search: SearchType) => {
                        const appId = import.meta.env.VITE_API_KEY
                        setLoading(true)
                        try {
                          ...
                          if(result.success){
                            setWeather(result.data)
                          }else {
                              console.log('Respuesta mal formada...')
                          }
                        } catch (error) {
                          console.log(error)
                        } finally {
                            setLoading(false)
                        }
                      }  
                    </code></pre>
                  </div>
                </div> 
              </li>
              <li class="my-1.25">No nos olvidemos de exportarlo desde nuestro custom hook en su return:

                <pre data-line="0,3"><code class="language-ts">
                  //useWeather.ts
                  return {
                    weather,
                    loading,
                    fetchWeather,
                    hasWeatherData
                }
                </code></pre></li>
              <li class="my-1.25">En nuestro <span class="file">App.tsx</span> lo extraemos e imprimimos un párrafo en caso de que loading sea true que diga "cargando...". 
                <pre data-line="0,2,10"><code class="language-ts">
                  //App.tsx
                  function App() {  
                    const { fetchWeather, weather, loading, hasWeatherData } = useWeather()        
                    return (
                      &lt;&gt;
                        &lt;h1 className={styles.title}&gt;Buscador de clima&lt;/h1&gt;        
                        &lt;div className={styles.container}&gt;
                          &lt;Form
                            fetchWeather = {fetchWeather}
                          /&gt;                
                          {loading &amp;&amp; &lt;p&gt;Cargando...&lt;/p&gt;}
                          {hasWeatherData &amp;&amp;
                            &lt;WeatherDetail
                              weather = {weather}
                            /&gt;
                          }
                </code></pre>
                
                Si lo probamos vemos como en cuanto le damos al botón para consultar:
                <img src="./src/assets/img/277.png" alt="img" loading="lazy">      
              </li>
              <li class="my-1.25">Creamos componente nuevo con uno de los spinner que cogemos de aquí: <a href="https://tobiasahlin.com/spinkit/" class="underline" target="blank">https://tobiasahlin.com/spinkit/</a> y ojo! que como estamos utilizando css modules, vemos que si creamos un Spinner.module.css, recordemos que por las mejoras de nombre que introducen los modules, no va a coincidir con los nombres de clase definidos en la css (y no vamos a ver que aparezca el spinner, como si no tuviera clases ¡vamos!), por lo que en estos casos es mejor crear <span class="file">Spinner.css</span> e importarlo así en nuestro compo <span class="file">Spinner.tsx</span>: <code class="language-ts">import './Spinner.css'</code>

                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre data-line="0"><code class="language-ts">
                      //Spinner.css
                      .spinner {
                        margin: 100px auto 0;
                        width: 70px;
                        text-align: center;
                      }
                      .spinner>div {
                          width: 18px;
                          height: 18px;
                          background-color: #fff;
                          border-radius: 100%;
                          display: inline-block;
                          -webkit-animation: sk-bouncedelay 1.4s infinite ease-in-out both;
                          animation: sk-bouncedelay 1.4s infinite ease-in-out both;
                      }
                      .spinner .bounce1 {
                          -webkit-animation-delay: -0.32s;
                          animation-delay: -0.32s;
                      }
                      .spinner .bounce2 {
                          -webkit-animation-delay: -0.16s;
                          animation-delay: -0.16s;
                      }
                      @-webkit-keyframes sk-bouncedelay {
                          0%,
                          80%,
                          100% {
                              -webkit-transform: scale(0)
                          }
                          40% {
                              -webkit-transform: scale(1.0)
                          }
                      }
                      @keyframes sk-bouncedelay {
                          0%,
                          80%,
                          100% {
                              -webkit-transform: scale(0);
                              transform: scale(0);
                          }
                          40% {
                              -webkit-transform: scale(1.0);
                              transform: scale(1.0);
                          }
                      }
                    </code></pre>
                  </div>
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre data-line="0"><code class="language-ts">
                      //Spinner.tsx
                      import './Spinner.css'
                      export default function Spinner() {
                          return (
                            &lt;div className=&quot;spinner&quot;&gt;
                              &lt;div className=&quot;bounce1&quot;&gt;&lt;/div&gt;
                              &lt;div className=&quot;bounce2&quot;&gt;&lt;/div&gt;
                              &lt;div className=&quot;bounce3&quot;&gt;&lt;/div&gt;
                            &lt;/div&gt;
                          )
                      }
                    </code></pre>

                    <pre data-line="0,2,10"><code class="language-ts">
                      //App.tsx
                      function App() {  
                        const { fetchWeather, weather, loading, hasWeatherData } = useWeather()        
                        return (
                          &lt;&gt;
                            &lt;h1 className={styles.title}&gt;Buscador de clima&lt;/h1&gt;        
                            &lt;div className={styles.container}&gt;
                              &lt;Form
                                fetchWeather = {fetchWeather}
                              /&gt;                
                              {loading &amp;&amp; &lt;Spinner /&gt;}
                              {hasWeatherData &amp;&amp;
                                &lt;WeatherDetail
                                  weather = {weather}
                                /&gt;
                              }
                    </code></pre>
                  </div>
                </div>    
              </li>
            </ul>

            <p class="naranja">Reiniciar el Estado después de cada consulta</p>

            <p>Si con un clima consultado vuelvo a darle hace un salto extraño. Tenemos esta función que se encarga de revisar si hay algo en el state de weather. Si hay algo en futuras búsquedas estamos cambiando loading a true y eso hace que se muestren ambos componentes y por eso tenemos ese "salto raro"</p>
            <pre><code class="language-ts">
              //App.tsx
              {hasWeatherData &&
                &lt;WeatherDetail
                  weather = {weather}
                /&gt;
              }
            </code></pre>
            <p>Lo solucionamos regresando el state a su estado inicial para que, en nuestra función que comprueba si hay algo esa condición ya no se cumpla y se "desmonte" ese componente. Para ello creamos una nueva variable que llamaremos "initialState" en la que pegamos el código del state inicial de weather:</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre class="rojo" data-line="0,3-10"><code class="language-ts">
                  //useWeather.ts
                  export default function useWeather(){

                    const [weather, setWeather] = useState&lt;Weather&gt;({
                        name: '',
                        main: {
                          temp: 0,
                          temp_max: 0, 
                          temp_min: 0
                        }
                    })      
                    const [loading, setLoading] = useState(false)      
                    const fetchWeather = async (search: SearchType) => {
                        const appId = import.meta.env.VITE_API_KEY
                        setLoading(true)
                        try {...
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre class="verde" data-line="0-8,11,16"><code class="language-ts">
                  //useWeather.ts
                  const initialState = {
                    name: '',
                    main: {
                      temp: 0,
                      temp_max: 0, 
                      temp_min: 0
                    }
                  }
                
                  export default function useWeather(){        
                      const [weather, setWeather] = useState&lt;Weather&gt;(initialState)        
                      const [loading, setLoading] = useState(false)        
                      const fetchWeather = async (search: SearchType) => {
                          const appId = import.meta.env.VITE_API_KEY
                          setLoading(true)
                          setWeather(initialState)
                          try {...
                </code></pre>
              </div>
            </div>
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion16-278').toggle();">
            <h3>279. Trabajar con ciudades que no existen</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion16-278" class="hidden">
            <p>Veamos como mostrar un mensaje personalizado cuando intentemos buscar una ciudad que no se encuentra. Si intentamos buscar una ciudad que no existe vemos que nos sale este error "estoy tratando de leer latitud y longitud pero no puedo encontrar esos valores". Como vemos, no es que esto esté cayendo en el catch, la API debería tener ese diseño, si no se encuentra entonces lanzar un error para que caiga en el catch <span class="destacado">eso veremos como hacerlo más adelante nosotros cuando estemos diseñando nuestras propias REST API en node</span></p>

            <img src="./src/assets/img/279.png" alt="img" loading="lazy">  

            <p>El error está aquí, está tratando de leer la latitud. Por la forma en que funciona JS detecta un error y ya no ejecuta la siguiente línea, por lo tanto el siguiente "lon" tampoco se ejecuta:</p>
            <pre data-line="0,6"><code class="language-ts">
              //useWeather.ts
              ...
              try {
                const geoUrl = `https://api.openweathermap.org/geo/1.0/direct?q=${search.city},${search.country}&appid=${appId}`        
                const {data} = await axios.get(geoUrl)
                //console.log(data)    
                const lat= data[0].lat
                const lon= data[0].lon
            </code></pre>

            <p>si le pusiéramos un console.log(data), veríamos en consola que una ciudad que no existe la marca como un arreglo vacío {} (y es por eso que no se va hacia el catch, porque ellos están retornando un arreglo vacío). Como en nuestras variables lat y lon tenemos posicion [0] podemos probar a hacer <strong>console.log(data)[0] y nos marca undefined</strong>, por tanto podemos hacer lo siguiente: comprobamos si data[0] no existe y lanzamos un console log con 'Clima no encontrado' y <span class="destacado">muy importante, un return para que se pare la ejecución</span></p>

            <pre data-line="0,6-10"><code class="language-ts">
              //useWeather.ts
              ...
              try {
                const geoUrl = `https://api.openweathermap.org/geo/1.0/direct?q=${search.city},${search.country}&appid=${appId}`  
                const {data} = await axios.get(geoUrl)
                //console.log(data)
                //Comprobar si existe
                if(!data[0]){
                  console.log('Clima no encontrado')
                  return
                }      
                const lat= data[0].lat
                const lon= data[0].lon
            </code></pre>



              <p>En vez de en consola mostrémoslo en la pantalla:</p>
              
              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <p>Creamos una nueva variable state que llamamos 'notFound' <code class="language-ts">const [notFound, setNotFound] = useState(false)</code>. La seteamos a true cuando se cumpla la condición de que no existe data[0] y la exportamos en el return de nuestro custom hook:</p>
                  <pre data-line="0,2,6-10,15"><code class="language-ts">
                    //useWeather.ts
                    ...
                    const [notFound, setNotFound] = useState(false)
                    ...
                    try {
                      ...
                      //Comprobar si existe
                      if(!data[0]){
                        setNotFound(true)
                        return
                      }      
                      ...
                      return {
                        weather,
                        loading,
                        notFound,
                        fetchWeather,
                        hasWeatherData
                      } 
                  </code></pre>
              
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <p>En <span class="file">App.tsx</span> extraemos ese objeto y le decimos 1ue si tiene algo muestre lo siguiente (utilizamos el componente de Alerta que creábamos que tomaba un children, pudiendo ser una variable, un componente o en este caso un texto):</p>
                  <pre data-line="0,14"><code class="language-ts">
                    //App.tsx
                    function App() {  
                      const { weather, loading, notFound, fetchWeather, hasWeatherData } = useWeather()          
                      //console.log(import.meta.env)          
                      return (
                        &lt;&gt;
                          &lt;h1 className={styles.title}&gt;Buscador de clima&lt;/h1&gt;          
                          &lt;div className={styles.container}&gt;
                            &lt;Form
                              fetchWeather = {fetchWeather}
                            /&gt;
                            
                            {loading &amp;&amp; &lt;Spinner /&gt;}
                            {hasWeatherData &amp;&amp; &lt;WeatherDetail weather = {weather}/&gt;}
                            {notFound &amp;&amp; &lt;Alert&gt;Ciudad No encontrada&lt;/Alert&gt;}
                            
                          &lt;/div&gt;
                        &lt;/&gt;
                      )
                    }
                  </code></pre>
                </div>
              </div>
              
              
              <p>De esta forma queda listo este proyecto, ya un poco más complejo que consume una REST API, y lo hace de una forma segura, asegurándonos que la respuesta que obtenemos como JSON coincida con los types que hemos recibido</p>

              <p>De aquí en adelante todos los poryectos ya incluyen esta funcionalidad desde una APi o desde una BBDD.</p>

          </div>


          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion16-280').toggle();">
            <h3>280. Deployment del PROYECTO con API Key</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion16-280" class="hidden">
            <p>Veamos como realizar el Deployment de un proyecto qeu incluye un API KEY. tenemos que agregar el Api Key una vez que subamos nuestro proyecto, porqeu recordemos, el archivo donde está la api key (variable de entorno) es ignorado en GIT y tampoco forma parte del build que realizamos.</p>

            <ul class="list-disc my-3">
              <li class="my-1.25">Construimos <span class="destacado">npm run build</span> y la carpeta dist la agregamos a Netlify. Si abrimos el sitio y abrimos el deploy de producción. Vemos que si intentamos hacer una búsqueda nos aparece un error, y eso es porque no tenemos agregado nuestro API KEY
              <img src="./src/assets/img/280.png" alt="img" loading="lazy">
              </li>
              <li class="my-1.25">Vamos a Site configuration <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
              </svg></li>
              Environment variables
              <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
              </svg>
              Add a variable y podemos elegir una o un archivo, en nuestro caso solo tenemos una, elegimos esa opción y la llamamos con el mismo nombre que tenemos en nuestro <span class="file">.env.local</span> y en el value el que tenemos en ese fichero y le damos a "Create variable". 
              <img src="./src/assets/img/280-2.png" alt="img" loading="lazy">
              (en este punto vemos que teníamos un error en la variable <code class="language-ts">const geoUrl = `https://api.openweathermap.org/geo/1.0/direct?q=${search.city},${search.country}&appid=${appId}`</code> que la teníamos con http en vez de con https. Lo cambiamos, hacemos nuevo deploy y ne ntelify en deplys, abajo podemos arrastrar nuestra carpea dist, no es necesrio que creemos un site nuevo, y la variable de entorno se nos va a mantener.)


              <li class="my-1.25">Si probamos de nuevo el deploy de producción vemos que ya funciona!</li>
            </ul>

            <p><span class="destacado">Siempre que tengamos variables de entorno nos tenemos que asegurar de agregarlas en nuestro proyecto (en el lugar indicado del panel del hosting) una vez que hagamos el deployment porque estas variables son ignoradas una vez que subimos el proyecto</span> pero la mayor parte de opciones modernas de hosting siempre nos van a ofrecer un panel en el que podremos agregar las variables de entorno. Y si por algo cambia digamos la conexión a la BBDD o el servidor SMTP tienes que colocar ya en producción la conexión a la BBDD de producción o el SMTP de producción, etc y localmente mantener las credenciales de los valores del entorno de desarrollo.</p>
          </div>
            

        </div>
        <!-- Fin div colapsable-->

      </div>
      <!-- FIN SECCION 16 -->


      <!-- SECCION PROYECTO PROPIO TUDÚS -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-emerald-200 my-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">

        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between" onclick="$('#secciontudus').toggle();">
          <h2>PROYECTO FOS TUDÚS</h2>
          <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
        </div>

        <div id="secciontudus" class="hidden">

          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro2" onclick="$('#secciontudus-ficheros').toggle();">
            <h3>FICHEROS FINALES</h3>
            <span class="cambiaicono ico_chevron_up_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="secciontudus-ficheros" class="bg-white">
            <div class="flex max-sm:flex-col">
              <div class="w-[25%] max-sm:w-[100%]">
                <span class="destacado">types/index.ts, App.tsx, index.css, main.tsx, store.ts</span><br>

                <code class="cursor-pointer" onclick="$('#XX-types').toggle();">types/index.ts</code>
                <pre data-line="0" id="XX-types" class="hidden"><code class="language-ts">
                  //types/index.ts

                </code></pre>

                <code class="cursor-pointer" onclick="$('#XX-app').toggle();">App.tsx</code>
                <pre data-line="0" id="XX-app" class="hidden"><code class="language-ts">
                  //App.tsx

                </code></pre>

                <code class="cursor-pointer" onclick="$('#XX-indexcss').toggle();">index.css</code>
                <pre data-line="0" id="XX-indexcss" class="hidden"><code class="language-css">
                  //index.css

                </code></pre>

                <code class="cursor-pointer" onclick="$('#XX-maintsx').toggle();">main.tsx</code>
                <pre data-line="0" id="XX-maintsx" class="hidden"><code class="language-js">
                  //main.tsx

                </code></pre>

                <code class="cursor-pointer" onclick="$('#XX-store').toggle();">store.ts</code>
                <pre data-line="0" id="XX-store" class="hidden"><code class="language-ts">
                  //store.ts

                </code></pre>
              </div>

              <div class="w-[25%] max-sm:w-[100%]">
                <span class="destacado">data, helpers, hooks, reducer, types</span><br>

                <code class="cursor-pointer" onclick="$('#XX-data').toggle();">data/XXXXX.ts</code>
                <pre data-line="0" id="XX-data" class="hidden"><code class="language-ts">
                  //data/XXXXX.ts

                </code></pre>

                <code class="cursor-pointer" onclick="$('#XX-helpers').toggle();">helpers/index.ts</code>
                <pre data-line="0" id="XX-helpers" class="hidden"><code class="language-ts">
                  //helpers/index.ts

                </code></pre>

                <code class="cursor-pointer" onclick="$('#XX-customhook').toggle();">hooks/XXXXX.ts</code>
                <pre data-line="0" id="XX-customhook" class="hidden"><code class="language-ts">
                  //hooks/XXXXX.ts

                </code></pre>

                <code class="cursor-pointer" onclick="$('#XX-XXXXX-reducer').toggle();">reducer/XXXXX-reducer.ts</code>
                <pre data-line="0" id="XX-XXXXX-reducer" class="hidden"><code class="language-ts">
                  //reducer/XXXXX-reducer.ts

                </code></pre>
              </div>

              <div class="w-[50%] max-sm:w-[100%]">
                <span class="destacado">Componentes</span><br>
                <code class="cursor-pointer" onclick="$('#XX-XXXXXXXXXX').toggle();">XXXXXXXXXX.tsx</code>
                <pre data-line="0" id="XX-XXXXXXXXXX" class="hidden"><code class="language-ts">
                  // XXXXXXXXXX.tsx

                </code></pre>
              </div>
            </div>

          </div>

        </div>
        <!-- Fin div colapsable-->

      </div>
      <!-- FIN SECCION PROYECTO PROPIO TUDÚS -->


      <!-- SECCION MIGRADO CONTROL GASTOS FOS A ZUSTAND -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-emerald-200 my-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">

        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between" onclick="$('#seccionFOSgastos').toggle();">
          <h2>MIGRADO CONTROL GASTOS FOS A ZUSTAND</h2>
          <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
        </div>

        <div id="seccionFOSgastos" class="hidden">

            <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro2" onclick="$('#seccionFOSgastos-ficheros').toggle();">
            <h3>FICHEROS FINALES</h3>
            <span class="cambiaicono ico_chevron_up_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccionFOSgastos-ficheros" class="bg-white">
            <div class="flex max-sm:flex-col">
              <div class="w-[25%] max-sm:w-[100%]">
                <span class="destacado">types/index.ts, App.tsx, index.css, main.tsx, store.ts</span><br>

                <code class="cursor-pointer" onclick="$('#XX-types').toggle();">types/index.ts</code>
                <pre data-line="0" id="XX-types" class="hidden"><code class="language-ts">
                  //types/index.ts

                </code></pre>

                <code class="cursor-pointer" onclick="$('#XX-app').toggle();">App.tsx</code>
                <pre data-line="0" id="XX-app" class="hidden"><code class="language-ts">
                  //App.tsx

                </code></pre>

                <code class="cursor-pointer" onclick="$('#XX-indexcss').toggle();">index.css</code>
                <pre data-line="0" id="XX-indexcss" class="hidden"><code class="language-css">
                  //index.css

                </code></pre>

                <code class="cursor-pointer" onclick="$('#XX-maintsx').toggle();">main.tsx</code>
                <pre data-line="0" id="XX-maintsx" class="hidden"><code class="language-js">
                  //main.tsx

                </code></pre>

                <code class="cursor-pointer" onclick="$('#XX-store').toggle();">store.ts</code>
                <pre data-line="0" id="XX-store" class="hidden"><code class="language-ts">
                  //store.ts

                </code></pre>
              </div>

              <div class="w-[25%] max-sm:w-[100%]">
                <span class="destacado">data, helpers, hooks, reducer, types</span><br>

                <code class="cursor-pointer" onclick="$('#XX-data').toggle();">data/XXXXX.ts</code>
                <pre data-line="0" id="XX-data" class="hidden"><code class="language-ts">
                  //data/XXXXX.ts

                </code></pre>

                <code class="cursor-pointer" onclick="$('#XX-helpers').toggle();">helpers/index.ts</code>
                <pre data-line="0" id="XX-helpers" class="hidden"><code class="language-ts">
                  //helpers/index.ts

                </code></pre>

                <code class="cursor-pointer" onclick="$('#XX-customhook').toggle();">hooks/XXXXX.ts</code>
                <pre data-line="0" id="XX-customhook" class="hidden"><code class="language-ts">
                  //hooks/XXXXX.ts

                </code></pre>

                <code class="cursor-pointer" onclick="$('#XX-XXXXX-reducer').toggle();">reducer/XXXXX-reducer.ts</code>
                <pre data-line="0" id="XX-XXXXX-reducer" class="hidden"><code class="language-ts">
                  //reducer/XXXXX-reducer.ts

                </code></pre>
              </div>

              <div class="w-[50%] max-sm:w-[100%]">
                <span class="destacado">Componentes</span><br>
                <code class="cursor-pointer" onclick="$('#XX-XXXXXXXXXX').toggle();">XXXXXXXXXX.tsx</code>
                <pre data-line="0" id="XX-XXXXXXXXXX" class="hidden"><code class="language-ts">
                  // XXXXXXXXXX.tsx

                </code></pre>
              </div>
            </div>

          </div>

        </div>
        <!-- Fin div colapsable-->

      </div>
      <!-- FIN SECCION SECCION MIGRADO CONTROL GASTOS FOS A ZUSTAND -->



      <!-- SECCION 15 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 my-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">

        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between" onclick="$('#seccion15').toggle();">
          <h2>Sección 15: PROYECTO - Administrador de Pacientes con Zustand y React Hook Form</h2>
          <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
        </div>

        <div id="seccion15" class="hidden">

          <p>Introduce herramientas nuevas:</p>	

          <ul class="list-disc my-2.5">
            <li><span class="destacado">React Hook Form - npm i react-hook-form</span> - <a class="underline" href="https://react-hook-form.com/" target="_blank">https://react-hook-form.com/</a> - es una librería para para la parte de validación y procesamiento de nuestros formularios de manera bastante sencilla.</li>
            <li><span class="destacado">Zustand - npm i zustand</span> - <a class="underline" href="https://www.npmjs.com/package/zustand" target="_blank">https://www.npmjs.com/package/zustand</a> - <a class="underline" href="https://github.com/pmndrs/zustand" target="_blank"> github zustand</a> - administrador para manejar un estado global de forma muy simple</li>
            <li><span class="destacado">npm i uuid</span> - <a class="underline" href="https://www.npmjs.com/package/uuid" target="_blank">https://www.npmjs.com/package/uuid</a> - uuid es una dependencia para generar id</li>
            <li><span class="destacado">React-Toastify</span> para notificaciones <a href="https://www.npmjs.com/package/react-toastify" target="_blank" class="underline">https://www.npmjs.com/package/react-toastify</a></li>
          </ul>      
          
          
           <!-- Bloque desplegable interior-->
           <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion15-ficheros').toggle();">
            <h3>FICHEROS FINALES</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion15-ficheros" class="hidden">                                
            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <span class="destacado">types/index.ts, App.tsx, index.css, main.tsx, store.ts</span><br>

                <code class="cursor-pointer" onclick="$('#15-types').toggle();">types/index.ts</code>
                <pre data-line="0" id="15-types" class="hidden"><code class="language-ts">
                  //types/index.ts
                  export type Patient = {
                    id: string
                    name: string
                    caretaker: string
                    email: string
                    date: Date
                    symptoms: string
                  }
                
                  export type DraftPatient = Omit&lt;Patient, &#39;id&#39;&gt;                  
                </code></pre>

                <code class="cursor-pointer" onclick="$('#15-app').toggle();">App.tsx</code>
                <pre data-line="0" id="15-app" class="hidden"><code class="language-ts">                  
                  //App.tsx
                  import { ToastContainer } from 'react-toastify'
                  import PatientForm from "./components/PatientForm"
                  import PatientsList from "./components/PatientsList"
                  import "react-toastify/dist/ReactToastify.css"
                  
                  function App() {
                  
                    return (
                      &lt;&gt;
                        &lt;div className=&quot;container mx-auto mt-20&quot;&gt;
                            &lt;h1 className=&quot;font-black text-5xl text-center md:w-2/3 md:mx-auto&quot;&gt;
                              Seguimiento de Pacientes {&#39;&#39;}
                              &lt;span className=&quot;text-indigo-700&quot;&gt;Veterinaria&lt;/span&gt;
                            &lt;/h1&gt;
                  
                            &lt;div className=&quot;mt-12 md:flex&quot;&gt;
                                &lt;PatientForm /&gt;
                                &lt;PatientsList /&gt;
                            &lt;/div&gt;
                        &lt;/div&gt;
                  
                        &lt;ToastContainer /&gt;
                      &lt;/&gt;
                    )
                  }
                  
                  export default App                  
                </code></pre>
      
                <code class="cursor-pointer" onclick="$('#15-indexcss').toggle();">index.css</code>
                <pre data-line="0" id="15-indexcss" class="hidden"><code class="language-css">
                  //index.css
                  @import "tailwindcss";                  
                </code></pre>
      
                <code class="cursor-pointer" onclick="$('#15-maintsx').toggle();">main.tsx</code>
                <pre data-line="0" id="15-maintsx" class="hidden"><code class="language-js">
                  //main.tsx
                  import React from 'react'
                  import ReactDOM from 'react-dom/client'
                  import App from './App.tsx'
                  import './index.css'
                  
                  ReactDOM.createRoot(document.getElementById('root')!).render(
                    &lt;React.StrictMode&gt;
                      &lt;App /&gt;
                    &lt;/React.StrictMode&gt;,
                  )                     
                </code></pre> 

                <code class="cursor-pointer" onclick="$('#15-store').toggle();">store.ts</code>
                <pre data-line="0" id="15-store" class="hidden"><code class="language-ts">
                  //store.ts
                  import { create } from 'zustand'
                  import { devtools, persist } from 'zustand/middleware'
                  import { v4 as uuidv4 } from 'uuid'
                  import { DraftPatient, Patient } from './types'
                  
                  type PatientState = {
                      patients: Patient[]
                      activeId: Patient['id']
                      addPatient: (data: DraftPatient) => void
                      deletePatient: (id: Patient['id']) => void
                      getPatientById: (id: Patient['id']) => void
                      updatePatient: (data: DraftPatient) => void
                  }
                  
                  const createPatient = (patient: DraftPatient) : Patient => {
                      return { ...patient, id: uuidv4() }
                  }
                  
                  export const usePatientStore = create&lt;PatientState&gt;()(
                      devtools(
                      persist( (set) => ({
                          patients: [],
                          activeId: '',
                          addPatient: (data) => {
                              const newPatient = createPatient(data)
                              set((state) => ({
                                  patients: [...state.patients, newPatient]
                              }))
                          },
                          deletePatient: (id) => {
                              set((state) => ({
                                  patients: state.patients.filter( patient => patient.id !== id )
                              }))
                          },
                          getPatientById: (id) => {
                              set(() => ({
                                  activeId: id
                              }))
                          },
                          updatePatient: (data) => {
                              set((state) => ({
                                  patients: state.patients.map( patient => patient.id === state.activeId ? {id: state.activeId, ...data } : patient),
                                  activeId: ''
                              }))
                          }
                      }), {
                          name: 'patient-storage'
                          // storage: createJSONStorage (() => sessionStorage)
                      })
                  ))                   
                </code></pre>
              </div>
              
              <div class="w-[50%] max-sm:w-[100%]">
                <span class="destacado">Componentes</span><br>
                <code class="cursor-pointer" onclick="$('#15-Error').toggle();">Error.tsx</code>
                <pre data-line="0" id="15-Error" class="hidden"><code class="language-ts">
                  // Error.tsx  
                  export default function Error({children} : {children: React.ReactNode}) {
                    return (
                      &lt;p className=&quot;text-center my-4 bg-red-600 text-white font-bold p-3 uppercase text-sm&quot;&gt;
                          {children}
                      &lt;/p&gt;
                    )
                  }                                    
                </code></pre>

                <code class="cursor-pointer" onclick="$('#15-PatientDetailItem').toggle();">PatientDetailItem.tsx</code>
                <pre data-line="0" id="15-PatientDetailItem" class="hidden"><code class="language-ts">
                  // PatientDetailItem.tsx  
                  type PatientDetailItemProps = {
                    label: string
                    data: string
                  }
                  export default function PatientDetailItem({label, data} : PatientDetailItemProps) {
                    return (
                      &lt;p className=&quot;font-bold mb-3 text-gray-700 uppercase&quot;&gt;{label}: {&#39;&#39;}
                          &lt;span className=&quot;font-normal normal-case&quot;&gt;{data}&lt;/span&gt;
                      &lt;/p&gt;
                    )
                  }                                  
                </code></pre>

                <code class="cursor-pointer" onclick="$('#15-PatientDetails').toggle();">PatientDetails.tsx</code>
                <pre data-line="0" id="15-PatientDetails" class="hidden"><code class="language-ts">
                  // PatientDetails.tsx  
                  import { toast } from 'react-toastify'
                  import { Patient } from "../types"
                  import PatientDetailItem from "./PatientDetailItem"
                  import { usePatientStore } from "../store"
                  
                  type PatientDetailsProps = {
                      patient: Patient
                  }
                  
                  export default function PatientDetails({patient} : PatientDetailsProps) {
                  
                      // const deletePatient = usePatientStore((state) => state.deletePatient)
                      // const getPatientById = usePatientStore((state) => state.getPatientById)
                  
                      const {deletePatient, getPatientById} = usePatientStore()
                  
                      const handleClick = () => {
                          deletePatient(patient.id)
                          toast('Paciente Eliminado', {
                              type: 'error'
                          })
                      }
                          
                      return (
                          &lt;div className=&quot;mx-5 my-10 px-5 py-10 bg-white shadow-md rounded-xl&quot;&gt;
                              &lt;PatientDetailItem label=&quot;ID&quot; data={patient.id} /&gt;
                              &lt;PatientDetailItem label=&quot;Nombre&quot; data={patient.name} /&gt;
                              &lt;PatientDetailItem label=&quot;Propietario&quot; data={patient.caretaker} /&gt;
                              &lt;PatientDetailItem label=&quot;Email&quot; data={patient.email} /&gt;
                              &lt;PatientDetailItem label=&quot;Fecha Alta&quot; data={patient.date.toString()} /&gt;
                              &lt;PatientDetailItem label=&quot;Síntomas&quot; data={patient.symptoms} /&gt;
                  
                              &lt;div className=&quot;flex flex-col lg:flex-row gap-3 justify-between mt-10&quot;&gt;
                                  &lt;button
                                      type=&quot;button&quot;
                                      className=&quot;py-2 px-10 bg-indigo-600 hover:bg-indigo-700 text-white font-bold uppercase rounded-lg&quot;
                                      onClick={() =&gt; getPatientById(patient.id)}
                                  &gt;Editar&lt;/button&gt;
                  
                                  &lt;button
                                      type=&quot;button&quot;
                                      className=&quot;py-2 px-10 bg-red-600 hover:bg-red-700 text-white font-bold uppercase rounded-lg&quot;
                                      onClick={handleClick}
                                  &gt;Eliminar&lt;/button&gt;
                              &lt;/div&gt;
                          &lt;/div&gt;
                      )
                  }                                    
                </code></pre>

                <code class="cursor-pointer" onclick="$('#15-PatientForm').toggle();">PatientForm.tsx</code>
                <pre data-line="0" id="15-PatientForm" class="hidden"><code class="language-ts">
                  // PatientForm.tsx  
                  import { useEffect } from 'react'
                  import { useForm } from 'react-hook-form'
                  import { toast } from 'react-toastify'
                  import Error from './Error'
                  import type { DraftPatient } from '../types'
                  import { usePatientStore } from '../store'
                  
                  export default function PatientForm() {                  
                    const addPatient  = usePatientStore(state => state.addPatient)
                    const activeId = usePatientStore(state => state.activeId)
                    const patients = usePatientStore(state => state.patients)
                    const updatePatient = usePatientStore(state => state.updatePatient)
                
                    const { register, handleSubmit, setValue , formState: { errors }, reset } = useForm<DraftPatient>()
                
                    useEffect(() => {
                        if(activeId) {
                            const activePatient = patients.filter( patient => patient.id === activeId)[0]
                            setValue('name', activePatient.name)
                            setValue('caretaker', activePatient.caretaker)
                            setValue('date', activePatient.date)
                            setValue('email', activePatient.email)
                            setValue('symptoms', activePatient.symptoms)
                        }
                    }, [activeId])
                
                    const registerPatient = (data: DraftPatient) => {
                        if(activeId) {
                            updatePatient(data)
                            toast('Paciente Actualizado Correctamente', {
                                type: 'success'
                            })
                        } else {
                            addPatient(data)
                            toast.success('Paciente Registrado Correctamente')
                        }
                        reset()
                    }
                
                
                  
                    return (
                      &lt;div className=&quot;md:w-1/2 lg:w-2/5 mx-5&quot;&gt;
                          &lt;h2 className=&quot;font-black text-3xl text-center&quot;&gt;Seguimiento Pacientes&lt;/h2&gt;
                  
                          &lt;p className=&quot;text-lg mt-5 text-center mb-10&quot;&gt;
                              Añade Pacientes y {&#39;&#39;}
                              &lt;span className=&quot;text-indigo-600 font-bold&quot;&gt;Administralos&lt;/span&gt;
                          &lt;/p&gt;
                
                          &lt;form 
                              className=&quot;bg-white shadow-md rounded-lg py-10 px-5 mb-10&quot;
                              noValidate
                              onSubmit={handleSubmit(registerPatient)}
                          &gt;
                                &lt;div className=&quot;mb-5&quot;&gt;
                                    &lt;label htmlFor=&quot;name&quot; className=&quot;text-sm uppercase font-bold&quot;&gt;
                                        Paciente 
                                    &lt;/label&gt;
                                    &lt;input  
                                        id=&quot;name&quot;
                                        className=&quot;w-full p-3  border border-gray-100&quot;  
                                        type=&quot;text&quot; 
                                        placeholder=&quot;Nombre del Paciente&quot; 
                                        {...register(&#39;name&#39;, {
                                            required: &#39;El Nombre del paciente es obligatorio&#39;
                                        })}
                                    /&gt;
                
                                    {errors.name &amp;&amp; (
                                        &lt;Error&gt;{errors.name?.message}&lt;/Error&gt;
                                    )}
                                    
                                &lt;/div&gt;
                  
                                &lt;div className=&quot;mb-5&quot;&gt;
                                    &lt;label htmlFor=&quot;caretaker&quot; className=&quot;text-sm uppercase font-bold&quot;&gt;
                                        Propietario 
                                    &lt;/label&gt;
                                    &lt;input  
                                        id=&quot;caretaker&quot;
                                        className=&quot;w-full p-3  border border-gray-100&quot;  
                                        type=&quot;text&quot; 
                                        placeholder=&quot;Nombre del Propietario&quot; 
                                        {...register(&#39;caretaker&#39;, {
                                            required: &#39;El Propietario es obligatorio&#39;
                                        })}
                                        /&gt;
                
                                        {errors.caretaker &amp;&amp; (
                                            &lt;Error&gt;{errors.caretaker?.message}&lt;/Error&gt;
                                        )}
                                &lt;/div&gt;
                  
                              &lt;div className=&quot;mb-5&quot;&gt;
                                &lt;label htmlFor=&quot;email&quot; className=&quot;text-sm uppercase font-bold&quot;&gt;
                                    Email 
                                &lt;/label&gt;
                                &lt;input  
                                    id=&quot;email&quot;
                                    className=&quot;w-full p-3  border border-gray-100&quot;  
                                    type=&quot;email&quot; 
                                    placeholder=&quot;Email de Registro&quot; 
                                    {...register(&quot;email&quot;, {
                                    required: &quot;El Email es Obligatorio&quot;,
                                        pattern: {
                                            value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i,
                                            message: &#39;Email No Válido&#39;
                                        }
                                    })} 
                                /&gt;
                
                                {errors.email &amp;&amp; (
                                    &lt;Error&gt;{errors.email?.message}&lt;/Error&gt;
                                )}
                              &lt;/div&gt;
                  
                              &lt;div className=&quot;mb-5&quot;&gt;
                                  &lt;label htmlFor=&quot;date&quot; className=&quot;text-sm uppercase font-bold&quot;&gt;
                                      Fecha Alta 
                                  &lt;/label&gt;
                                  &lt;input  
                                      id=&quot;date&quot;
                                      className=&quot;w-full p-3  border border-gray-100&quot;  
                                      type=&quot;date&quot; 
                                      {...register(&#39;date&#39;, {
                                            required: &#39;La fecha de alta es obligatoria&#39;
                                        })}
                                    /&gt;
                
                                    {errors.date &amp;&amp; (
                                        &lt;Error&gt;{errors.date?.message}&lt;/Error&gt;
                                    )}
                              &lt;/div&gt;
                              
                              &lt;div className=&quot;mb-5&quot;&gt;
                                  &lt;label htmlFor=&quot;symptoms&quot; className=&quot;text-sm uppercase font-bold&quot;&gt;
                                    Síntomas 
                                  &lt;/label&gt;
                                  &lt;textarea  
                                      id=&quot;symptoms&quot;
                                      className=&quot;w-full p-3  border border-gray-100&quot;  
                                      placeholder=&quot;Síntomas del paciente&quot; 
                                      {...register(&#39;symptoms&#39;, {
                                        required: &#39;Los síntomas son obligatorios&#39;
                                        })}
                                    /&gt;
                
                                    {errors.symptoms &amp;&amp; (
                                        &lt;Error&gt;{errors.symptoms?.message}&lt;/Error&gt;
                                    )}
                              &lt;/div&gt;
                  
                              &lt;input
                                  type=&quot;submit&quot;
                                  className=&quot;bg-indigo-600 w-full p-3 text-white uppercase font-bold hover:bg-indigo-700 cursor-pointer transition-colors&quot;
                                  value=&#39;Guardar Paciente&#39;
                              /&gt;
                          &lt;/form&gt; 
                      &lt;/div&gt;
                    )
                  }                  
                </code></pre>

                <code class="cursor-pointer" onclick="$('#15-PatientsList').toggle();">PatientsList.tsx</code>
                <pre data-line="0" id="15-PatientsList" class="hidden"><code class="language-ts">
                  //PatientsList.tsx  
                  import { usePatientStore } from "../store"
                  import PatientDetails from "./PatientDetails"
                  
                  export default function PatientsList() {
                  
                      const patients = usePatientStore(state => state.patients)
                      console.log(patients)
                      
                      return (
                          &lt;div className=&quot;md:w-1/2 lg:3/5 md:h-screen overflow-y-scroll&quot;&gt;
                              {patients.length ? (
                                  &lt;&gt;
                                      &lt;h2 className=&quot;font-black text-3xl text-center&quot;&gt;Listado de Pacientes&lt;/h2&gt;
                                      &lt;p className=&quot;text-xl mt-5 mb-10 text-center&quot;&gt;
                                          Administra tus {&#39;&#39;}
                                          &lt;span className=&quot;text-indigo-600 font-bold&quot;&gt;Pacientes y Citas&lt;/span&gt;
                                      &lt;/p&gt;
                                      {patients.map( patient =&gt; (
                                          &lt;PatientDetails
                                              key={patient.id}
                                              patient={patient}
                                          /&gt;
                                      ))}
                                  &lt;/&gt;
                              ) : (
                                  &lt;&gt;
                                      &lt;h2 className=&quot;font-black text-3xl text-center&quot;&gt;No hay pacientes&lt;/h2&gt;
                                      &lt;p className=&quot;text-xl mt-5 mb-10 text-center&quot;&gt;
                                          Comienza agregando pacientes {&#39;&#39;}
                                          &lt;span className=&quot;text-indigo-600 font-bold&quot;&gt;y aparecerán en este lugar&lt;/span&gt;
                                      &lt;/p&gt;
                                  &lt;/&gt;
                              )}
                          &lt;/div&gt;
                      )
                  }                                    
                </code></pre>
              </div>
            </div>

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion15-235').toggle();">
            <h3>235. El Proyecto que vamos a construir</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion15-235" class="hidden">
                            
              <p class="font-bold">Administrador de pacientes de veterinaria</p>
              <p>													
              <img class="my-2.5" src="./src/assets/img/s1-05.jpg" width="" height="" alt=""> 
              
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion15-236').toggle();">
            <h3>236. Creando el Proyecto / 237. Creando los primeros componentes - <a class="underline text-white" href="https://gist.github.com/codigoconjuan/f6b6ae96c36b15c479a96c54bdb2afb5" target="_blank">Gist formulario</a></h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion15-236" class="hidden">
            <p>Creamos proyecto, instalamos dependencias y hacemos limpieza como siempre, instalamos tailwind</p>
            <p>Vamos a ver que con Zustand va a ser muy sencillo manejar el flujo de datos.</p>
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion15-238').toggle();">
            <h3>238. Introducción a React Hook Form / 239. Procesar el Formulario con React Hook Form / 240. Creando un componente para mensajes de error / 241. Agregando validación a los otros campos</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion15-238" class="hidden">
            <p>Cuando tenemos un formulario más complejo o múltiples formularios lo ideal es implementar una librería de formularios. <strong>¿Cuando vamos a utilizar una librería de formularios en React?</strong> si tu proyecto va a contar con múltiples formularios que son muy grandes, muy complejos, con validaciones complejas una librería de estas va a solucionar muchos de estos problemas. Mucha de la parte de estar escribiendo validaciones, código, comprobar que los datos lleguen correctamente, leerlos, etcétera llega a ser bastante código e implementando una librería de este tipo vas a ahorrartebastante trabajo.</p>

            <p>Algunas librerías, no todas, cuentan con validaciones muy robustas y otras se integran bien con alguna dependencia de validación.</p>

            <p>Las opciones más comunes son:</p>

            <ul class="list-disc my-2.5">
              <li><strong>React Hook Form:</strong> es la más común, y la que vamos a utilizar para este proyecto.</li>
              <li><strong>Formic con Yup:</strong> formic se integra con una librería de validaciones de esquemas llamada Yup</li>
              <li><strong>ZOD: </strong>validaciones de esquemas. Lo utilizaremos un poco más adelante en este curso</li>
            </ul>

            <p>Instalamos React Hook Form <span class="destacado">npm i react-hook-form</span>. La documentación es excelente: <a class="underline" href="https://react-hook-form.com/" target="_blank">https://react-hook-form.com/</a></p>

            <p>Importamos useForm() y lo instanciamos por medio de una variable extrayendo la función 'register' (en la docu online arriba en API podemos ver todo lo que incluye useForm()). este método permite registrar un input o un select y aplicar las reglas de validación de react hook form (esas reglas están basadas en estándares de html pero también nos permiten crear nuestros propios métodos de validación)</p>

            <p>usando useForm() y la función de register, quiero que este formualrio que tnemos lo procese useForm. Escribimos esto para tomar una copia de esa funcion register y pasarla vía props hacia el primer input. Como parámetro en el IS vemos que toma un nombre, que es el que vamos a utilizar para recuperar los datos que el user introduce en el campo; es un nombre que es único, le pone el mismo que el id, añadimos coma y entre { } añadimos algunas opciones que es donde va a estar la validación, por ejemplo required : 'El nombre del paciente es obligatorio'. El siguiente código lo único que hace es especificar que este campo es obligatorio, pero aún nos hace falta un procesar el formulario, un leer los errores y mostrarlos. Veamos a continuación como validar este formulario y añadirle un onSubmit con el cual recuperar esos mensajes de error:</p>

            <pre data-line="0"><code class="language-ts">
              //PatientForm.tsx
              import { useForm } from 'react-hook-form'
              ...
              &lt;input  
                id=&quot;name&quot;
                className=&quot;w-full p-3  border border-gray-100&quot;  
                type=&quot;text&quot; 
                placeholder=&quot;Nombre del Paciente&quot; 
                {...register(&#39;name&#39;, {
                    required: &#39;El Nombre del paciente es obligatorio&#39;
                })}
              /&gt;
            </code></pre>

            <p class="naranja">Procesar el Formulario con React Hook Form</p>

            <p>otra función que extraemos es handleSubmit y la llamamos desde el onSubmit de nuestro formulario. Creamos una función nueva registerPatient que la pasamos como parámetro. Extraemos también formState y tras nuestro input que estamos validano añadimos el objeto {errors.name?.message}</p>

            <pre><code class="language-ts">
              ///PatientForm.tsx
              ...
              const { register, handleSubmit, formState: { errors } } = useForm()
              ...
              &lt;form 
                className=&quot;bg-white shadow-md rounded-lg py-10 px-5 mb-10&quot;
                noValidate
                onSubmit={handleSubmit(registerPatient)}
              &gt;
              ...
              &lt;input  
                id=&quot;name&quot;
                className=&quot;w-full p-3  border border-gray-100&quot;  
                type=&quot;text&quot; 
                placeholder=&quot;Nombre del Paciente&quot; 
                {...register(&#39;name&#39;, {
                    required: &#39;El Nombre del paciente es obligatorio&#39;
                })}
              /&gt;
              {errors.name?.message}
            </code></pre>

            <p>Ya estamos mostrando los mensajes de error si presiono el botón sin escribir me muestra el mensaje que yo he definido. Está esperando a que ocurra el evento del onSubmit y entonces, gracias a que extraemos este método de 'formState' podemos recuperar el estado del formulario y en este caso como no escribimos nada en ese input nombre la validación <code class="language-ts">{errors.name?.message}</code> se muestra porque especificamos que el nombre del paciente tiene que ser obligatorio.</p>
              
            <p class="naranja">Creando un componente para mensajes de error</p>
            <p><strong>Hagamos un componente error para gestionar esos errores de manera reutilizable y que se vea mejor</strong>. Lo creamos y le vamos a pasar children, recordemos que es un prop especial de React </p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-ts">
                  //Error.tsx
                  export default function Error({children} : {children: React.ReactNode}) {
                    return (
                      &lt;p className=&quot;text-center my-4 bg-red-600 text-white font-bold p-3 uppercase text-sm&quot;&gt;
                          {children}
                      &lt;/p&gt;
                    )
                  }
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  ////PatientForm.tsx
                  {errors.name &amp;&amp; (
                      &lt;Error&gt;{errors.name?.message}&lt;/Error&gt;
                  )}
                </code></pre>
              </div>
            </div>

            <p>Podríamos añadirle otra regla de validación para nº máximo de caracteres:</p>

            <pre><code class="language-ts">
              //PatientForm.tsx
              {...register('name', {
                required: 'El Nombre del paciente es obligatorio',
                maxLength: {
                  value: 8,
                  message: 'Máximo 8 caracteres'
                }
            })}

            {errors.maxLength &amp;&amp; (
              &lt;Error&gt;{errors.maxLength?.message}&lt;/Error&gt;
            )}
            </code></pre>

            <p class="naranja">Agregando validación a los otros campos - <a class="underline text-white" href="https://gist.github.com/codigoconjuan/0494cc3a11f808fe6478a56e7d51100f" target="_blank">Validación email para react-hook-form</a></p>

            <p>Realiza lo mismo que hemso hecho para el primer input con el resto de campos. Textarea como tiene apertura y cierre para hacer esto solo deja una etiqueta de autocierre.</p>

            <p>¿Como hacemos ahora para recuperar los datos que metimos en el formulario? Antes lo hacíamos con state pero react hook forms tiene su propia forma de hacerlo.</p>

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion15-242').toggle();">
            <h3>242. Definiendo un Type al Formulario</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion15-242" class="hidden">
            <p>¿Cómo recuperar los datos que el usuario mete en el form? Antes creábamos un state u escribíamos la función de onchange y hacíamos una serie de comprobaciones para preservar el tipo de dato. No es necesario colocarlo en state cuando trabajamos con react hook form, digamos que lo que mantiene ese state es nuestro <strong>register</strong></p>

            <p>Es muy sencillo porque una vez se pasen las validaciones, la función que nosotros creamos toma como parámetro lo que el usuario metió. Normalmente lo llamamos <strong>data</strong>. Si probamos lo siguiente vemos en consola como aparece ese objeto con la información metida en el formulario (la parte de la izquierda es lo que colocamos como register y la parte de la derecha lo que el usuario ingresó)</p>

            <pre><code class="language-ts">
              //PatientForm.tsx
              const registerPatient = (data) => {
              console.log(data)
              }
            </code></pre>

            <p>para evitar el any de nuestro data, creamos el archivo de types donde tendremos el type de Patient (que tiene id y es el que vamos a manejar en el store de Zustand) y también uno de DraftPatient:</p>
            <pre><code class="language-ts">
              //types/index.ts
              export type Patient = {
                id: string
                name: string
                caretaker: string
                email: string
                date: Date
                symptoms: string
              }  
              export type DraftPatient = Omit&lt;Patient, &#39;id&#39;&gt;
            </code></pre>

            <p>Usamos ese type para tipar nuestro parámetro data, pero tan pronto como guardamos ese cambio nos marca un error, nos aparece en rojo el parámetro (función en función :P) de nuestro onSubmit, y dice el IS 'Los tyipos de parámetro data y data no son compatibles' ¿por qué? básicamente cuando se registra el formulario <code class="language-ts">const { register, handleSubmit, setValue , formState: { errors }} = useForm()</code> tiene un data y cuando nosotros generamos nuestra función <code class="language-ts">const registerPatient = (data: DraftPatient) =>{}</code> tenemos ese data ya tipado con nuestro nuevo Type. Cuando el componente se genera se ejecuta el useForm() así que con un generic le vamos a decir que al generarse su tipo ha de ser también DraftPatient <code class="language-ts">const { register, handleSubmit, setValue , formState: { errors }} = useForm&lt;DraftPatient&gt;()</code> </p>

            <pre><code class="language-ts">
              //PatientForm.tsx
              const { register, handleSubmit, setValue , formState: { errors }} = useForm&lt;DraftPatient&gt;()
              const registerPatient = (data: DraftPatient) => { ... }
            </code></pre>

            <p>Tener estos types así definidos también nos va a asegurar que concuerdan los nombres de nuestros campos con lo que estamos definiendo ahí, además de que tenemos un buen autocompletado si probamos por ejemplo la notación del punto con errors.</p>
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion15-243').toggle();">
            <h3>243. Introducción a Zustand - <a class="underline text-white" href="https://www.npmjs.com/package/zustand" target="_blank">https://www.npmjs.com/package/zustand</a> - <a class="underline text-white" href="https://github.com/pmndrs/zustand" target="_blank"> github zustand</a></h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion15-243" class="hidden">
            <p>Una vez pasada la validación quiero ir almacenando mis pacientes. Lo vimos con useReducer() lo vimos con contextAPI, sin embargo Zustand simplifica aún más estos dos. Vamos a incorporar Zustand que nos va a permitir tener un estado global de una forma muy sencilla. <strong>Zustand es una dependencia. Es un estado global de forma simple</strong></p>
            <ul class="list-disc my-2.5">
              <li>Zustand es una dependencia para manejar un estado global en tus aplicaciones de React.</li>
              <li>Su API es bastante sencilla y se puede utilizar tanto con JavaScript como con TypeScript.</li>
              <li>Es una de las principales alternativas a Redux Toolkit.</li>
            </ul>

            <p>Vamos al link <a class="underline" href="https://www.npmjs.com/package/zustand" target="_blank">https://www.npmjs.com/package/zustand</a> y vemos que tenemos varios ejemplos, se nos indica como crear nuestro store, como ir utilizando los diferentes actions que modifican nuestro store y como crear el state etc.</p>

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion15-244').toggle();">
            <h3>244. Creando el Store de Zustand / 245. Definiendo acciones en el Store de Zustand</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion15-244" class="hidden">
            <p>Vamos a crear nuestro primer store de Zustand. ¿Qué es un store? es exactamente lo mismo que hicimos con reducer. Es lo mismo solo que en Zustand, en Redux, ellos le dan el nombre de store. <strong>Y es donde vamos a colocar nuestro state y las funciones que lo modifican.</strong> Se puede crear (uno o si son varios) en una carpeta llamada store y también, suelto junto al App.tsx y main.tsx. Nosotros solo tendremos uno así que lo dejamos suelto <span class="file">store.ts</span>. Es una sintaxis más fácil que con useReducer() y por tanto más fácil de entender.</p>

            <p>La forma en que vamos a crear un store es importando de zustand la función para hacerlo, create <code class="language-ts">import { create } from "zustand"</code>. Nuestra primera variable, el nombre de nuestro hook va a ser <code class="language-ts">export const usePatientStore = </code> y usamos la función create con su callback, paréntesis y llaves.</p>

            <pre data-line="0"><code class="language-ts">
              //store.ts
              import { create } from "zustand" 

              export const usePatientStore = create(() => ({

              }))
            </code></pre>

            <p>Creemos un arreglo de pacientes <code class="language-ts">patients: []</code>. Para que no tenga el type never sino que use el type Patient que acabamos de definir en nuestro fichero de types/index.ts, definimos aquí un type que llamamos 'PatienteState' (va a ser un state de pacientes) y va a ser el que utilicemos como generic junto a la llamada de la función create:</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="0"><code class="language-js">
                  //types/index.ts
                  export type Patient = {
                    id: string
                    name: string
                    caretaker: string
                    email: string
                    date: Date
                    symptoms: string
                  }
                  
                  export type DraftPatient = Omit&lt;Patient, &#39;id&#39;&gt;
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="0"><code class="language-ts">
                  //store.ts
                  import { create } from "zustand" 
              
                  type PatienteState = {
                    patients: Patient[]
                  }
              
                  export const usePatientStore = create&lt;PatienteState&gt;(() => ({
                    patients: []
                  }))
                </code></pre>
              </div>
            </div>

            <p>Así es como "va a ir quedando sincronizado nuestro store con cierta estructura" como hicimos con la parte de reducer´. Y si queremos agregar más state o funciones hay que seguir la misma dinámica de añadirlas en el store y en el type.</p>

            <p>Cuando vimos la parte de Context API, registrábamos el provider y registrábamos nuestro context con bastante código, teníamos acciones y mucho código, también creábamos un context hook... también en el main agregábamos toda nuestra aplicación dentro del context. Ahora no necesitamos nada de eso. Nuestro custom hook está en la línea <code class="language-ts">export const usePatientStore = create(() =&gt; ({}))</code> Lo que vemos aquí es todo lo que necesitamos para tener un estado global con Zustand.</p>

            <p>Veamos como escribir en pacientes, como comunicar nuestros componentes con nuestro store para comenzar a escribir en nuestro state.</p>
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion15-245').toggle();">
            <h3>245. Definiendo acciones en el Store de Zustand / 246. Escribiendo en el Estado de Zustand</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion15-245" class="hidden">

            <p class="naranja">Definiendo acciones en el Store de Zustand</p>

            <p>Veamos como comunicar desde nuestro componente de formulario <span class="file">PatienteForm.tsx</span> hacia nuestro store. Eso lo hacemos vía acciones que, aunque en Zustand tienen el mismo nombre, <strong>la cantidad de código a escribir para ello es mínimo. Básicamente van a ser funciones a las que especificamos qué toman y qué retornan y toda la lógica la manejamos en nuestro hook 'usePatientStore' y la reflejamos en 'el type del store'</strong>.</p>

            <p>Creamos la función addPatient que toma data (los datos que vienen del formulario) que son de type DraftPatient y no retorna nada y a continuación registramos la función en el hook:</p>

            <pre data-line="0"><code class="language-ts">
              //store.ts
              import { create } from "zustand" 
              import { DraftPatient, Patient } from "./types"
              
              type PatientState = {
                  patients: Patient[]
                  addPatient: (data: DraftPatient) => void
              }
              
              export const usePatientStore = create&lt;PatientState&gt;(() => ({
                  patients: [],
                  addPatient: (data) => {
                      console.log(data)
                  }
              }))
            </code></pre>

            <p>¿Cómo mandamos llamar esta función en nuestro compo <span class="file">PatientForm.tsx</span>? Importamos el store <code class="language-ts">import { usePatientStore } from '../store'</code> y lo utilizamos antes de useForm(). Algo importante es que hay dos formas en que podemos extraer state y funciones y ambas funcionan muy bien, si vemos nuestra consola (el console.log(data) que de momento tenemos en la acción 'addPatient' de nuestro store) vemos que los datos ya vienen del store.ts, ya estaremos comunicando los datos ingresados en el formulario hacia el store:</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                con destructuring extraemos la función addPatient y la utilizamos a continuación en 'regiterPatient'. :
                <pre data-line="1"><code class="language-ts">
                  //PatientForm.tsx
                  const { addPatient } = usePatientStore()
                  ...
                  const registerPatient = (data: DraftPatient) => {
                    addPatient(data)
                  }
                </code></pre>   
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                otra forma de hacerlo que viene en la documentación y que también es más común en redux toolkit:               
                <pre data-line="1"><code class="language-ts">
                  //PatientForm.tsx
                  const addPatient = usePatientStore(state => state.addPatient)
                  ...
                  const registerPatient = (data: DraftPatient) => {
                    addPatient(data)
                  }
                </code></pre> 
              </div>
            </div>
            
            <p><strong>Como vemos este de momento es un draft, no tiene id. ¿Cómo hacemos para escribir en el state y también para generar in id?</strong></p>

            <p class="naranja">Escribiendo en el Estado de Zustand</p>

            <p>Estamos comunicando de nuestro formulario de pacientes al store. Es en el store donde vamos a almacenar nuestros pacientes para tener un estado global y sobre todo un lugar centralizado para manejar nuestro state y ahí tenemos las funciones que escriben en el state. Zustand como decimos simplifica mucho lo que habíamos visto con useReducer() (acciones arriba, state y lógica abajo), aquí tenemos el state junto a las acciones que lo modifican.</p>
            
            <p>¿Como hacemos para escribir en Patients en addPatient. <strong>En el callback de create le podemos pasar un par de funciones <span class="destacado">set y get</span></strong> siendo set para setear un valor en nuestro state y get para obtenerlo. De momento usamos set porque queremos escribir en patients. set toma un callback, paréntesis y llaves (es muy similar a la parte del return que vimos con useReducer(), pero esta es la manera en que lo hace Zustand) y en el callback le pasamos el state para poder acceder a todo lo que tiene con la notación del punto y recuperamos los patients para no perder lo que ya estuviera almacenado, y le pasamos data, momento en que nos marca error ('oye en el type del store me dijiste que patients es un arreglo de Patient, pero este data es un draft, te hace falta generar su id')</p>

            <img src="./src/assets/img/246.png" alt="img" loading="lazy">

            <p>Antes de ese set podríamos crear toda la lógica que necesitemos, pero él va a escribir una función aparte, antes de la definición del store 'usePatientStore'. Instalamos primero la dependencia uuid para generar ids <span class="destacado">npm i uuid</span>. Creamos esta función 'createPatient' que va a tomar un paciente draft y va a retornarnos un paciente con la misma información que tenía el draft + un id gracias al uso de esta librería que importamos:</p>

            <ul class="list-disc my-2.5">
              <li>nuestra primera acción del store addPatient toma en el callback los datos de paciente draft que le user ha metido en el formulario</li>
              <li>crea nueva const 'newPatient' en la que ejecuta nuestra función 'createPatient' para añadir un id al draft y convertirlo en un Patient 'de verdad'</li>
              <li>hace un set (tomando el state en el callback) a patients con esa información de paciente</li>
            </ul>

            <pre data-line="2,9-11,16,18"><code class="language-ts">
              //store.ts
              import { create } from "zustand" 
              import { v4 as uuidv4 } from 'uuid'
              import { DraftPatient, Patient } from "./types"
              
              type PatientState = {
                  patients: Patient[]
                  addPatient: (data: DraftPatient) => void
              }              
              const createPatient = (Patient: DraftPatient) : Patient => {
                  return { ...Patient, id: uuidv4()}
              }              
              export const usePatientStore = create<PatientState>((set) => ({
                  patients: [],
                  addPatient: (data) => {
                      //console.log(data)
                      const newPatient = createPatient(data)
                      set((state) => ({
                          patients: [...state.patients, newPatient]
                      }))
                  }
              }))
            </code></pre>

            <p><strong>Importante tener en cuenta de Zustand:</strong> como nuestro store es un archivo a parte, por tanto no podemos verlo como hacíamos antes con el componente en RDT (con contextAPI rodeábamos nuestra App con ese context y podíamos verlo en el árbol de compos de RWDT). Vamos a nuestro componente <span class="file">PatientsList.tsx</span> y creamos una variable pra extraer los pacientes y verlos con un console.log. Si miramos la consola la primera vez está como un arreglo vacío pero en cuanto rellenamos un paciente ya lo podemos ver ahí. También podemos verlo ya en la pestaña componentes de RDT mirando en PatientList:</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-ts">
                  //PatientsList.tsx
                  import { usePatientStore } from "../store"
    
                  export default function PatientsList() {  
                    const patients = usePatientStore((state) => state.patients)
                    console.log(patients)
                    return()
                  }
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%] ml-2">
                <img src="./src/assets/img/246-2.png" alt="img" loading="lazy">
              </div>
            </div>

            <p>Recapitulación de cómo funciona Zustand y lo que estamos haciendo: Tenemos en nuestro <span class="file">store.ts</span> juntos los pacientes <code class="language-ts">patients[]</code> y la función que modifica el state <code class="language-ts">addPatient: (data) => {}</code>. Desde <span class="file">PatientForm.tsx</span> estamos disparando esa función pasándole los datos <code class="language-ts">addPatient(data)</code>, llega hacia nuestro store donde con la función 'createPatient' añadimos id único y lo regresa de tipo Patient y lo seteamos en patients con la sintaxis <code class="language-ts">set((state) => ({...}))</code></p>

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion15-247').toggle();">
            <h3>247. Trabajando con el Listado de Pacientes / 248. Mostrando la información del Paciente / 249. Creando los botones de Editar y eliminar</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion15-247" class="hidden">
            <p>Ya estamos escribiendo en nuestro state desde nuestro formulario. Hemos creado un store, que maneja tanto state como funciones, de momento solo tenemos una que es 'addPatient'. Vamos a comenzar a mostrar nuestros pacientes para tener esa aplicación dinámica y reactiva. Vemos que la sintaxis para acceder al state <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
            </svg><span class="file">PatientList.tsx</span> <code class="language-ts">const patients = usePatientStore(state => state.patients)</code> y acceder a nuestras funciones que modifican el state <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
            </svg> <span class="file">PatientForm.tsx</span> <code class="language-ts">const addPatient  = usePatientStore(state => state.addPatient)</code> es la misma.</p>

            <pre data-line="0"><code class="language-ts">
              //PatienteList.tsx
              import { usePatientStore } from &quot;../store&quot;
              import PatientDetails from &quot;./PatientDetails&quot;
              
              export default function PatientsList() {
              
                  const patients = usePatientStore(state =&gt; state.patients)
                  console.log(patients)
                  
                  return (
                      &lt;div className=&quot;md:w-1/2 lg:3/5 md:h-screen overflow-y-scroll&quot;&gt;
                          {patients.length ? (
                              &lt;&gt;
                                  &lt;h2 className=&quot;font-black text-3xl text-center&quot;&gt;Listado de Pacientes&lt;/h2&gt;
                                  &lt;p className=&quot;text-xl mt-5 mb-10 text-center&quot;&gt;
                                      Administra tus {&#39;&#39;}
                                      &lt;span className=&quot;text-indigo-600 font-bold&quot;&gt;Pacientes y Citas&lt;/span&gt;
                                  &lt;/p&gt;
                                  {patients.map( patient =&gt; (
                                      &lt;PatientDetails
                                          key={patient.id}
                                          patient={patient}
                                      /&gt;
                                  ))}
                              &lt;/&gt;
                          ) : (
                              &lt;&gt;
                                  &lt;h2 className=&quot;font-black text-3xl text-center&quot;&gt;No hay pacientes&lt;/h2&gt;
                                  &lt;p className=&quot;text-xl mt-5 mb-10 text-center&quot;&gt;
                                      Comienza agregando pacientes {&#39;&#39;}
                                      &lt;span className=&quot;text-indigo-600 font-bold&quot;&gt;y aparecerán en este lugar&lt;/span&gt;
                                  &lt;/p&gt;
                              &lt;/&gt;
                          )}
                      &lt;/div&gt;
                  )
              }    
            </code></pre>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="0"><code class="language-js">
                  //PatienteDetail.tsx
                  import { toast } from 'react-toastify'
                  import { Patient } from "../types"
                  import PatientDetailItem from "./PatientDetailItem"
                  import { usePatientStore } from "../store"
                  
                  type PatientDetailsProps = {
                      patient: Patient
                  }
                  
                  export default function PatientDetails({patient} : PatientDetailsProps) {
                  
                      const deletePatient = usePatientStore((state) => state.deletePatient)
                      const getPatientById = usePatientStore((state) => state.getPatientById)
                  
                      const handleClick = () => {
                          deletePatient(patient.id)
                          toast('Paciente Eliminado', {
                              type: 'error'
                          })
                      }
                          
                      return (
                          &lt;div className=&quot;mx-5 my-10 px-5 py-10 bg-white shadow-md rounded-xl&quot;&gt;
                              &lt;PatientDetailItem label=&quot;ID&quot; data={patient.id} /&gt;
                              &lt;PatientDetailItem label=&quot;Nombre&quot; data={patient.name} /&gt;
                              &lt;PatientDetailItem label=&quot;Propietario&quot; data={patient.caretaker} /&gt;
                              &lt;PatientDetailItem label=&quot;Email&quot; data={patient.email} /&gt;
                              &lt;PatientDetailItem label=&quot;Fecha Alta&quot; data={patient.date.toString()} /&gt;
                              &lt;PatientDetailItem label=&quot;Síntomas&quot; data={patient.symptoms} /&gt;
                  
                              &lt;div className=&quot;flex flex-col lg:flex-row gap-3 justify-between mt-10&quot;&gt;
                                  &lt;button
                                      type=&quot;button&quot;
                                      className=&quot;py-2 px-10 bg-indigo-600 hover:bg-indigo-700 text-white font-bold uppercase rounded-lg&quot;
                                      onClick={() =&gt; getPatientById(patient.id)}
                                  &gt;Editar&lt;/button&gt;
                  
                                  &lt;button
                                      type=&quot;button&quot;
                                      className=&quot;py-2 px-10 bg-red-600 hover:bg-red-700 text-white font-bold uppercase rounded-lg&quot;
                                      onClick={handleClick}
                                  &gt;Eliminar&lt;/button&gt;
                              &lt;/div&gt;
                          &lt;/div&gt;
                      )
                  }        
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="0"><code class="language-js">
                  //PatientDetailItem.tsx
                  type PatientDetailItemProps = {
                    label: string
                    data: string
                  }
                  export default function PatientDetailItem({label, data} : PatientDetailItemProps) {
                    return (
                      <p className="font-bold mb-3 text-gray-700 uppercase">{label}: {''}
                          <span className="font-normal normal-case">{data}</span>
                      </p>
                    )
                  }
                </code></pre>
                <p>Vemos que tras añadir un paciente, el formulario de la izquierda mantiene los datos que acabamos de teclear. Si queremos borrarlos no tenemos que reiniciar el formulario reiniciando el state como antes, podemos extraer la función reset y usarla así, es algo que va a hacer en automático React Hook Form:</p>
                <pre data-line="2,14"><code class="language-ts">
                  ///PatientForm.tsx
                  ...
                  const { register, handleSubmit, setValue , formState: { errors }, reset } = useForm<DraftPatient>()
                  ...
                  const registerPatient = (data: DraftPatient) => {
                    if(activeId) {
                        updatePatient(data)
                        toast('Paciente Actualizado Correctamente', {
                            type: 'success'
                        })
                    } else {
                        addPatient(data)
                        toast.success('Paciente Registrado Correctamente')
                    }
                    reset()
                  }
                </code></pre>
              </div>
            </div>

            

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion15-250').toggle();">
            <h3>250. Eliminar Pacientes en Zustand</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion15-250" class="hidden">
            <p>Vamos a crear en nuestro store una función nueva que llamamos 'deletePatient'. recordemos que hay que añadirla también en nuestra firma (type de store) 'PatientState' <code class="language-ts">deletePatient: (id: Patient['id']) => void</code> Tenemos que identificar qué paciente es, pasémosle como parámetro un id y hagamos un console.log(id). Una vez comprobado en cuanto llamamos a esta función desde el onClick de nuestro botón de la interfaz, con un set establecemos que el state patients quede con todos los pacientes menos con el que tiene el id que le estamos pasando a esa función... </p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="4,11-16"><code class="language-ts">
                  //store.ts
                  type PatientState = {
                    patients: Patient[]
                    addPatient: (data: DraftPatient) => void
                    deletePatient: (id: Patient['id']) => void
                }
                  export const usePatientStore = create&lt;PatientState&gt;((set) => ({
                    patients: [],
                    addPatient: (data) => {
                        ...
                    },
                    deletePatient: (id) => {
                      //console.log(id)
                      set((state) => ({
                        patients: state.patients.filter(patient=>patient.id != id)
                      }))
                    }
                }))
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <p>La mandamos llamar en nuestro componente <span class="file">PatientDetail.tsx</span>. Importo el store para tener acceso a todas sus funciones y el state, extraigo deletePatient y lo conecto a mi interfaz de react utilizando el evento de onClick en el botón correspondiente.</p>

                <pre data-line="1,3,8"><code class="language-ts">
                  //PatientDetail.tsx
                  import { usePatientStore } from "../store"
                  ...
                  const deletePatient = usePatientStore((state) => state.deletePatient)
                  ...
                  &lt;button
                      type=&quot;button&quot;
                      className=&quot;py-2 px-10 bg-red-600 hover:bg-red-700 text-white font-bold uppercase rounded-lg&quot;
                      onClick={deletePatient(patient.id)}
                  &gt;Eliminar&lt;/button&gt;
                </code></pre>
              </div>
            </div>

            

            

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion15-251').toggle();">
            <h3>251. Obtener el paciente a editar</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion15-251" class="hidden">
            <p>Con un paciente introducido, hemos de ser capaces de identificar el registro de dicho paciente cuando pulsamos en el botón de editar. Generamos en nuestro store un state nuevo que va a tener el id que está en activo <code class="language-ts">activeId: Patient['id']</code>, también una función que identifique y agregue en el state 'activeId' que estamos presionando en un paciente para editarlo <code class="language-ts">getPatientById: (id: Patient['id']) => void</code></p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="3,6,11,18-22"><code class="language-ts">
                  //store.ts
                  type PatientState = {
                    patients: Patient[]
                    activeId: Patient['id']
                    addPatient: (data: DraftPatient) => void
                    deletePatient: (id: Patient['id']) => void
                    getPatientById: (id: Patient['id']) => void
                  }
                  ...
                  export const usePatientStore = create&lt;PatientState&gt;((set) => ({
                    patients: [],
                    activeId: '',
                    addPatient: (data) => {
                     ...
                    },
                    deletePatient: (id) => {
                      ...
                    },
                    getPatientById: (id) => {
                        set(() => ({
                            activeId: id
                        }))
                    }
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <p>En <span class="file">PatientDetails.tsx</span> creamos la variable 'getPatientById' donde extraemos la nueva función correspondiente. Recordar que también podríamos hacer las extracciones así:</p>
                <pre><code class="language-ts">
                  const {deletePatient, getPatientById} = usePatientStore()
                </code></pre>
                <p>Y llamamos a la función desde el onClick del botón editar:</p>
                <pre data-line="2,7"><code class="language-js">
                  //PatientDetails.tsx
                  const deletePatient = usePatientStore((state) => state.deletePatient)
                  const getPatientById = usePatientStore((state) => state.getPatientById)
                  ...
                  &lt;button
                    type=&quot;button&quot;
                    className=&quot;py-2 px-10 bg-indigo-600 hover:bg-indigo-700 text-white font-bold uppercase rounded-lg&quot;
                    onClick={() =&gt; getPatientById(patient.id)}
                  &gt;Editar&lt;/button&gt;
                </code></pre>
                <p></p>

              </div>
            </div>

            <p>En este caso para poder ver una vez seteado ese activeId tendríamos que extraerlo y vía variable renderizarlo en mi vista. <strong>Como eso no es la mejor manera de trabajr en desarrollo</strong>, <span class="destacado">Veamos como incorporar Redux devtools par apoder ver el state de Zustand</span></p>   
          </div>


          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion15-252').toggle();">
            <h3>252. Incorporar Redux DevTools para inspeccionar el Store de Zustand / 253. Llenar el Formulario cuando editamos un Paciente / 254. Actualizando el Paciente</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion15-252" class="hidden">
            <ul class="list-disc my-3">
              <li class="my-1.25">Instalamos la extensión para el navegador: <a class="underline" href="https://chromewebstore.google.com/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=es" target="_blank">Extensión Redux DevTools</a> </li>
              <li class="my-1.25">En nuestro <span class="file">store.ts</span> importamos devtools <code class="language-ts">import { devtools, persist } from 'zustand/middleware'</code></li>
              <li class="my-1.25">Lo utilizamos: 
                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre data-line="0"><code class="language-js">
                      //store.ts
                      export const usePatientStore = create&lt;PatientState&gt;(
                        (set) => ({
                          patients: [],
                          activeId: '',
                          addPatient: (data) => {
                              //console.log(data)
                              const newPatient = createPatient(data)
                              set((state) => ({
                                  patients: [...state.patients, newPatient]
                              }))
                          },
                          deletePatient: (id) => {
                            ...
                          },
                          getPatientById: (id) => {
                            ...
                          }
                        })
                      )
                    </code></pre>
                  </div>
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre class="verde" data-line="1,2,20"><code class="language-js">
                      //store.ts
                      export const usePatientStore = create&lt;PatientState&gt;()(
                        devtools(
                          (set) => ({
                            patients: [],
                            activeId: '',
                            addPatient: (data) => {
                                //console.log(data)
                                const newPatient = createPatient(data)
                                set((state) => ({
                                    patients: [...state.patients, newPatient]
                                }))
                            },
                            deletePatient: (id) => {
                              ...
                            },
                            getPatientById: (id) => {
                              ...
                            }
                          })
                        )
                      )
                    </code></pre>
                  </div>
                </div>
              </li>
              <li>Recargar y ya vemos que nos aparece en la nueva pestaña Redux, Action, State <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"> y ahí podemos ver, como estaba el state antes, las acciones que disparan el estate (están como anónimas porque no hay acciones como tal en Zustand como sí las hay en useReducer o en Redux Toolkit</path>
              </svg>
              <img src="./src/assets/img/254.png" alt="img" loading="lazy">
            </li>
            </ul>
            
            <p class="naranja">Llenar el Formulario cuando editamos un Paciente</p>


            <ul class="list-disc my-3">
              <li class="my-1.25">Nos vamos a <span class="file">PatientForm.tsx</span> y extraemos el state 'activeId' en una nueva variable: <code class="language-ts">const activeId = usePatientStore(state => state.activeId)</code> y también la información de los pacientes: <code class="language-ts">const patients = usePatientStore(state => state.patients)</code></li>
              <li class="my-1.25">Tenemos que revisar e identificar cuando activeId tenga algo. Usamos para ello useEffect() pasándole como dependencia activeId para ejecutar ese código cada vez que cambie ese state. Y en ese código metemos en una variable el filtrado del paciente que tenga el mismo id que activeId (recordar, .filter() devuelve un arreglo como esta vez solo quiero uno, un objeto, pongo la coletilla [0]).</li>
              <li class="my-1.25">¿Cómo colocamos esa información del state de nuevo en nuestro formulario? Usando una función de useForm() llamada <strong>setValue</strong> que nos va a permitir setear un valor por default a nuestro formulario.</li>
              <li class="my-1.25">Si guardamos a continuación nos crearía paciente nuevo así que <strong>tenemos que revisar si estamos editando o creando uno nuevo</strong>. En esta parte vamos a disparar acciones diferentes en función se si hay un activeId.                

                <pre data-line="0"><code class="language-ts">
                  //PatientForm.tsx
                  ...
                  const activeId = usePatientStore(state => state.activeId)
                  const patients = usePatientStore(state => state.patients)
                  ...
                  const { register, handleSubmit, setValue , formState: { errors }, reset } = useForm&lt;DraftPatient&gt;()
                  useEffect(() => {
                    if(activeId) {
                        const activePatient = patients.filter( patient => patient.id === activeId)[0]
                        setValue('name', activePatient.name)
                        setValue('caretaker', activePatient.caretaker)
                        setValue('date', activePatient.date)
                        setValue('email', activePatient.email)
                        setValue('symptoms', activePatient.symptoms)
                    }
                  }, [activeId])
                
                  const registerPatient = (data: DraftPatient) => {                  
                    addPatient(data)
                        
                    reset()
                  }
                </code></pre>
              </li>
            </ul>  

            <p class="naranja">Actualizando el Paciente</p>
                
            <ul class="list-disc my-3">
              <li class="my-1.25"><strong>Creamos una nueva acción en nuestro store: en ella iteramos con .map() sobre los patients del state</strong> y tenemos que identificar cual es el que estamos editando = compruebo si el paciente de la iteración tiene el mismo id que 'activeId', si es así retorno un objeto {} y si no, el patient que está en el state (para no perder lo que teníamos). En el objeto {} ponemos 2 cosas: el id (recordemos que este es un draft, requerimos id ¿de donde lo sacamos? pues o de nuestro state.activeId o del state.id (porque en esa iteración coincide :P)) y el segundo parámetro tras la coma <strong>todo lo que el user puso en el form es decir una copia de data: '...data'</strong>. <span class="destacado">En Zustand se puede escribir en múltiples id al mismo tiempo</span> y en este punto es un buen ejemplo porque recién hecho esto, regresamos activeId a string vacío: <code class="language-ts">activeId: ''</code>
                <pre data-line="3,20-25"><code class="language-ts">
                  //store.ts
                  type PatientState = {
                    ...
                    updatePatient: (data: DraftPatient) => void
                  }
                  ...
                  export const usePatientStore = create&lt;PatientState&gt;()(
                    devtools(
                      persist( (set) => ({
                          patients: [],
                          activeId: '',
                          addPatient: (data) => {
                              ...
                          },
                          deletePatient: (id) => {
                            ...
                          },
                          getPatientById: (id) => {
                            ...
                          },
                          updatePatient: (data) => {
                              set((state) => ({
                                  patients: state.patients.map( patient => patient.id === state.activeId ? {id: state.activeId, ...data } : patient),
                                  activeId: ''
                              }))
                          }
                       })
                    )
                  )
                </code>
                </pre>
              
             </li>             
            <li class="my-1.25">Vamos a <span class="file">PatientForm.tsx</span> y creamos nueva variable para extraer la función updatePatient


            <pre data-line="0"><code class="language-ts">
              //PatientForm.tsx
              ...
              const activeId = usePatientStore(state => state.activeId)
              const patients = usePatientStore(state => state.patients)
              const updatePatient = usePatientStore(state => state.updatePatient)

              ...
              const { register, handleSubmit, setValue , formState: { errors }, reset } = useForm&lt;DraftPatient&gt;()
              useEffect(() => {
                if(activeId) {
                    const activePatient = patients.filter( patient => patient.id === activeId)[0]
                    setValue('name', activePatient.name)
                    setValue('caretaker', activePatient.caretaker)
                    setValue('date', activePatient.date)
                    setValue('email', activePatient.email)
                    setValue('symptoms', activePatient.symptoms)
                }
            }, [activeId])

            const registerPatient = (data: DraftPatient) => {
              if(activeId) {
                  updatePatient(data)                  
              } else {
                  addPatient(data)                  
              }
              reset()
            }
            </code></pre>

            </li>
          </ul>
            
          </div>


          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion15-255').toggle();">
            <h3>255. Mensajes de Alerta con React-Toastify / 256. Mostrar Toast en Editar y eliminar</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion15-255" class="hidden">
            <p>Vamos a utilizar un componente de avisos que tiene muy buen aspecto y al usuario le dan retroalimentación de lo que está pasando. Instalamos la dependencia <span class="destacado">npm i react-toastify</span>. Es algo que se añade en dos lugares:</p>
            <ul class="list-disc my-3">
              <li class="my-1.25">En <span class="destacado">App.tsx</span> importamos <code class="language-ts">import { ToastContainer } from 'react-toastify'</code> y también su hoja de estilos: <code class="language-ts">import "react-toastify/dist/ReactToastify.css"</code>. Aquí en nuestro compo ppal de App va a estar el componente resgistrado esperando que ocurra el evento que lo mande llamar. Usamos el Tag <code class="language-html">&lt;ToastContainter/&gt;</code> y si lo ponemos en cualquier sitio y vamos a RDT vemos que ya aparece en la pestaña componentes.</li>
                
              <li class="my-1.25">En nuestro código en las funciones donde queremos disparar los eventos de tostify. ¿Cuando queremos que se muestre? por ejemplo al generar un nuevo paciente. Vamos a <span class="file">PatientForm.tsx</span> e importamos <code class="language-ts">import { toast } from 'react-toastify'</code> y lo usamos teniendo en cuenta las instrucciones y el constructor de su url (<a href="https://fkhadra.github.io/react-toastify/introduction/" target="_blank" class="underline">react-toastify documentación</a>) donde podemos testar la apariencia y el posición en función de los props que le pasemos: <a href="https://www.npmjs.com/package/react-toastify" target="_blank" class="underline">https://www.npmjs.com/package/react-toastify</a>. Mostramos toast al guardar paciente y también al editarlo:
              <pre><code class="language-ts">
                //PatientForm.tsx
                const registerPatient = (data: DraftPatient) => {
                  if(activeId) {
                      updatePatient(data)
                      toast('Paciente Actualizado Correctamente', {
                          type: 'success'
                      })
                  } else {
                      addPatient(data)
                      toast.success('Paciente Registrado Correctamente')
                  }
                  reset()
                }
              </code></pre>
              </li>
              <li>Vamos a mostrar toast al eliminar un paciente. Vamos a <span class="file">PatientDetail.tsx</span>. Como vemos tenemos en el onClick un callback que lanza la acción del store para eliminar <code class="language-ts">onClick={() => deletePatient(patient.id)}</code> pero además de disparar esta acción queremos mostrar el toast, así que creamos la función handleClick que conteng alas dos cosas:
              <pre><code class="language-ts">
                //PatientDetail.tsx
                const handleClick = () => {
                  deletePatient(patient.id)
                  toast('Paciente Eliminado', {
                      type: 'error'
                  })
                }
                ...
                &lt;button
                    type=&quot;button&quot;
                    className=&quot;py-2 px-10 bg-red-600 hover:bg-red-700 text-white font-bold uppercase rounded-lg&quot;
                    onClick={handleClick}
                &gt;Eliminar&lt;/button&gt;
              </code></pre>
              </li>
            </ul>

          </div>


          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion15-257').toggle();">
            <h3>257. LocalStorage al contenido del Store de Zustand</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion15-257" class="hidden">
            <p>Vemos cómo implementar LocalStorage a nuestro store de Zustand. Es muy sencillo, con persist y un name!!. En <span class="file">store.ts</span> importamos persist <code class="language-ts">import { devtools, persist } from 'zustand/middleware'</code> que es lo que nos va a permitir tener un estado persistente y admite diferentes opciones permitiendo que le especifiquemos si queremos que sea en sessionStorage o localStorage. utilizamos persist justo a continuación de devtools de esta manera. El nuevo objeto {} va a almacenar las opciones de persist. Le damos un nombre que es en el cual se va a almacenar en sessión o local storage. Si vemos en la pestaña aplicación de WDT vemos en almacenamiento local esa clave que acabamos de crear. Si quisiéramos almacenar en sessionStorage hemos de importar createJSONStorage (este también viene desde middleware) y añadiríamos esto al objeto tras una coma (ojo! solo funcionaría el session y no el local): <code class="language-ts">storage: createJSONStorage (() => sessionStorage)</code>. También se puede especificar el localStorage así aunque como es el default no es necesario: <code class="language-ts">storage: createJSONStorage (() => localStorage)</code>. <span class="destacado">Recordar no almacenar en almacenamiento local nunca datos sensibles como passwords, tarjetas...</span></p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre class="rojo" data-line="5,17"><code class="language-js">
                  //store.ts
                  import { devtools, persist } from 'zustand/middleware'
                  ...
                  export const usePatientStore = create&lt;PatientState&gt;()(
                    devtools(
                      (set) => ({
                        patients: [],
                        activeId: '',
                        addPatient: (data) => {
                          ...
                        },
                        deletePatient: (id) => {
                          ...
                        },
                        getPatientById: (id) => {
                          ...
                        }
                      })
                    )
                  )
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre class="verde" data-line="5,23-26"><code class="language-js">
                  //store.ts
                  import { devtools, persist } from 'zustand/middleware'
                  ...
                  export const usePatientStore = create&lt;PatientState&gt;()(
                    devtools(
                      persist( (set) => ({
                        patients: [],
                        activeId: '',
                        addPatient: (data) => {
                          ...
                        },
                        deletePatient: (id) => {
                          ...
                        },
                        getPatientById: (id) => {
                          ...
                        },
                        updatePatient: (data) => {
                          set((state) => ({
                            patients: state.patients.map( patient => patient.id === state.activeId ? {id: state.activeId, ...data } : patient),
                            activeId: ''
                          }))
                        }
                      }), {
                        name: 'patient-storage'
                        //,storage: createJSONStorage (() => sessionStorage)
                      })
                    )
                  )
                </code></pre>
              </div>
            </div>

            <p>Más adelante estaremos viendo Redux Toolkit que ofrece más cosas que Zustand, pero en principio en los siguientes usaremos Zustand que es muy sencillo para tener un estado global sin tener que andar con un custom hook y un context.</p>

            <p>Hacemos un build para asegurarnos de que no tenemos errores.</p>

            <p>En el siguiente proyecto veremos como consumir datos de Internet, conectarnos a alguna API.</p>
          </div>


        </div>
        <!-- Fin div colapsable-->

      </div>
      <!-- FIN SECCION 15 -->

            
      <!-- SECCION 14 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 my-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">

        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between" onclick="$('#seccion14').toggle();">
          <h2>Sección 14: PROYECTO - Contador de Calorias hacia ContextAPI y useReducer <span class="rojo">PTE. HACER</span></h2>
          <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
        </div>

        <div id="seccion14" class="hidden">

            <!-- Bloque desplegable interior-->
            <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion14-XX').toggle();">
              <h3>XXXXXXXXXXXXXXX</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion14-XX" class="hidden">
              

            </div>

        </div>
        <!-- Fin div colapsable-->

      </div>
      <!-- FIN SECCION 14 -->


      <!-- SECCION 13 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 my-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">

        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between" onclick="$('#seccion13').toggle();">
          <h2>Sección 13: PROYECTO - Control de Gastos y Presupuestos con Context API para estado global</h2>
          <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
        </div>

        <div id="seccion13" class="hidden">

          <a class="underline text-rose-600 font-bold" href="https://github.com/and....55/control-gastos-contextapi/" target="blank">https://github.com/and....55/control-gastos-contextapi/</a>
          <p> Planificador de gastos. Proyecto con un un state más complejo pero nos apoyamos en <span class="destacado">useReducer</span> y <span class="destacado">contextAPI</span>. También <span class="destacado">localStorage</span>, <span class="destacado">validación de formulario</span>, <span class="destacado">modal que utiliza Headless UI</span></p>

          <p>Vemos el beneficio de tener un estado global: vamos importando el hook 'useBudget' donde lo necesitamos y vamos teniendo acceso a la información sin necesidad de estar pasando continuamente propos.</p>       


          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion13-ficheros').toggle();">
            <h3>FICHEROS FINALES</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-ficheros" class="hidden">
                                
            <div class="flex max-sm:flex-col">
              <div class="w-[20%] max-sm:w-[100%]">
                <span class="destacado">App.tsx, index.css, main.tsx</span><br>
                <code class="cursor-pointer" onclick="$('#13-app').toggle();">App.tsx</code>
                <pre data-line="0" id="13-app" class="hidden"><code class="language-ts">
                  //App.tsx  
                  import { useEffect, useMemo } from 'react'
                  import { useBudget } from './hooks/useBudget'
                  import BudgetForm from './components/BudgetForm'
                  import BudgetTracker from './components/BudgetTracker'
                  import ExpenseModal from './components/ExpenseModal'
                  import ExpenseList from './components/ExpenseList'
                  import FilterByCategory from './components/FilterByCategory'
                  
                  function App() {
                    const {state} = useBudget()
                    const isValidObject = useMemo(()=> state.budget>0, [state.budget])
                  
                    useEffect(() => {
                      localStorage.setItem('budget', state.budget.toString())
                      localStorage.setItem('expenses', JSON.stringify(state.expenses))
                    },[state])
                  
                    return (
                      &lt;&gt;
                      &lt;header className=&quot;bg-blue-600 py-8 max-h-72&quot;&gt;
                        &lt;h1 className=&quot;uppercase text-center font-black text-4xl text-white&quot;&gt;
                          Planificador de gastos
                        &lt;/h1&gt;
                      &lt;/header&gt;
                  
                        &lt;div className=&quot;max-w-3xl mx-auto bg-white shadow-lg rounded-lg mt-10 p-10&quot;&gt;      
                          {isValidObject? &lt;BudgetTracker /&gt; : &lt;BudgetForm /&gt;}    
                        &lt;/div&gt;
                  
                        {isValidObject &amp;&amp; (
                          &lt;main className=&#39;max-w-3xl mx-auto py-10&#39;&gt;
                            &lt;FilterByCategory /&gt;
                            &lt;ExpenseList/&gt;
                            &lt;ExpenseModal/&gt;
                          &lt;/main&gt;
                        )}
                      
                      &lt;/&gt;
                    )
                  }
                  
                  export default App
                                    
                </code></pre>
      
                <code class="cursor-pointer" onclick="$('#13-indexcss').toggle();">index.css</code>
                <pre data-line="0" id="13-indexcss" class="hidden"><code class="language-css">
                  //index.css
                  @import "tailwindcss";
      
                  /*** SWIPE LIST OVERRIDES **/
                  .swipeable-list-item__leading-actions, 
                  .swipeable-list-item__trailing-actions {
                    @apply text-white text-lg uppercase font-bold;
                  }
                  .swipeable-list-item__leading-actions{
                    @apply bg-blue-600;
                  }
                  .swipeable-list-item__trailing-actions {
                    @apply bg-pink-600;
                  }
                  .swipeable-list .swipe-action {
                    @apply flex justify-center items-center
                  }
                </code></pre>
      
                <code class="cursor-pointer" onclick="$('#13-maintsx').toggle();">main.tsx</code>
                <pre data-line="0" id="13-maintsx" class="hidden"><code class="language-js">
                  //main.tsx
                  import { StrictMode } from &#39;react&#39;
                  import { createRoot } from &#39;react-dom/client&#39;
                  import &#39;./index.css&#39;
                  import App from &#39;./App.tsx&#39;
                  import { BudgetProvider } from &#39;./context/BudgetContext.tsx&#39;
                  
                  createRoot(document.getElementById(&#39;root&#39;)!).render(
                    &lt;StrictMode&gt;
                      &lt;BudgetProvider&gt;
                      &lt;App /&gt;
                      &lt;/BudgetProvider&gt;
                    &lt;/StrictMode&gt;,
                  )           
                </code></pre> 
              </div>

              <div class="w-[20%] max-sm:w-[100%]">
                <span class="destacado">context, data, helpers, hooks, reducer, types</span><br>
                <code class="cursor-pointer" onclick="$('#13-BudgetContext').toggle();">context/BudgetContext.tsx</code>
                <pre data-line="0" id="13-BudgetContext" class="hidden"><code class="language-ts">
                  //context/BudgetContext.tsx
                  import { useReducer, createContext, Dispatch, ReactNode, useMemo } from &#39;react&#39;;
                  import { BudgetState, BudgetActions, budgetReducer, initialState } from &quot;../reducers/budget-reducer&quot;
                  
                  type BudgetContextProps = {
                      state:  BudgetState
                      dispatch: Dispatch&lt;BudgetActions&gt;
                      totalExpenses: number
                      remainingBudget: number
                  }
                  type BudgetProviderProps = {
                      children : ReactNode
                  }
                  
                  export const BudgetContext = createContext&lt;BudgetContextProps&gt;(null!)
                  
                  export const BudgetProvider = ({children}: BudgetProviderProps) =&gt; {
                  
                      const [state, dispatch] = useReducer(budgetReducer, initialState)
                  
                      const totalExpenses = useMemo( () =&gt; state.expenses.reduce((total,expense) =&gt; expense.amount + total, 0 )
                      , [state.expenses])
                      const remainingBudget = state.budget - totalExpenses
                    
                      return(
                          &lt;BudgetContext.Provider
                              value={{
                                  state,
                                  dispatch,
                                  totalExpenses,
                                  remainingBudget
                              }}
                          &gt;
                              {children}
                          &lt;/BudgetContext.Provider&gt;
                      )
                  
                  }            
                </code></pre>

                <code class="cursor-pointer" onclick="$('#13-categories').toggle();">data/categories.ts</code>
                <pre data-line="0" id="13-categories" class="hidden"><code class="language-ts">
                  //data/categories.ts
                  import type { Category } from "../types";

                  export const categories: Category[] = [
                      { id: '1', name: 'Ahorro', icon: 'ahorro' },
                      { id: '2', name: 'Comida', icon: 'comida' },
                      { id: '3', name: 'Casa', icon: 'casa' },
                      { id: '4', name: 'Gastos Varios', icon: 'gastos' },
                      { id: '5', name: 'Ocio', icon: 'ocio' },
                      { id: '6', name: 'Salud', icon: 'salud' },
                      { id: '7', name: 'Suscripciones', icon: 'suscripciones' },
                    ];           
                </code></pre>

                <code class="cursor-pointer" onclick="$('#13-helpers').toggle();">helpers/index.ts</code>
                <pre data-line="0" id="13-helpers" class="hidden"><code class="language-ts">
                  //helpers/index.ts
                  export function formatCurrency(amount: number){
                    return new Intl.NumberFormat('es-ES', { style: 'currency', currency: 'EUR' }).format(amount)
                  }
                  
                  export function formatDate(dateStr : string) : string {
                      const dateObj = new Date(dateStr) //convertimos a objeto de tipo fecha
                      const options : Intl.DateTimeFormatOptions = {
                          weekday: 'long',
                          year: 'numeric',
                          month: 'long',
                          day: 'numeric'
                      }
                      return new Intl.DateTimeFormat('es-ES', options).format(dateObj)
                  }
                </code></pre>   
      
                <code class="cursor-pointer" onclick="$('#13-customhook').toggle();">hooks/useBudget.ts</code>
                <pre data-line="0" id="13-customhook" class="hidden"><code class="language-ts">
                  //hooks/useBudget.ts
                  import { useContext } from "react"
                  import { BudgetContext } from "../context/BudgetContext"
                  
                  export const useBudget = () => {
                      const context = useContext(BudgetContext)
                      if(!context){
                          throw new Error('useBudget must be used within a BudgetContext')
                          //throw new Error('useBudget must be used within a BudgetProvider')
                      }
                      return context
                  }
                </code></pre>
      
                <code class="cursor-pointer" onclick="$('#13-budget-reducer').toggle();">reducer/budget-reducer.ts</code>
                <pre data-line="0" id="13-budget-reducer" class="hidden"><code class="language-ts">
                  //reducer/budget-reducer.ts
                  import { v4 as uuidv4} from &#39;uuid&#39;
                  import { Category, DraftExpense, Expense } from &quot;../types&quot;
                  
                  export type BudgetActions = 
                      { type: &#39;add-budget&#39;, payload: {budget: number} } |
                      { type: &#39;show-modal&#39; } |
                      { type: &#39;close-modal&#39; } |
                      { type: &#39;add-expense&#39;, payload: {expense: DraftExpense} } |
                      { type: &#39;remove-expense&#39;, payload: {id: Expense[&#39;id&#39;]} } |
                      { type: &#39;get-expense-by-id&#39;, payload: {id: Expense[&#39;id&#39;]} } |
                      { type: &#39;update-expense&#39;, payload: {expense: Expense} } | 
                      { type: &#39;restart-app&#39; } |
                      { type: &#39;add-filter-category&#39; , payload: {id: Category[&#39;id&#39;]} }
                  
                  
                  export type BudgetState = {
                      budget: number
                      modal: boolean
                      expenses: Expense[]
                      editingId: Expense[&#39;id&#39;]
                      currentCategory: Category[&#39;id&#39;]
                  }
                  
                  const initialBudget = () : number =&gt;{
                      const localStorageBudget = localStorage.getItem(&#39;budget&#39;)
                      return localStorageBudget ? +localStorageBudget : 0
                  }
                  const localStorageExpenses = () : Expense[] =&gt; {
                      const localStorageExpenses = localStorage.getItem(&#39;expenses&#39;)
                      return localStorageExpenses ? JSON.parse(localStorageExpenses) : []
                  }
                  export const initialState: BudgetState = {
                      budget: initialBudget(),
                      modal: false,
                      expenses: localStorageExpenses(),
                      editingId: &#39;&#39;,
                      currentCategory: &#39;&#39;
                  }
                  
                  const createExpense = (draftExpense: DraftExpense ) : Expense =&gt; {
                      return {
                          ...draftExpense,
                          id: uuidv4()
                      }
                  }
                  
                  export const budgetReducer = (
                          state: BudgetState=initialState,
                          action: BudgetActions
                      ) =&gt;{
                  
                      if(action.type === &quot;add-budget&quot;){
                          return{
                              ...state,
                              budget: action.payload.budget
                          }
                      }
                      if(action.type === &quot;show-modal&quot;){
                          return{
                              ...state,
                              modal: true
                          }
                      }
                      if(action.type === &quot;close-modal&quot;){
                          return{
                              ...state,
                              modal: false,
                              editingId: &#39;&#39;
                          }
                      }    
                      if(action.type === &quot;add-expense&quot;){
                          const expenseconId = createExpense(action.payload.expense)
                          return{
                              ...state,
                              expenses: [...state.expenses, expenseconId],
                              modal: false
                          }
                      }
                      if(action.type === &quot;remove-expense&quot;){
                          return{
                              ...state,
                              expenses: state.expenses.filter( expense =&gt; expense.id !== action.payload.id)
                          }
                      }
                      if(action.type === &quot;get-expense-by-id&quot;){
                          return{
                              ...state,
                              editingId: action.payload.id,
                              modal: true
                          }
                      }
                      if(action.type===&quot;update-expense&quot;){
                          return{
                              ...state,
                              expenses: state.expenses.map(expense =&gt; expense.id === action.payload.expense.id ? action.payload.expense : expense),
                              modal: false,
                              editingId: &#39;&#39;
                          }
                      }
                      if(action.type == &quot;restart-app&quot; ){
                          return{
                              ...state,
                              budget: 0,
                              expenses: []
                          }
                      }
                      if(action.type === &quot;add-filter-category&quot;){
                  
                          return {
                              ...state,
                              currentCategory: action.payload.id
                          }
                      }
                  
                      return state
                  }
                </code></pre>
      
                <code class="cursor-pointer" onclick="$('#13-indexts').toggle();">types/index.ts</code>
                <pre data-line="0" id="13-indexts" class="hidden"><code class="language-ts">
                  //types&gt;index.ts
                  type ValuePiece = Date | null;
                  export type Value = ValuePiece | [ValuePiece, ValuePiece];
                  
                  export type Expense = {
                      id: string
                      expenseName: string
                      amount: number
                      category: string
                      date: Value
                  }
                  
                  export type DraftExpense = Omit&lt;Expense, &#39;id&#39;&gt;
                  
                  export type Category = {
                      id: string
                      name: string
                      icon: string
                  }
                </code></pre>              
              </div>
              
              <div class="w-[60%] max-sm:w-[100%]">
                <span class="destacado">Componentes</span><br>
                <code class="cursor-pointer" onclick="$('#13-AmountDisplay').toggle();">AmountDisplay.tsx</code>
                <pre data-line="0" id="13-AmountDisplay" class="hidden"><code class="language-ts">
                  // AmountDisplay.tsx
                  import { formatCurrency } from "../helpers"
                  type AmountDisplayProps = {
                      label?: string
                      amount: number
                  }
                  
                  export default function AmountDisplay({label, amount} : AmountDisplayProps) {
                    return (
                      &lt;p className=&quot;text-2xl text-blue-600 font-bold&quot;&gt;
                          {/* {label}: {&#39;&#39;} */}
                          {label &amp;&amp; `${label}: `}
                          &lt;span className=&quot;text-black&quot;&gt;{formatCurrency(amount)}&lt;/span&gt;
                      &lt;/p&gt;
                    )
                  } 
                </code></pre> 

                <code class="cursor-pointer" onclick="$('#13-BudgetForm').toggle();">BudgetForm.tsx</code>
                <pre data-line="0" id="13-BudgetForm" class="hidden"><code class="language-ts">
                  //BudgetForm.tsx
                  import { useState, ChangeEvent, useMemo, FormEvent } from &quot;react&quot;
                  import { useBudget } from &quot;../hooks/useBudget&quot;
                  
                  export default function BudgetForm() {
                  
                      const [budget, setBudget] = useState(0)
                      const { dispatch } = useBudget() //estas llaves son importantes porque useReducer nos retornaba state y dispatch pero en un arreglo, pero en este caso es un custom hook, tiene que ser con llaves
                  
                      const handleChange = (e: ChangeEvent&lt;HTMLInputElement&gt;) =&gt;{
                          //setBudget(+e.target.value)
                          setBudget(e.target.valueAsNumber)
                      }
                  
                      const isValid = useMemo(() =&gt;{
                          return isNaN(budget) || budget &lt;= 0
                      }, [budget])
                  
                      const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =&gt; {
                          e.preventDefault();
                          //console.log(&#39;Añadir o definir presupuesto&#39;)
                          dispatch({type: &#39;add-budget&#39;, payload: {budget}})
                      }   
                  
                      return (
                          &lt;form className=&quot;space-y-5&quot; onSubmit={handleSubmit}&gt;
                              &lt;div className=&quot;flex flex-col space-y-5&quot;&gt;
                                  &lt;label htmlFor=&quot;budget&quot; className=&quot;text-4xl text-blue-600 font-bold text-center&quot;&gt;
                                      Definir Presupuesto
                                  &lt;/label&gt;
                                  &lt;input
                                      type=&quot;number&quot;
                                      className=&quot;w-full bg-white border border-gray-200 p-2&quot;
                                      placeholder=&quot;Define tu presupuesto&quot;
                                      name=&quot;budget&quot;
                                      value={budget}
                                      onChange={handleChange }
                                  /&gt;
                              &lt;/div&gt;
                              &lt;input 
                                  type=&quot;submit&quot;
                                  value=&quot;Definir Presupuesto&quot;
                                  className=&quot;bg-blue-600 hover:bg-blue-700 cursor-pointer w-full p-2 text-white font-black uppercase disabled:opacity-40&quot;
                                  disabled={isValid}
                                  /&gt;
                          &lt;/form&gt;
                      )
                  }            
                </code></pre> 

                <code class="cursor-pointer" onclick="$('#13-BudgetTracker').toggle();">BudgetTracker.tsx</code>
                <pre data-line="0" id="13-BudgetTracker" class="hidden"><code class="language-ts">
                  //BudgetTracker.tsx
                  import { CircularProgressbar, buildStyles } from &#39;react-circular-progressbar&#39;
                  import { useBudget } from &#39;../hooks/useBudget&#39;;
                  import AmountDisplay from &#39;./AmountDisplay&#39;;
                  import &quot;react-circular-progressbar/dist/styles.css&quot;
                  
                  export default function BudgetTracker() {
                      const { state, remainingBudget, totalExpenses, dispatch } = useBudget()
                  
                      const percentage = +((totalExpenses / state.budget) * 100).toFixed(2)
                      //console.log(percentage)
                  
                      const resetApp = () =&gt;{dispatch({type: &#39;restart-app&#39;}) }
                  
                      return (
                      &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-5&quot;&gt;
                          &lt;div className=&quot;flex justify-center&quot;&gt;
                              &lt;CircularProgressbar 
                                  value={percentage}
                                  styles={buildStyles({
                                      pathColor: percentage &gt;= 80? &#39;#dc2626&#39; : &#39;#3b82f6&#39;,
                                      trailColor: &#39;#f5f5f5&#39;,
                                      textSize: 8,
                                      textColor: percentage &gt;= 80? &#39;#dc2626&#39; : &#39;#3b82f6&#39;
                                  })}
                                  text={`${percentage}% gastado`}                
                              /&gt;
                          &lt;/div&gt;
                  
                          &lt;div className=&quot;flex flex-col justify-center items-center gap-8&quot;&gt;
                              &lt;button
                                  type=&quot;button&quot;
                                  className=&#39;bg-pink-600 w-full p-2 text-white uppercase font-bold rounded-lg cursor-pointer&#39;
                                  onClick={resetApp}
                              &gt;
                                  Resetear App
                              &lt;/button&gt;
                  
                              &lt;AmountDisplay
                                  label=&quot;Presupuesto&quot;
                                  amount={state.budget}
                              /&gt;
                              &lt;AmountDisplay
                                  label=&quot;Disponible&quot;
                                  amount={remainingBudget}
                              /&gt;
                              &lt;AmountDisplay
                                  label=&quot;Gastado&quot;
                                  amount={totalExpenses}            
                              /&gt;
                          &lt;/div&gt;
                          
                      &lt;/div&gt;
                      )
                  }            
                </code></pre> 

                <code class="cursor-pointer" onclick="$('#13-ErrorMessage').toggle();">ErrorMessage.tsx</code>
                <pre data-line="0" id="13-ErrorMessage" class="hidden"><code class="language-ts">
                  //ErrorMessage.tsx
                  import { ReactNode } from &quot;react&quot;

                  type ErrorMessageProps = {
                      children: ReactNode
                  }
                  export default function ErrorMessage({children} : ErrorMessageProps) {
                    return (
                      &lt;p className=&quot;bg-red-600 p-2 text-white font-bold text-sm text-center&quot;&gt;
                          {children}
                      &lt;/p&gt;
                    )
                  }            
                </code></pre> 

                <code class="cursor-pointer" onclick="$('#13-ExpenseDetail').toggle();">ExpenseDetail.tsx</code>
                <pre data-line="0" id="13-ExpenseDetail" class="hidden"><code class="language-ts">
                  //ExpenseDetail.tsx
                  import { useMemo } from &#39;react&#39;;
                  import { LeadingActions, SwipeableList, SwipeableListItem, SwipeAction, TrailingActions} from &#39;react-swipeable-list&#39;
                  import { categories } from &#39;../data/categories&#39;;
                  import { formatDate } from &#39;../helpers&#39;;
                  import { Expense } from &#39;../types/index&#39;;
                  import AmountDisplay from &#39;./AmountDisplay&#39;;
                  import { useBudget } from &#39;../hooks/useBudget&#39;;
                  import &quot;react-swipeable-list/dist/styles.css&quot;
                  
                  type ExpenseDetailsProps = {
                      expense : Expense
                  }
                  
                  export default function ExpenseDetail({expense} : ExpenseDetailsProps) {
                  
                      const {dispatch} = useBudget()
                  
                      const categoryInfo = useMemo(() =&gt; categories.filter(cat =&gt; cat.id === expense.category)[0],[expense])
                  
                      const leadingActions = () =&gt; (
                          &lt;LeadingActions&gt;
                              &lt;SwipeAction onClick={() =&gt; dispatch({type: &quot;get-expense-by-id&quot;, payload: {id: expense.id}})}&gt;
                                  Actualizar
                              &lt;/SwipeAction&gt;
                          &lt;/LeadingActions&gt;
                      )
                      const trailingActions = () =&gt; (
                          &lt;TrailingActions&gt;
                              &lt;SwipeAction 
                                  onClick={() =&gt; dispatch({type: &#39;remove-expense&#39;, payload: {id: expense.id}})}
                                  destructive = {true}
                              &gt;
                                  Eliminar
                              &lt;/SwipeAction&gt;
                  
                          &lt;/TrailingActions&gt;
                      )
                  
                      return (
                      &lt;SwipeableList&gt;  
                          &lt;SwipeableListItem            
                              leadingActions = {leadingActions()}
                              trailingActions = {trailingActions()}
                          &gt;
                  
                              &lt;div className=&quot;bg-white shadow-lg p-5 w-full border-b border-gray-200 flex gap-4 items-center&quot;&gt;
                                  &lt;div&gt;
                                      &lt;img 
                                          src={`./icono_${categoryInfo.icon}.svg`} 
                                          alt=&quot;icono gasto&quot;
                                          className=&#39;w-20&#39;
                                      /&gt;
                                  &lt;/div&gt;
                  
                                  &lt;div className=&#39;flex-1 space-y-2&#39;&gt;
                                      &lt;p className=&quot;text-sm font-bold uppercase text-slate-500&quot;&gt;{categoryInfo.name}&lt;/p&gt;
                                      &lt;p&gt;{expense.expenseName}&lt;/p&gt;
                                      &lt;p className=&quot;text-slate-600 text-sm&quot;&gt;{ formatDate( expense.date!.toString() ) }&lt;/p&gt;
                                  &lt;/div&gt;
                  
                                  &lt;AmountDisplay
                                      amount={expense.amount}
                                  /&gt;
                              &lt;/div&gt;
                  
                          &lt;/SwipeableListItem&gt;
                      &lt;/SwipeableList&gt;
                      )
                  }              
                </code></pre> 

                <code class="cursor-pointer" onclick="$('#13-ExpenseForm').toggle();">ExpenseForm.tsx</code>
                <pre data-line="0" id="13-ExpenseForm" class="hidden"><code class="language-ts">
                  //ExpenseForm.tsx
                  import { ChangeEvent, FormEvent, useEffect, useState } from &quot;react&quot;;
                  import type { DraftExpense, Value } from &quot;../types&quot;;
                  import { categories } from &quot;../data/categories&quot;;
                  import DatePicker from &#39;react-date-picker&#39;;
                  import &#39;react-date-picker/dist/DatePicker.css&#39;;
                  import &#39;react-calendar/dist/Calendar.css&#39;;
                  import ErrorMessage from &quot;./ErrorMessage&quot;;
                  import { useBudget } from &quot;../hooks/useBudget&quot;;
                  
                  export default function ExpenseForm() {
                  
                    const [expense, setExpense] = useState&lt;DraftExpense&gt;({
                      amount: 0,
                      expenseName: &#39;&#39;,
                      category: &#39;&#39;,
                      date: new Date()
                    })
                  
                    const [error, setError] = useState(&#39;&#39;)
                    const [previousAmount, setPreviousAmount] = useState(0)
                    const { dispatch, state, remainingBudget } = useBudget()
                  
                    useEffect(() =&gt; {
                      if(state.editingId){
                        const editingExpense = state.expenses.filter( currentExpense =&gt; currentExpense.id === state.editingId)[0]
                        setExpense(editingExpense)
                        setPreviousAmount(editingExpense.amount)
                      }
                    },[state.editingId])
                  
                    const handleChange = (e: ChangeEvent&lt;HTMLInputElement&gt; | ChangeEvent&lt;HTMLSelectElement&gt;) =&gt; {
                      const { name, value } = e.target //extraemos name y value de cada campo de formulario
                      const isAmountField = [&#39;amount&#39;].includes(name) //true si estamos escribiendo en amount y false si escribimos en gasto o seleccionamos categoría
                      //console.log(isAmountField)
                      setExpense({
                        ...expense,
                        [name] : isAmountField ? +value : value
                      })
                    }
                  
                    const handleChangeDate = (value : Value) =&gt;{
                      //console.log(value)
                      setExpense({
                        ...expense,
                        date: value
                      })
                    }
                  
                    const handleSubmit = (e: FormEvent&lt;HTMLFormElement&gt;) =&gt; {
                      e.preventDefault()
                  
                      //validar
                      if(Object.values(expense).includes(&#39;&#39;)){
                        setError(&#39;Todos los campos son obligatorios&#39;)
                        return
                      }
                  
                      //Validar que no me pase del presupuesto
                      if( (expense.amount-previousAmount) &gt; remainingBudget){
                        setError(&#39;Ese gasto es mayor que lo que resta de Presupuesto&#39;)
                        return
                      }
                  
                      //Agregar un nuevo gasto o actualizar uno existente
                      if(state.editingId){
                        dispatch({type: &#39;update-expense&#39;, payload: {expense: {id: state.editingId, ...expense}} })
                      }else{
                        dispatch({type: &#39;add-expense&#39;, payload: {expense}})
                      }
                  
                      //reiniciar el state
                      setExpense({
                        amount: 0,
                        expenseName: &#39;&#39;,
                        category: &#39;&#39;,
                        date: new Date()
                      })
                      setPreviousAmount(0)
                    }
                  
                    return (
                      &lt;form className=&quot;space-y-5&quot; onSubmit={handleSubmit}&gt;
                        &lt;legend
                          className=&quot;uppercase text-center text-2xl font-black border-b-4 border-blue-500 py-2&quot;
                        &gt;{state.editingId ? &#39;Guardar Cambios&#39; : &#39;Nuevo gasto&#39;}&lt;/legend&gt;
                  
                        {error &amp;&amp; &lt;ErrorMessage&gt;{error}&lt;/ErrorMessage&gt;}
                  
                        &lt;div className=&quot;flex flex-col gap-2&quot;&gt;
                          &lt;label 
                            htmlFor=&quot;expenseName&quot;
                            className=&quot;text-xl&quot;&gt;
                            Nombre gasto:
                          &lt;/label&gt;
                          &lt;input 
                            type=&quot;text&quot;
                            id=&quot;expenseName&quot;
                            placeholder=&quot;Añade el nombre del gasto&quot;
                            className=&quot;bg-slate-100 p-2&quot;
                            name=&quot;expenseName&quot;
                            value={expense.expenseName} 
                            onChange={handleChange}
                          /&gt;
                        &lt;/div&gt;
                  
                        &lt;div className=&quot;flex flex-col gap-2&quot;&gt;
                          &lt;label 
                            htmlFor=&quot;amount&quot;
                            className=&quot;text-xl&quot;&gt;
                            Cantidad:
                          &lt;/label&gt;
                          &lt;input 
                            type=&quot;number&quot;
                            id=&quot;amount&quot;
                            placeholder=&quot;Añade la cantidad del gasto: ej. 300&quot;
                            className=&quot;bg-slate-100 p-2&quot;
                            name=&quot;amount&quot;
                            value={expense.amount} 
                            onChange={handleChange}
                            /&gt;
                        &lt;/div&gt;
                  
                        &lt;div className=&quot;flex flex-col gap-2&quot;&gt;
                          &lt;label 
                            htmlFor=&quot;category&quot;
                            className=&quot;text-xl&quot;&gt;
                            Categoría:
                          &lt;/label&gt;
                          &lt;select 
                            id=&quot;category&quot;
                            className=&quot;bg-slate-100 p-2&quot;
                            name=&quot;category&quot; 
                            value={expense.category}
                            onChange={handleChange}
                            &gt;
                              &lt;option value=&quot;&quot;&gt;-- Selecciona --&lt;/option&gt;
                              {categories.map(category =&gt; (
                                &lt;option 
                                  key={category.id}
                                  value={category.id}
                                  &gt;{category.name}&lt;/option&gt;
                              ))}
                            &lt;/select&gt;
                        &lt;/div&gt;
                  
                        &lt;div className=&quot;flex flex-col gap-2&quot;&gt;
                          &lt;label 
                            htmlFor=&quot;amount&quot;
                            className=&quot;text-xl&quot;&gt;
                            Fecha gasto:
                          &lt;/label&gt;
                          &lt;DatePicker
                            className=&quot;bg-slate-100 p-2 border-0&quot;
                            value={expense.date}
                            onChange={handleChangeDate}
                          /&gt;
                        &lt;/div&gt;
                        
                        &lt;input 
                          type=&quot;submit&quot; 
                          className=&quot;bg-blue-600 cursor-pointer w-full p-2 text-white uppercase font-bold rounded-lg&quot;
                          value={state.editingId ? &#39;Guardar Cambios&#39; : &#39;Registrar gasto&#39;}
                        /&gt;
                  
                      &lt;/form&gt;
                    )
                  }            
                </code></pre> 

                <code class="cursor-pointer" onclick="$('#13-ExpenseList').toggle();">ExpenseList.tsx</code>
                <pre data-line="0" id="13-ExpenseList" class="hidden"><code class="language-ts">
                  //ExpenseList.tsx
                  import { useMemo } from &quot;react&quot;
                  import { useBudget } from &quot;../hooks/useBudget&quot;
                  import ExpenseDetail from &quot;./ExpenseDetail&quot;
                  
                  export default function ExpenseList() {
                  
                      const { state } = useBudget()    
                      const filteredExpenses = state.currentCategory ? state.expenses.filter( expense =&gt; expense.category === state.currentCategory) : state.expenses
                      // const isEmpty = useMemo(() =&gt; state.expenses.length === 0, [state.expenses])
                      const isEmpty = useMemo(() =&gt; filteredExpenses.length === 0, [filteredExpenses])
                      
                      return (
                          &lt;div className=&quot;mt-10 bg-white shadow-lg rounded-lg p-5&quot;&gt;
                              {isEmpty ? &lt;p className=&quot;text-gray-600 text-2xl font-bold&quot;&gt;No hay gastos&lt;/p&gt; : (
                                  &lt;&gt;
                                      &lt;p className=&quot;text-gray-600 text-2xl font-bold mb-5&quot;&gt;Listado de gastos.&lt;/p&gt;
                                      {/* {state.expenses.map( expense =&gt; ( */}
                                      {filteredExpenses.map( expense =&gt; (
                                          &lt;ExpenseDetail
                                              key = {expense.id}
                                              expense = {expense}
                                          /&gt;
                                      ))}
                                  &lt;/&gt;
                              )}
                          &lt;/div&gt;
                      )
                  }            
                </code></pre> 

                <code class="cursor-pointer" onclick="$('#13-ExpenseModal').toggle();">ExpenseModal.tsx</code>
                <pre data-line="0" id="13-ExpenseModal" class="hidden"><code class="language-ts">
                  //ExpenseModal.tsx
                  import { Fragment } from &#39;react&#39;
                  import { PlusCircleIcon } from &#39;@heroicons/react/24/solid&#39;
                  import { Dialog, Transition } from &#39;@headlessui/react&#39;
                  import { useBudget } from &#39;../hooks/useBudget&#39;
                  import ExpenseForm from &#39;./ExpenseForm&#39;;
                  
                  export default function ExpenseModal() {
                  
                    const { state, dispatch } = useBudget()
                  
                    return (
                      &lt;&gt;
                        &lt;div className=&quot;fixed right-5 bottom-5 flex items-center justify-center&quot;&gt;
                          &lt;button
                            type=&quot;button&quot;
                            onClick={() =&gt; dispatch({type:&#39;show-modal&#39;})}
                          &gt;
                            &lt;PlusCircleIcon className=&#39;w-16 h-16 text-blue-600 rounded-full&#39; /&gt;
                          &lt;/button&gt;
                        &lt;/div&gt;
                  
                        &lt;Transition appear show={state.modal} as={Fragment}&gt;
                          &lt;Dialog as=&quot;div&quot; className=&quot;relative z-10&quot; onClose={() =&gt; dispatch({type : &#39;close-modal&#39;})}&gt;
                            &lt;Transition.Child
                              as={Fragment}
                              enter=&quot;ease-out duration-300&quot;
                              enterFrom=&quot;opacity-0&quot;
                              enterTo=&quot;opacity-100&quot;
                              leave=&quot;ease-in duration-200&quot;
                              leaveFrom=&quot;opacity-100&quot;
                              leaveTo=&quot;opacity-0&quot;
                            &gt;
                              &lt;div className=&quot;fixed inset-0 bg-black opacity-65&quot; /&gt;
                            &lt;/Transition.Child&gt;
                  
                            &lt;div className=&quot;fixed inset-0 overflow-y-auto&quot;&gt;
                              &lt;div className=&quot;flex min-h-full items-center justify-center p-4 text-center&quot;&gt;
                                &lt;Transition.Child
                                  as={Fragment}
                                  enter=&quot;ease-out duration-300&quot;
                                  enterFrom=&quot;opacity-0 scale-95&quot;
                                  enterTo=&quot;opacity-100 scale-100&quot;
                                  leave=&quot;ease-in duration-200&quot;
                                  leaveFrom=&quot;opacity-100 scale-100&quot;
                                  leaveTo=&quot;opacity-0 scale-95&quot;
                                &gt;
                                  &lt;Dialog.Panel className=&quot;w-full max-w-3xl transform overflow-hidden rounded-2xl bg-white p-6 text-left align-middle shadow-xl transition-all&quot;&gt;
                      
                                    &lt;ExpenseForm /&gt;
                      
                                  &lt;/Dialog.Panel&gt;
                                &lt;/Transition.Child&gt;
                              &lt;/div&gt;
                            &lt;/div&gt;
                          &lt;/Dialog&gt;
                        &lt;/Transition&gt;
                      &lt;/&gt;
                    )
                  }  
                </code></pre> 

                <code class="cursor-pointer" onclick="$('#13-FilterByCategory').toggle();">FilterByCategory.tsx</code>
                <pre data-line="0" id="13-FilterByCategory" class="hidden"><code class="language-ts">
                //FilterByCategory.tsx
                import { ChangeEvent } from &quot;react&quot;;
                import { categories } from &quot;../data/categories&quot;;
                import { useBudget } from &quot;../hooks/useBudget&quot;;
                
                export default function FilterByCategory() {
                
                    const { dispatch } = useBudget() 
                
                    const handleChange = (e: ChangeEvent&lt;HTMLSelectElement&gt;) =&gt; {
                        dispatch({type: &quot;add-filter-category&quot;, payload: {id: e.target.value}})
                    }
                  return (
                    &lt;div className=&quot;bg-white shadow-lg rounded-lg p-10&quot;&gt;
                      &lt;form action=&quot;&quot;&gt;
                        &lt;div className=&quot;flex flex-col md:flex-row md:items-center gap-5&quot;&gt;
                            &lt;label htmlFor=&quot;category&quot;&gt;Filtrar gastos&lt;/label&gt;
                            &lt;select 
                                id=&quot;category&quot;
                                className=&quot;bg-slate-100 p-3 flex-1 rounded&quot;
                                onChange={handleChange}
                            &gt;
                                &lt;option value=&quot;&quot;&gt;-- Todas las categorías&lt;/option&gt;
                                {categories.map(category =&gt; (
                                    &lt;option 
                                        key={category.id}
                                        value={category.id}
                                    &gt;
                                        {category.name}
                                    &lt;/option&gt;
                                ))}
                            &lt;/select&gt;
                        &lt;/div&gt;
                      &lt;/form&gt;
                    &lt;/div&gt;
                  )
                }              
                </code></pre> 

                
              </div>
            </div>

          </div>


          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-188').toggle();">
            <h3>188. El Proyecto que vamos a construir</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-188" class="hidden">
            <p>Vamos a hacer un <span class="destacado">planificador de gastos</span>. <strong>Va a ser el proyecto más complejo hasta ahora pero pone en práctica todo lo que hemos aprendido.</strong> <strong>Su backend (también hecho con typescrpt) lo hace en el curso que tiene de node.js</strong>. Podemos definir un presupuesto, por ejemplo para el mes, tendremos <span class="destacado">validación de formulario</span> para que no nos deje escribir letras ni negativos... Podremos filtrar los gastos por categorías, al pulsar el "+" inferior aparece una <span class="destacado">ventana modal que utiliza Headless UI: un framework de React de los colaboradores de Tailwindcss</span>. Vamos registrando gastos y vemos como se va actualizando la información con lo gastado, disponible... además tenemos un filtro de los gastos ya registrados. También podemos quitar gastos ya añadidos arrastrando a la izquierda o actualizarlos arrastrando a la derecha (en ese caso aparece el modal panel con el formulario completo con los datos de la actividad registrada que vamos a modificar). <span class="destacado">Son gastos persistentes, van a esta en LocalStorage</span> y, digamos que ya pasó la semana, reseteamos la app y definimos otro presupuesto para volver a calcular los gastos de la semana</p>

            <p>Este proyecto <span class="destacado">tiene un state más complejo pero nos apoyamos en useReducer y <strong>contextAPI</strong></span></p>

            <img class="mx-auto" src="./src/assets/img/188-planificador-gastos.jpg" alt="img" loading="lazy">

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-189').toggle();">
            <h3>189. Creando el Proyecto y Copiando Materiales / 190. Instalando TailwindCSS</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-189" class="hidden">
            <p>Proyecto nuevo. Usamos useReducer pero tambien estaremos agregando <span class="destacado">contextAPI para tener un estado global en nuestras aplicaciones y no tener que pasar todo via props</span>. Lo veremos a continuación el cómo se agrega a nuestro proyecto.</p>

            <ul class="list-disc my-2.5">
              <li>npm create vite@latest</li>
              <li>control-gastos-contextapi</li>
              <li>TS + SWC</li>
              <li>npm install</li>
              <li>limpiamos (borramos src, borramos app.css ya que usaremos tailwindcss (estandar en apps de React (Next.js y otros frameworks ya lo incluyen)) limpiamos app.tsx, limpiamos index.css...)</li>
              <li>Descomprimos "Materiales+Control.zip" y todos esos iconos necesarios que están ahí los colocamos en la carpeta public de nuestro proyecto.</li>
              <li>instalamos tailwind: <a class="underline" href="https://tailwindcss.com/docs/installation/using-vite" target="_blank">https://tailwindcss.com/docs/installation/using-vite</a> 
                <ul class="mb-3.75">
                  <li><span class="destacado">npm install tailwindcss @tailwindcss/vite</span></li>
                  <li>configurar el plugin: 
                    <div class="code-toolbar"><pre class="language-js" tabindex="0"><code class="language-js"><span class="token comment">//vite.config.ts</span>
  <span class="token keyword module keyword-import">import</span> <span class="token imports">tailwindcss</span> <span class="token keyword module keyword-from">from</span> <span class="token string">'@tailwindcss/vite'</span>
  <span class="token keyword module keyword-export">export</span> <span class="token keyword module keyword-default">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token function">tailwindcss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><div class="toolbar"><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" data-copy-state="copy"><span>Copy</span></button></div></div></div>
                  </li>
                  <li>importar tailwindcss en nuestra css principal: 
                    <div class="code-toolbar"><pre class="language-js" tabindex="0"><code class="language-js"><span class="token comment">//src&gt;index.css</span>
  @<span class="token keyword module keyword-import">import</span> <span class="token string">"tailwindcss"</span><span class="token punctuation">;</span></code></pre><div class="toolbar"><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" data-copy-state="copy"><span>Copy</span></button></div></div></div>
                  </li>
                </ul>                   
              </li>
              <li>Tenemos que instalar @heroicons <span class="destacado">npm install @heroicons/react</span> y @headlessui <span class="destacado">npm install @headlessui/react</span> en el vídeo 202. También <span class="destacado">npm install uuid</span> en el vídeo 210. <span class="destacado">npm i react-swipeable-list</span> para lista swipeable del vídeo 215. --&gt; 
                <br><span class="rojo">OJO me daba este error y blancazo interfaz:</span><br> 16:44:03 [vite] (client) error while updating dependencies:<br>
                Error: Build failed with 1 error:<br>
                node_modules/react-swipeable-list/dist/react-swipeable-list.esm.js:2:22: ERROR: Could not resolve "prop-types"
                <br><span class="verde">Solucionado con</span> <br>
                As of React 15.5.0, PropTypes have been removed from the core React package as a separate dependency. To fix this, add prop-types into your code:

                If you're loading via script tags:<br>

                &lt;script src=&quot;https://unpkg.com/prop-types/prop-types.min.js&quot;&gt;&lt;/script&gt;
                Or via NPM:<br>

                <span class="destacado">npm install --save prop-types</span><br>
                En el vídeo 224 instala <span class="destacado">npm i react-circular-progressbar</span>
              
              
              </li>
            </ul>
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-191').toggle();">
            <h3>191. Creando los Primeros Componentes</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-191" class="hidden">
            <p>Vamos a empezar a trabajar con la interfaz.</p>

            <p>De momento nuestra App.tsx queda así:</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-ts">
                  //App.tsx
                  &lt;header className=&quot;bg-blue-600 py-8 max-h-72&quot;&gt;
                    &lt;h1 className=&quot;uppercase text-center font-black text-4xl text-white&quot;&gt;Planificador de gastos&lt;/h1&gt;
                  &lt;/header&gt;
            
                  &lt;div className=&quot;max-w-3xl mx-auto bg-white shadow-lg rounded-lg mt-10 p-10&quot;&gt;
                    &lt;p&gt;Formulario aquí&lt;/p&gt;
                  &lt;/div&gt;
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%] ml-2">
                <img src="./src/assets/img/192.png" alt="img" loading="lazy">
              </div>
            </div>

            <p><strong>En el minuto 2 cuenta como le ha convencido tailwindcss empezó como frontend y hacía guías de estilo, adaptando bootstrap a loq ue pedían... muy bueno ESCUCHARLO</strong></p>

            <p>Hacemos nuestra carpeta components y creamos el primero <strong>BudgetForm.tsx:</strong> que va a contener el formulario para que el usuario defina su presupuesto (y comenzar a agregar gastos y controlarlo). Agregamos el tag de este nuevo componente en nuestro compo ppal App.tsx</p>
            

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-192').toggle();">
            <h3>192. Creando el Formulario para Definir el presupuesto / 193. Validando el presupuesto / 194. Creando el Reducer para Presupuestos</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-192" class="hidden">
            <p>Solo va a tener <strong>un campo para introducir la cantidad del presupuesto y un submit</strong>. Ese input va a tener el id="budget" y name="budget". Si recordamos en el ejemplo anterior cuando leíamos el state utilizábamos e.target.id pero si le ponemos un name podemos leer con e.target.name, que es otra forma de hacerlo (ninguna de las 2 sería necesaria, con e.target.value lo sacaríamos)</p>

            <p>Requerimos un state local para validar ese formulario y en caso de que pase la validación ya escribimos en nuestro reducer, por lo que importamos useState y lo definimos con valor inicial de 0. Lo usamos en el value de nuestro input numérico y así inicia en 0 nuestro formulario.</p>

            <p>Escribimos en nuestro state: <strong>creamos la nueva variable handleChange</strong> como arrow function y <strong>el tipo del parámetro e lo sacamos infiriendo</strong> de la siguiente manera: poniendo en el input un <code class="language-js">onChange={e =>}</code> y poniéndonos encima de la e (nos lo dice el IS no tenemos que memorizar nada). Utilizamos la función del state para setear en el state el value de nuestro campo, <strong>Ojo! el state lo iniciamos como número, si le ponemos simplemente 'e.target.value' da un error al indicarnos que es un string y no se puede, para pasarlo a número podemos usar cualquiera de las dos formas vistas, con el '+' o con el 'valueAsNumber'(en este caso sí podemos usarlo, solo daba problemas con radios)</strong></p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="5,7-10,22,23"><code class="language-js">
                  //BudgetForm.tsx                  
                  import { useState, ChangeEvent } from "react"

                  export default function BudgetForm() {

                      const [budget, setBudget] = useState(0)

                      const handleChange = (e: ChangeEvent&lt;HTMLInputElement&gt;) =>{
                          //setBudget(+e.target.value)
                          setBudget(+e.target.valueAsNumber)
                      }
                      return (
                          &lt;form className=&quot;space-y-5&quot;&gt;
                              &lt;div className=&quot;flex flex-col space-y-5&quot;&gt;
                                  &lt;label htmlFor=&quot;budget&quot; className=&quot;text-4xl text-blue-600 font-bold text-center&quot;&gt;
                                      Definir Presupuesto
                                  &lt;/label&gt;
                                  &lt;input
                                      type=&quot;number&quot;
                                      className=&quot;w-full bg-white border border-gray-200 p-2&quot;
                                      placeholder=&quot;Define tu presupuesto&quot;
                                      name=&quot;budget&quot;
                                      value={budget}
                                      onChange={handleChange}
                                  /&gt;
                              &lt;/div&gt;
                              &lt;input 
                                  type=&quot;submit&quot;
                                  value=&quot;Definir Presupuesto&quot;
                                  className=&quot;bg-blue-600 hover:bg-blue-700 cursor-pointer w-full p-2 text-white font-black uppercase&quot;
                                  /&gt;
                          &lt;/form&gt;
                      )
                  }
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%] ml-2">
                <img src="./src/assets/img/192-2.png" alt="img" loading="lazy">
              </div>
            </div>

            <p class="naranja">Validando el Presupuesto</p>

            <p>Como vemos puede ser que esté a 0 o incluso borremos la cantidad(string vacío) y el botón sigue activo, no queremos eso, vamos a validar que sean números y mayores a 0. creamos la función 'isValid' y usamos useMemo() usando como dependencia nuestro state local budget para que, <strong>solo cuando el usuario escriba se ejecute esa función</strong>. Si miramos con un <code class="language-js">console.log(isNaN(budget))</code> <strong>vemos que nos devuelve true cuando no es número. Podemos usar esa información para controlar el disabled del botón submit</strong></p>

            <p>Si los formularios son más complicados utilizaremos librerías para validación de formularios.</p>

            <pre data-line="12-14,35"><code class="language-js">
              //BudgetForm.tsx
              import { useState, ChangeEvent, useMemo } from "react"

              export default function BudgetForm() {

                  const [budget, setBudget] = useState(0)

                  const handleChange = (e: ChangeEvent&lt;HTMLInputElement&gt;) =&gt;{
                      //setBudget(+e.target.value)
                      setBudget(e.target.valueAsNumber)
                  }

                  const isValid = useMemo(() =&gt;{
                      return isNaN(budget) || budget &lt;= 0
                  }, [budget])

                  return (
                      &lt;form className=&quot;space-y-5&quot;&gt;
                          &lt;div className=&quot;flex flex-col space-y-5&quot;&gt;
                              &lt;label htmlFor=&quot;budget&quot; className=&quot;text-4xl text-blue-600 font-bold text-center&quot;&gt;
                                  Definir Presupuesto
                              &lt;/label&gt;
                              &lt;input
                                  type=&quot;number&quot;
                                  className=&quot;w-full bg-white border border-gray-200 p-2&quot;
                                  placeholder=&quot;Define tu presupuesto&quot;
                                  name=&quot;budget&quot;
                                  value={budget}
                                  onChange={handleChange }
                              /&gt;
                          &lt;/div&gt;
                          &lt;input 
                              type=&quot;submit&quot;
                              value=&quot;Definir Presupuesto&quot;
                              className=&quot;bg-blue-600 hover:bg-blue-700 cursor-pointer w-full p-2 text-white font-black uppercase disabled:opacity-40&quot;
                              disabled={isValid}
                              /&gt;
                      &lt;/form&gt;
                  )
              }
            </code></pre>

            <p>Supongamos que introducimos un valor de presupuesto válido. Lo queremos tener en el reducer para ir controlando todo mi state, así que vamos a crear el reducer de esta aplicación</p>
            
            <p class="naranja">Creando el Reducer para Presupuestos</p>

            <p>Creamos <span class="file">reducers&gt;budget-reducer.ts</span> donde lo vamos a controlar todo presupuesto, gastos, editarlos, eliminarlos, reiniciar la aplicación y también vamos a filtrar por categoría porque son todo elementos que pertenecen a estos gastos y presupuesto.</p>

            <p>el primer type va a ser lo que tenemos en nuestro state local del compo BudgetForm.tsx <code class="language-js">const [budget, setBudget] = useState(0)</code>. El form va a tener un onSubmit y es cuando lo vamos a escribir.</p>

            <pre><code class="language-js">
              //budget-reducer.ts
              export type BudgetActions = 
              { type: 'add-budget', payload: {budget: number} }
          
              export type BudgetState = {
                  budget: number
              }
              
              export const initialState: BudgetState = {
                  budget: 0
              }
              
              export const budgetReducer = (
                      state: BudgetState=initialState,
                      action: BudgetActions
                  ) =>{
              
                  if(action.type === "add-budget"){
              
                      return{
                          ...state,
                          budget: action.payload.budget
                      }
                  }
              
                  return state
              }
            </code></pre>

            <p>Hasta ahora lo que hemos hecho para escribir aquí es: ir a la App.tsx (que es donde nace nuestra aplicación) e importar useReducer, el state inicial, el reducer que acabamos de crear y extraemos tanto state como dispatch y pasamos ya sea state o funciones de tipo dispatch a nuestros componentes. Eso está bien pero podemos evitar estar pasando esos props de state y dispatch a los componentes utilizando contextApi o algún manejador de estados globales</p>

          </div>         
            
          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-195').toggle();">
            <h3>195. Introducción a ContextAPI</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-195" class="hidden">
            <p>Si el proyecto comienza a ser más complejo, tener un estado global nos va a ahorrar muchas líneas de código. Context API ya viene incluído en React y nos permite manejar un estado global sin instalar dependencias (porque hay varias opciones que sí requieren ser instaladas)</p>

            <ul class="list-disc my-2.5">
              <li><strong>Nos va a permitir tener un estado global en tu aplicación. Esto quiere decir que solo se tiene una instancia del State que se puede acceder desde cualquier componente sin pasarlo por diferentes componentes vía props.</strong> Si colocamos un state en un custom hook o en un reducer, lo que hemos hecho es tenerlo en el App.tsx y de ahí pasamos todo vía props. Si comenzamos a instanciar ese reducer o ese custom hook, veremos que se crean múltiples instancias de ese state por lo tanto las funciones no se pueden comunicar correctamente, solo se comunican con el state que fue instanciado ya sea via custom hook o custom reducer. Esto es lo que se soluciona con <strong>Context API: solo tendremos una instancia de nuestra aplicación</strong></li>
              <li><strong>El hook para utilizarlo es useContext</strong></li>
              <li><strong>Muchas librerías utilizan Context API</strong> muchas veces instalamos algo y ya solo es importarlo para que funcione correctamente. Una forma de poder hacerlo es con Context API porque ya viene incluido con React a diferencia de otras opciones como Redux Toolkit o Zustand</li>
            </ul>

            <p>Veamos un ejemplo. Actualmente tenemos nuestra aplicación de esta forma, y si tenemos un state de productos tenemos que pasarlo de App a tienda y de Tienda a productos. Con useContext lo podemos pasar directamente de App a Productos o simplemente llamarlo directamente en productos y va a funcionar sin problema. <strong>Por tanto lo principal es que nos va a evitar estar pasando via props ya sea state o dispatch porque podemos instanciarlo directamente.</strong></p>

            <img src="./src/assets/img/195.png" alt="img" loading="lazy">

            <p>Alternativas a Context API</p>

            <ul class="list-disc my-2.5">
              <li>Algo muy bueno de Context API es que no requiere dependencias pero su boilerplate para configurarlo (su configuración) puede ser algo complejo, de hecho vamos a crear nuestro context y también un custom hook para poder acceder a ese context</li>
              <li>Otras alternativas son Zustand o Redux Toolkit, que también los veremos a continuación en el curso</li>
            </ul>

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-196').toggle();">
            <h3>196. Definiendo el Context</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-196" class="hidden">
            <p>Vamos a crear nuestro context y el nombrado es como si fuera una clase (el reducer con minúsculas y guion, recordemos <span class="file">reducers&gt;budget-reducer.ts</span>) <span class="file">context&gt;BudgetContext.tsx</span> </p>

            <ul class="list-disc my-2.5">
              <li><strong>Creamos nuestro provider (de donde vienen los datos)</strong> y los datos van a venir de nuestro reducer pero tenemos que agregarlo para tener de esa forma acceso al estado y a las funciones que modifican nuestro state. arrow function porque retorna algo. 
                <ul class="list-disc my-2.5">
                  <li class="my-2.5">Para acceder al state y las acciones de nuestro reducer, hemos de instanciar aquí nuestro reducer (aquí podríamos usar useState y useEffect pero lo estamos haciendo con un reducer) para lo cual importamos useReducer, budgetReducer y el initialState. Y a continuación instanciamos: <code class="language-ts">const[state, dispatch] = useReducer(budgetReducer, initialState)</code></li>
                  <li class="my-2.5">En el return() le vamos a pasar el state y el dispatch. <strong>Siempre que utilicemos nuestro provider, vamos a tener acceso a nuestro reducer y a las funciones de ese reducer, en este caso al dispatch.</strong> Pero para ello <strong>tenemos que crear el context </strong>porque esto que llevamos escrito
                    <pre><code class="language-ts">
                      import { useReducer, createContext } from 'react';
                      import { budgetReducer, initialState } from "../reducers/budget-reducer"
                      
                      export const BudgetProvider = () => {
                      
                          const[state, dispatch] = useReducer(budgetReducer, initialState)
                      
                          return(
                              
                          )
                      
                      }
                    </code></pre>
                    es solamente la sintaxis para poder acceder a la información y poder utilizar la sintaxis de React.</li>
                    <li>Creamos nuestro context con una función especial que se llama <span class="destacado">createContext</span> <code class="language-ts">import { useReducer, createContext } from 'react';</code> <code class="language-ts">export const BudgetContext = createContext()</code> como vemos nos da error porque se espera un argumento que es su valor por default. Lo primero que tenemos que decirle es qué va a manejar este provider, que en este caso maneja state y dispatch por lo tanto creamos un type (como hacíamos para tipar las propiedades en los compos) que llamamos BudgetContextProps. Vamos a manejar el state y ahí es donde se conectan tanto el context (la acción de tener el estado global) como el provider (los datos que va a tener ese context). Ponemos 'state:'' y 'dispatch:' porque es lo que va a manejar este provider. Con este type, este context sabe qué es lo que tiene que tener registrado, y al tener esos props tenemos el autocompletado y va a estar sincronizado tanto el context (qué tiene que manejar) como el provider (qué datos tiene que manejar). Para completar esos tipos inferimos de <code class="language-ts">const[state, dispatch] = useReducer(budgetReducer, initialState)</code>
                    <pre><code class="language-ts">
                      type BudgetContextProps = {
                        state:  BudgetState
                        dispatch: Dispatch&lt;BudgetActions&gt;
                    }
                  </code></pre>
                    así es como le hacemos saber estos props a nuestro createContext(), que nuestro provider va a manejar tanto state como dispatch con esas acciones de este reducer. Le aplicamos ese tipo con un generic a nuestro context <code class="language-ts">export const BudgetContext = createContext<BudgetContextProps>()</code> y de esa forma nuestro context va a saber que tenemos state y dispatch, de donde vienen y el provider tiene el acceso ya a la información. Sin embargo vemos que sigue marcando rojo porque espera un argumento. <strong>Escribir context es un poco complicado con Typescript como vemos pero tenemos dos opciones que podemos usar:</strong>
                      <ul class="list-disc my-2.5">
                        <li><code class="language-ts">export const BudgetContext = createContext&lt;BudgetContextProps&gt;({} as BudgetContextProps)</code> Crear un objeto vacío y ponerle un as para "castearlo" como BudgetContextProps --&gt; le decimos a TS "confía en mí, se lo que hago y te voy a pasar correctamente state y dispatch"</li>
                        <li><code class="language-ts">export const BudgetContext = createContext&lt;BudgetContextProps&gt;(null!)</code> esta es otra forma aceptada por la comunidad y lo importante es que desaparece el error y podamos continuar</li>
                      </ul>
                      
                      <pre><code class="language-ts">
                        //BudgetContext.tsx
                        import { useReducer, createContext, Dispatch } from &#39;react&#39;;
                        import { BudgetState, BudgetActions, budgetReducer, initialState } from &quot;../reducers/budget-reducer&quot;
                        
                        type BudgetContextProps = {
                            state:  BudgetState
                            dispatch: Dispatch&lt;BudgetActions&gt;
                        }
                        
                        export const BudgetContext = createContext&lt;BudgetContextProps&gt;({} as BudgetContextProps)
                        
                        export const BudgetProvider = () =&gt; {
                        
                            const[state, dispatch] = useReducer(budgetReducer, initialState)
                        
                            return(
                        
                            )
                        
                        }
                      </code></pre>
                    
                  </li> 
                </ul>            
              </li>
              
            </ul>

            <p><strong>Tenemos nuestros BudgetContext y BudgetProvider. Actualmente lo que los conecta, lo que le dice a este context que este provider va a manejar este state y dispatch es el type &lt;BudgetContextProps&gt;, pero son dos funciones independientes, como tal no están conectadas</strong>, solo le estamos diciendo a nuestro context que el provider va a tener un state y un dispatch, (porque los types al final solo son para darle información pero no hacen nada en tu código solo dan información de como se relacionan ciertos datos o qué esperar de ciertos datos). <strong>Por lo tanto en el return del BudgetProvider lo que hacemos es colocar este BudgetContext con sintaxis de componente y pasaremos state y dispatch y de esa forma cuando instanciemos o utilicemos nuestro context vamos a tener acceso a state y dispatch.</strong></p>

            <pre><code class="language-ts">
              &lt;BudgetContext.Provider&gt;
              
              &lt;/BudgetContext.Provider&gt;
            </code></pre>

            <p>Como decimos, es como sintaxis de componente lo que va a hacer es rodear toda nuestra aplicación de React y dentro va  aser muy simple tener acceso al state y al dispatch ¿Cómo vamos a poder utilizar este código en los otros componentes? ahí es donde entra algo llamado <span class="destacado">children</span> <code class="language-ts">export const BudgetProvider = ({children}) => {</code> <strong>¿Qué es children?</strong> Veámoslo con un ejemplo fácil: supongamos que estamos en el App.tsx y tenemos un párrafo y diferentes componentes, esos componentes serían hijos de ese párrafo y <strong>children es un prop especial que existe en React que hace referencia a los hijos de un componente.</strong> Como no sabemos (o puede ser que a futuro no sepamos) como se llaman esos componentes, existe ese prop especial que va a hacer referencia a todos los hijos de un componente</p>

              <pre><code class="language-ts">
                &lt;p&gt;
                  &lt;BudgetForm /&gt;
                  &lt;BudgetForm /&gt;
                  &lt;BudgetForm /&gt;
                &lt;/p&gt;
              </code></pre>
            
            <p>y eso es lo que le pasamos en el return: Vemos que hasta ahora nos saldrían dos errores:</p>

            <ul class="list-disc my-2.5">
              <li>1º - el children está marcado como any</li>
              <li>2º - el provider no está retornando nada, nos dice que hace falta la propiedad value. Es un prop especial que existe en provider</li>
            </ul>

            <img src="./src/assets/img/196.png" alt="img" loading="lazy">

            <p><strong>ese prop value siempre es un objeto y aunque es un objeto retornamos otro objeto y le pasamos el state y el dispatch</strong>. De esta forma ya están conectados porque este context 'BudgetContext' espera estos props (tanto state como dispatch) y ya se los estamos pasando con ese prop value característico de provider.</p>

            <p>children es un poco más complejo porque pueden ser párrafos, formularios, componentes... Vamos a crear un type para  BudgetProvider con el cual ya tipamos ese {children} que extraemos como parámetro en el provider:</p>
            <pre><code class="language-ts">
              type BudgetProviderProps = {
                children : ReactNode
              }
            </code></pre>

            <p>Esto como tal no hace nada aún porque lo hemos creado como archivo independiente pero no lo hemos colocado en nuestro código de React, por lo que nuestra App de React no sabe aún que existe este archivo.</p>

            <pre><code class="language-ts">
              //BudgetContext.tsx
              import { useReducer, createContext, Dispatch, ReactNode } from &#39;react&#39;;
              import { BudgetState, BudgetActions, budgetReducer, initialState } from &quot;../reducers/budget-reducer&quot;
              
              type BudgetContextProps = {
                  state:  BudgetState
                  dispatch: Dispatch&lt;BudgetActions&gt;
              }
              type BudgetProviderProps = {
                  children : ReactNode
              }
              
              export const BudgetContext = createContext&lt;BudgetContextProps&gt;(null!)
              
              export const BudgetProvider = ({children}: BudgetProviderProps) =&gt; {
              
                  const[state, dispatch] = useReducer(budgetReducer, initialState)
              
                  return(
                      &lt;BudgetContext.Provider
                          value={{
                              state,
                              dispatch
                          }}
                      &gt;
                          {children}
                      &lt;/BudgetContext.Provider&gt;
                  )
              
              }
            </code></pre>

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-197').toggle();">
            <h3>197. Agregando el Context a nuestra aplicación</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-197" class="hidden">
            <p>Actualmente ya tenemos el Boilerplate de nuestro context. tenemos dos partes,  provider(de donde vienen los datos y en este caso también las funciones) y context: que nos sirve para generar ese "componente" del return que es donde se están conectando ambos, tanto provider como context:</p>

            <pre><code class="language-ts">
              //BudgetContext.tsx
              return(
                &lt;BudgetContext.Provider
                    value={{
                        state,
                        dispatch
                    }}
                &gt;
                    {children}
                &lt;/BudgetContext.Provider&gt;
              )
            </code></pre>

            <p>Sin embargo este código no está conectado con nuestra app de React, es un archivo que está aparte ¿donde lo vamos a colocar para conectarlo y utilizarlo en nuestros componentes? Vamos hacia el <span class="file">main.tsx</span>. <span class="destacado">Context va a colocarse y envolver=rodear nuestra Aplicación para que podamos accder a las funciones, al state, a los datos que tengamos en este provider (en este ejemplo en nuestro provider estamos manejando el state y las funciones con useReducer, pero podríamos tener useEffect, variables, funciones, state, muchas otras cosas...)</span></p>

            <ul class="list-disc my-2.5">
              <li>Importamos BudgetProvider (recordemos, <strong>lo que contiene los datos</strong>, mientras que el context solo lo genera)</li>
              <li>Escribimos el tag <strong>&lt;BudgetProvider&gt;&lt;/BudgetProvider&gt;</strong> y llevamos el tag <strong>&lt;App/&gt;</strong> dentro de él <strong>para que estén disponibles en la app de forma global el state y el dispatch (con sus acciones) del reducer</strong></li>
            </ul>
            <pre data-line="5,9,11"><code class="language-ts">
              //main.tsx
              import { StrictMode } from 'react'
              import { createRoot } from 'react-dom/client'
              import './index.css'
              import App from './App.tsx'
              import { BudgetProvider } from './context/BudgetContext.tsx'
              
              createRoot(document.getElementById('root')!).render(
                &lt;StrictMode&gt;
                  &lt;BudgetProvider&gt;
                  &lt;App /&gt;
                  &lt;/BudgetProvider&gt;
                &lt;/StrictMode&gt;,
              )
            </code></pre>

            <p>Si recargamos la app y abrimos en RDT componentes, vemos que ahora (antes en rojo) tenemos el BudgetProvider y Context.Provider. EN BudgetProvider vemos que viene el Reducer y el Budget mientras que en el Context.Provider viene el value con el dispatch y el state</p>

            <img src="./src/assets/img/197.png" alt="img" loading="lazy">

            <p>De esta forma ya hemos conectado y tenemos acceso a esa información.</p>

            <p>¿Como podemos acceder al dispatch y al state (que es lo que estamos retornando en el prop value del tag <strong>&lt;BudgetContext.Provider&gt;&lt;/BudgetContext.Provider&gt;</strong> en el return de nuestro context)? Recordamos que se utiliza el Hook useContext(). Algo importante es que createContext aquí: <code class="language-ts">export const BudgetContext = createContext&lt;BudgetContextProps&gt;(null!)</code> genera el context y aquí con <strong>useReducer</strong>le estamos "pasando el reducer" <code class="language-ts">const[state, dispatch] = useReducer(budgetReducer, initialState)</code> pero para poder utilizar este context, acceder y utilizar a lo que le estamos retornando en ese prop value <code class="language-ts">value={{state,dispatch}}</code> vamos a utilizar en <span class="file">App.tsx</span> useContext(), creando una nueva variable <strong>context</strong> en la que usamos este hook pasándole BudgetContext: <code class="language-ts">const context = useContext(BudgetContext)</code>. Si hacemos un console.log(context) vemos como aparece state y dispatch</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="3,7"><code class="language-ts">
                  //App.tsx
                  import { useContext } from 'react';
                  import BudgetForm from './components/BudgetForm';
                  import { BudgetContext } from './context/BudgetContext';    
                  
                  function App() {
                  
                    const context = useContext(BudgetContext)
                    console.log(context)
                  
                    return (
                      &lt;&gt;
                      &lt;header className=&quot;bg-blue-600 py-8 max-h-72&quot;&gt;
                        &lt;h1 className=&quot;uppercase text-center font-black text-4xl text-white&quot;&gt;Planificador de gastos&lt;/h1&gt;
                      &lt;/header&gt;
                  
                      &lt;div className=&quot;max-w-3xl mx-auto bg-white shadow-lg rounded-lg mt-10 p-10&quot;&gt;
                        
                        &lt;BudgetForm /&gt;
                        
                      &lt;/div&gt;
                      &lt;/&gt;
                    )
                  }
                  
                  export default App
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%] ml-2">
                <img src="./src/assets/img/197-2.png" alt="img" loading="lazy">
              </div>
            </div>

            <p>Pone un ejemplo para que queda un poco más claro cual es el uso de ese value... crea en BudgetContext.tsx una const auth = true y la pasa como objeto en ese objeto prop 'value'. Si vemos el console.log que tenemos vemos que aparece!</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%] mr-2">
                <img src="./src/assets/img/197-3.png" alt="img" loading="lazy">              
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <p>Podemos agregar más variables, funciones, state.... y en este value vamos colocando lo que vamos a poder consumir en nuestros componentes utilizando useContext() como acabamos de ver en el ejemplo de App.tsx <code class="language-ts">const context = useContext(BudgetContext)</code>. 
              </div>
            </div>

            <p>Pero utilizar en nuestra App.tsx useContext() para acceder a los contenidos de ese provider, (creando una variable nueva que llamamos 'context' a la que le asignamos el hook useContext() al que le pasamos nuestro context <code class="language-ts">const context = useContext(BudgetContext)</code>) no es la mejor forma. <span class="destacado">Es mejor usar un custom hook para ello</span>, veámoslo a continuación.</p>

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-198').toggle();">
            <h3>198. Creando un Hook para fácilmente acceder al Context y al Reducer</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-198" class="hidden">
            <p>Ya hemos creado nuestro context y también tenemos nuestro provider:</p>

            <pre data-line="4-7,12, 20-23"><code class="language-ts">
              //BudgetContext.tsx
              import { useReducer, createContext, Dispatch, ReactNode } from &#39;react&#39;;
              import { BudgetState, BudgetActions, budgetReducer, initialState } from &quot;../reducers/budget-reducer&quot;
              
              type BudgetContextProps = {
                  state:  BudgetState
                  dispatch: Dispatch&lt;BudgetActions&gt;
              }
              type BudgetProviderProps = {
                  children : ReactNode
              }
              
              export const BudgetContext = createContext&lt;BudgetContextProps&gt;(null!)
              
              export const BudgetProvider = ({children}: BudgetProviderProps) =&gt; {
              
                  const[state, dispatch] = useReducer(budgetReducer, initialState)
                
                  return(
                      &lt;BudgetContext.Provider
                          value={{
                              state,
                              dispatch
                          }}
                      &gt;
                          {children}
                      &lt;/BudgetContext.Provider&gt;
                  )
              
              }
            </code></pre>
              
              
            <p><strong>Creemos nuestro custom hook que haga exactamente lo que acabamos de ver en el App.tsx del punto anterior.</strong></p>
            
            <p>Creamos <span class="file">hooks&gt;useBudget.ts</span> donde importamos el hook useContext y el context que queremos utilizar con él. A continuación creamos la variable useBudget que va a ser un arrow function y no vamos a retornar un objeto porque, como vemos en nuestro console.log anterior de App.tsx retorna el context completo (que tiene state y dispatch). Dentro del arrow function creamos la variable <span class="destacado">export const = useBudget () =&gt; {}</span> que es un arrow function en el que creamos la variable 'context' (que es la que habíamos creado antes en nuestra App.tsx) y en la que usamos el Hook de React useContext() para pasarle nuestro context personalizado. <strong>Mirar nuestro context en el 1er code de este desplegable para no perdernos</strong>:</p>
            
            <pre><code class="language-ts">
              //hooks&gt;useBudget.ts
              import { useContext } from "react"
              import { BudgetContext } from "../context/BudgetContext"
              
              export const useBudget = () => {
                  const context = useContext(BudgetContext)
                  return context
              }
            </code></pre>

            <p>Limpiamos así nuestro compo ppal App.tsx, para usar nuestro custom hook <strong>useBudget.tsx</strong>. Probamos a usar nuestro custom hook con este destructuring que extrae esos 2 objetos de nuestro context 'BudgetContext' (que es el que le estamos pasando al useContext() de mi custom hook) <code class="language-ts">const{ state, dispatch } = useBudget()</code>Vemos con el console.log(state) que nos muestra el budget: 0. Si abrimos nuestro reducer y en el initialState detras de budget:0 ponemos auth:true vemos en la consola que también nos lo muestra, porque <strong>va a estar conectado todo el tiempo con ese state y también podremos añadir más acciones, que se muestran/pueden usar por medio del dispatch</strong>:</p>
            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="2,6,7"><code class="language-ts">
                  //App.tsx
                  import BudgetForm from './components/BudgetForm';
                  import { useBudget } from './hooks/useBudget';    
                  
                  function App() {
                  
                    const{ state, dispatch } = useBudget()
                    console.log(state)
                  
                    return (
                      &lt;&gt;
                      &lt;header className=&quot;bg-blue-600 py-8 max-h-72&quot;&gt;
                        &lt;h1 className=&quot;uppercase text-center font-black text-4xl text-white&quot;&gt;Planificador de gastos&lt;/h1&gt;
                      &lt;/header&gt;
                  
                      &lt;div className=&quot;max-w-3xl mx-auto bg-white shadow-lg rounded-lg mt-10 p-10&quot;&gt;
                        
                        &lt;BudgetForm /&gt;
                        
                      &lt;/div&gt;
                      &lt;/&gt;
                    )
                  }
                  
                  export default App    
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <img src="./src/assets/img/198-1.png" alt="img" loading="lazy">

                <pre data-line="4"><code class="language-ts">
                  //budget-reducer.ts
                  ...
                  export const initialState: BudgetState = {
                    budget: 0,
                    auth: true
                  }
                  ...
                </code></pre>

                <img src="./src/assets/img/198-2.png" alt="img" loading="lazy">
              </div>
            </div>

            <p>Una buena práctica cuando creamos nuestros hooks y tienen un context es colocar un if que maneje la casuística de que no tengamos context lanzando un error con un mensjae en inglés a poder ser, que recuerde qué context(el que importamos <strong>BudgetContext</strong>) utiliza nuestra variable arrow function que lo maneja / o qué provider (<strong>BudgetProvider</strong>) --&gt; eso le dice a los usuarios: tienes que rodear tu app con este provider para poder hacer uso de mi custom hook. Y así es como se crean las librerías (los paquetes npm) que utilizan context API (si por ejemplo probamos en el main.tsx a quitar el tag del provider que envuelve el tag de nuestra app vemos que lanza ese error en consola). Así garantizas que el usuario haya tenido ese provider y entonces en ese provider comenzar a agregar los datos de la aplicación. <span class="destacado">Esta es su forma favorita de que todo esté controlado tener un reducer, un context y utilizar typescript.</span></p>

            <pre><code class="language-ts">
              //useBudget.ts
              import { useContext } from "react"
              import { BudgetContext } from "../context/BudgetContext"
              
              export const useBudget = () => {
                  const context = useContext(BudgetContext)
                  if(!context){
                      throw new Error('useBudget must be used within a BudgetContext')
                      //throw new Error('useBudget must be used within a BudgetProvider')
                  }
                  return context
              }
            </code></pre>

            <p>Dejemos bien limpio nuestro compo ppal App.tsx y a continuación usaremos nuestro custom hook <strong>useBudget.ts</strong> para definir nuestro presupuesto.</p>

            <pre><code class="language-ts">
              //App.tsx
              import BudgetForm from './components/BudgetForm';

              function App() {
              
                return (
                  &lt;&gt;
                  &lt;header className=&quot;bg-blue-600 py-8 max-h-72&quot;&gt;
                    &lt;h1 className=&quot;uppercase text-center font-black text-4xl text-white&quot;&gt;Planificador de gastos&lt;/h1&gt;
                  &lt;/header&gt;
              
                  &lt;div className=&quot;max-w-3xl mx-auto bg-white shadow-lg rounded-lg mt-10 p-10&quot;&gt;
                    
                    &lt;BudgetForm /&gt;
                    
                  &lt;/div&gt;
                  &lt;/&gt;
                )
              }
              
              export default App
              
            </code></pre>


            

          </div>


          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-199').toggle();">
            <h3>199. Llamando las acciones del reducer desde el Hook por medio del Context <span class="destacado">BudgetContext.tsx</span></h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-199" class="hidden">
            <p>Vamos a usar nuestro custom hook para definir nuestro presupuesto y escribir en nuestro reducer lo que el usuario ponga en el input. Hasta ahora ¿cómo lo hemos hecho? hemos estado usando nuestro reducer en el app.tsx, extraíamos state y dispatch, pasamos por ejemplo dispatch como prop al compo BudgetForm.tsx, lo agregamos a la firma de nuestro type... pero <span class="destacado">gracias a que ya tenemos configurado context API</span> no tenemos que hacerlo así. Vamos a usar nuestro custom hook <span class="file">useBudget.tsx</span> directamente en el componente. Y podemos tener múltiples instancias de ese custom hook, pero al final solo vamos a tener una instancia del state y de las funciones de tipo dispatch. Abrimos nuestro componente <span class="file">BudgetForm.tsx</span> y definimos un handleSubmit (recordar usar el IS para inferir el type del 'e', no tenemos que memorizar), ponemos un console.log() para ver que funciona y lo probamos. Es ahí donde vamos a usar el dispatch pero <strong>Ya no tenemos que hacerlo en el app.tsx ni usar useReducer, de aquí en adelante usamos nuestro hook useBudget.ts (donde tenemos habilitado context API y por tanto tenemos nuestro estado global) que lo importamos</strong>. Extraemos el dispatch de nuestro custom Hook con destructuring (<span class="destacado">ojo! llaves { } y no corchetes [ ]. useReducer nos retornaba state y dispatch ¡en un arreglo!. En este caso es un custom hook, tiene que ser con llaves porque retorna un objeto</span>) y directamente lo usamos en nuestro handleSubmit!!!</p>

            <pre data-line="1,6,8-12,15"><code class="language-ts">
              //BudgetForm.tsx
              import { useBudget } from "../hooks/useBudget"

              export default function BudgetForm() {

                const [budget, setBudget] = useState(0)
                const { dispatch } = useBudget() //ojo! llaves{} y no corchetes[]. useReducer nos retornaba state y dispatch ¡en un arreglo!. En este caso es un custom hook, tiene que ser con llaves
                ...
                const handleSubmit = (e:FormEvent<HTMLFormElement>) => {
                  e.preventDefault();
                  //console.log('Añadir o definir presupuesto')
                  dispatch({type: 'add-budget', payload: {budget}})
                }   

                return (
                  &lt;form className=&quot;space-y-5&quot; onSubmit={handleSubmit}&gt;
                  ...
            </code></pre>

            <p>Si probamos, en RDT en componentes y pulsamos en BudgetProvider, vemos que el budget es 0 (es como tenemos definido el initialState en nuestro budget-reducer.ts) pero si ahora ponemos una cantidad en el formulario y le damos al botón "Definir presupuesto" vemos que estamos escribiendo en nuestro state de presupuesto. Entonces como vemos va a ser una gran ventaja haber incorporado context API para tener un estado global en nuestras apps. Sí fue bastante código pero <span class="destacado">recapitulemos</span>:</p>

            <ul class="list-disc my-2.5">
              <li>hemos definido este context: <span class="file">BudgetContext.tsx</span> en el cual creamos el context <strong>BudgetContext</strong> usando la función de React createContext() y también nuestro provider <strong>BudgetProvider</strong>. Para decirle que este provider va a tener state y dispatch creamos el type BudgetContextProps. La forma en que utilizamos o conectamos el context con este provider es con el return &lt;BudgetContext.Provider&gt;&lt;/BudgetContext.Provider&gt; </li>
              <li>Como estamos utilizando useReducer nos da acceso a BudgetReducer y vamos a poder definir y mandar llamar las acciones, como acabamos de hacer en nuestro componente BudgetForm.tsx utilizando dispatch</li>
              <li>La forma en que conectamos nuestro archivo de context BudgetContext.tsx creado a parte con nuestra aplicación, es en nuestro archivo <span class="file">main.tsx</span> en donde "envolvemos" nuestra aplicación con nuestro provider
                <pre><code class="language-ts">
                  //main.tsx
                  &lt;BudgetProvider&gt;
                    &lt;App /&gt;
                  &lt;/BudgetProvider&gt;
                </code></pre>
              </li>
              <li>Para no estar escribiendo useContext() pasándole el context, hemos creado un custom Hook llamado <span class="file">useBudget.ts</span> donde importamos useContext() y el context en cuestión (BudgetContext), lo montamos, nos aseguramos de que tengamos un provider (si no lanzamos el error) y lo vamos a utilizar directamente en nuestros componentes, como hemos hecho en <span class="file">BudgetForm.tsx</span> importándolo <code class="language-ts">import { useBudget } from "../hooks/useBudget"</code> lo cual me da acceso a todas las funciones que tenga ese provider (en nuestro último ejemplo fue dispatch) tal cual se define en el prop value del tag del provider que escribimos en el return del correspondiente fichero.</li>
            </ul>

            <p>Este context ya no va a tener nada más de código, vamos a estar escribiendo todo lo demás en el reducer. Este es un Boilerplate que va a estar prácticamente en todos los proyectos así que guardemos el código, no hace falta memorizarlo, y cuando vayamos a usarlo lo copiamos, pegamos y lo vamos adaptando. En base a esa repetición e ir creando nuestros proyectos todo esto se irá haciendo má sencillo.</p>

            <pre><code class="language-ts">
              //BudgetContext.tsx
              import { useReducer, createContext, Dispatch, ReactNode } from &#39;react&#39;;
              import { BudgetState, BudgetActions, budgetReducer, initialState } from &quot;../reducers/budget-reducer&quot;
              
              type BudgetContextProps = {
                  state:  BudgetState
                  dispatch: Dispatch&lt;BudgetActions&gt;
              }
              type BudgetProviderProps = {
                  children : ReactNode
              }
              
              export const BudgetContext = createContext&lt;BudgetContextProps&gt;(null!)
              
              export const BudgetProvider = ({children}: BudgetProviderProps) =&gt; {
              
                  const[state, dispatch] = useReducer(budgetReducer, initialState)
                
                  return(
                      &lt;BudgetContext.Provider
                          value={{
                              state,
                              dispatch
                          }}
                      &gt;
                          {children}
                      &lt;/BudgetContext.Provider&gt;
                  )
              
              }
            </code></pre>


          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-200').toggle();">
            <h3>200. Mostrando de forma condicional un componente si el presupuesto es válido</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-200" class="hidden">
            <p>Una vez que defino un presupuesto ya quiero ocultar este componente BudgetForm.tsx y comenzar a mostrar otros. Para continuar trabajando en esa dirección, tenemos que:</p>

            <ul class="list-disc my-2.5">
              <li><strong>Creamos un nuevo componente</strong> <span class="file">components&gt;BudgetTracker.tsx</span> que nos servirá para mostrar qué cantidad hemos definido como presupuesto, cuanto hemos gastado y cuanto nos queda.</li>
              <li><strong>Leemos el state de nuestro context</strong>. Vamos a nuestro compo ppal <span class="file">App.tsx</span> donde vamos a importar nuestro custom hook y leer nuestro state. Ponemos un console.log(state.budget) y si recargamos y definimos un nuevo presupuesto vemos que aparece en la consola ese presupuesto.</li>
              <li><strong>Escribimos algo para validar ese presupuesto</strong>. Importamos useMemo() y, pasándole como dependencia el valor de state.budget vamos a comprobar si state.budget>0 (que es su valor inicial) y de esa forma comprobaremos si ya ha sido modificado por el usuario <code class="language-ts">const isValidObject = useMemo(()=> state.budget>0, [state.budget])</code>. Y a continuación en la parte del return de nuestro App.tsx donde simplemente escribíamos el tag del compo BudgetForm.tsx, vamos a completarlo utilizando nuestra nueva función para validar si ya tenemos presupuesto válido o no ¿no? renderiza el compo BudgetForm.tsx ¿si? renderiza nuestro nuevo compo BudgetTracker.tsx <code class="language-ts"> {isValidObject? &lt;BudgetTracker /&gt; : &lt;BudgetForm /&gt;}</code></li>    
            </ul>
              

            <pre data-line="1,2,4,7,19"><code class="language-ts">
              //App.tsx
              import { useMemo } from 'react';
              import { useBudget } from './hooks/useBudget';
              import BudgetForm from './components/BudgetForm';
              import BudgetTracker from './components/BudgetTracker';
              
              function App() {
                const {state} = useBudget()
                const isValidObject = useMemo(()=> state.budget>0, [state.budget])
              
                return (
                  &lt;&gt;
                  &lt;header className=&quot;bg-blue-600 py-8 max-h-72&quot;&gt;
                    &lt;h1 className=&quot;uppercase text-center font-black text-4xl text-white&quot;&gt;
                      Planificador de gastos
                    &lt;/h1&gt;
                  &lt;/header&gt;
              
                  &lt;div className=&quot;max-w-3xl mx-auto bg-white shadow-lg rounded-lg mt-10 p-10&quot;&gt;      
                    {isValidObject? &lt;BudgetTracker /&gt; : &lt;BudgetForm /&gt;}    
                  &lt;/div&gt;
                  &lt;/&gt;
                )
              }
              
              export default App
            </code></pre>

            

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-201').toggle();">
            <h3>201. Creando el Componente con las cantidades y la gráfica</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-201" class="hidden">

            <p>Trabajamos con nuestro nuevo componente <span class="file">BudgetTracker.tsx</span>:</p>
            <ul class="list-disc my-2.5">
              <li>Añadimos clases de tailwindcss, el gráfico estático que tenemos en public (más adelante lo haremos dinámico), el botón de reset</li>
              <li>Creamos un compo nuevo para las cantidades: <span class="file">AmountDisplay.tsx</span> y lo renderizamos 3 veces en nuestro compo BudgetTracker.tsx con sus correspondientes props de label y amount. <strong>Esas props las extraemos con destructuring y tipamos con su type de props en ese compo nuevo específico para cantidades AmountDisplay.tsx.</strong> Como queremos formatearlo como dinero creamos <span class="file">helpers&gt;index.ts</span>
              <pre data-line="0"><code class="language-ts">
                //helpers&gt;index.ts
                export function formatCurrency(amount: number){
                  return new Intl.NumberFormat('es-ES', { style: 'currency', currency: 'EUR' }).format(amount)
              }
              </code></pre>    

              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <img class="mx-auto" src="./src/assets/img/201.png" alt="img" loading="lazy">
                  <pre data-line="2-5,7"><code class="language-js">
                    //AmountDisplay.tsx
                    import { formatCurrency } from "../helpers"
                    type AmountDisplayProps = {
                        label: string
                        amount: number
                    }
                    
                    export default function AmountDisplay({label, amount} : AmountDisplayProps) {
                      return (
                        &lt;p className=&quot;text-2xl text-blue-600 font-bold&quot;&gt;
                            {label}: {&#39;&#39;}
                            &lt;span className=&quot;text-black&quot;&gt;{formatCurrency(amount)}&lt;/span&gt;
                        &lt;/p&gt;
                      )
                    }
                  </code></pre>                
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre data-line="17,18,21,22,25,26"><code class="language-js">
                    //BudgetTracker.tsx
                    import AmountDisplay from './AmountDisplay';
                    export default function BudgetTracker() {
                      return (
                        &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-5&quot;&gt;
                            &lt;div className=&quot;flex justify-center&quot;&gt;
                                &lt;img src=&quot;./grafico.jpg&quot; alt=&quot;Gráfica de gastos&quot; /&gt;
                            &lt;/div&gt;
                    
                            &lt;div className=&quot;flex flex-col justify-center items-center gap-8&quot;&gt;
                                &lt;button
                                    type=&quot;button&quot;
                                    className=&#39;bg-pink-600 w-full p-2 text-white uppercase font-bold rounded-lg&#39;&gt;
                                        Resetear App
                                &lt;/button&gt;
                    
                                &lt;AmountDisplay
                                    label=&quot;Presupuesto&quot;
                                    amount={300}
                                /&gt;
                                &lt;AmountDisplay
                                    label=&quot;Disponible&quot;
                                    amount={200}
                                /&gt;
                                &lt;AmountDisplay
                                    label=&quot;Presupuesto&quot;
                                    amount={100}
                                /&gt;
                            &lt;/div&gt;
                        
                        &lt;/div&gt;
                      )
                    }
                  </code></pre>
                </div>              
              </div>

          </li>
          </ul>

            <p>Hasta aquí la parte superior de nuestro compo ppal App.tsx. Vamos a añadirle un div nuevo que va a tener una ventana modal en la cual vamos a poder mostrar el formulario para registrar gastos.</p>

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-202').toggle();">
            <h3>202. Instalando Headless UI para tener una ventana modal - <a class="text-white underline" href="https://gist.github.com/codigoconjuan/92e8a52abc8bd9ea5b81e5ad664d8ef0" target="blank">ExpenseModal.tsx</a></h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-202" class="hidden">
            <p>Vamos a crear una ventan modal para mostrar el formulario con el que vamos a agregar los gastos.</p>

            <ul class="list-disc my-2.5">
              <li>Creamos nuevo componente <span class="file">ExpenseModal.tsx</span> y su contenido va a ser lo que copiemos del link del gist que tenemos en este apartado.</li>
              <li>Tenemos que instalar @heroicons <span class="destacado">npm install @heroicons/react</span> y @headlessui <span class="destacado">npm install @headlessui/react</span> para que funcionen las importaciones correspondientes de lo que acabamos de copiar.</li>
              <li>En nuestro <span class="file">App.tsx</span> tras el segundo div renderizamos nuestra modal con el tag correspondiente a este nuevo componente <code class="language-ts">&lt;ExpenseModal/&gt;</code> y veremos que nos aparece este signo de '+' en la parte inferior de nuestra interfaz:
              <img src="./src/assets/img/202.png" alt="img" loading="lazy">
              y al pulsarlo debe mostrar el modal (cambiando a true el false que hay en la línea 16 del código del componente modal: <code class="language-ts">&lt;Transition appear show={false} as={Fragment}&gt;&lt;/Transition&gt;</code>), lo haremos con un dispatch, pero si lo cambiamos un momento a mano veremos que se muestra correctamente el modal.
              </li>
              <li>Creamos un tag main <code class="language-ts">&lt;main&gt;&lt;/main&gt;</code> y movemos dentro el tag <code class="language-ts">&lt;ExpenseModal/&gt;</code>. (el modal está flotado, es decir no le van a afectar las clases de estilo del main, pero en él vamos a tener los gastos y el filtrado por categorías) </li>
              <li>Si ahora mismo recargamos la pantalla vemos que ese '+' aparece cuando todavía no hemos definido el presupuesto así que vamos a controlar que eso no pase (es decir que solo aparezca el + una vez hayamos introducido un presupuesto) usando nuestro <code class="language-ts">const isValidObject = useMemo(()=> state.budget>0, [state.budget])</code> y lo utilizamos con && (es como un ternario pero solo se evalúa la condición del true):
              <pre><code class="language-ts">
                {isValidObject &amp;&amp; (
                  &lt;main className=&#39;max-w-3xl mx-auto py-10&#39;&gt;
                    
                    &lt;ExpenseModal/&gt;
                  &lt;/main&gt;
                )}
              </code></pre>
              </li>
              <li>El siguiente paso va a ser el dispatch para mostrar y ocultar el modal</li>
            </ul>
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-204').toggle();">
            <h3>203. Mostrando el Modal cuando agregamos un nuevo gasto / 204. Agregando una acción para cerrar el modal</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-204" class="hidden">
            <p class="naranja">Mostrando el Modal cuando agregamos un nuevo gasto</p>

            <p>Vamos a nuestro reducer <span class="file">budget-reducer.ts</span>, que es donde estamos manejando todo el código de nuestro state. Vamos a añadir una acción nueva 'show-modal' que no toma ningún payload porque solo cambia de false a true.</p>

            <pre data-line="3,7,12,26-31"><code class="language-ts">
              //budget-reducer.ts
              export type BudgetActions = 
              { type: 'add-budget', payload: {budget: number} } |
              { type: 'show-modal' } 

              export type BudgetState = {
                  budget: number
                  modal: boolean
              }

              export const initialState: BudgetState = {
                  budget: 0,
                  modal: false
              }

              export const budgetReducer = (
                      state: BudgetState=initialState,
                      action: BudgetActions
                  ) =&gt;{

                  if(action.type === &quot;add-budget&quot;){
                      return{
                          ...state,
                          budget: action.payload.budget
                      }
                  }
                  if(action.type === &quot;show-modal&quot;){
                      return{
                          ...state,
                          modal: true
                      }
                  }

                  return state
              }
            </code></pre>

            <p>Vamos a nuestro compo <span class="file">ExpanseModal.tsx</span> y, <strong>recordando que todo nuestro state se maneja por medio del custom Hook:</strong></p>

            <ul class="list-disc my-2.5">
              <li><strong>Importamos nuestro custom Hook</strong><svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
              </svg> <code class="language-ts">import { useBudget } from '../hooks/useBudget'</code></li>
              <li><strong>Extraemos state y dispatch</strong> <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
              </svg> <code class="language-ts">const { state, dispatch } = useBudget()</code>.<br>
                <span class="destacado">state</span> porque el modal se muestra en base al <code class="language-ts">show="{false}"</code> y queremos ya comenzar a controlarlo y hacerlo dinámico<br>
                <span class="destacado">dispatch</span> porque, es el botón '+' que está en la parte superior el que controla que se muestre:
                <div class="flex max-sm:flex-col">
                  <div class="w-[40%] max-sm:w-[100%]">
                    <pre class="rojo" data-line="1-3,7"><code class="language-js">
                      //ExpanseModal.tsx               
                      &lt;button
                        type=&quot;button&quot;
                      &gt;
                        &lt;PlusCircleIcon className=&#39;w-16 h-16 text-blue-600 rounded-full&#39; /&gt;
                      &lt;/button&gt;    
                      ...
                      &lt;Transition appear show={false} as={Fragment}&gt;&lt;/Transition&gt;
                    </code></pre>
                  </div>
                  <div class="w-[60%] max-sm:w-[100%]">
                    <pre class="verde" data-line="3,8"><code class="language-js">
                      //ExpanseModal.tsx
                      &lt;button
                        type=&quot;button&quot;
                        onClick={() =&gt; dispatch({type:&#39;show-modal&#39;})}
                      &gt;
                        &lt;PlusCircleIcon className=&#39;w-16 h-16 text-blue-600 rounded-full&#39; /&gt;
                      &lt;/button&gt;  
                      ...
                      &lt;Transition appear show={state.modal} as={Fragment}&gt;&lt;/Transition&gt; 
                    </code></pre>
                  </div>
                </div>
              
              </li>
            </ul>

            <p class="naranja">Agregando una acción para cerrar el modal</p>
            <p>Si vemos el código del compo modal, vemos que aquí es donde se gestiona cerrarlo: <code class="language-ts">&lt;Dialog as=&quot;div&quot; className=&quot;relative z-10&quot; onClose={() =&gt; {}}&gt;</code></p>

            <ul class="list-disc my-2.5">
              <li>Añadimos una acción nueva 'close-modal' en nuestro reducer. No toma ningún payload porque solo cambia de true a false y añadimos el correspondiente:
                <pre data-line="4,6-11"><code class="language-js">
                  //budget-reducer.ts
                  export type BudgetActions = 
                  { type: 'add-budget', payload: {budget: number} } |
                  { type: 'show-modal' } |
                  { type: 'close-modal' } 
                  ...
                  if(action.type === "close-modal"){
                    return{
                        ...state,
                        modal: false
                    }
                  }
                </code></pre>
              </li>
              <li>Vamos a nuestro compo modal ExpenseModal.tsx y hacemos la modificación necesaria en la línea que controla el cerrado del modal:
                <div class="flex max-sm:flex-col">
                  <div class="w-[40%] max-sm:w-[100%]">
                    <pre class="rojo" data-line="1"><code class="language-js">
                      //ExpenseModal.tsx
                      &lt;Dialog as=&quot;div&quot; className=&quot;relative z-10&quot; onClose={() =&gt; {}}&gt;           
                    </code></pre>
                  </div>
                  <div class="w-[60%] max-sm:w-[100%]">
                    <pre class="verde" data-line="1"><code class="language-js">
                      //ExpenseModal.tsx
                      &lt;Dialog as=&quot;div&quot; className=&quot;relative z-10&quot; onClose={() =&gt; dispatch({type : &#39;close-modal&#39;})}&gt;
                    </code></pre>
                  </div>
                </div>
              </li>
              <li>Vamos a crear un componente nuevo <span class="file">ExpenseForm.tsx</span> que va a tener el formulario para registrar gastos. Lo vamos a llamar desde el componente modal, justo entre los tags <code class="language-ts">&lt;Dialog.Panel&gt;...&lt;/Dialog.Panel&gt;</code>:
                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre data-line="3"><code class="language-js">
                      //ExpenseModal.tsx
                      ..
                      &lt;Dialog.Panel className=&quot;w-full max-w-3xl transform overflow-hidden rounded-2xl bg-white p-6 text-left align-middle shadow-xl transition-all&quot;&gt;
                        &lt;ExpenseForm /&gt;
                      &lt;/Dialog.Panel&gt;
                    </code></pre>
                  </div>
                  <div class="w-[50%] max-sm:w-[100%] ml-2">
                    <img src="./src/assets/img/204.png" alt="img" loading="lazy">
                  </div>
                </div>    
                En él vamos a tener un formulario un poco más complejo con categoría a la que pertenece un gasto, la cantidad, la fecha en la que se hizo y le nombre del gasto.
              </li>
            </ul>


          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-205').toggle();">
            <h3>205. Creando el Formulario de Gastos - <a class="underline text-white" href="https://gist.github.com/codigoconjuan/75ba8738a387410b9fff81d96ffbc67d" target="_blank">Categorias para Admin de Gastos</a> / 206. Agregando un calendario definir la fecha de gasto</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-205" class="hidden">
            <p>Comenzamos a trabajar con el formulario que sirve de entrada para procesar cada uno de los de gastos <span class="file">ExpenseForm-tsx</span>.</p>
            <ul class="list-disc my-3">
              <li>Nombre gasto. El name del input lo ponemos para poder escribir en el state. La función que modifica state y value la vemos un poco más adelante.</li>
              <li>Cantidad</li>
              <li>Creamos <span class="file">data&gt;categories.ts</span> Categorías que cogemos del gist <a class="underline text-black" href="https://gist.github.com/codigoconjuan/75ba8738a387410b9fff81d96ffbc67d" target="_blank">Categorias para Admin de Gastos</a> que es un arreglo que tiene objetos con id, nombre e icono.</li>
              <li>También vamos a tener cuándo se realiza ese gasto, pero eso va a ser una dependencia para que sera más sencillo.</li>
              <li>boton de submit</li>
              <li>Tenemos que definir el state y conectarlo pero antes hagamos la dependencia para seleccionar de un date picker</li>
            </ul>

            <p class="naranja">Agregando calendario para definir la fecha de gasto - <a class="underline text-black" href="https://www.npmjs.com/" target="_blank">https://www.npmjs.com/</a></p>

            <p>Buscamos react-date-picker y elegimos este que vemos que soporta TS <a class="underline" href="https://www.npmjs.com/package/react-date-picker" target="_blank">https://www.npmjs.com/package/react-date-picker</a>. En esa misma página hay instrucciones sobre cómo utilizarlo. Instalamos con <span class="destacado">npm install react-date-picker</span>. Vamos a ExpenseForm.tsx e importamos DatePicker, las dos hojas de estilo. A continuación creamos los 2 types que están en la documentación de la dependencia (<strong>estos mejor, los llevamos al fichero de types que vamos a crear, ver siguiente punto</strong>) y con esto ya podemos comenzar a utilizarlo, marcar una fecha, la cual aparecerá ahí una vez empecemos a escribir en el state:</p>
            <pre><code class="language-ts">
              //ExpenseForm.tsx
              import DatePicker from 'react-date-picker'
              import 'react-date-picker/dist/DatePicker.css';
              import 'react-calendar/dist/Calendar.css';
              type ValuePiece = Date | null
              type Value = ValuePiece | [ValuePiece, ValuePiece]
            </code></pre>

            <p>Si vemos en la app ya nos aparece este calendario personlizado (que podríamos haber usado un input type="date" pero quería mostrarnos como hacerlo con una dependencia).</p>

            <img src="./src/assets/img/206.png" alt="img" loading="lazy">

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-207').toggle();">
            <h3>207. Definiendo el Type para los gastos y definir el state</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-207" class="hidden">
            <p>Vamos a ver una forma un poco más avanzada de escribir en el state porque como vemos en nuestro formulario de gasto tenemos nombre de gasto, cantidad que es de tipo número, categoría y la fecha que es de tipo date.</p>

            <p><span class="destacado">Creamos un fichero para types</span>: <span class="file">types/index.ts</span> (en este punto vuelve a recordar que se puede usar interfaces en lugar de types pero que es preferencia personal porque es más sencillo)</p>

            <ul class="list-disc my-3">
              <li class="my-2"><strong>Creamos type para gasto una vez que se almacena (por tanto tiene id):</strong> <code class="language-ts">export type Expense = {}</code> que va a tener un id: string (vemos que nuestro formulario no lo tiene): vamos a hacer un enfoque un poco diferente, <strong>en el proyecto anterior generábamos el id cuando cargaba el componente, en este proyecto generamos id cuando se guarde este gasto</strong>. el date va a ser la fecha que tenemos de la dependencia instalada 'react-calendar', de hecho si nos fijamos en el 'cómo se usa' de su url <a class="underline mx-auto" href="https://www.npmjs.com/package/react-date-picker" target="_blank">https://www.npmjs.com/package/react-date-picker</a> vemos que definen el type 'value' y al crear una fecha le ponen con un generic el type: <code class="language-ts">&lt;value&gt;</code>. Con lo cual, el código de 'tipado' de esta dependencia mejor nos lo llevamos a nuestro fichero de type que tenerlo en el compo del form de gasto ExpenseForm.tsx (<strong>hemos de ponerle, eso sí, un export al type value</strong>)
                <img class="mx-auto" src="./src/assets/img/207.png" alt="img" loading="lazy">
              </li>
              <li class="my-2"><strong>Creamos type para gasto temporal (que no va a tener id)</strong> y salvo el id va a ser igual por lo que utilizamos un utility type llamado Omit: <code class="language-ts">export type DraftExpense = Omit&lt;Expense, &#39;id&#39;&gt;</code></li>
              <li class="my-2"><strong>Creamos type para las categorías</strong>, podemos inferir lo que contiene abriendo nuestros datos <span class="file">data/categories</span> y mirando el IS:
                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%] mr-2">
                    <img class="mx-auto" src="./src/assets/img/207-2.png" alt="img" loading="lazy">
                  </div>
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre data-line="1,3"><code class="language-ts">
                      //data/categories.ts
                      import type { Category } from "../types";
                
                      export const categories: Category[] = [
                      ...
                    </code></pre>
                  </div>
                </div> 
                
                <pre><code class="language-js">
                  //types/index.ts   
                  export type Expense = {
                      id: string
                      expenseName: string
                      amount: number
                      category: string
                      date: Value
                  }
                  export type DraftExpense = Omit&lt;Expense, &#39;id&#39;&gt;

                  type ValuePiece = Date | null;
                  export type Value = ValuePiece | [ValuePiece, ValuePiece];

                  export type Category = {
                    id: string
                    name: string
                    icon: string
                  }
                </code></pre>
              </li>
            </ul>
          
            
            <p><span class="destacado">Definimos nuestro state local 'expense' con useState()</span> en ExpenseForm.tsx (vamos a manejar un estado local, no se requiere en el reducer por tanto lo voy a hacer en este archivo) para lo que <strong>importamos useState y también el type DraftExpense</strong> que acabamos de crear para tipar con un generic el estado que vamos a crear.</p>

            <pre data-line="1,2,6,11"><code class="language-css">
              //ExpenseForm.tsx
              import { useState } from "react";
              import type { DraftExpense } from "../types";
              ...
              export default function ExpenseForm() {

                const [expense, setExpense] = useState&lt;DraftExpense&gt;({
                  amount: 0,
                  expenseName: '',
                  category: '',
                  date: new Date()
                })
                ...
            </code></pre>

            <p><span class="destacado">Vamos a comenzar a asignar cada elemento del state expense ya en su correspondiente campo de formulario:</span>

              <pre><code class="language-js">
                //Input Nombre gasto    
                  --&gt; value={expense.expenseName}
                //Input Cantidad        
                  --&gt; value={expense.amount}
                //Select de Categoría   
                  --&gt; value={expense.category}
                //Dependencia DatePicker 
                  &lt;DatePicker
                    className=&quot;bg-slate-100 p-2 border-0&quot;
                    value={expense.date}
                  /&gt;
              </code></pre>
              
              <p>Eso nos va a permitir conectar ese state con cada uno de los campos, sin embargo si buscamos el componente ExpenseForm en nuestra pestaña componentes de RWTD (Headless UI agrega un montón de componentes) vemos que si escribimos algo en Nombre de Gasto, no se está guardando en nuestro state, porque <strong>tenemos que utilizar un onChange</strong>. Va a ser un onChange un poco diferente/complejo porque tanto nombre de gasto como categorías son strings, la cantidad es un number y fecha gasto es un type value... por lo que vamos a tener dos funciones diferentes para poder escribir en el state</p>

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-208').toggle();">
            <h3>208. Escribiendo el gasto en el State <span class="destacado">2 funciones handle, e.target-conexión name-destructuring</span></h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-208" class="hidden">

            <p>Nuestro state local para este formulario de gastos:</p>
            <pre><code class="language-js">
              //ExpenseForm.ts
                const [expense, setExpense] = useState&lt;DraftExpense&gt;({
                  amount: 0,
                  expenseName: '',
                  category: '',
                  date: new Date()
                })
            </code></pre>
            <p>Si vemos en la pestaña componentes de RDT y buscamos el ExpenseForm, vemos en el state que amount aparece un 0 en azul (string), hemos de conservar esa cantidad amount como número así que vamos a escribir un código para convertirlo a número. Nombre y categoría son strings, están bien y la fecha es una librería, una dependencia que hemos instalado, que si recordamos el type, los creadores de la librería definieron como Value (ya importado en nuestro fichero de types/index.ts). <strong>Entonces no podemos gestionarlo todo con la misma función por la disparidad de tipos, creamos dos funciones handleChange:</strong></p>
            <ul class="list-disc my-3">
              <li class="my-2"><strong>Función <code class="language-ts">const handleChangeDate = () => {}</code> para el campo fecha:</strong> cuando seleccionamos una fecha en el picker, la fecha nueva, el value, se pasa en automático así que le pasamos como parámetro value (del tipo Value que es el que definieron los de la librería y nosotros incluímos en nuestro fichero de types, así que lo importamos). Si hacemos un console.log(value) vemos que nos saca en consola la fecha que seleccionamos cada vez en el picker. Seteamos el state haciendo copia del mismo y estableciendo a continuación que el valor de date es el value (la fecha que acabamos de seleccionar del picker):
              <pre data-line="14"><code class="language-js">
                //ExpenseForm.tsx
                import type { DraftExpense, Value } from "../types";
                ...
                const handleChangeDate = (value:Value) =>{
                  //console.log(value)
                  setExpense({
                    ...expense,
                    date: value
                  })
                }
                ... //En el onChange del campo fecha la llamamos:
                &lt;DatePicker
                  className=&quot;bg-slate-100 p-2 border-0&quot;
                  //value={expense.date}
                  onChange={handleChangeDate}
                /&gt;
              </code></pre>
              </li>
              <li class="my-2"><strong>Función <code class="language-ts">const handleChange = () => {}</code> para los campos gasto, cantidad y categoría:</strong> escribimos código para, identificar si estamos escribiendo en amount y si es así comnvertirlo a número (+value ó Number[value]).
              <pre data-line="11"><code class="language-js">
                //ExpenseForm.tsx
                const handleChange = (e: ChangeEvent&lt;HTMLInputElement&gt; | ChangeEvent&lt;HTMLSelectElement&gt;) => {
                  const { name, value } = e.target //extraemos name y value de cada campo de formulario
                  const isAmountField = ['amount'].includes(name) //true si estamos escribiendo en amount y false si escribimos en gasto o seleccionamos categoría
                  //console.log(isAmountField)
                  setExpense({
                    ...expense,
                    [name] : isAmountField ? +value : value
                  })
                }
                ... // en el onChange de los campos Nombre gasto, cantidad y categoría la llamamos:
                onChange={handleChange}
              </code></pre>
              </li>
            </ul>

            <p>Así ya estamos escribiendo en nuestro state y conservando los tipos de datos que hemos definido en el type de DrafExpense (una copia temporal que no tiene un id aún). Vamos a continuación a trabajar con el form. Una vez que presionemos el submit, necesitamos que todos los campos tenga algo relleno/seleccionado, veamos una forma de validarlo y, en vez de deshabilitar el input mostraremos una alerta.</p>.
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-209').toggle();">
            <h3>209. Mostrando una alerta si la validación falla en el formulario <span class="destacado">error: compo, state y tag</span></h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-209" class="hidden">
            <p><strong>Función <code class="language-ts">const handleSubmit = () => {}</code> para trabajar con el submit del formulario.</strong><br>
              (Recordar, para sacar el type del parámetro 'e' que le pasamos a esta función, poner en el onSubmit del form: <code class="language-ts">onSubmit={e=>}</code> para que VSC lo infiera y lo podamos copiar del IS.</p>

            <p><span class="destacado">Para validar utilizamos Object.values(), método para objetos que lo que hace es convertir un objeto a arreglo</span> De momento  probamos con estos 2 console.log siguientes. Si probamos a enviar el formulario sin rellenar tal cual, veríamos que en la consola el console.log de error y a continuación el de 'todo bien' porque entra en el if pero al no haber nada que lo detenga, el código se seguiría ejecutando así que pongamos un return para que esto no pase:</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="8,13"><code class="language-ts">
                  //ExpenseForm.ts
                  ...
                  const handleSubmit = (e: FormEvent&lt;HTMLFormElement&gt;) => {
                    e.preventDefault()
                
                    //validar
                    if(Object.values(expense).includes('')){
                      console.log('error...')
                      return
                    }
                    console.log('todo bien')  
                  }
                
                  return (
                    &lt;form className=&quot;space-y-5&quot; onSubmit={handleSubmit}&gt;
                    ...
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">   
                <img src="./src/assets/img/209-1.png" alt="img" loading="lazy">
              </div>
            </div>

            <p>Creamos un state local para error que iniciamos como string vacío: <code class="language-ts">const [error, setError] = useState('')</code> y creamos un componente nuevo para error llamado <span class="file">ErrorMessage.tsx</span>. Vamos a hacer que pueda recibir errores de forma dinámica (de antemano no sabemos el mensaje que vamos a enviarle) usando como parámetro {children} (recordar su uso en el context y también su tipado: podríamos tiparlo de cualquiera de estas dos maneras: <strong>ReactNode</strong> nos va a permitir renderizar componentes dentro de otros componentes o <strong>PropsWithChildren</strong>). Usamos todo esto para, si nuestro state de error cambia (lo hemos inicializado como string vacío) entonces pintamos el componente de error con lo que tenga mi state: <code class="language-ts">{error &amp;&amp; &lt;ErrorMessage&gt;{error}&lt;/ErrorMessage&gt;}</code></p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  //ErrorMessage.tsx
                  import { ReactNode } from "react"

                  type ErrorMessageProps = {
                      children: ReactNode
                  }
                  export default function ErrorMessage({children} : ErrorMessageProps) {
                    return (
                      &lt;p className=&quot;bg-red-600 p-2 text-white font-bold text-sm text-center&quot;&gt;
                          {children}
                      &lt;/p&gt;
                    )
                  }
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  ////ErrorMessage.tsx
                  import { PropsWithChildren } from &quot;react&quot;

                  export default function ErrorMessage({children} : PropsWithChildren) {
                    return (
                      &lt;p className=&quot;bg-red-600 p-2 text-white font-bold text-sm text-center&quot;&gt;
                          {children}
                      &lt;/p&gt;
                    )
                  }        
                </code></pre>
              </div>
            </div>

            <p>A continuación vemos un resumen de todo lo que entra en juego:</p>

            <ul class="list-disc my-3">
              <li class="my-1.25">El compo nuevo para error.</li>
              <li class="my-1.25">El state para error que inicializamos con string vacío.</li>
              <li class="my-1.25">La función que maneja el submit conteniendo la validación:
                <ul class="list-disc my-3">
                  <li class="my-1.25">si no pasa la validación se setea el error en cuestión.</li>
                  <li class="my-1.25">si pasa la validación aplicaremos un dispatch para comenzar a setear los gastos</li>
                </ul>
                </li>
              <li class="my-1.25">La llamada a la función en el submit del formulario.</li>
              <li class="my-1.25">La renderización del componente error con el contenido el state error en caso de que haya cambiado dicho state</li>
            </ul>

            <pre data-line="1,3,5,12,15,20"><code class="language-js">
              //ExpenseForm.tsx
              import ErrorMessage from "./ErrorMessage";
              ...
              const [error, setError] = useState('')
              ...
              const handleSubmit = (e: FormEvent&lt;HTMLFormElement&gt;) =&gt; {
                e.preventDefault()  
                //validar
                if(Object.values(expense).includes(&#39;&#39;)){
                  setError(&#39;Todos los campos son obligatorios&#39;)
                }
                console.log(&#39;todo bien&#39;)  //
              }
            
              return (
                &lt;form className=&quot;space-y-5&quot; onSubmit={handleSubmit}&gt;
                  &lt;legend
                    className=&quot;uppercase text-center text-2xl font-black border-b-4 border-blue-500 py-2&quot;
                  &gt;Nuevo gasto&lt;/legend&gt;
            
                  {error &amp;&amp; &lt;ErrorMessage&gt;{error}&lt;/ErrorMessage&gt;}
            
            </code></pre>
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-210').toggle();">
            <h3>210. Definiendo la acción para nuevos gastos</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-210" class="hidden">
            <p>Veamos como agregar la acción que va a agregar los nuevos gastos. Vamos a nuestro budget-reducer.ts y agregamos la acción: <code class="language-ts">{ type: 'add-expense', payload: {expense: DraftExpense} } </code> de tipo DraftExpense porque no va a tener id, el id lo vamos a generar en el reducer. Veamos nuestros cambios en el budget-reducer.ts</p>

            <pre data-line="1,7,12,18,26-32"><code class="language-ts">
              //budget-reducer.ts
              import { DraftExpense, Expense } from "../types"

              export type BudgetActions = 
                  { type: 'add-budget', payload: {budget: number} } |
                  { type: 'show-modal' } |
                  { type: 'close-modal' } |
                  { type: 'add-expense', payload: {expense: DraftExpense} } 
              
              export type BudgetState = {
                  budget: number
                  modal: boolean
                  expenses: Expense[]
              }
              
              export const initialState: BudgetState = {
                  budget: 0,
                  modal: false,
                  expenses: []
              }
              
              export const budgetReducer = (
                      state: BudgetState=initialState,
                      action: BudgetActions
                  ) =>{
                  ...
                  if(action.type === "add-expense"){

                    return{
                        ...state,
                        expenses: [...state.expenses, action.payload.expense]
                    }
                  }
            
                return state
            }
            </code></pre>

            <p>Ya tenemos todo esto en un state global, ya no necesitamos pasarlo via props. Nos vamos al ExpenseForm.ts:</p>

            <ul class="list-disc my-3">
              <li class="my-1.25">Importamos useBudget y lo instanciamos después del state de error, extrayendo el dispatch. En nuestro handleSubmit cuando pasa la validación llamamos al dispatch en concreto a la acción que acabamos de crear para añadir gasto de tipo 'add-expense' y en el payload pasamos el gasto 'expense': 
                <pre data-line="1,11">
                <code class="language-ts">
                  //ExpenseForm.ts
                  const { dispatch } = useBudget()
                  --
                  const handleSubmit = (e: FormEvent&lt;HTMLFormElement&gt;) => {
                    e.preventDefault()
                
                    //validar
                    if(Object.values(expense).includes('')){
                      setError('Todos los campos son obligatorios')
                    }
                    //Agregar un nuevo gasto
                    dispatch({type: 'add-expense', payload: {expense}})
                  }
                </code>
                </pre>

                Si vemos en la pestaña componentes de nuestro RDT el componente Budget Provider, vemos que en el reducer ya tenemos el nuevo state que acabamos de crear "expenses" y si en la app añadimos un gasto vemos que se añade, aunque si lo expandimos vemos que no hay ningún id único 
                <img src="./src/assets/img/210-01.png" alt="img" loading="lazy">      
                </li>
              <li class="my-1.25">En un ejemplo anterior cada vez que se montaba el componente generábamos un nuevo id. <strong>En este caso vamos a simular como si fuera una base de datos</strong>. En una bbdd nosotros no le decimos cual es el id; una vez que se genera se le asigna, por lo tanto vamos a volver al budget-reducer.tsx. Instalamos en nuestro proyecto <span class="destacado">npm install uuid</span> En nuestro budget-reducer.tsx importamos la dependencia (él, aunque parece que no lo necesitamos, instala las definiciones de types para uuid <strong>npm install --save-dev @types/uuid</strong>). Vamos a crear una función que va a tomar el payload de nuestro último action y le va a añadir un id, pero muy importante: <strong>lo va a convertir a type Expense, en lugar de que sea un DraftExpnse que no tiene id. Esta función 'createExpense' va a tomar desde el payload lo que está en el formulario, una vez que llega aquí mandamos llamar a esa función, le añade un id y lo devuelve hacia el reducer de nuevo</strong>. En lugar de generar el id en el formulario, no lo vamos a generar hasta que no haya pasado su validación. Podemos probar la app 
              
              <pre><code class="language-ts">
                //budget-reducer.tsx
                ...
                const createExpense = (draftExpense: DraftExpense ) : Expense => {
                  return {
                      ...draftExpense,
                      id: uuidv4()
                  }
                }
                
                export const budgetReducer = (
                      state: BudgetState=initialState,
                      action: BudgetActions
                  ) =>{
                  ...
                  if(action.type === "add-expense"){
                    const expense = createExpense(action.payload.expense)
                    return{
                        ...state,
                        expenses: [...state.expenses, expense]
                    }
                  } 
                  return state
                }

              </code></pre>
              </li>
            </ul>

            <p>Una vez agregado un gasto correctamente querremos que se reinicie el formulario y se cierre el modal. Veamos como hacerlo</p>

          </div>

          <!-- Bloque desplegable interior -->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-211').toggle();">
            <h3>211. Reiniciar el Formulario y Ocultar el Modal si se agrega un gasto</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-211" class="hidden">
            <p>Ya estamos escribiendo en el arreglo de los gastos (el state 'expenses' que definimos en nuestro reducer y que podemos ver en la pestaña componentes de RDT pulsando el componente BudgetProvider dentro de los hooks)</p>

            <img src="./src/assets/img/211.png" alt="img" loading="lazy">

            <p>Una vez rellenado el gasto deberíamos o resetear el formulario o cerrar el modal para que el usuario pueda interactuar enla aplicación.</p>

            <p>En nuestro <span class="file">ExpenseForm.tsx</span> una vez que disparamos el dispatch para 'Agregar nuevo gasto' podemos reiniciar el state local con su función 'setExpense' pasándole los valores iniciales que teníamos. Eso lo podemos hacer porque tenemos conectado el value de los campos de formulario con nuestro state local. (<strong>en cada campo llamamos el id y el name del mismo como cada una de las propiedades de nuestro state local :)</strong>)</p>

            <pre data-line="11-17"><code class="language-ts">
              //ExpenseForm.tsx
              const handleSubmit = (e: FormEvent&lt;HTMLFormElement&gt;) => {
                e.preventDefault()
            
                //validar
                if(Object.values(expense).includes('')){
                  setError('Todos los campos son obligatorios')
                }
                //Agregar un nuevo gasto
                dispatch({type: 'add-expense', payload: {expense}})
            
                //reiniciar el state
                setExpense({
                  amount: 0,        //&lt;input type=&quot;number&quot; id=&quot;amount&quot; name=&quot;amount&quot; value={expense.amount} onChange={handleChange}/&gt;
                  expenseName: '',  //&lt;input type=&quot;text&quot; id=&quot;expenseName&quot; name=&quot;expenseName&quot; value={expense.expenseName} onChange={handleChange} /&gt;
                  category: '',     //&lt;select id=&quot;category&quot; name=&quot;category&quot; value={expense.category} onChange={handleChange}&gt;
                  date: new Date()
                })
              }
            </code></pre>

            <p>Si quisiéramos cerrar el modal después de agregar el gasto, lo hacemos en nuestro reducer (gran ventaja de reducer tener algo de lógica y poder escribir en múltiples states al mismo tiempo, a diferencia de usar useState donde tendríamos que estar manejando para esto mismo distintos setStates):</p>
            <pre data-line="7"><code class="language-ts">
              //budget-reducer.ts
              ...
              if(action.type === "add-expense"){
                const expenseconId = createExpense(action.payload.expense)
                return{
                    ...state,
                    expenses: [...state.expenses, expenseconId],
                    modal: false
                }
              }
            </code></pre>

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-212').toggle();">
            <h3>212. Creando el Componente para mostrar los gastos / 213. Mostrando los gastos / 214. Mostrando los iconos de la categoría del gasto</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-212" class="hidden">
            <p>Vamos a trabajar con <span class="file">App.tsx</span> y con <span class="file">budget-reducer.tsx</span> más que nada para extraer información</p>

            <p>En App.tsx tenemos la  comprobación de que si el presupuesto(budget) es válido el usuario pueda generar gastos; ahí es donde vamos a mostrar el listado de gastos. </p>

            <ul class="list-disc my-3">
              <li class="my-1.25"><strong>Creamos nuestro componente nuevo <span class="file">ExpenseList.tsx</span> para ese listado de gastos:</strong>  y lo renderizamos en App.tsx dentro de esa misma condición porque solo cuando tengamos un presupuesto válido es cuando queremos poder agregar nuevos gastos y listarlos:</li>

              <li class="my-1.25"><strong>Importamos nuestro useBudget.tsx en el nuevo componente:</strong> anteriormente pasábamos el state a utilizar como prop en este nuevo tag desde App.tsx al nuevo componentes ExpenseList.tsx pero ahora como tenemos contextAPI recordemos, disponemos de un state global.</li>

              <li><strong>Extraemos el state como nueva variable:</strong> <code class="language-ts">const { state } = useBudget()</code></li>
              <li><strong>Creamos una nueva variable 'isEmpty' usando useMemo que, teniendo el state como dependencia va a devolver true cuando no haya gastos:</strong> <code class="language-ts">const isEmpty = useMemo(() => state.expenses.length === 0, [state.expenses])</code> Queremos que en nuestra app, cuando aún no hay gastos se muestre el mensaje "No hay gastos" y si los hay, iterar sobre ellos para mostrarlos</li>
              <li class="my-1.25">Creamos un nuevo componente ExpenseDetail.tsx para usar en ExpenseList.tsx cuando iteramos sobre state.expenses y le pasamos como props key por iterar y expense (<strong>notar como con el autocompletado y la notación de punto tenemos accesos a las propiedades del type de gasto</strong>). Ese prop hemos de extraerlo y tiparlo en el nuevo componente ExpenseDetail.tsx como venimos haciendo hasta ahora con los props entre compos.
                <div class="flex max-sm:flex-col">            
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre data-line="0"><code class="language-js">
                      //ExpenseList.tsx
                      import { useMemo } from "react"
                      import { useBudget } from "../hooks/useBudget"
                      import ExpenseDetail from "./ExpenseDetail"
      
                      export default function ExpenseList() {
      
                          const { state } = useBudget()
                          const isEmpty = useMemo(() => state.expenses.length === 0, [state.expenses])
      
                          return (
                              &lt;div className=&quot;mt-10&quot;&gt;
                                  {isEmpty ? &lt;p className=&quot;text-gray-600 text-2xl font-bold&quot;&gt;No hay gastos&lt;/p&gt; : (
                                      &lt;&gt;
                                          &lt;p className=&quot;text-gray-600 text-2xl font-bold my-5&quot;&gt;Listado de gastos.&lt;/p&gt;
                                          {state.expenses.map( expense =&gt; (
                                              &lt;ExpenseDetail
                                                  key = {expense.id}
                                                  expense = {expense}
                                              /&gt;
                                          ))}
                                      &lt;/&gt;
                                  )}
                              &lt;/div&gt;
                          )
                      }
                    </code></pre>
                  </div>
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre data-line="0"><code class="language-ts">
                      //App.tsx
                      {isValidObject && (
                        &lt;main className=&#39;max-w-3xl mx-auto py-10&#39;&gt;
                          &lt;ExpenseList/&gt;
                          &lt;ExpenseModal/&gt;
                        &lt;/main&gt;
                      )}
                    </code></pre>
                    <pre data-line="0"><code class="language-js">
                      //ExpenseDetail.tsx
                      import { Expense } from '../types/index';
      
                      type ExpenseDetailsProps = {
                          expense : Expense
                      }
                      
                      export default function ExpenseDetail({expense} : ExpenseDetailsProps) {
                          return (
                          &lt;div&gt;
                              
                          &lt;/div&gt;
                          )
                      }
                    </code></pre>
                  </div>
                
                </div>
              </li>
              <li class="my-1.25">
                <p><strong>Construimos y damos estilos a las distintas etiquetas de la interfaz del componente <span class="file">ExpenseDetail.tsx</span>.</strong> Ojo! al intentar llamar a {expense.date} nos da este error porque, recordemos, tenía un type 'Value' de los creadores de la libreria, así que lo convertimos a string con un .toString(). Si lo vemos ahora, vemos que la fecha sale en el formato de la librería usada:</p>
                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <img src="./src/assets/img/213-1.png" alt="img" loading="lazy">
                  </div>
                  <div class="w-[50%] max-sm:w-[100%]">
                    <img src="./src/assets/img/213-2.png" alt="img" loading="lazy">
                  </div>
                </div>            
              
                <p>Para que nos salga en formato español (hay muchas librerías y opciones para hacerlo porque trabajar con fechas es complicado). Nosotros vamos a utilizar las funciones Intl, como la que tenemos en nuestro helper y ahí es donde vamos a crear nuestra función para formatear la fecha, una función que toma un parámetro de tipo string y debe devolver un string. En la función creamos el objeto(usando el parámetro que recibe), le pasamos una configuración y retornamos la fecha formateada:</p>          

                <pre data-line="0"><code class="language-ts">
                  //helpers/index.ts
                  export function formatDate(dateStr : string) : string {
                    const dateObj = new Date(dateStr) //convertimos a objeto de tipo fecha
                    const options : Intl.DateTimeFormatOptions = {
                        weekday: 'long',
                        year: 'numeric',
                        month: 'long',
                        day: 'numeric'
                    }
                    return new Intl.DateTimeFormat('es-ES', options).format(dateObj)
                  }
                </code></pre>

                <p>En nuestro componente ExpenseDetail.tsx llamamos a esa función para que formate la fecha (con la admiración le decimos a TS que ese valor va a estar ahí): <code class="language-ts">&lt;p className=&quot;text-slate-600 text-sm&quot;&gt;{ formatDate( expense.date!.toString() ) }&lt;/p&gt;</code></p>

                <p>A continuación utilizamos nuestro compo AmountDisplay.tsx, pero como ahora no queremos que nos saque label, lo modificamos para que sea opcional y además no queremos que nos saque los ":" que pusimos, hacemos estos cambios:</p>

                <pre data-line="0"><code class="language-js">
                  // AmountDisplay.tsx
                  import { formatCurrency } from "../helpers"
                  type AmountDisplayProps = {
                      label?: string
                      amount: number
                  }

                  export default function AmountDisplay({label, amount} : AmountDisplayProps) {
                    return (
                      &lt;p className=&quot;text-2xl text-blue-600 font-bold&quot;&gt;
                          {/* {label}: {&#39;&#39;} */}
                          {label &amp;&amp; `${label}: `}
                          &lt;span className=&quot;text-black&quot;&gt;{formatCurrency(amount)}&lt;/span&gt;
                      &lt;/p&gt;
                    )
                  }
                </code></pre>

                <p>Nos falta por mostrar el icono y el texto de la categoría (tenemos el diccionario con toda la información de esas categorías en nuestro <span class="file">data/categories.ts</span>), los iconos en la carpeta public y recordemos que en nuestro state de gastos del reducer, la categoría solo almacena el id, el resto de la info la vamos a tener que sacar de este diccionario.</p>             
              </li>

              <li class="my-1.25">
                Vamos a ver cómo tomar la información de la categoría, porque cuando estamos almacenando en el state solo estamos guardando el id, pero tenemos un diccionario de catergorías en <span class="file">data/categories.ts</span> de donde podemos sacar el nombre (para mostrarlo en mi listado) y el icono para renderizarlo desde public. (es como si lo hiciéramos desde una bbdd, otro gallo cantaría si tuviéramos un arreglo en memoria donde accederíamos directamente a esas props)
                
                <p>Vamos a <span class="file">EspenseDetails.tsx</span> y antes del return creamos nueva variable con useMemo() con dependencia del state expense para ejecutar lo siguiente cada vez que cambie ese state de nuestro reducer: <code class="language-ts">const categoryInfo = useMemo(() => categories.filter(cat => cat.id === expense.category)[0],[expense])</code>,  es decir <span class="destacado">usando filter sobre nuestro diccionario de datos categories, vamos a poder filtrar sobre ese arreglo y encontrar la coincidencia de la categoría del gasto que estamos iterando, permitiéndonos así con el id del gasto que itero traerme todo el objeto correspondiente a ese id y poder acceder a lo que necesito: name y al icono</span>.</p>

                <pre data-line="0"><code class="language-js">
                  //ExpenseDetail.tsx
                  import { useMemo } from 'react';
                  import { categories } from '../data/categories';
                  import { formatDate } from '../helpers';
                  import { Expense } from '../types/index';
                  import AmountDisplay from './AmountDisplay';
                  
                  type ExpenseDetailsProps = {
                      expense : Expense
                  }
                  
                  export default function ExpenseDetail({expense} : ExpenseDetailsProps) {
                  
                      const categoryInfo = useMemo(() => categories.filter(cat => cat.id === expense.category)[0],[expense])
                  
                      return (
                      &lt;div className=&quot;bg-white shadow-lg p-10 w-full border-b border-gray-200 flex gap-4 items-center&quot;&gt;
                          &lt;div&gt;
                              &lt;img 
                                  src={`./icono_${categoryInfo.icon}.svg`} 
                                  alt=&quot;icono gasto&quot;
                                  className=&#39;w-20&#39;
                              /&gt;
                          &lt;/div&gt;
                  
                          &lt;div className=&#39;flex-1 space-y-2&#39;&gt;
                              &lt;p className=&quot;text-sm font-bold uppercase text-slate-500&quot;&gt;{categoryInfo.name}&lt;/p&gt;
                              &lt;p&gt;{expense.expenseName}&lt;/p&gt;
                              &lt;p className=&quot;text-slate-600 text-sm&quot;&gt;{ formatDate( expense.date!.toString() ) }&lt;/p&gt;
                          &lt;/div&gt;
                  
                          &lt;AmountDisplay
                              amount={expense.amount}
                          /&gt;
                      &lt;/div&gt;
                      )
                  }
                </code></pre>
              </li>
            </ul>
              
            <p>A continuación empezaremos con la parte de editar y eliminar e instalaremos para ello una librería para la interacción Swipe.</p>     
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-215').toggle();">
            <h3>215. Agregando interacción de Swipe a los gastos para Editar y Eliminar - <a class="underline text-white" href="https://www.npmjs.com/package/react-swipeable-list" target="_blank">react-swipeable-list</a> - <a class="underline text-white" href="https://gist.github.com/codigoconjuan/e1a67f2a729bc44978c2c7d0f946ce7e" target="_blank">gist para para swipleable List</a></h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-215" class="hidden">
            <p>Vamos con las acciones de editar y eliminar. Podríamos añadir algunos iconos como hemos hecho hasta ahora pero vamos a utilizar un efecto que tiene distintas apps, whatsapp, gmail. amazon... swipeable-list. Instalamos esta dependencia que soporta TS y además tiene actualizaciones recientes: <a class="underline text-black" href="https://www.npmjs.com/package/react-swipeable-list" target="_blank">react-swipeable-list</a> con <span class="destacado">npm i react-swipeable-list</span>. </p>

            <p>Vamos a <span class="file">ExpenseDetail.tsx</span> e importamos varias cosas entre ellas: LeadingActions (las acciones que vienen del lado izquierdo) y TrailingActions (las acciones que vienen del otro lado) así como la hoja de estilos propia que tiene sus propias animaciones. Aunque aún nos queda trabajo, así es como queda de momento nuestro componente con swype inicialmente configurado y si lo probamos en al interfaz vemos que ya hace el swype para ambos lados (actualizar hacia la izquierda y Eliminar hacia la derecha).</p>

            <p><strong>SwipeableList:</strong> tiene que rodear todo nuestro div princpal</p>
            <p><strong>SwipeableListItem:</strong> para especificarle cuales son las acciones y la configuración. Este prop <code class="language-ts">maxSwipe={30}</code> que le pasamos le especifica los px que queremos que recorra para que se dispare. Los props <code class="language-ts">LeadingActions={}</code> y <code class="language-ts">TrailingActions={}</code> son para especificar lo que queremos que haga ese elemento cuando arrastramos respectivamente de izda a derecha o de drecha a izda. Así que creamos las correspondientes funciones que queremos que ejecuten esos props.</p>

            <p>Copiamos en raw el código que ha preparado en este gist <a class="underline text-black" href="https://gist.github.com/codigoconjuan/e1a67f2a729bc44978c2c7d0f946ce7e" target="_blank">gist para para swipleable List</a> con estilos y lo pegamos en nuestro index.css (con @apply leemos las clases que utiliza esa librería y aplico clases de tailwindcss incorporándolas a lo que de por sí tiene esa librería que tomamos de npm).</p>

            <p>La librería nos da unos props muy útiles como por ejemplo: usemos este en el SwipeAction del TrailingAction: <code class="language-ts">destructive={true}</code> visualmente vemos que desaparece de nuestra interfaz, aunque no lo ha eliminado de nuestro state porque tenemos que disparar esa acción.</p>

            <pre data-line="2,7,17-32,35-40,62,63"><code class="language-ts">
              //ExpenseDetail.tsx
              import { useMemo } from 'react';
              import { LeadingActions, SwipeableList, SwipeableListItem, SwipeAction, TrailingActions} from 'react-swipeable-list'
              import { categories } from '../data/categories';
              import { formatDate } from '../helpers';
              import { Expense } from '../types/index';
              import AmountDisplay from './AmountDisplay';
              import "react-swipeable-list/dist/styles.css"
              
              type ExpenseDetailsProps = {
                  expense : Expense
              }
              
              export default function ExpenseDetail({expense} : ExpenseDetailsProps) {
              
                  const categoryInfo = useMemo(() =&gt; categories.filter(cat =&gt; cat.id === expense.category)[0],[expense])
              
                  const leadingActions = () =&gt; (
                      &lt;LeadingActions&gt;
                          &lt;SwipeAction onClick={() =&gt; {}}&gt;
                              Actualizar
                          &lt;/SwipeAction&gt;
              
                      &lt;/LeadingActions&gt;
                  )
                  const trailingActions = () =&gt; (
                      &lt;TrailingActions&gt;
                          &lt;SwipeAction onClick={() =&gt; {}}&gt;
                              Eliminar
                          &lt;/SwipeAction&gt;
              
                      &lt;/TrailingActions&gt;
                  )
              
                  return (
                  &lt;SwipeableList&gt;  
                      &lt;SwipeableListItem
                          maxSwipe={30}
                          leadingActions = {leadingActions()}
                          trailingActions = {trailingActions()}
                      &gt;
              
                          &lt;div className=&quot;bg-white shadow-lg p-10 w-full border-b border-gray-200 flex gap-4 items-center&quot;&gt;
                              &lt;div&gt;
                                  &lt;img 
                                      src={`./icono_${categoryInfo.icon}.svg`} 
                                      alt=&quot;icono gasto&quot;
                                      className=&#39;w-20&#39;
                                  /&gt;
                              &lt;/div&gt;
              
                              &lt;div className=&#39;flex-1 space-y-2&#39;&gt;
                                  &lt;p className=&quot;text-sm font-bold uppercase text-slate-500&quot;&gt;{categoryInfo.name}&lt;/p&gt;
                                  &lt;p&gt;{expense.expenseName}&lt;/p&gt;
                                  &lt;p className=&quot;text-slate-600 text-sm&quot;&gt;{ formatDate( expense.date!.toString() ) }&lt;/p&gt;
                              &lt;/div&gt;
              
                              &lt;AmountDisplay
                                  amount={expense.amount}
                              /&gt;
                          &lt;/div&gt;
              
                      &lt;/SwipeableListItem&gt;
                  &lt;/SwipeableList&gt;
                  )
              }    
            </code></pre>
              
            
            


          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-216').toggle();">
            <h3>216. Eliminando un gasto cuando ejecutamos un Swipe</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-216" class="hidden">
            <p>Abrimos budget-reducer.ts y creamos acción nueva para eliminar <code class="language-ts"> </code> y lo que le estamos especificando en el payload es "lo que sea que tenga expense en su campo id, ese mismo type queremos usar". Un poco más abajo en el if de nuestro reducer, podríamos usar algo de lógica para eliminarlo, por ejemplo con un filter y después asignarlo pero también lo podemos poner todo directamente en el return: hacemos una copia del state y a continuación en el filter accedemos a cada gasto y le decimos "traete todos los que sean diferentes al payload que estamos pasando que es el que queremos eliminar"</p>
            <pre><code class="language-js">
              //budget-reducer.ts
              ...
              { type: 'remove-expense', payload: {id: Expense['id']} }
              ...
              if(action.type="remove-expense"){
                return{
                    ...state,
                    expenses: state.expenses.filter( expense => expense.id !== action.payload.id)
                }
              }
            </code></pre>

            <p>Ahora en <span class="file">ExpenseDetail.tsx</span> importamos nuestro custom hook e instanciamos extrayendo dispatch para entonces, ¿¿escribir en mi state esa acción:</p>

            <pre data-line="1,5,10"><code class="language-ts">
              //ExpenseDetail.tsx
              import { useBudget } from '../hooks/useBudget';
              ..
              export default function ExpenseDetail({expense} : ExpenseDetailsProps) {

                const { dispatch } = useBudget()
                ...
                const trailingActions = () =&gt; (
                  &lt;TrailingActions&gt;
                      &lt;SwipeAction 
                          onClick={() =&gt; dispatch({type: &#39;remove-expense&#39;, payload: {id: expense.id}})}
                          destructive = {true}
                      &gt;
                          Eliminar
                      &lt;/SwipeAction&gt;

                  &lt;/TrailingActions&gt;
                )
            </code></pre>

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-217').toggle();">
            <h3>217. Seleccionando el Gasto a Editar cuando ejecutamos Swipe en la otra dirección / 218. Llenar el formulario del gasto a editar automáticamente</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-217" class="hidden">
            <p>Vamos a ver cómo editamos los gastos. Lo primero es identificar qué gasto estamos "arrastrando" de izquierda a derecha con el swype, lo colocaremos en el state del que estamos editando, abriremos modal y entonces filtrar el gasto por ese id.</p>
            <ul class="list-disc my-3">
              <li class="my-1.25">Añadimos una nueva propiedad de state en nuestro reducer llamada <strong>'editingId'</strong> de tipo Expense y usamos lookup para buscar id. Registramos una acción nueva <strong>'get-expense-by-id'</strong> que es la que vamos a disparar para que escriba en nuestra prop de state 'editingId'. En nuestro reducer definimos el if de esa acción. En <span class="file">ExpenseDetail.tsx</span> en el cnClick del LeadingActions SwipeActions llamamos con el dispatch a nuestra nueva acción. Quiero que al arrastrar me lance el modal: es muy fácil gracias a reducer, añadimos en el if correspondiente que <code class="language-ts">modal: true</code>. 
                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre data-line="0,3,9,15,18-24"><code class="language-ts">
                      //budget-reducer.ts
                      export type BudgetActions = 
                        ... |
                        { type: 'get-expense-by-id', payload: {id: Expense['id']} } 
              
                      export type BudgetState = {
                        budget: number
                        modal: boolean
                        expenses: Expense[]
                        editingId: Expense['id']
                      }
                      export const initialState: BudgetState = {
                          budget: 0,
                          modal: false,
                          expenses: [],
                          editingId: ''
                      }
                      ...
                      if(action.type === "get-expense-by-id"){
                        return{
                            ...state,
                            editingId: action.payload.id ,
                            modal: true
                        }
                      }
                    </code></pre>
                  </div>
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre data-line="0,3"><code class="language-ts">
                      //ExpenseDetail.tsx
                      const leadingActions = () => (
                        &lt;LeadingActions&gt;
                            &lt;SwipeAction onClick={() =&gt; dispatch({type: &quot;get-expense-by-id&quot;, payload: {id: expense.id}})}&gt;
                                Actualizar
                            &lt;/SwipeAction&gt;
                        &lt;/LeadingActions&gt;
                      )
                    </code></pre>
                  </div>
                </div> 
              </li>
              <li class="my-1.25">Llenemos el formulario del modal en función del id que aparece en el state 'editingId': nos vamos a <span class="file">ExpenseForm.tsx</span> y al instanciar nuestro useBudget, además de extraer el dispatch vamos a extraer el state: <code class="language-ts">const { dispatch, state } = useBudget()</code> y entonces utilizamos un useEffect() y le pasamos como dependencia state.editingId (teniendo en cuenta que useEffect siempre se ejecuta al menos una vez así que añadimos if comprobando). Una vez hecho el filter seteamos! regresamos de lo global a lo local (anteriormente lo habíamos movido de local a global) para tener toda la validación y el código que hemos hecho en nuestro compo.
              <pre data-line="0"><code class="language-ts">
                //ExpenseForm.tsx
                const { dispatch, state } = useBudget()

                useEffect(() => {
                  if(state.editingId){
                    const editingExpense = state.expenses.filter( currentExpense => currentExpense.id === state.editingId)[0]
                    setExpense(editingExpense)
                  }
                },[state.editingId])
              </code></pre>
              </li>
            </ul>

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-219').toggle();">
            <h3>219. Editando el gasto / 220. Mostrar de forma condicional si es un gasto nuevo o edición</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-219" class="hidden">
            <p>Con lo que llevamos hecho si tratamos de editar un gasto y le damos a enviar vemos que nos agrega uno nuevo. Hemos de identificar cuando estamos editando para actualizar el gasto y si es uno nuevo entonces agregarlo a la lista. Nos vamos a <span class="file">budget-reducer.ts</span> y creamos una acción nueva que se dispara cuando actualizamos. Le pasamos este payload porque cuando estamos actualizando pasamos el objeto completo (estamos actualizando un gasto que ya tiene un id) <code class="language-ts">{ type: 'update-expense', payload: {expense: Expense} } </code>. En el reducer creamos su if correspondiente creando una copia del state actual y con un map vamos a recorrer todos los gastos para identificar cual estoy actualizando vamos a poner(siendo expense el elemento iterado) expense.id === y aquí hay dos formas de hacerlo:</p>

            <ul class="list-disc my-3">
              <li class="my-1.25">Una forma sería con expense.id === state.editingId (porque ese es el activo y el que estamos actualizando)</li>
              <li class="my-1.25">Pero también ese gasto, esta actualización tiene su propio id solo que primero tendríamos que validar en el dispatch 'add-expense' de ExpenseForm.tsx <code class="language-ts">dispatch({type: 'add-expense', payload: {expense}})</code>si hay algo en activo para editar y si es así despechar la acción de editar y si no hay nada PARA EDITAR DESPACHAR la que hay actualmente de agregar el gasto. Lo hacemos así.</li>
            </ul>
          
            <p>Cuando detecte que es igual entonces voy a reescribir de mis gastos con action.payload.expense (es decir el objeto completo) y en caso contrario retorno expense (el gasto sobre el cual estoy iterando) para no perder así los otros gastos.</p>
                <pre><code class="language-ts">
                  //budget-reducer.ts
                  if(action.type==="update-expense"){
                    return{
                        ...state,
                        expenses: state.expenses.map(expense => expense.id === action.payload.expense.id ? action.payload.expense : expense),
                        modal: false,
                        editingId: ''
                    }
                }
                </code></pre>
              
                <p>Como estamos comparando por al payload, para que mande llamar correctamente a esa función tenemos que ir a <span class="file">ExpenseForm.tsx</span> como decíamos y vamos a comprobar si estamos agregando o actualizando gasto: si agregamos usamos el dispatch como lo teníamos, si estmaos actualizando, usamos la acción recién creada pero el payload es un poco más complejo porque, recordemos, nuestro expense no tenía id, pero al actualizar la estamos pasando que su objeto va a ser ya un gasto que tiene id. Le vamos a decir que el id lo coja del editingId (id: state.editingId), y del resto toma una copia de lo que tenemos en el state como gasto (...expense)</p>

                <pre><code class="language-ts">
                  //ExpenseForm.tsx
                  //Agregar un nuevo gasto o actualizar uno existente
                  if(state.editingId){
                    dispatch({type: 'update-expense', payload: {expense: {id: state.editingId, ...expense}} })
                  }else{
                    dispatch({type: 'add-expense', payload: {expense}})
                  }
                </code></pre>

            <p>Si nos fijamos, al editar un gasto en cuanto se cierra el modal lo reseteábamos, sin embargo a darle a agregar nuevo gasto a continuación nos sale el último editado de nuevo ¿por qué? mirando 'BudgetProvider' en la pestaña components en RDT vemos que nuestro state 'editingID' SIEMPRE está en activo (usaba un useEffect) entonces cuando lo vuelve a llamar se rellena. Por lo tanto vamos a especificarle tras el cierre del modal que editingId sea un string vacío. Esto mismo lo vamos a especificar en nuestra acción de cierre de modal también para prevenir que si un usuario edita y cierra el modal sin finalizar la acción de editar, este permanezca lleno:
            
            <p>Vamos a mostrar el título del modal diferente si se trata de un nuevo gasto o de una edición. Vamos a ExpenseForm.tsx. Ese título está en un legend y como ya teníamos importado el state de nuestra aplicación podemos hacer lo siguiente:</p>

            <pre><code class="language-ts">
              //ExpenseForm.tsx
              &lt;legend
                className=&quot;uppercase text-center text-2xl font-black border-b-4 border-blue-500 py-2&quot;
              &gt;{state.editingId ? &#39;Guardar Cambios&#39; : &#39;Nuevo gasto&#39;}&lt;/legend&gt;
              ...
              &lt;input 
                type=&quot;submit&quot; 
                className=&quot;bg-blue-600 cursor-pointer w-full p-2 text-white uppercase font-bold rounded-lg&quot;
                value={state.editingId ? &#39;Guardar Cambios&#39; : &#39;Registrar gasto&#39;}
              /&gt;
            </code></pre>
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-221').toggle();">
            <h3>221. Colocando gastos en LocalStorage</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-221" class="hidden">
            <p>Vamos a nuestro reducer que es donde manejamos el state. Requerimos el presupuesto (budget) pero también los gastos (expenses) así que vamos a tener dos funciones, dos objetos distintos para no tener tanta lógica. De esta manera, separado, es más simple, más fácil de leer, más sencillo de mantener:</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre class="rojo" data-line="2,4"><code class="language-js">
                  //budget-reducer.ts
                  export const initialState: BudgetState = {
                    budget: 0,
                    modal: false,
                    expenses: [],
                    editingId: ''
                }
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre class="verde" data-line="1-8,10,12"><code class="language-js">
                  //budget-reducer.ts
                  const initialBudget = () : number =>{
                    const localStorageBudget = localStorage.getItem('budget')
                    return localStorageBudget ? +localStorageBudget : 0
                  }
                  const localStorageExpenses = () : Expense[] => {
                    const localStorageExpenses = localStorage.getItem('expenses')
                    return localStorageExpenses ? JSON.parse(localStorageExpenses) : []
                  }
                  export const initialState: BudgetState = {
                    budget: initialBudget(),
                    modal: false,
                    expenses: localStorageExpenses(),
                    editingId: ''
                }
                </code></pre>
              </div>
            </div>

            <p>En <span class="file">App.tsx</span> usamos un useEffect() y le pasamos como dependencia para escuchar el state que ya tiene importado ese App.tsx de manera global.</p>
            
            <ul class="list-disc my-3">
              <li class="my-1.25">Seteamos nuestro 'budget' de localStorage usando toString() porque localStorage no acepta números (y recordemos nuestro presupuesto budget es un número) y en typescript tenemos que ser muy específicos.</li>
              <li class="my-1.25">Seteamos nuestro 'expenses' de localStorage usando JSON.stringify() porque localStorage no acepta arreglos (y nuestros gastos lo son)</li>
            </ul>

            <pre data-line="0"><code class="language-ts">
              //App.tsx
              useEffect(() => {
                localStorage.setItem('budget', state.budget.toString())
                localStorage.setItem('expenses', JSON.stringify(state.expenses))
              },[state])
            </code></pre>

          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-222').toggle();">
            <h3>222. Trabajando con el Componente que muestra Presupuesto, Gastado y Disponible</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-222" class="hidden">
            <p>Vamos a trabajar con el compo <span class="file">BudgetTracker.tsx</span> que es donde mostramos Presupuesto, Gastado y Disponible. Vamos a hacerlo como un state derivado, vamos a ir escribiendo algunas funciones que, gracias a que se actualiza el state también se van a ir actualizando. Importamos nuestro useBudget y extraemos el state que es donde vamos a tener nuestro presupuesto, nuestras cantidades y podemos calcular el total a pagar.</p>
            <ul class="list-disc my-3">
              <li class="my-1.25"><strong>Nuestro presupuesto:</strong> Cambiamos el código hardcodeado de 300 que teníamos en el prop Amount del tag AmountDisplay de : <code class="language-ts">amount={300}</code> por <code class="language-ts">amount={state.budget}</code> </li>
              <li class="my-1.25"><strong>Lo gastado: </strong> Vamos a crear una variable 'totalExpenses' y usaremos en ella useMemo() porque queremos que ese cálculo se ejecute cada vez que cambie el state de gastos. usamos reduce() con sus dos parámetros para el cálculo</li>
              <li class="my-1.25">Lo disponible: creamos variable 'remainingBudget' y calculamos la diferencia entre el presupuesto y lo gastado. </li>
            </ul>
          
            <pre data-line="4-5,7,11,15,19"><code class="language-ts">
            //BudhetTracker.tsx
            export default function BudgetTracker() {
              const { state } = useBudget()
          
              const totalExpenses = useMemo( () => state.expenses.reduce((total,expense) => expense.amount + total, 0 )
              , [state.expenses])

              const remainingBudget = state.budget - totalExpenses
              ...
              &lt;AmountDisplay
              label=&quot;Presupuesto&quot;
              amount={state.budget}
              /&gt;
              &lt;AmountDisplay
                label=&quot;Disponible&quot;
                amount={remainingBudget}
              /&gt;
              &lt;AmountDisplay
                label=&quot;Gastado&quot;
                amount={totalExpenses}            
              /&gt;
            </code></pre>
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-223').toggle();">
            <h3>223. Evitar Excedernos del presupuesto</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-223" class="hidden">
            <p>Veamos como hacer para no pasarnos del presupuesto y evitar añadir/editar un gasto con cuya cantidad se exceda nuestro presupuesto (nos aparecería cifra negativa ahí). Básicamente tendríamos que copiar todo el código que acabamos de crear en el punto anterior también al formulario porque ahí es cuanto queda disponible... sin embargo en vez de tener copias por ahí en nuestro código, nos lo vamos a llevar al context <span class="file">context/BudgetContext.tsx</span> donde estamos utilizando reducer (aunque no tenga que ver esclusivamente con nuestro estate, si lo podemos utilizar en distintos sitios de nuestra app para no tener así código duplicado lo llevamos al context):</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[40%] max-sm:w-[100%]">
                <pre data-line="0"><code class="language-js">
                  //context/BudgetContext.tsx
                  import { useReducer, createContext, Dispatch, ReactNode } from &#39;react&#39;;
                  import { BudgetState, BudgetActions, budgetReducer, initialState } from &quot;../reducers/budget-reducer&quot;
                  
                  type BudgetContextProps = {
                      state:  BudgetState
                      dispatch: Dispatch&lt;BudgetActions&gt;
                  }
                  type BudgetProviderProps = {
                      children : ReactNode
                  }
                  
                  export const BudgetContext = createContext&lt;BudgetContextProps&gt;(null!)
                  
                  export const BudgetProvider = ({children}: BudgetProviderProps) =&gt; {
                  
                      const[state, dispatch] = useReducer(budgetReducer, initialState)
                    
                      return(
                          &lt;BudgetContext.Provider
                              value={{
                                  state,
                                  dispatch
                              }}
                          &gt;
                              {children}
                          &lt;/BudgetContext.Provider&gt;
                      )                
                  }
                </code></pre>
              </div>
              <div class="w-[60%] max-sm:w-[100%]">
                <pre class="verde" data-line="7,8,20-22,29,30"><code class="language-js">
                  //context/BudgetContext.tsx
                  import { useReducer, createContext, Dispatch, ReactNode, useMemo } from &#39;react&#39;;
                  import { BudgetState, BudgetActions, budgetReducer, initialState } from &quot;../reducers/budget-reducer&quot;
                  
                  type BudgetContextProps = {
                      state:  BudgetState
                      dispatch: Dispatch&lt;BudgetActions&gt;
                      totalExpenses: number
                      remainingBudget: number
                  }
                  type BudgetProviderProps = {
                      children : ReactNode
                  }
                  
                  export const BudgetContext = createContext&lt;BudgetContextProps&gt;(null!)
                  
                  export const BudgetProvider = ({children}: BudgetProviderProps) =&gt; {
                  
                      const [state, dispatch] = useReducer(budgetReducer, initialState)
                  
                      const totalExpenses = useMemo( () =&gt; state.expenses.reduce((total,expense) =&gt; expense.amount + total, 0 )
                      , [state.expenses])
                      const remainingBudget = state.budget - totalExpenses
                    
                      return(
                          &lt;BudgetContext.Provider
                              value={{
                                  state,
                                  dispatch,
                                  totalExpenses,
                                  remainingBudget
                              }}
                          &gt;
                              {children}
                          &lt;/BudgetContext.Provider&gt;
                      )                
                  }
                </code></pre>
              </div>
            </div>

            <p>En <span class="file">BudgetTracker.tsx</span> eliminaríamos entonces ese código que creamos antes y simplemente extraemos esos dos objetos que hemos creado en el context con el importe que resta del presupuesto y la suma del total de los gastos (remainingBudget y totalExpenses). Quedaría así:</p>

            <pre data-line="5"><code class="language-ts">
              //BudgetTracker.tsx
              import { useBudget } from &#39;../hooks/useBudget&#39;;
              import AmountDisplay from &#39;./AmountDisplay&#39;;
              
              export default function BudgetTracker() {
                  const { state, remainingBudget, totalExpenses } = useBudget()
              
                  return (
                  &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-5&quot;&gt;
                      &lt;div className=&quot;flex justify-center&quot;&gt;
                          &lt;img src=&quot;./grafico.jpg&quot; alt=&quot;Gráfica de gastos&quot; /&gt;
                      &lt;/div&gt;
              
                      &lt;div className=&quot;flex flex-col justify-center items-center gap-8&quot;&gt;
                          &lt;button
                              type=&quot;button&quot;
                              className=&#39;bg-pink-600 w-full p-2 text-white uppercase font-bold rounded-lg&#39;&gt;
                                  Resetear App
                          &lt;/button&gt;
              
                          &lt;AmountDisplay
                              label=&quot;Presupuesto&quot;
                              amount={state.budget}
                          /&gt;
                          &lt;AmountDisplay
                              label=&quot;Disponible&quot;
                              amount={remainingBudget}
                          /&gt;
                          &lt;AmountDisplay
                              label=&quot;Gastado&quot;
                              amount={totalExpenses}            
                          /&gt;
                      &lt;/div&gt;
                      
                  &lt;/div&gt;
                  )
              }
            </code></pre>

            <p>Si vemos nuestra app sigue funcionando igual pero al tenerlo en nuestro context ya es algo reutilizable así que vamos a <span class="file">ExpenseForm.tsx</span> en donde, como tenemos ya importado el useBudget, extraemos el objeto remainingBudget y agregamos una segunda validación en nuestro handleSubmit:</p>

            <pre><code class="language-ts">
              //ExpenseForm.tsx
              ...
              const { dispatch, state, remainingBudget } = useBudget()
              ...
              //Validar que no me pase del presupuesto
              if( expense.amount > remainingBudget){
                setError('Ese gasto es mayor que lo que resta de Presupuesto')
                return
              }
            </code></pre>

            <p>Llegados a este punto vemos que el nivel de complejidad es grande y algo nos falla (si intentamos modificar un gasto de 200 y bajarlo a 180 cuando por ejemplo aun nos quedan 100 de presupeusto nos sale error). Vamos a agregar en <span class="file">ExpenseForm.tsx</span> un nuevo state local 'previousAmount' <code class="language-ts">const [previousAmount, setPreviousAmount] = useState(0)</code> para que, cuando estemos editando, vamos a congelar esa cantidad porque la requerimos. Añadimos lo siguiente en nuestro useEffect() de editar:</p>

            <pre data-line="2,9"><code class="language-ts">
              //ExpenseForm.tsx
              ...
              const [previousAmount, setPreviousAmount] = useState(0)
              const { dispatch, state, remainingBudget } = useBudget()

              useEffect(() => {
                if(state.editingId){
                  const editingExpense = state.expenses.filter( currentExpense => currentExpense.id === state.editingId)[0]
                  setExpense(editingExpense)
                  setPreviousAmount(editingExpense.amount)
                }
              },[state.editingId])

            </code></pre>

            <p>y entonces cambiamos nuestra validación de esto a esto e importante reinicar también ese nuevo state previousAmount porqeu en los siguientes que yo agregue queremos iniciar a 0 y entonces cuando se monte el componente, cuando estemos editando que lo tome de ahí:</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre class="rojo" data-line="1"><code class="language-js">
                  //Validar que no me pase del presupuesto
                  if( expense.amount > remainingBudget){
                    setError('Ese gasto es mayor que lo que resta de Presupuesto')
                    return
                  }
                  ...
                  //reiniciar el state
                  setExpense({
                    amount: 0,
                    expenseName: '',
                    category: '',
                    date: new Date()
                  })
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre class="verde" data-line="1,13"><code class="language-js">
                  //Validar que no me pase del presupuesto
                  if( (expense.amount-previousAmount) > remainingBudget){
                    setError('Ese gasto es mayor que lo que resta de Presupuesto')
                    return
                  }
                  ...
                  //reiniciar el state
                  setExpense({
                    amount: 0,
                    expenseName: '',
                    category: '',
                    date: new Date()
                  })
                  setPreviousAmount(0)
                </code></pre>
              </div>
            </div>


          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-224').toggle();">
            <h3>224. Agregando una gráfica circular interactiva y RETO 05 - <a class="text-white underline" href="https://www.npmjs.com/package/react-circular-progressbar" target="_blank">React Circular Progressbar</a> / 225. Crear un botón para reiniciar la app</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-224" class="hidden">
            <p>Veamos como realizar esta gráfica circular dinámica para lo cual instalamos la dependencia <span class="destacado">npm i react-circular-progressbar</span>. Importamos y sustituimos el jpg estático por este componente. El prop value representa el % de lo que se llena, hay que hacerlo dinámico para lo cual hacemos lo siguiente: <code class="language-ts">const percentage = +((totalExpenses / state.budget) * 100).toFixed(2)</code>.</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="1,2,7,13-19"><code class="language-ts">
                  //BudgetTracker.tsx
                  import { CircularProgressbar, buildStyles } from 'react-circular-progressbar'
                  import "react-circular-progressbar/dist/styles.css"
                  ...
                  export default function BudgetTracker() {
                    const { state, remainingBudget, totalExpenses } = useBudget()
                
                    const percentage = +((totalExpenses / state.budget) * 100).toFixed(2)
                    //console.log(percentage)
                
                    return (
                      &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-5&quot;&gt;
                        &lt;div className=&quot;flex justify-center&quot;&gt;
                        &lt;CircularProgressbar 
                            value={percentage}
                            styles={buildStyles({
                                pathColor: percentage === 100? &#39;#dc2626&#39; : &#39;#3b82f6&#39;,
                                trailColor: &#39;#f5f5f5&#39;,
                                textSize: 8,
                                textColor: percentage === 100? &#39;#dc2626&#39; : &#39;#3b82f6&#39;
                            })}
                            text={`${percentage}% gastado`}                
                        /&gt;
                        &lt;/div&gt;
                        ...
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%] mr-2">
                <img src="./src/assets/img/224.png" alt="img" loading="lazy">
              </div>
            </div>  

            <p>Hagamos el <strong>Reto 05: Reiniciar la App</strong></p>

            <ul class="list-disc my-2.5">
              <li>Hacer funcional el botón de Reiniciar o Resetear App</li>
              <li>Deberemos crear la acción y mandarla llamar con Dispatch</li>
              <li>Seguir las convenciones de nombres del custom hook y reducer</li>
            </ul>

            <p>En <span class="file">budget-reducer.ts</span> agregamos nueva acción sin payload y en el if del reducer tomamos copia del state, inicializamos el presupuesto a 0 y los gastos array vacío (no hace falt poner a false el modal porque el hecho de estar pulsando el botón ya presupone que está cerrado). En <span class="file">BudgetTracker</span> extraemos el dispatch de nuestro useBudget() y lo usamos para crear una función de borrado que llamamos desde el onClick del botón.</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  //budget-reducer.ts
                  ...
                  { type: 'restart-app' } 
                  ...
                  if(action.type == "restart-app" ){
                    return{
                        ...state,
                        budget: 0,
                        expenses: []
                    }
                }
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="1,2,6"><code class="language-ts">
                  //BudgetTracker.tsx
                  const { state, remainingBudget, totalExpenses, dispatch } = useBudget()
                  const resetApp = () =>{dispatch({type: 'restart-app'}) }
                  ..
                  &lt;button
                      type=&quot;button&quot;
                      className=&#39;bg-pink-600 w-full p-2 text-white uppercase font-bold rounded-lg cursor-pointer&#39;
                      onClick={resetApp}
                  &gt;
                      Resetear App
                  &lt;/button&gt;
                </code></pre>
              </div>
            </div>

            

          </div>


          <!-- Bloque desplegable interior-->
          <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-226').toggle();">
            <h3>226. Creando un componente para filtrar los gastos / 227. Escribiendo en el State la categoría a filtrar / 228. Mostrar los gastos de la categoría seleccionada y Building de la App</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion13-226" class="">
            <p>Vamos a preparar un compo para poder filtrar los gastos por categorías en caso de que lleguen a ser muchos. Cerramos todo y abrimos nuestro App.tsx. Vamos a colocar nuestro nuevo componente antes de &lt;ExpenseList/&gt;.</p>

            <p>Una vez que elijamos una de esas categorías se tiene que actualizar el listado de gastos para presentarnos solo los correspondientes a esa categoría elegida. <strong>Debido a que son dos componentes distintos lo ideal va a ser colocarlo en el reducer para que con context tengamos ese valor de forma global.</strong> Vamos a nuestro reducer y agregamos una nueva acción 'add-filter-category', un nuevo state 'currentCategory' (y también en el type) y su correspondiente if.</p>

            <p>En nuestro nuevo componente importamos nuestro hook useBudget() yextraemos el dispatch porque vamos a escribir en el state. En nuestro select añadimos onChange que llama a la función que creamos handleChange.</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="1,8,15,18-23"><code class="language-ts">
                  //budget-reducer.ts
                  { type: 'add-filter-category' , payload: {id: Category['id']} }
                  ....
                  export type BudgetState = {
                    budget: number
                    modal: boolean
                    expenses: Expense[]
                    editingId: Expense['id']
                    currentCategory: Category['id']
                  }
                  export const initialState: BudgetState = {
                    budget: initialBudget(),
                    modal: false,
                    expenses: localStorageExpenses(),
                    editingId: '',
                    currentCategory: ''
                  }
                  ...
                  if(action.type === "add-filter-category"){
                    return {
                        ...state,
                        currentCategory: action.payload.id
                    }
                  }
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-ts">
                  //FilterByCategory.tsx
                  import { ChangeEvent } from "react";
                  import { categories } from &quot;../data/categories&quot;;
                  import { useBudget } from &quot;../hooks/useBudget&quot;;

                  export default function FilterByCategory() {

                      const { dispatch } = useBudget() 

                      const handleChange = (e: ChangeEvent&lt;HTMLSelectElement&gt;) =&gt; {
                          dispatch({type: &quot;add-filter-category&quot;, payload: {id: e.target.value}})
                      }
                    return (
                      &lt;div className=&quot;bg-white shadow-lg rounded-lg p-10&quot;&gt;
                        &lt;form action=&quot;&quot;&gt;
                          &lt;div className=&quot;flex flex-col md:flex-row md:items-center gap-5&quot;&gt;
                              &lt;label htmlFor=&quot;category&quot;&gt;Filtrar gastos&lt;/label&gt;
                              &lt;select 
                                  id=&quot;category&quot;
                                  className=&quot;bg-slate-100 p-3 flex-1 rounded&quot;
                                  onChange={handleChange}
                              &gt;
                                  &lt;option value=&quot;&quot;&gt;-- Todas las categorías&lt;/option&gt;
                                  {categories.map(category =&gt; (
                                      &lt;option 
                                          key={category.id}
                                          value={category.id}
                                      &gt;
                                          {category.name}
                                      &lt;/option&gt;
                                  ))}
                              &lt;/select&gt;
                          &lt;/div&gt;
                        &lt;/form&gt;
                      &lt;/div&gt;
                    )
                  }
                </code></pre>
              </div>
            </div>

            <p>Si vemos en la pestaña componentes de RDT vemos que en nuestro nuevo state 'currentCategory' se guarda la categoría cada vez que cambiamos el select de filtrado, por lo que podemos añadir algo de código en ExpenseList.tsx para que itere sobre los gastos que pertenecen a esa categoría.</p>

            <p class="naranja">Mostrar los gastos de la categoría seleccionada y Building de la App</p>

            <p>Abrimos ExpenseList.tsx y para no iterar directamente sobre el state 'state.expenses', vamos a crear una variable 'filteredExpenses' en la que vamos a revisar si hay una categoría seleccionada; si la hay filtramos los gastos que tienen esa categoría y si no la hay devolvemos todos los gasto. A continuación vamos a iterar con el .map() sobre nuestra nueva variable 'filteredExpenses' en lugar de state.expenses (y hacemos el mismo cambio en isEmpty (incluso en la dependencia del useMemo) para que nos muestre el título adecuado Listado de gastos vs No hay gastos)</p>

            <pre data-line="2,8-10,18"><code class="language-ts">
              //ExpenseList.tsx
              import { useMemo } from &quot;react&quot;
              import { useBudget } from &quot;../hooks/useBudget&quot;
              import ExpenseDetail from &quot;./ExpenseDetail&quot;

              export default function ExpenseList() {

                const { state } = useBudget()    
                const filteredExpenses = state.currentCategory ? state.expenses.filter( expense => expense.category === state.currentCategory) : state.expenses
                // const isEmpty = useMemo(() => state.expenses.length === 0, [state.expenses])
                const isEmpty = useMemo(() => filteredExpenses.length === 0, [filteredExpenses])

                return (
                    &lt;div className=&quot;mt-10 bg-white shadow-lg rounded-lg p-5&quot;&gt;
                        {isEmpty ? &lt;p className=&quot;text-gray-600 text-2xl font-bold&quot;&gt;No hay gastos&lt;/p&gt; : (
                            &lt;&gt;
                                &lt;p className=&quot;text-gray-600 text-2xl font-bold mb-5&quot;&gt;Listado de gastos.&lt;/p&gt;
                                {/* {state.expenses.map( expense =&gt; ( */}
                                {filteredExpenses.map( expense =&gt; (
                                    &lt;ExpenseDetail
                                        key = {expense.id}
                                        expense = {expense}
                                    /&gt;
                                ))}
                            &lt;/&gt;
                        )}
                    &lt;/div&gt;
                )
              }
            </code></pre>

          </div>


        </div>
        <!-- Fin div colapsable-->

      </div>
      <!-- FIN SECCION 13 -->


      <!-- SECCION 12 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 my-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">

        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between" onclick="$('#seccion12').toggle();">
          <h2>Section 12: PROYECTO - Calculadora de Propinas - Migrando hacia useReducer <span class="rojo">PTE. HACER</span></h2>
          <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
        </div>

        <div id="seccion12" class="hidden">

            <!-- Bloque desplegable interior-->
            <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion12-XX').toggle();">
              <h3>XXXXXXXXXXXXXXX</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion12-XX" class="hidden">


            </div>

        </div>
        <!-- Fin div colapsable-->

      </div>
      <!-- FIN SECCION 12 -->


      <!-- SECCION 11 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 my-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">

        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between" onclick="$('#seccion11').toggle();">
          <h2>Sección 11: PROYECTO - Migrar el Carrito de Compras de Guitarras a useReducer</h2>
          <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
        </div>

        <div id="seccion11" class="hidden">
          
          <a class="underline text-rose-600 font-bold" href="https://github.com/and....55/guitarla-ur/" target="blank">https://github.com/and....55/guitarla-ur/</a>
          <p> <span class="destacado">migrar la funcionalidad de nuestro custom hook hacia useReducer</span> <span class="destacado">localStorage</span> <strong>useReducer:</strong> recordemos una excelente forma de manejar states más complejos o hacer operaciones en diferentes estados al mismo tiempo.</p>


            <!-- Bloque desplegable interior-->
            <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion11-ficheros').toggle();">
              <h3>FICHEROS FINALES</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion11-ficheros" class="hidden">
              
              <code class="cursor-pointer" onclick="$('#11-guitar').toggle();">Guitar.tsx</code>
              <pre data-line="0" id="11-guitar" class="hidden"><code class="language-ts">
                  //Guitar.tsx
                  import { Dispatch } from 'react'
                  import type { Guitar } from &#39;../types&#39;
                  import { CartActions } from &#39;../reducers/cart-reducer&#39;

                  type GuitarProps = {
                      guitar : Guitar, 
                      dispatch : Dispatch&lt;CartActions&gt;
                  }

                  export default function Guitar({guitar, dispatch} : GuitarProps) {

                      const { name, image, description, price } = guitar

                      return (
                          &lt;div className=&quot;col-md-6 col-lg-4 my-4 row align-items-center&quot;&gt;
                              &lt;div className=&quot;col-4&quot;&gt;
                                  &lt;img className=&quot;img-fluid&quot; src={`/img/${image}.jpg`} alt=&quot;imagen guitarra&quot; /&gt;
                              &lt;/div&gt;
                              &lt;div className=&quot;col-8&quot;&gt;
                                  &lt;h3 className=&quot;text-black fs-4 fw-bold text-uppercase&quot;&gt;{name}&lt;/h3&gt;
                                  &lt;p&gt;{description}&lt;/p&gt;
                                  &lt;p className=&quot;fw-black text-primary fs-3&quot;&gt;${price}&lt;/p&gt;
                                  &lt;button 
                                      type=&quot;button&quot;
                                      className=&quot;btn btn-dark w-100&quot;
                                      onClick={() =&gt; dispatch({type: &#39;add-to-cart&#39;, payload: {item: guitar} })}
                                  &gt;Agregar al Carrito&lt;/button&gt;
                              &lt;/div&gt;
                          &lt;/div&gt;
                      )
                  }  
              </code></pre>   

              <code class="cursor-pointer" onclick="$('#11-header').toggle();">Header.tsx</code>
              <pre data-line="0" id="11-header" class="hidden"><code class="language-ts">
                import { useMemo, Dispatch } from &quot;react&quot;
                import type { CartItem } from &quot;../types&quot;
                import { CartActions } from &quot;../reducers/cart-reducer&quot;
                
                type HeaderProps = {
                    cart: CartItem[]
                    dispatch: Dispatch&lt;CartActions&gt;
                }
                
                export default function Header({ cart, dispatch } : HeaderProps ) {
                
                    // State Derivado
                    const isEmpty = useMemo( () =&gt; cart.length === 0, [cart])
                    const cartTotal = useMemo( () =&gt; cart.reduce( (total, item ) =&gt; total + (item.quantity * item.price), 0), [cart] )
                
                    return (
                        &lt;header className=&quot;py-5 header&quot;&gt;
                            &lt;div className=&quot;container-xl&quot;&gt;
                                &lt;div className=&quot;row justify-content-center justify-content-md-between&quot;&gt;
                                    &lt;div className=&quot;col-8 col-md-3&quot;&gt;
                                        &lt;a href=&quot;index.html&quot;&gt;
                                            &lt;img className=&quot;img-fluid&quot; src=&quot;/img/logo.svg&quot; alt=&quot;imagen logo&quot; /&gt;
                                        &lt;/a&gt;
                                    &lt;/div&gt;
                                    &lt;nav className=&quot;col-md-6 a mt-5 d-flex align-items-start justify-content-end&quot;&gt;
                                        &lt;div 
                                            className=&quot;carrito&quot;
                                        &gt;
                                            &lt;img className=&quot;img-fluid&quot; src=&quot;/img/carrito.png&quot; alt=&quot;imagen carrito&quot; /&gt;
                
                                            &lt;div id=&quot;carrito&quot; className=&quot;bg-white p-3&quot;&gt;
                                                {isEmpty ? (
                                                    &lt;p className=&quot;text-center&quot;&gt;El carrito esta vacio&lt;/p&gt;
                                                ) : (
                                                &lt;&gt;
                                                    &lt;table className=&quot;w-100 table&quot;&gt;
                                                        &lt;thead&gt;
                                                            &lt;tr&gt;
                                                                &lt;th&gt;Imagen&lt;/th&gt;
                                                                &lt;th&gt;Nombre&lt;/th&gt;
                                                                &lt;th&gt;Precio&lt;/th&gt;
                                                                &lt;th&gt;Cantidad&lt;/th&gt;
                                                                &lt;th&gt;&lt;/th&gt;
                                                            &lt;/tr&gt;
                                                        &lt;/thead&gt;
                                                        &lt;tbody&gt;
                                                            {cart.map( guitar =&gt; (
                                                                &lt;tr key={guitar.id}&gt;
                                                                    &lt;td&gt;
                                                                        &lt;img 
                                                                            className=&quot;img-fluid&quot; 
                                                                            src={`/img/${guitar.image}.jpg`}
                                                                            alt=&quot;imagen guitarra&quot; 
                                                                        /&gt;
                                                                    &lt;/td&gt;
                                                                    &lt;td&gt;{guitar.name}&lt;/td&gt;
                                                                    &lt;td className=&quot;fw-bold&quot;&gt;
                                                                        ${guitar.price}
                                                                    &lt;/td&gt;
                                                                    &lt;td className=&quot;flex align-items-start gap-4&quot;&gt;
                                                                        &lt;button
                                                                            type=&quot;button&quot;
                                                                            className=&quot;btn btn-dark&quot;
                                                                            onClick={() =&gt; dispatch({type: &quot;decrease-quantity&quot;, payload:{id: guitar.id}})}
                                                                        &gt;
                                                                            -
                                                                        &lt;/button&gt;
                                                                            {guitar.quantity}
                                                                        &lt;button
                                                                            type=&quot;button&quot;
                                                                            className=&quot;btn btn-dark&quot;
                                                                            onClick={() =&gt; dispatch({type: &quot;increase-quantity&quot;, payload:{id: guitar.id}})}
                                                                        &gt;
                                                                            +
                                                                        &lt;/button&gt;
                                                                    &lt;/td&gt;
                                                                    &lt;td&gt;
                                                                        &lt;button
                                                                            className=&quot;btn btn-danger&quot;
                                                                            type=&quot;button&quot;
                                                                            onClick={() =&gt; dispatch({type: &#39;remove-from-cart&#39;, payload: {id: guitar.id}})}
                                                                        &gt;
                                                                            X
                                                                        &lt;/button&gt;
                                                                    &lt;/td&gt;
                                                                &lt;/tr&gt;
                                                            ))}
                                                        &lt;/tbody&gt;
                                                    &lt;/table&gt;
                
                                                    &lt;p className=&quot;text-end&quot;&gt;Total pagar: &lt;span className=&quot;fw-bold&quot;&gt;${cartTotal}&lt;/span&gt;&lt;/p&gt;
                                                &lt;/&gt;
                                                )}
                
                                                &lt;button 
                                                    className=&quot;btn btn-dark w-100 mt-3 p-2&quot;
                                                    onClick={()=&gt;dispatch({type: &quot;clear-cart&quot;})}
                                                &gt;Vaciar Carrito&lt;/button&gt;
                                            &lt;/div&gt;
                                        &lt;/div&gt;
                                    &lt;/nav&gt;
                                &lt;/div&gt;
                            &lt;/div&gt;
                        &lt;/header&gt;
                    )
                }                
              </code></pre>

              <code class="cursor-pointer" onclick="$('#11-data').toggle();">data&gt;db.ts</code>
              <pre data-line="0" id="11-data" class="hidden"><code class="language-ts">
                import type { Guitar } from '../types'

                export const db : Guitar[] = [
                    {
                        id: 1,
                        name: 'Lukather',
                        image: 'guitarra_01',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 299
                    },
                    {
                        id: 2,
                        name: 'SRV',
                        image: 'guitarra_02',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 349,
                    },
                    {
                        id: 3,
                        name: 'Borland',
                        image: 'guitarra_03',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 329,
                    },
                    {
                        id: 4,
                        name: 'VAI',
                        image: 'guitarra_04',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 299,
                    },
                    {
                        id: 5,
                        name: 'Thompson',
                        image: 'guitarra_05',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 399,
                    },
                    {
                        id: 6,
                        name: 'White',
                        image: 'guitarra_06',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 329,
                    },
                    {
                        id: 7,
                        name: 'Cobain',
                        image: 'guitarra_07',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 349,
                    },
                    {
                        id: 8,
                        name: 'Dale',
                        image: 'guitarra_08',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 379,
                    },
                    {
                        id: 9,
                        name: 'Krieger',
                        image: 'guitarra_09',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 289,
                    },
                    {
                        id: 10,
                        name: 'Campbell',
                        image: 'guitarra_10',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 349,
                    },
                    {
                        id: 11,
                        name: 'Reed',
                        image: 'guitarra_11',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 399,
                    },
                    {
                        id: 12,
                        name: 'Hazel',
                        image: 'guitarra_12',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 379,
                    },
                  ]
              </code></pre>

              <code class="cursor-pointer" onclick="$('#11-reducer').toggle();">reducer&gt;cart-reducer.ts</code>
              <pre data-line="0" id="11-reducer" class="hidden"><code class="language-ts">
                import { db } from &#39;../data/db&#39;
                import type { CartItem, Guitar } from &quot;../types&quot;
                
                export type CartActions = 
                    { type: &#39;add-to-cart&#39;, payload: {item : Guitar}} |
                    { type: &#39;remove-from-cart&#39;, payload: {id : Guitar[&#39;id&#39;]}} |
                    { type: &#39;decrease-quantity&#39;, payload: {id: Guitar[&#39;id&#39;]}} |
                    { type: &#39;increase-quantity&#39;, payload: {id: Guitar[&#39;id&#39;]}} |
                    { type: &#39;clear-cart&#39;}
                
                export type CartState = {
                    data: Guitar[],
                    cart: CartItem[]
                }
                const initialCart = () : CartItem[] =&gt; {
                    const localStorageCart = localStorage.getItem(&#39;cart&#39;)
                    return localStorageCart ? JSON.parse(localStorageCart) : []
                }
                export const initialState : CartState = {
                    data: db, //nuestra bbdd de guitarra con los datos
                    //cart: []
                    cart: initialCart()
                }
                
                const MIN_ITEMS = 1
                const MAX_ITEMS = 5
                
                export const cartReducer = (    
                        state: CartState = initialState,
                        action: CartActions
                    ) =&gt; {
                
                    if (action.type === &quot;add-to-cart&quot;){
                        const itemExists = state.cart.find(guitar =&gt; guitar.id === action.payload.item.id)
                        //console.log(itemExists)
                        let updatedCart : CartItem[] = []
                        if(itemExists ) { // existe en el carrito
                            updatedCart = state.cart.map(item =&gt; {
                                if(item.id === action.payload.item.id){ //ese es el elemento que el user está agregando repetido
                                    if(item.quantity &lt; MAX_ITEMS){ //le permitimos agregarlo
                                        return{...item,quantity: item.quantity + 1 } //copia del item e incrementamos quantity
                                    } else {
                                        return item // llegamos a 5, no se cumple lo anterior pero mantenemos lo que teníamos en el carrito
                                    }
                                } else {//el que no estamos agregando repetido pero no queremos perder
                                    return item
                                }
                            })            
                        } else {
                            const newItem : CartItem = {...action.payload.item, quantity : 1}
                            updatedCart = [...state.cart, newItem]
                        }
                
                        return{
                            ...state,
                            cart: updatedCart
                        }
                    }
                    if (action.type === &quot;remove-from-cart&quot;){
                        const updatedCart = state.cart.filter( item =&gt; item.id !== action.payload.id)       
                        return{
                            ...state,
                            cart: updatedCart
                        }
                    }
                    if (action.type === &quot;decrease-quantity&quot;){
                        const updatedCart = state.cart.map( item =&gt; {
                            if(item.id === action.payload.id &amp;&amp; item.quantity &gt; MIN_ITEMS) {
                                return {
                                    ...item,
                                    quantity: item.quantity - 1
                                }
                            }
                            return item
                        })    
                        return{
                            ...state,
                            cart: updatedCart
                        }
                    }
                    if(action.type === &quot;increase-quantity&quot;){
                        const updatedCart = state.cart.map( item =&gt; {
                            if(item.id === action.payload.id &amp;&amp; item.quantity &lt; MAX_ITEMS) {
                                return {
                                    ...item,
                                    quantity: item.quantity + 1
                                }
                            }
                            return item
                        })        
                        return{
                            ...state,
                            cart: updatedCart
                        }
                    }
                    if(action.type === &quot;clear-cart&quot;){
                        const updatedCart : CartItem[] = []
                        return{
                            ...state,
                            cart: updatedCart
                        }
                    }
                
                    return state
                    
                }
              </code></pre>

              <code class="cursor-pointer" onclick="$('#11-indexts').toggle();">types&gt;index.ts</code>
              <pre data-line="0" id="11-indexts" class="hidden"><code class="language-ts">
                export type Guitar = {
                  id: number
                  name: string
                  image: string
                  description: string
                  price: number
              }
              
              export type CartItem = Guitar & {
                  quantity: number
              }
              
              // export type CartItem = Pick&lt;Guitar, &#39;id&#39; | &#39;name&#39; | &#39;price&#39; &gt; &amp; {
              //     quantity: number
              // }
              // export type CartItem = Omit&lt;Guitar, &#39;id&#39; | &#39;name&#39; | &#39;price&#39; &gt; &amp; {
              //     quantity: number
              // }
              </code></pre>

              <code class="cursor-pointer" onclick="$('#11-app').toggle();">App.tsx</code>
              <pre data-line="0" id="11-app" class="hidden"><code class="language-ts">
                import { useReducer, useEffect } from &quot;react&quot;
                import Guitar from &quot;./components/Guitar&quot;
                import Header from &quot;./components/Header&quot;
                import { cartReducer, initialState } from &quot;./reducers/cart-reducer&quot;
                
                function App() {
                
                  const [state,dispatch] = useReducer(cartReducer, initialState)
                
                  useEffect(() =&gt; {
                    localStorage.setItem(&#39;cart&#39;, JSON.stringify(state.cart))
                  }, [state.cart])
                
                  return (
                    &lt;&gt;
                      &lt;Header 
                        cart={state.cart}
                        dispatch={dispatch}     
                      /&gt;
                      
                      &lt;main className=&quot;container-xl mt-5&quot;&gt;
                          &lt;h2 className=&quot;text-center&quot;&gt;Nuestra Colección&lt;/h2&gt;
                
                          &lt;div className=&quot;row mt-5&quot;&gt;
                              {state.data.map((guitar) =&gt; (
                                  &lt;Guitar 
                                    key={guitar.id}
                                    guitar={guitar}
                                    dispatch={dispatch}
                                  /&gt;
                              ))}
                              
                          &lt;/div&gt;
                      &lt;/main&gt;
                
                
                      &lt;footer className=&quot;bg-dark mt-5 py-5&quot;&gt;
                          &lt;div className=&quot;container-xl&quot;&gt;
                              &lt;p className=&quot;text-white text-center fs-4 mt-4 m-md-0&quot;&gt;GuitarLA - Todos los derechos Reservados&lt;/p&gt;
                          &lt;/div&gt;
                      &lt;/footer&gt;
                    &lt;/&gt;
                  )
                }
                
                export default App                
              </code></pre>

              <code class="cursor-pointer" onclick="$('#11-indexcss').toggle();">index.css</code>
              <pre data-line="0" id="11-indexcss" class="hidden"><code class="language-css">
                @charset "UTF-8";
                .fw-black {
                  font-weight: 900;
                }
                
                .btn-dark {
                  text-transform: uppercase;
                }
                
                .carrito {
                  background-color: transparent;
                  border: none;
                  max-width: 2rem;
                  position: relative;
                  z-index: 100;
                }
                
                .carrito #carrito {
                  display: none;
                  position: absolute;
                  box-shadow: 0px 10px 15px -3px rgba(0,0,0,0.1);
                }
                
                .carrito:hover #carrito {
                  display: block;
                  background-color: white;
                  padding: 10px;
                  height: fit-content;
                  min-width: 350px;
                  width: fit-content;
                  top: 100%;
                  right: 0;
                  left: unset;
                  margin-left: unset;
                  margin-right: unset;
                }
                
                #carrito img {
                  width: 30px;
                }
                
                #carrito .btn-danger {
                  font-size: 10px;
                  border-radius: 50%;
                  padding: 5px 9px;
                }
                
                #carrito .btn-dark {
                  padding: 0 2px;
                  margin: 0 3px;
                }
                .m-0 {
                  margin: 0;
                }
                /*!
                 * Bootstrap  v5.2.3 (https://getbootstrap.com/)
                 * Copyright 2011-2022 The Bootstrap Authors
                 * Copyright 2011-2022 Twitter, Inc.
                 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
                 */
                :root {
                  --bs-blue: #0d6efd;
                  --bs-indigo: #6610f2;
                  --bs-purple: #6f42c1;
                  --bs-pink: #d63384;
                  --bs-red: #dc3545;
                  --bs-orange: #fd7e14;
                  --bs-yellow: #ffc107;
                  --bs-green: #198754;
                  --bs-teal: #20c997;
                  --bs-cyan: #0dcaf0;
                  --bs-black: #000;
                  --bs-white: #FFF;
                  --bs-gray: #6c757d;
                  --bs-gray-dark: #343a40;
                  --bs-gray-100: #f8f9fa;
                  --bs-gray-200: #e9ecef;
                  --bs-gray-300: #dee2e6;
                  --bs-gray-400: #ced4da;
                  --bs-gray-500: #adb5bd;
                  --bs-gray-600: #6c757d;
                  --bs-gray-700: #495057;
                  --bs-gray-800: #343a40;
                  --bs-gray-900: #212529;
                  --bs-primary: #e99401;
                  --bs-secondary: #6c757d;
                  --bs-success: #198754;
                  --bs-info: #0dcaf0;
                  --bs-warning: #ffc107;
                  --bs-danger: #dc3545;
                  --bs-light: #f8f9fa;
                  --bs-dark: #262626;
                  --bs-primary-rgb: 233, 148, 1;
                  --bs-secondary-rgb: 108, 117, 125;
                  --bs-success-rgb: 25, 135, 84;
                  --bs-info-rgb: 13, 202, 240;
                  --bs-warning-rgb: 255, 193, 7;
                  --bs-danger-rgb: 220, 53, 69;
                  --bs-light-rgb: 248, 249, 250;
                  --bs-dark-rgb: 38, 38, 38;
                  --bs-white-rgb: 255, 255, 255;
                  --bs-black-rgb: 0, 0, 0;
                  --bs-body-color-rgb: 33, 37, 41;
                  --bs-body-bg-rgb: 255, 255, 255;
                  --bs-font-sans-serif: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", "Noto Sans", "Liberation Sans", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
                  --bs-font-monospace: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
                  --bs-gradient: linear-gradient(180deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0));
                  --bs-body-font-family: Outfit, sans-serif;
                  --bs-body-font-size: 1rem;
                  --bs-body-font-weight: 400;
                  --bs-body-line-height: 1.5;
                  --bs-body-color: #212529;
                  --bs-body-bg: #FFF;
                  --bs-border-width: 1px;
                  --bs-border-style: solid;
                  --bs-border-color: #dee2e6;
                  --bs-border-color-translucent: rgba(0, 0, 0, 0.175);
                  --bs-border-radius: 0.375rem;
                  --bs-border-radius-sm: 0.25rem;
                  --bs-border-radius-lg: 0.5rem;
                  --bs-border-radius-xl: 1rem;
                  --bs-border-radius-2xl: 2rem;
                  --bs-border-radius-pill: 50rem;
                  --bs-link-color: #FFF;
                  --bs-link-hover-color: #FFF;
                  --bs-code-color: #d63384;
                  --bs-highlight-bg: #fff3cd;
                }
                
                *,
                *::before,
                *::after {
                  box-sizing: border-box;
                }
                
                @media (prefers-reduced-motion: no-preference) {
                  :root {
                    scroll-behavior: smooth;
                  }
                }
                
                body {
                  margin: 0;
                  font-family: var(--bs-body-font-family);
                  font-size: var(--bs-body-font-size);
                  font-weight: var(--bs-body-font-weight);
                  line-height: var(--bs-body-line-height);
                  color: var(--bs-body-color);
                  text-align: var(--bs-body-text-align);
                  background-color: var(--bs-body-bg);
                  -webkit-text-size-adjust: 100%;
                  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
                }
                
                 h3, .h3, h2, .h2, h1, .h1 {
                  margin-top: 0;
                  margin-bottom: 0.5rem;
                  font-family: "Outfit", sans-serif;
                  font-weight: 900;
                  line-height: 1.2;
                  color: #e99401;
                }
                
                h1, .h1 {
                  font-size: calc(1.565rem + 3.78vw);
                }
                @media (min-width: 1200px) {
                  h1, .h1 {
                    font-size: 4.4rem;
                  }
                }
                
                h2, .h2 {
                  font-size: calc(1.485rem + 2.82vw);
                }
                @media (min-width: 1200px) {
                  h2, .h2 {
                    font-size: 3.6rem;
                  }
                }
                
                h3, .h3 {
                  font-size: calc(1.385rem + 1.62vw);
                }
                @media (min-width: 1200px) {
                  h3, .h3 {
                    font-size: 2.6rem;
                  }
                }
                
                p {
                  margin-top: 0;
                  margin-bottom: 1rem;
                }
                
                a {
                  color: var(--bs-link-color);
                  text-decoration: none;
                }
                a:hover {
                  color: var(--bs-link-hover-color);
                }
                
                a:not([href]):not([class]), a:not([href]):not([class]):hover {
                  color: inherit;
                  text-decoration: none;
                }
                
                img,
                svg {
                  vertical-align: middle;
                }
                
                table {
                  caption-side: bottom;
                  border-collapse: collapse;
                }
                
                th {
                  text-align: inherit;
                  text-align: -webkit-match-parent;
                }
                
                thead,
                tbody,
                tr,
                td,
                th {
                  border-color: inherit;
                  border-style: solid;
                  border-width: 0;
                }
                
                button {
                  border-radius: 0;
                }
                
                button:focus:not(:focus-visible) {
                  outline: 0;
                }
                
                
                button {
                  margin: 0;
                  font-family: inherit;
                  font-size: inherit;
                  line-height: inherit;
                }
                
                button {
                  text-transform: none;
                }
                
                button,
                [type=button] {
                  -webkit-appearance: button;
                }
                button:not(:disabled),
                [type=button]:not(:disabled) {
                  cursor: pointer;
                }
                
                ::-moz-focus-inner {
                  padding: 0;
                  border-style: none;
                }
                
                ::-webkit-datetime-edit-fields-wrapper,
                ::-webkit-datetime-edit-text,
                ::-webkit-datetime-edit-minute,
                ::-webkit-datetime-edit-hour-field,
                ::-webkit-datetime-edit-day-field,
                ::-webkit-datetime-edit-month-field,
                ::-webkit-datetime-edit-year-field {
                  padding: 0;
                }
                
                ::-webkit-inner-spin-button {
                  height: auto;
                }
                
                /* rtl:raw:
                [type="tel"],
                [type="url"],
                [type="email"],
                [type="number"] {
                  direction: ltr;
                }
                */
                ::-webkit-search-decoration {
                  -webkit-appearance: none;
                }
                
                ::-webkit-color-swatch-wrapper {
                  padding: 0;
                }
                
                ::file-selector-button {
                  font: inherit;
                  -webkit-appearance: button;
                }
                
                .display-2 {
                  font-size: calc(1.575rem + 3.9vw);
                  font-weight: 300;
                  line-height: 1.2;
                }
                @media (min-width: 1200px) {
                  .display-2 {
                    font-size: 4.5rem;
                  }
                }
                
                .img-fluid {
                  max-width: 100%;
                  height: auto;
                }
                
                
                .container-xl {
                  --bs-gutter-x: 1.5rem;
                  --bs-gutter-y: 0;
                  width: 100%;
                  padding-right: calc(var(--bs-gutter-x) * 0.5);
                  padding-left: calc(var(--bs-gutter-x) * 0.5);
                  margin-right: auto;
                  margin-left: auto;
                }
                @media (min-width: 1200px) {
                  .container-xl {
                    max-width: 1140px;
                  }
                }
                @media (min-width: 1400px) {
                   .container-xl {
                    max-width: 1320px;
                  }
                }
                .row {
                  --bs-gutter-x: 1.5rem;
                  --bs-gutter-y: 0;
                  display: flex;
                  flex-wrap: wrap;
                  margin-top: calc(-1 * var(--bs-gutter-y));
                  margin-right: calc(-0.5 * var(--bs-gutter-x));
                  margin-left: calc(-0.5 * var(--bs-gutter-x));
                }
                .row > * {
                  flex-shrink: 0;
                  width: 100%;
                  max-width: 100%;
                  padding-right: calc(var(--bs-gutter-x) * 0.5);
                  padding-left: calc(var(--bs-gutter-x) * 0.5);
                  margin-top: var(--bs-gutter-y);
                }
                
                .col-4 {
                  flex: 0 0 auto;
                  width: 33.33333333%;
                }
                
                .col-8 {
                  flex: 0 0 auto;
                  width: 66.66666667%;
                }
                @media (min-width: 768px) {
                  .col-md-3 {
                    flex: 0 0 auto;
                    width: 25%;
                  }
                  .col-md-6 {
                    flex: 0 0 auto;
                    width: 50%;
                  }
                }
                @media (min-width: 992px) {
                  .col-lg-4 {
                    flex: 0 0 auto;
                    width: 33.33333333%;
                  }
                }
                .table {
                  --bs-table-color: var(--bs-body-color);
                  --bs-table-bg: transparent;
                  --bs-table-border-color: var(--bs-border-color);
                  --bs-table-accent-bg: transparent;
                  --bs-table-striped-color: var(--bs-body-color);
                  --bs-table-striped-bg: rgba(0, 0, 0, 0.05);
                  --bs-table-active-color: var(--bs-body-color);
                  --bs-table-active-bg: rgba(0, 0, 0, 0.1);
                  --bs-table-hover-color: var(--bs-body-color);
                  --bs-table-hover-bg: rgba(0, 0, 0, 0.075);
                  width: 100%;
                  margin-bottom: 1rem;
                  color: var(--bs-table-color);
                  vertical-align: top;
                  border-color: var(--bs-table-border-color);
                }
                .table > :not(caption) > * > * {
                  padding: 0.5rem 0.5rem;
                  background-color: var(--bs-table-bg);
                  border-bottom-width: 1px;
                  box-shadow: inset 0 0 0 9999px var(--bs-table-accent-bg);
                }
                .table > tbody {
                  vertical-align: inherit;
                }
                .table > thead {
                  vertical-align: bottom;
                }
                
                .btn {
                  --bs-btn-padding-x: 0.75rem;
                  --bs-btn-padding-y: 0.375rem;
                  --bs-btn-font-family: ;
                  --bs-btn-font-size: 1rem;
                  --bs-btn-font-weight: 900;
                  --bs-btn-line-height: 1.5;
                  --bs-btn-color: #212529;
                  --bs-btn-bg: transparent;
                  --bs-btn-border-width: 1px;
                  --bs-btn-border-color: transparent;
                  --bs-btn-border-radius: 0;
                  --bs-btn-hover-border-color: transparent;
                  --bs-btn-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.15), 0 1px 1px rgba(0, 0, 0, 0.075);
                  --bs-btn-disabled-opacity: 0.65;
                  --bs-btn-focus-box-shadow: 0 0 0 0.25rem rgba(var(--bs-btn-focus-shadow-rgb), .5);
                  display: inline-block;
                  padding: var(--bs-btn-padding-y) var(--bs-btn-padding-x);
                  font-family: var(--bs-btn-font-family);
                  font-size: var(--bs-btn-font-size);
                  font-weight: var(--bs-btn-font-weight);
                  line-height: var(--bs-btn-line-height);
                  color: var(--bs-btn-color);
                  text-align: center;
                  vertical-align: middle;
                  cursor: pointer;
                  user-select: none;
                  border: var(--bs-btn-border-width) solid var(--bs-btn-border-color);
                  border-radius: var(--bs-btn-border-radius);
                  background-color: var(--bs-btn-bg);
                  transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
                }
                @media (prefers-reduced-motion: reduce) {
                  .btn {
                    transition: none;
                  }
                }
                .btn:hover {
                  color: var(--bs-btn-hover-color);
                  background-color: var(--bs-btn-hover-bg);
                  border-color: var(--bs-btn-hover-border-color);
                }
                .btn:focus-visible {
                  color: var(--bs-btn-hover-color);
                  background-color: var(--bs-btn-hover-bg);
                  border-color: var(--bs-btn-hover-border-color);
                  outline: 0;
                  box-shadow: var(--bs-btn-focus-box-shadow);
                }
                 :not(.btn-check) + .btn:active, .btn:first-child:active {
                  color: var(--bs-btn-active-color);
                  background-color: var(--bs-btn-active-bg);
                  border-color: var(--bs-btn-active-border-color);
                }
                 :not(.btn-check) + .btn:active:focus-visible, .btn:first-child:active:focus-visible {
                  box-shadow: var(--bs-btn-focus-box-shadow);
                }
                .btn:disabled {
                  color: var(--bs-btn-disabled-color);
                  pointer-events: none;
                  background-color: var(--bs-btn-disabled-bg);
                  border-color: var(--bs-btn-disabled-border-color);
                  opacity: var(--bs-btn-disabled-opacity);
                }
                
                .btn-danger {
                  --bs-btn-color: #FFF;
                  --bs-btn-bg: #dc3545;
                  --bs-btn-border-color: #dc3545;
                  --bs-btn-hover-color: #FFF;
                  --bs-btn-hover-bg: #bb2d3b;
                  --bs-btn-hover-border-color: #b02a37;
                  --bs-btn-focus-shadow-rgb: 225, 83, 97;
                  --bs-btn-active-color: #FFF;
                  --bs-btn-active-bg: #b02a37;
                  --bs-btn-active-border-color: #a52834;
                  --bs-btn-active-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
                  --bs-btn-disabled-color: #FFF;
                  --bs-btn-disabled-bg: #dc3545;
                  --bs-btn-disabled-border-color: #dc3545;
                }
                
                .btn-dark {
                  --bs-btn-color: #FFF;
                  --bs-btn-bg: #262626;
                  --bs-btn-border-color: #262626;
                  --bs-btn-hover-color: #FFF;
                  --bs-btn-hover-bg: #474747;
                  --bs-btn-hover-border-color: #3c3c3c;
                  --bs-btn-focus-shadow-rgb: 71, 71, 71;
                  --bs-btn-active-color: #FFF;
                  --bs-btn-active-bg: #515151;
                  --bs-btn-active-border-color: #3c3c3c;
                  --bs-btn-active-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
                  --bs-btn-disabled-color: #FFF;
                  --bs-btn-disabled-bg: #262626;
                  --bs-btn-disabled-border-color: #262626;
                }
                
                .nav {
                  --bs-nav-link-padding-x: 1rem;
                  --bs-nav-link-padding-y: 0.5rem;
                  --bs-nav-link-font-weight: ;
                  --bs-nav-link-color: var(--bs-link-color);
                  --bs-nav-link-hover-color: var(--bs-link-hover-color);
                  --bs-nav-link-disabled-color: #6c757d;
                  display: flex;
                  flex-wrap: wrap;
                  padding-left: 0;
                  margin-bottom: 0;
                  list-style: none;
                }
                
                @keyframes progress-bar-stripes {
                  0% {
                    background-position-x: 1rem;
                  }
                }
                
                /* rtl:begin:ignore */
                
                /* rtl:end:ignore */
                
                /* rtl:begin:ignore */
                
                /* rtl:end:ignore */
                
                /* rtl:begin:ignore */
                
                /* rtl:end:ignore */
                
                /* rtl:begin:ignore */
                
                /* rtl:end:ignore */
                
                /* rtl:options: {
                  "autoRename": true,
                  "stringMap":[ {
                    "name"    : "prev-next",
                    "search"  : "prev",
                    "replace" : "next"
                  } ]
                } */
                
                @keyframes spinner-border {
                  to {
                    transform: rotate(360deg) /* rtl:ignore */;
                  }
                }
                
                @keyframes spinner-grow {
                  0% {
                    transform: scale(0);
                  }
                  50% {
                    opacity: 1;
                    transform: none;
                  }
                }
                
                @keyframes placeholder-glow {
                  50% {
                    opacity: 0.2;
                  }
                }
                
                @keyframes placeholder-wave {
                  100% {
                    mask-position: -200% 0%;
                  }
                }
                
                .d-flex {
                  display: flex !important;
                }
                
                .w-100 {
                  width: 100% !important;
                }
                
                .justify-content-end {
                  justify-content: flex-end !important;
                }
                
                .justify-content-center {
                  justify-content: center !important;
                }
                
                .align-items-start {
                  align-items: flex-start !important;
                }
                
                .align-items-center {
                  align-items: center !important;
                }
                
                .my-4 {
                  margin-top: 1.5rem !important;
                  margin-bottom: 1.5rem !important;
                }
                
                .mt-3 {
                  margin-top: 1rem !important;
                }
                
                .mt-4 {
                  margin-top: 1.5rem !important;
                }
                
                .mt-5 {
                  margin-top: 3rem !important;
                }
                
                .p-2 {
                  padding: 0.5rem !important;
                }
                
                .p-3 {
                  padding: 1rem !important;
                }
                
                .px-5 {
                  padding-right: 3rem !important;
                  padding-left: 3rem !important;
                }
                
                .py-2 {
                  padding-top: 0.5rem !important;
                  padding-bottom: 0.5rem !important;
                }
                
                .py-5 {
                  padding-top: 3rem !important;
                  padding-bottom: 3rem !important;
                }
                
                .pt-5 {
                  padding-top: 3rem !important;
                }
                
                .gap-4 {
                  gap: 1.5rem !important;
                }
                
                .fs-1 {
                  font-size: calc(1.565rem + 3.78vw) !important;
                }
                
                .fs-3 {
                  font-size: calc(1.385rem + 1.62vw) !important;
                }
                
                .fs-4 {
                  font-size: calc(1.275rem + 0.3vw) !important;
                }
                
                .fs-5 {
                  font-size: 1.25rem !important;
                }
                
                .fw-bold {
                  font-weight: 700 !important;
                }
                
                .text-end {
                  text-align: right !important;
                }
                
                .text-center {
                  text-align: center !important;
                }
                
                .text-uppercase {
                  text-transform: uppercase !important;
                }
                
                /* rtl:begin:remove */
                
                /* rtl:end:remove */
                .text-primary {
                  --bs-text-opacity: 1;
                  color: rgba(var(--bs-primary-rgb), var(--bs-text-opacity)) !important;
                }
                
                .text-black {
                  --bs-text-opacity: 1;
                  color: rgba(var(--bs-black-rgb), var(--bs-text-opacity)) !important;
                }
                
                .text-white {
                  --bs-text-opacity: 1;
                  color: rgba(var(--bs-white-rgb), var(--bs-text-opacity)) !important;
                }
                
                .bg-primary {
                  --bs-bg-opacity: 1;
                  background-color: rgba(var(--bs-primary-rgb), var(--bs-bg-opacity)) !important;
                }
                
                .bg-dark {
                  --bs-bg-opacity: 1;
                  background-color: rgba(var(--bs-dark-rgb), var(--bs-bg-opacity)) !important;
                }
                
                .bg-white {
                  --bs-bg-opacity: 1;
                  background-color: rgba(var(--bs-white-rgb), var(--bs-bg-opacity)) !important;
                }
                @media (min-width: 768px) {
                  .justify-content-md-between {
                    justify-content: space-between !important;
                  }
                  .m-md-0 {
                    margin: 0 !important;
                  }
                  .text-md-start {
                    text-align: left !important;
                  }
                }
                @media (min-width: 1200px) {
                  .fs-1 {
                    font-size: 4.4rem !important;
                  }
                  .fs-3 {
                    font-size: 2.6rem !important;
                  }
                  .fs-4 {
                    font-size: 1.5rem !important;
                  }
                }
                @keyframes animarImagen {
                  0% {
                    opacity: 0;
                    transform: translateX(-10rem);
                  }
                  50% {
                    opacity: 0;
                  }
                  100% {
                    opacity: 1;
                    transform: translateX(0);
                  }
                }
                .header {
                  background-image: linear-gradient(to right, rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url("/img/header.jpg");
                  background-position: 50%;
                  background-size: cover;
                  position: relative;
                }
                .header .header-guitarra {
                  display: none;
                }
                @media (min-width: 992px) {
                  .header .header-guitarra {
                    display: block;
                    position: absolute;
                    right: 0;
                    bottom: 0;
                    animation-duration: 1s;
                    animation-delay: 0s;
                    animation-timing-function: ease-in-out;
                    animation-name: animarImagen;
                    z-index: 10;
                  }
                }
              </code></pre>

              <code class="cursor-pointer" onclick="$('#11-maintsx').toggle();">main.tsx</code>
              <pre data-line="0" id="11-maintsx" class="hidden"><code class="language-js">
                import React from 'react'
                import ReactDOM from 'react-dom/client'
                import App from './App.jsx'
                import './index.css'
                
                ReactDOM.createRoot(document.getElementById('root')!).render(
                  &lt;React.StrictMode&gt;
                    &lt;App /&gt;
                  &lt;/React.StrictMode&gt;,
                )
              </code></pre>                     
            </div>


            <!-- Bloque desplegable interior-->
            <div class="flex justify-between items-center mt-1.25 cursor-pointer oscuro" onclick="$('#seccion11-167').toggle();">
              <h3>167. Primeros pasos</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion11-167" class="hidden">
              <p>Bajamos el .zip de Recursos <strong>06-guitarla-ts-usereducer.zip</strong> y descomprimimos y nos quedamos con el de windows. Yo lo renombro a <span class="file">guitarla-ur</span> e instalamos dependencias <span class="destacado">npm install</span></p>
              <p>Gran parte de nuestro trabajo va a ser abrir nuestro fichero de hooks>useCart.ts y llevar todo ello hacia useReducer:</p>
              <pre><code class="language-js">
                //hooks>useCart.ts
                import { useState, useEffect, useMemo } from &#39;react&#39;
                import { db } from &#39;../data/db&#39;
                import type { Guitar, CartItem } from &#39;../types&#39;
                
                export const useCart = () =&gt; {
                
                    const initialCart = () : CartItem[] =&gt; {
                        const localStorageCart = localStorage.getItem(&#39;cart&#39;)
                        return localStorageCart ? JSON.parse(localStorageCart) : []
                    }
                
                    const [data] = useState(db)
                    const [cart, setCart] = useState(initialCart)
                
                    const MIN_ITEMS = 1
                    const MAX_ITEMS = 5
                
                    useEffect(() =&gt; {
                        localStorage.setItem(&#39;cart&#39;, JSON.stringify(cart))
                    }, [cart])
                
                    function addToCart(item : Guitar) {
                        const itemExists = cart.findIndex(guitar =&gt; guitar.id === item.id)
                        if(itemExists &gt;= 0 ) { // existe en el carrito
                            if(cart[itemExists].quantity &gt;= MAX_ITEMS) return
                            const updatedCart = [...cart]
                            updatedCart[itemExists].quantity++
                            setCart(updatedCart)
                        } else {
                            const newItem : CartItem = {...item, quantity : 1}
                            setCart([...cart, newItem])
                        }
                    }
                
                    function removeFromCart(id : Guitar[&#39;id&#39;]) {
                        setCart(prevCart =&gt; prevCart.filter(guitar =&gt; guitar.id !== id))
                    }
                
                    function decreaseQuantity(id : Guitar[&#39;id&#39;]) {
                        const updatedCart = cart.map( item =&gt; {
                            if(item.id === id &amp;&amp; item.quantity &gt; MIN_ITEMS) {
                                return {
                                    ...item,
                                    quantity: item.quantity - 1
                                }
                            }
                            return item
                        })
                        setCart(updatedCart)
                    }
                
                    function increaseQuantity(id : Guitar[&#39;id&#39;]) {
                        const updatedCart = cart.map( item =&gt; {
                            if(item.id === id &amp;&amp; item.quantity &lt; MAX_ITEMS) {
                                return {
                                    ...item,
                                    quantity: item.quantity + 1
                                }
                            }
                            return item
                        })
                        setCart(updatedCart)
                    }
                
                    function clearCart() {
                        setCart([])
                    }
                
                    // State Derivado
                    const isEmpty = useMemo( () =&gt; cart.length === 0, [cart])
                    const cartTotal = useMemo( () =&gt; cart.reduce( (total, item ) =&gt; total + (item.quantity * item.price), 0), [cart] )
                
                    return {
                        data,
                        cart,
                        addToCart,
                        removeFromCart,
                        decreaseQuantity,
                        increaseQuantity,
                        clearCart,
                        isEmpty,
                        cartTotal
                    }
                }
              </code></pre>

            </div>

            <!-- Bloque desplegable interior-->
            <div class="flex justify-between items-center mt-1.25 cursor-pointer oscuro" onclick="$('#seccion11-168').toggle();">
              <h3>168. Creando el reducer y el type de acciones / 169. Definiendo el State inicial / 170. Escribiendo el resto de las acciones</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion11-168" class="hidden">
              <p>Hacer esto no significa que el custom hook que hemos creado esté mal, hay muchos proyectos que lo hacen así, pero está intentando abrcar todo lo que hay que saber de React.</p>
              <p>Creamos en la carpeta src <span class="file">reducers&gt;cart-reducer.ts</span></p>
              <pre><code class="language-js">
                //reducers/cart-reducer.ts
                export type CartActions = {
    
                }
              </code></pre>
              <p class="naranja">Definiendo el type de acciones</p>
              <p>Cojamos las funciones siguientes de nuestro hook useCart.ts y convirtámoslas en un action en nuestro reducer:</p>
              
              
              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre data-line="0"><code class="language-js">
                    //hooks/useCart.ts                    
                    function addToCart(item : Guitar) { ... }
                    function removeFromCart(id : Guitar['id']) { ... }
                    function decreaseQuantity(id : Guitar['id']) { ... }
                    function increaseQuantity(id : Guitar['id']) { ... }
                    function clearCart() {
                        setCart([])
                    }
                  </code></pre>
                  <div class="bg-white">
                    <svg class="size-6 shrink-0 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                    </svg>
                  </div>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre data-line="0"><code class="language-js">
                    //cart-reducer.ts
                    import type { Guitar } from "../types"

                    export type CartActions = 
                        { type: 'add-to-cart', payload: {item : Guitar}} |
                        { type: 'remove-from-cart', payload: {id : Guitar['id']}} |
                        { type: 'decrease-quantity', payload: {id: Guitar['id']}} |
                        { type: 'increase-quantity', payload: {id: Guitar['id']}} |
                        { type: 'clear-cart'}
                  </code></pre>
                </div>
              </div>
              <p>Ya tenemos definidas todas las acciones y nos hace falta toda la lógica que veremos a continuación.</p>

              <p class="naranja">Definiendo el type de state y state inicial</p>
            
              <p><strong>Definamos el type y state inicial de nuestro carrito</strong> Nuestro proyecto solo tiene 2 states, uno los datos y otro el carrito. Una vez definido el type de nuestro carrito definimos el state inicial (<strong>¡Recordar! este se utiliza cuando utilizamos useReducer</strong>):</p>
              

              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre data-line="0"><code class="language-js">
                    //useCart.ts
                    const [data] = useState(db)
                    const [cart, setCart] = useState(initialCart)
                  </code></pre>
                  <div class="bg-white">
                    <svg class="size-6 shrink-0 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                    </svg>
                  </div>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre data-line="0"><code class="language-js">
                    //cart-reducer.ts
                    import { db } from '../data/db'
                    import type { CartItem, Guitar } from "../types"
                    ...
                    export type CartState = {
                      data: Guitar[],
                      cart: CartItem[]
                    } 
                    export const initialState : CartState = {
                      data: db, //nuestra bbdd de guitarra con los datos
                      cart: [] //de momento arreglo vacío pero recordemos que viene de localStorage, ahora lo hacemos                  
                  }
                  </code></pre>
                </div>
              </div>              

              <p class="naranja">Definiendo el reducer</p>

              <p>Creamos el reducer, con todas la funcionalidad para interaccionar con el state. Por tanto creamos cartReducer (con un export pues también este lo vamos a requerir cuando utilicemos el Hook de useReducer).</p>
              
              <ul class="my-2 list-disc">
                <li class="my-1">En la primera parte de los paréntesis le hacemos saber a este reducer cual es nuestro state y qué acciones son las que tenemos disponibles, colocando como parámetros y con esos types el state y las acciones. Con ello tenemos nuestro maravilloso autocompletado en el reducer.
                  <pre><code class="language-js">
                    //cart-reducer.ts                
                    export const cartReducer = (    
                      state: CartState = initialState,
                      actions: CartActions
                      ) => {
                        
                        reurn state
                    }
                  </code></pre>
                </li>
                <li class="my-1">y entonces ya podemos comenzar a definir todas las acciones. <strong>Vamos colocando los if validando el action.type con los nombres de las acciones que tenemos definidas en la parte superior</strong>:

                  <div class="flex max-sm:flex-col">
                    <div class="w-[50%] max-sm:w-[100%]">
                      <pre><code class="language-js">
                        //cart-reducer.ts                
                        import { db } from '../data/db'
                        import type { CartItem, Guitar } from "../types"
                        
                        export type CartActions = 
                            { type: 'add-to-cart', payload: {item : Guitar}} |
                            { type: 'remove-from-cart', payload: {id : Guitar['id']}} |
                            { type: 'decrease-quantity', payload: {id: Guitar['id']}} |
                            { type: 'increase-quantity', payload: {id: Guitar['id']}} |
                            { type: 'clear-cart'}
                        
                        export type CartState = {
                            data: Guitar[],
                            cart: CartItem[]
                        }
                        export const initialState : CartState = {
                            data: db, //nuestra bbdd de guitarra con los datos
                            cart: [] //de momento arreglo vacío pero recordemos que viene de localStorage, ahora lo hacemos
                        
                        }
                        
                        export const cartReducer = (    
                                state: CartState = initialState,
                                actions: CartActions
                            ) => {
                        
                            if (action.type === "add-to-cart"){
                                return{
                                    ...state
                                }
                            }
                            if (action.type === "remove-from-cart"){
                                return{
                                    ...state
                                }
                            }
                            if (action.type === "decrease-quantity"){
                                return{
                                    ...state
                                }
                            }
                            if(action.type === "increase-quantity"){
                                return{
                                    ...state
                                }
                            }
                            if(action.type === "clear-cart"){
                                return{
                                    ...state
                                }
                            }
                        
                            return state
                            
                        }
                      </code></pre>
                    </div>
                    <div class="w-[50%] max-sm:w-[100%]">
                      <img src="./src/assets/img/170.png" alt="img" loading="lazy">
                    </div>
                  </div>
                  
                </li>
              </ul>
             

              <p><span class="destacado">Ya tenemos los type de acciones, el type de state, state inicial y el reducer</span></p>

            </div>

            <!-- Bloque desplegable interior-->
            <div class="flex justify-between items-center mt-1.25 cursor-pointer oscuro" onclick="$('#seccion11-171').toggle();">
              <h3>171. Instanciando el reducer en la página principal / 172. Migrando del Custom Hook hacia useReducer / 173. Migrando el addToCart hacia useReducer</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion11-171" class="hidden">      
              <p>Como ya tenemos definido en nuestro fichero de reducers&gt;cart-reducer.ts las acciones, state(type y state inicial) y el reducer, ya podemos ir a nuestro compo ppal App.tsx y utilizar useReducer <code class="language-js">import { useReducer } from "react"</code>. Fijémonos que:</p>
              
              <ul class="list-disc">
                <li>de nuestro custom hook con destructuring  ¡¡¡retornamos 9 cosas!!! <span class="destacado">como objeto{}</span> <code class="language-js">const { data, cart, addToCart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart, isEmpty, cartTotal } = useCart()</code>.</li>
                <li>Usando nuestro reducer solo retornamos state y dispatch <span class="destacado">como arreglo[]</span>: <code class="language-js"> const [state,dispatch] = useReducer(cartReducer, initialState)</code> (esos dos parámetros que toma: reducer y el initial state los tenemos exportados en nuestro fichero de reducer así que se importan aquí e la App.tsx)</li>
              </ul> 

              <pre data-line="1,3,7"><code class="language-js">
                //App.tsx
                import { useReducer } from "react"
                ...
                import { cartReducer, initialState } from "./reducers/cart-reducer"
                
                function App() {    
                  const { data, cart, addToCart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart, isEmpty, cartTotal } = useCart()
                  const [state,dispatch] = useReducer(cartReducer, initialState)
              </code></pre>

                <p>Así ya tanto state como dispatch van a tener la información necesaria. Si ponemos un console.log(state) vemos que ya funciona correctamente, lo estamos conectando desde el reducer y en la consola nos retorna lo que hemos colocado como initialState: <strong>cart</strong> que es un array vacío [] y <strong>data</strong> lo que tenemos en nuestra pequeña bbdd.</p>

                <p>Vamos a ir reemplazando cada una de las partes ¿moviendo todo lo que tenemos en nuestro <span class="rojo">x9</span><strong>custom hook useCart()</strong> hacia nuestro <span class="verde">x2</span><strong>reducer useReducer()</strong></p>

                <p class="naranja">Migrando del Custom Hook hacia useReducer</p>
              

                <p>Vamos a mover todo lo de nuestro custom hook al reducer, no es que estuviera mal, simplemente Estamos tratando de usar diferentes técnicas para poner en práctica diferentes escenarios en este caso una función de tipo reducer.</p>

                <p>Comencemos con las guitarras, que es la parte central de nuestro proyecto. Actualmente las tenemos en data de nuestro custom hook pero como ya las tenemos en nuestro state del reducer las mostramos desde ahí:</p>

                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre class="rojo" data-line="1"><code class="language-js">
                      //App.tsx
                      {data.map((guitar) =&gt; (
                        &lt;Guitar 
                          key={guitar.id}
                          guitar={guitar}
                          addToCart={addToCart}
                        /&gt;
                      ))}
                    </code></pre>
                  </div>
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre class="verde" data-line="1"><code class="language-js">
                      //App.tsx
                      {state.data.map((guitar) =&gt; (
                        &lt;Guitar 
                          key={guitar.id}
                          guitar={guitar}
                          addToCart={addToCart}
                        /&gt;
                      ))}
                    </code></pre>
                  </div>
                </div>

                <p>Vamos limpiando: en <span class="file">App.tsx</span> la prop data que extraíamos <code class="language-js">const { data, cart, addToCart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart, isEmpty, cartTotal } = useCart()</code>, en nuestro hook useCart.ts: la variable que usábamos <code class="language-js">const [data] = useState(db)</code> + del return + también quitamos la importación que hacíamos de nuestra bbdd <strong>Para quitar importaciones que ya no se utilicen Ctrl + Mayus + P y escribimos "Quitar importaciones sin usar"</strong></p>

                <p class="naranja">Migrando el addToCart hacia useReducer</p>
                
                <p>Si abrimos RDT (a veces se queda atascado y hay que recargar) y pulsamos en el compo ppal App.tsx vemos los dos cart que de momento tenemos, el del custom hook y el del reducer. Si agrego guitarra veo que se añade en el cart de mi hook pero <strong>queremos que escriba en el de reducer. Para eso tenemos que utilizar un dispatch</strong></p>

                <p>Identificamos la función que es addToCart y esa se está pasando en cada una de las guitarras. Hemos de pasar en su lugar dispatch:</p>

                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre class="borrar" data-line="5"><code class="language-js">
                      //App.tsx
                      {state.data.map((guitar) =&gt; (
                        &lt;Guitar 
                          key={guitar.id}
                          guitar={guitar}
                          addToCart={addToCart}
                        /&gt;
                      ))}
                    </code></pre>
                  </div>
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre class="verde" data-line="5"><code class="language-js">
                      //App.tsx
                      {state.data.map((guitar) =&gt; (
                        &lt;Guitar 
                          key={guitar.id}
                          guitar={guitar}
                          dispatch={dispatch}
                        /&gt;
                      ))}
                    </code></pre>
                  </div>
                </div>

                <p>Si vemos, al hacer este cambio nos da error porque, la firma de nuestro componente guitar (el type) ya no coincide.</p>
                
                <img src="./src/assets/img/173.png" alt="img" loading="lazy">
                
                <p>Lo vamos a coger del IS de VSC para añadirle esa propiedad a la firma de mi compo guitarra (el type de las props). Importamos CartActions (para que el componente conozca todas las acciones que se soportan por el reducer, incluyendo sus payload) y al igual que ya hemos hecho otras veces, en vez de poner <code class="language-js">React.Dispatch&lt;CartActions&gt;</code> podemos quitar el 'React.' previo si importamos Dispatch en el componente. Lo cambiamos también en el destructuring del parámetro y en la llamada al <code class="language-js">onClick = {()=> ... }</code> en el que llamamos al dispatch llamando al type adecuado y a su correspondiente payload, que podemos inferirlo al escribir payload y viendo el IS.</p>

                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre class="rojo" data-line="5,8,13"><code class="language-js">
                      //Guitar.tsx
                      import type { Guitar } from '../types'

                      type GuitarProps = {
                          guitar : Guitar, 
                          dispatch : (item: Guitar) => void
                      }
                      
                      export default function Guitar({guitar, addToCart} : GuitarProps) {
                        ...
                        &lt;button 
                            type=&quot;button&quot;
                            className=&quot;btn btn-dark w-100&quot;
                            onClick={() =&gt; addToCart(guitar)}
                        &gt;Agregar al Carrito&lt;/button&gt;
                    </code></pre>
                  </div>
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre class="verde" data-line="1,3,7,10,15"><code class="language-js">
                      //Guitar.tsx
                      import { Dispatch } from 'react'
                      import type { Guitar } from '../types'
                      import { CartActions } from '../reducers/cart-reducer'
                      
                      type GuitarProps = {
                          guitar : Guitar, 
                          dispatch : Dispatch&lt;CartActions&gt;
                      }

                      export default function Guitar({guitar, dispatch} : GuitarProps) {
                      ...
                        &lt;button 
                            type=&quot;button&quot;
                            className=&quot;btn btn-dark w-100&quot;
                            onClick={() =&gt; dispatch({type: &#39;add-to-cart&#39;, payload: {item: guitar} })}
                        &gt;Agregar al Carrito&lt;/button&gt;
                    </code></pre>
                  </div>
                </div>

                <p>Si en el if del reducer correspondiente a ese type "add-to-cart" ponemos un console.log('desde-add-to-cart') vemos que ya lo llama.</p>

                <p>Veamos a continuación como tomar toda la lógica que teníamos en nuestra función addToCart() de nuestro custom hook y ajustarla para la sintaxis de useReducer.</p>

              </div>

            <!-- Bloque desplegable interior-->
            <div class="flex justify-between items-center mt-1.25 cursor-pointer oscuro" onclick="$('#seccion11-174').toggle();">
              <h3>174. Ajustando el Código para la sintaxis de useReducer / 175. Evitando registros duplicados con sintaxis de Reducer</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion11-174" class="hidden">
              <p>Como la la lógica de useState() que teníamos en la función addToCart() de nuestro custom hook es un poco distinta de la que se usa en useReducer(), vamos a adecuarla para usarla con useReducer(). Si la cogemos y la pegamos en el if correspondiente a esta acción vemos que de entrada nos da todos <span class="rojo">estos casques</span>. Vamos a ir siguiendo los errores para solucionarlos:</p>

              <div class="flex max-sm:flex-col">
                <div class="w-[30%] max-sm:w-[100%]">
                  <img src="./src/assets/img/174.png" alt="img" loading="lazy">
                </div>
                <div class="w-[70%] max-sm:w-[100%]">
                  <ul class="list-disc my-3">
                    <li>1º revisamos si un elemento existe para evitar registros dupicados: <span class="rojo">cart.</span>findIndex() lo cambiamos por <span class="verde">state.cart.</span>findIndex()</li>
                    <li><span class="rojo">item.id</span> falla; ese item era un parámetro de la función addToCart(item: Guitar), le pasábamos ese item que era el elemento sobre el cual presionábamos para agregarlo al carrito, pero ahora mismo eso ya forma parte del action.payload así que cambiamos <span class="rojo">item.id</span> por <span class="verde">action.payload.item.id</span></li>
                    <li><span class="rojo">MAX_ITEMS</span> al igual que <span class="rojo">MIN_ITEMS</span> eran variables que prevenían de que no agregáramos más elementos, de momento no existían en nuestro reducer así que las agregamos justo antes del <code class="language-js">export const cartReducer = (...</code></li>
                    <li>A cuento de <span class="rojo">setCart(updatedCart)</span> Importante: estamos escribiendo en el state en dos lugares (el if y el else) pero el reducer solo tiene un único return{} entonces ese const updatedCart lo declaramos fuera del bloque if pero como let (para poder reasignarlo). le quitamos el const, reasignamos y borramos el SetCart(updatedCart) que ya no lo usamos. ese updatedCart hay que setearlo en el state así que lo añadimos en el return y así lo que hacía el setState, ahora lo hace nuestro reducer.</li>
                    <li>en la parte del else <span class="rojo">...item</span> por <span class="verde">...action.payload.item</span> que recordemos es lo que en el componente Guitar.tsx estamos agregando en el payload cuando hacemos click <code class="language-js">onClick={() => dispatch({type: 'add-to-cart', payload: {item: guitar} })}</code>. Eliminamos el <span class="rojo">setCart([...cart, newItem])</span> que es lo que usábamos con useState y nos quedamos con su contenido: <span class="verde">updatedCart = [...state.cart, newItem]</span></li>
                  </ul>
                </div>
              </div>

              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //useCart.ts
                    function addToCart(item : Guitar) {
                      const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                      if(itemExists >= 0 ) { // existe en el carrito
                          if(cart[itemExists].quantity >= MAX_ITEMS) return
                          const updatedCart = [...cart]
                          updatedCart[itemExists].quantity++
                          setCart(updatedCart)
                      } else {
                          const newItem : CartItem = {...item, quantity : 1}
                          setCart([...cart, newItem])
                      }
                    }
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //cart-reducer.ts
                    if (action.type === "add-to-cart"){
                      const itemExists = state.cart.findIndex(guitar => guitar.id === action.payload.item.id)
                      
                      let updatedCart : CartItem[] = []
                      if(itemExists >= 0 ) { // existe en el carrito
                          if(state.cart[itemExists].quantity >= MAX_ITEMS) return
                          updatedCart = [...state.cart]
                          updatedCart[itemExists].quantity++
                      } else {
                          const newItem : CartItem = {...action.payload.item, quantity : 1}
                          updatedCart = [...state.cart, newItem]
                      }
              
                      return{
                          ...state,
                          cart: updatedCart
                      }
                  }
                  </code></pre>
                </div>
              </div>

              <div class="flex max-sm:flex-col">
                <div class="w-[30%] max-md:w-[100%] mr-1.25">
                  <p>Si miramos en nuestra <span class="file">App.tsx</span> vemos que nos dice que nuestro state posiblemente pueda ser undefined</p>
                  <img src="./src/assets/img/174-2.png" alt="img" loading="lazy">
                </div>
                <div class="w-[70%] max-md:w-[100%]">
                  <p>Si recargamos el navegador, vemos en nuestro RDT App reducer, cómo al agregar guitarra se añade al state, si pulso en la misma guitarra quantity pasa de 1 a 3, a continuación a 5 y a continuación la pantalla se queda en blanco <strong>¿Qué pasa?</strong> algo raro pasa aquí:</p>

                  <pre><code class="language-js">
                    //cart-reducer.ts
                    ...
                    if (action.type === "add-to-cart"){
                      const itemExists = state.cart.findIndex(guitar => guitar.id === action.payload.item.id)
                  </code></pre>

                  <p>y es que probablemente <span class="rojo">findIndex()</span> para este tipo de código/ejemplo no sea la mejor opción y Typescript sabe por adelantado que algo puede fallar. Esto es algo relativamente común que nos puede pasar, tener un código funcional y cuando lo movemos a Redux Toolkit o Zustand dejar de funcionar. <strong>Veamos cómo utilizar .find() en lugar de .findIndex() y adaptar nuestro código</strong>.</p>                  
                </div>
              </div>
              
              <p class="naranja">Evitando registros duplicados con sintaxis de Reducer</p>

              <p>En vez de .findIndex() usamos .find() y en lugar de hacer las comprobaciones como teníamos hasta ahora en el if(), usaremos un .map() para identificar el elemento y entonces ir incrementando las cantidades.</p>

              <ul class="list-disc my-2.5">
                <li>.findIndex() nos retornaba un nº del índice de la posición del elemento en el arreglo del carrito. Utilizando .find() nos retorna el objeto. Lo podemos ver si lo cambiamos aquí, ponemos un console.log(itemExists) (quitamos la lógica del if para que no falle dejando solo lo siguiente) y miramos la consola al pulsar una guitarra que ya habíamos agregado, que ya existía por tanto:
                <pre data-line="2,3,5"><code class="language-js">
                  //cart-reducer.ts
                  if (action.type === "add-to-cart"){
                    const itemExists = state.cart.find(guitar => guitar.id === action.payload.item.id)
                    console.log(itemExists)
                    let updatedCart : CartItem[] = []
                    if(itemExists ) { // existe en el carrito
                        
                    } else {...
                </code></pre>  
                <img src="./src/assets/img/175.png" alt="img" loading="lazy">
                </li>
                <li>Modificamos la lógica del if:
                  <pre><code class="language-js">
                    //cart-reducer.ts
                    if(itemExists ) { // existe en el carrito
                      updatedCart = state.cart.map(item => {
                          if(item.id === action.payload.item.id){ //ese es el elemento que el user está agregando repetido
                              if(item.quantity &lt; MAX_ITEMS){ //le permitimos agregarlo
                                  return{...item,quantity: item.quantity + 1 } //copia del item e incrementamos quantity
                              } else {
                                  return item // llegamos a 5, no se cumple lo anterior pero mantenemos lo que teníamos en el carrito
                              }
                          } else {//el que no estamos agregando repetido pero no queremos perder
                              return item
                          }
                      })            
                  } 
                  </code></pre>
                </li>
              </ul>

              <p>Como ya no estamos utilizando addToCart() la eliminamos de nuestro hook useCart.ts (también de su return) y también del destructuring que hacíamos en la App.tsx <code class="language-js">const { cart, addToCart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart, isEmpty, cartTotal } = useCart()</code></p>
                 

            </div>

            <!-- Bloque desplegable interior-->
            <div class="flex justify-between items-center mt-1.25 cursor-pointer oscuro" onclick="$('#seccion11-176').toggle();">
              <h3>176. Mostrando el contenido del carrito</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion11-176" class="hidden">
              <p>Ya estamos escribiendo en nuestro carrito de nuestro rediucer, si agrego guitarras, vemos en el <strong>RDT App reducer(mirando en el React Developer Tools de Chrome en el reducer de nuestro compo ppal App.tsx)</strong> que se agregan adecuadamente, sin embargo no se están mostrando en la renderización del carrito, porque el código del carrito aun tiene el código de nuestro custom hook useCart.ts</p>            
              
              <pre><code class="language-js">
                //Header.tsx
                ...
                &lt;div id=&quot;carrito&quot; className=&quot;bg-white p-3&quot;&gt;
                  {isEmpty ? (
                      &lt;p className=&quot;text-center&quot;&gt;El carrito esta vacio&lt;/p&gt;
                  ) : (
                  &lt;&gt;
                  ...
              </code></pre>
                
              <p>Vamos a tener que hacer cambios:</p>

              <ul class="list-disc my-2.5">
                <li>Debería bastar con cambiar en nuestro App.tsx la prop que le pasamos en el tag del compo Header.tsx(que es donde renderizamos nuestro carrito) de cart a state.cart:
                  <div class="flex max-sm:flex-col">
                    <div class="w-[50%] max-sm:w-[100%]">
                      <pre class="rojo" data-line="2"><code class="language-js">
                        //App.tsx
                        &lt;Header 
                          cart={cart}
                          removeFromCart={removeFromCart}
                          decreaseQuantity={decreaseQuantity}
                          increaseQuantity={increaseQuantity}
                          clearCart={clearCart}       
                        /&gt;
                      </code></pre>
                    </div>
                    <div class="w-[50%] max-sm:w-[100%]">
                      <pre class="verde" data-line="2"><code class="language-js">
                        //App.tsx
                        &lt;Header 
                          cart={state.cart}
                          removeFromCart={removeFromCart}
                          decreaseQuantity={decreaseQuantity}
                          increaseQuantity={increaseQuantity}
                          clearCart={clearCart}       
                        /&gt;
                      </code></pre>
                    </div>                    
                  </div>

                  <p>sin embargo vemos que en nuestro compo Header.tsx tenemos un código condicional que revisa "si está vacío nuestro carrito para mostrar un texto", y como nosotros ahora mismo esa funcionalidad la tenemos en nuestro reducer pues no se está mostrando nada, de momento se queda siempre en ese 'isEmpty' (esa variable es uno de los 2 states derivados que hemos de mover, que además usan useMemo()):</p>
                      <pre class="verde"><code class="language-js">
                        //Header.tsx                        
                        &lt;div id=&quot;carrito&quot; className=&quot;bg-white p-3&quot;&gt;
                          {isEmpty ? (
                              &lt;p className=&quot;text-center&quot;&gt;El carrito esta vacio&lt;/p&gt;
                          ) : (
                      </code></pre>
                </li>

                <li>
                  <div class="flex max-sm:flex-col">
                    <div class="w-[50%] max-sm:w-[100%]">
                      Movemos estos 2 states derivados que teníamos en nuestro custom hook useCart.ts antes del return (eliminamos la importación de useMemo, también quitamos ambos del return)...
                      <pre class="rojo" data-line="1-3,7-8"><code class="language-js">
                        // useCart.ts
                        // State Derivado
                          const isEmpty = useMemo( () => cart.length === 0, [cart])
                          const cartTotal = useMemo( () => cart.reduce( (total, item ) => total + (item.quantity * item.price), 0), [cart] )
                          ...//(eliminamos ambas del return)
                          return {
                            ...
                            isEmpty,
                            cartTotal
                        }
                      </code></pre>
                    </div>
                    <div class="w-[50%] max-sm:w-[100%]">
                      a nuestro compo Header.tsx justo antes del return, donde también importamos useMemo...
                      <pre class="verde" data-line="1,6-8"><code class="language-js">
                        // Header.tsx
                        import { useMemo } from "react"
                        ...
                          cartTotal
                        } : HeaderProps ) {
                    
                        // State Derivado
                        const isEmpty = useMemo( () =&gt; cart.length === 0, [cart])
                        const cartTotal = useMemo( () =&gt; cart.reduce( (total, item ) =&gt; total + (item.quantity * item.price), 0), [cart] )
                    
                        return (
                          <header className="py-5 header">
                      </code></pre>
                    </div>
                  </div>
                  
                  
                    <div class="flex max-sm:flex-col">
                      <div class="w-[50%] max-sm:w-[100%]">
                        <p>Seguimos los errores limpiando todas esas referencias a los 2 states derivados que hemos movido: en nuestro App.tsx quitamos de la extracción estos 2 states derivados y también cart, que ya no va a estar exportando y también eliminamos los 2 states derivados de las props que le pasábamos en el tag del compo Header.tsx:</p>
                        <pre class="rojo" data-line="2,6,7"><code class="language-js">
                          //App.tsx
                          ...
                          const { cart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart, isEmpty, cartTotal } = useCart()
                          ...
                          &lt;Header 
                            ...
                            isEmpty={isEmpty}
                            cartTotal={cartTotal}
                          /&gt;
                        </code></pre>
                      </div>
                      <div class="w-[50%] max-sm:w-[100%]">
                        <p>También los eliminamos del Header.tsx, tanto del type como las props extraídas:</p>
                        <pre class="rojo" data-line="3,4,9,10"><code class="language-js">
                          //Header.tsx
                          type HeaderProps = {
                            ...
                            isEmpty: boolean
                            cartTotal: number
                          }                         
                        
                          export default function Header({
                                ...
                                  isEmpty, 
                                  cartTotal
                              } : HeaderProps ) {
                        </code></pre>
                      </div>
                    </div>
                </li>                
              </ul>              

            </div>

            <!-- Bloque desplegable interior-->
            <div class="flex justify-between items-center mt-1.25 cursor-pointer oscuro" onclick="$('#seccion11-177').toggle();">
              <h3>177. Trabajando con la acción de eliminar del carrito</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion11-177" class="hidden">
              <p>Trabajamos con la acción de 'remove-from-cart' de nuestro reducer. Nos posicionamos en su correspondiente if. En lugar de usar setCart() que es la función de nuestro custom hook, hemos de crear una variable y esa misma lógica adaptarla</p>
              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //useCart.ts
                    function removeFromCart(id : Guitar['id']) {
                      setCart(prevCart => prevCart.filter(guitar => guitar.id !== id))
                    }
                  </code></pre>
                  
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //cart-reducer.ts
                    if (action.type === "remove-from-cart"){
                      const updatedCart = state.cart.filter( item => item.id !== action.payload.id)       
                      return{
                          ...state,
                          cart: updatedCart
                      }
                    }
                    //sintaxis forma 2
                    if (action.type === "remove-from-cart"){
                      const cart = state.cart.filter( item => item.id !== action.payload.id)       
                      return{
                          ...state,
                          cart
                      }
                    }
                    //sintaxis forma 3
                    if (action.type === "remove-from-cart"){                         
                      return{
                          ...state,
                          cart: state.cart.filter( item => item.id !== action.payload.id) 
                      }
                    }
                  </code></pre>

                </div>
              </div>

              <p><strong>El siguiente paso es disparar esa acción</strong>. Abrimos nuestra App.tsx y en el tag del componente Header sustituimos la antigua llamada a la propiedad removeFromCart por un dispatch. El proceso es el mismo que vimos en el punto 173; cambiamos la firma (cambiar el type, infiriendo de IS, de las props del compo donde se recibe el dispatch) esta vez en el compo Header.tsx. <strong>Buscamos esa llamada que teníamos en el onclick a la antigua función removeFromCart() y la cambiamos por un dispatch</strong></p>

              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre class="rojo" data-line="3,10,15,21,28"><code class="language-js">
                    //App.tsx
                      function App() {

                        const { removeFromCart, decreaseQuantity, increaseQuantity, clearCart } = useCart()
                        const [state,dispatch] = useReducer(cartReducer, initialState)
                    
                        return (
                          &lt;&gt;
                            &lt;Header 
                              ...
                              removeFromCart={removeFromCart}

                    //Header.tsx                        
                      type HeaderProps = {
                          cart: CartItem[]
                          removeFromCart: (id: Guitar['id'] ) => void
                          ...
                      }

                      export default function Header({
                              cart, 
                              removeFromCart, 
                              ...
                          } : HeaderProps ) {
                      ...
                      &lt;button
                          className=&quot;btn btn-danger&quot;
                          type=&quot;button&quot;
                          onClick={() =&gt; removeFromCart(guitar.id)}
                      &gt;X&lt;/button&gt;
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre class="verde" data-line="3,10,15,21,28"><code class="language-js">
                    //App.tsx
                      function App() {

                        const { decreaseQuantity, increaseQuantity, clearCart } = useCart()
                        const [state,dispatch] = useReducer(cartReducer, initialState)
                                            
                        return (
                          &lt;&gt;
                            &lt;Header 
                              ...
                              dispatch={dispatch}

                    //Header.tsx                        
                      type HeaderProps = {
                          cart: CartItem[]
                          dispatch: Dispatch<CartActions>
                          ...
                      }

                      export default function Header({
                              cart, 
                              dispatch, 
                              ...
                          } : HeaderProps ) {
                      ...
                      &lt;button
                          className=&quot;btn btn-danger&quot;
                          type=&quot;button&quot;
                          onClick={() =&gt; dispatch({type: &#39;remove-from-cart&#39;, payload: {id: guitar.id}})}
                      &gt;X&lt;/button&gt;
                  </code></pre>
                </div>
              </div>

              <p><span class="destacado">NOTA: importante tener delante la definición que hemos hecho de los payloads de los CartActions para escribir correctamente el payload y no perderse</span>. Comparamos el ejemplo del punto 173 donde añadíamos una guitarra con este que acabamos de hacer:</p>

              <pre><code class="language-js">
                //cart-reducer.ts
                export type CartActions = 
                { type: 'add-to-cart', payload: {item : Guitar}} |
                { type: 'remove-from-cart', payload: {id : Guitar['id']}} |
                { type: 'decrease-quantity', payload: {id: Guitar['id']}} |
                { type: 'increase-quantity', payload: {id: Guitar['id']}} |
                { type: 'clear-cart'}
              </code></pre>

              <div class="flex max-sm:flex-col">                
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //Guitar.tsx
                    &lt;button
                      type=&quot;button&quot;
                      className=&quot;btn btn-dark w-100&quot;
                      onClick={() =&gt; dispatch({type: &#39;add-to-cart&#39;, payload: {item: guitar} })} 
                    >Agregar al Carrito</button>                   
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //App.tsx
                    &lt;button
                      className=&quot;btn btn-danger&quot;
                      type=&quot;button&quot;
                      onClick={() =&gt; dispatch({type: &#39;remove-from-cart&#39;, payload: {id: guitar.id}})}
                    &gt;X&lt;/button&gt;
                  </code></pre>
                </div>
              </div>
              
              <p>Eliminamos del custom hook useCart.ts nuestra función removeFromCart() que ya no vamos a utilizar (también lo vamos a eliminar del return que lo exportaba) y en nuestro compo ppal App.tsx lo eliminamos de la extracción que hacíamos con destructuring al llamar a nuestro custom hook en <strong>const { <span class="rojo">removeFromCart</span>, decreaseQuantity, increaseQuantity, clearCart } = useCart()</strong>.</p>

            </div>

            <!-- Bloque desplegable interior-->
            <div class="flex justify-between items-center mt-1.25 cursor-pointer oscuro" onclick="$('#seccion11-178').toggle();">
              <h3>178. Trabajando con la acción de incrementar cantidad y RETO 02 / 179. SOLUCION RETO 02 / 180. SOLUCION RETO 03</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion11-178" class="hidden">
              <p>Trabajemos migrando la función increaseQuantity()  anuestro reducer.</p>
              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //useCart.ts
                    function increaseQuantity(id : Guitar['id']) {
                      const updatedCart = cart.map( item => {
                          if(item.id === id && item.quantity &lt; MAX_ITEMS) {
                              return {
                                  ...item,
                                  quantity: item.quantity + 1
                              }
                          }
                          return item
                      })
                      setCart(updatedCart)
                    }
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //cart-reducer.ts
                    if(action.type === "increase-quantity"){
                      const updatedCart = state.cart.map( item => {
                          if(item.id === action.payload.id && item.quantity &lt; MAX_ITEMS) {
                              return {
                                  ...item,
                                  quantity: item.quantity + 1
                              }
                          }
                          return item
                      })        
                      return{
                          ...state,
                          cart: updatedCart
                      }
                  }
                  </code></pre>
                </div>
              </div>

              <p>En App.tsx quitamos la importación de la función antigua, la prop que se pasaba al tag header y en el compo Header.tsx lo quitamos de la firma y también del destructuring de parámetros de la función del componente <span class="destacado">(el dispatch ya centraliza todas las acciones)</span>. Eliminamos la función del custom hook y también de su return. Modificamos la llamada del onclick:</p>

              <div class="flex max-sm:flex-col">
                <div class="w-[40%] max-sm:w-[100%]">
                  <pre class="rojo" data-line="4"><code class="language-js">
                    //Header.tsx
                    &lt;button
                      type=&quot;button&quot;
                      className=&quot;btn btn-dark&quot;
                      onClick={() =&gt; increaseQuantity(guitar.id)}
                    &gt;+&lt;/button&gt;
                  </code></pre>
                </div>
                <div class="w-[60%] max-sm:w-[100%]">
                  <pre class="verde" data-line="4"><code class="language-js">
                    //Header.tsx
                    &lt;button
                      type=&quot;button&quot;
                      className=&quot;btn btn-dark&quot;
                      onClick={() =&gt; dispatch({type: &quot;increase-quantity&quot;, payload: {id: guitar.id}})}
                    &gt;+&lt;/button&gt;
                  </code></pre>
                </div>
              </div>
              
              <p class="naranja">Hacemos lo mismo para decreaseQuantity() <strong>Reto 02: Decrementar cantidades</strong></p>

              <ul class="list-disc my-2.5">
                <li>Hacer funcional el botón de decrementar cantidades, ahora con useReducer</li>
                <li>Tendremos que crear la acción y mandarla llamar con dispatch</li>
                <li>Seguir las convenciones de nombres del custom hook y reducer</li>
              </ul>

              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //useCart.ts
                    function decreaseQuantity(id : Guitar['id']) {
                      const updatedCart = cart.map( item => {
                          if(item.id === id && item.quantity > MIN_ITEMS) {
                              return {
                                  ...item,
                                  quantity: item.quantity - 1
                              }
                          }
                          return item
                      })
                      setCart(updatedCart)
                    }
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //cart-reducer.ts
                    if (action.type === "decrease-quantity"){
                      const updatedCart = state.cart.map( item => {
                          if(item.id === action.payload.id && item.quantity > MIN_ITEMS) {
                              return {
                                  ...item,
                                  quantity: item.quantity - 1
                              }
                          }
                          return item
                      })    
                      return{
                          ...state,
                          cart: updatedCart
                      }
                    }
                  </code></pre>
                </div>
              </div>
              
              <div class="flex max-sm:flex-col">
                <div class="w-[40%] max-sm:w-[100%]">
                  <pre class="rojo" data-line="4"><code class="language-js">
                    //Header.tsx
                    &lt;button
                      type=&quot;button&quot;
                      className=&quot;btn btn-dark&quot;
                      onClick={() =&gt; decreaseQuantity(guitar.id)}
                    &gt;-&lt;/button&gt;
                  </code></pre>
                </div>
                <div class="w-[60%] max-sm:w-[100%]">
                  <pre class="verde" data-line="4"><code class="language-js">
                    //Header.tsx
                    &lt;button
                        type=&quot;button&quot;
                        className=&quot;btn btn-dark&quot;
                        onClick={() =&gt; dispatch({type: &quot;decrease-quantity&quot;, payload:{id: guitar.id}})}
                    &gt;-&lt;/button&gt;
                  </code></pre>
                </div>
              </div>
              
              <p class="naranja"><strong>Reto 03: Limpiar carrito</strong></p>

              <ul class="list-disc my-2.5">
                <li>Hacer funcional el botón de limpiar el carrito de compras ahora con useReducer</li>
                <li>Tendremos que crear la acción y mandarla llamar con dispatch</li>
                <li>Seguir las convenciones de nombres del custom hook y reducer</li>
              </ul>

              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //useCart.ts
                    function clearCart() {
                      setCart([])
                  }
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //cart-reducer.ts
                    if(action.type === "clear-cart"){
                      const updatedCart : CartItem[] = []
                      return{
                          ...state,
                          cart: updatedCart
                      }
                    }
                    //su manera
                    if(action.type === "clear-cart"){                      
                      return{
                          ...state,
                          cart: []
                      }
                  }
                  </code></pre>
                </div>
              </div>

              <p>Limpiamos todas las importaciones que ya no se usan. Como vemos en el tag de nuestro componente Header (que es donde s epinta le carrito) teníamos muchos props y como vemos es algo que se simplifica al incorporar useReducer.</p>
            </div>

            <!-- Bloque desplegable interior-->
            <div class="flex justify-between items-center mt-1.25 cursor-pointer oscuro" onclick="$('#seccion11-181').toggle();">
              <h3>181. Colocando el state en LocalStorage</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion11-181" class="hidden">
              <p>Vamos a colocar el state en LocalStorage. En nuestro custom hook tenemos dos partes relacionadas con local Storage ahora mismo, la primera va  hacia el reducer y la segunda hacia el componente:</p>

              <pre data-line="4-7,11-13"><code class="language-js">
                //useCart.ts
                ...
                export const useCart = () => {

                    const initialCart = () : CartItem[] => {
                        const localStorageCart = localStorage.getItem('cart')
                        return localStorageCart ? JSON.parse(localStorageCart) : []
                    }
                
                    const [cart, setCart] = useState(initialCart)

                    useEffect(() => {
                        localStorage.setItem('cart', JSON.stringify(cart))
                    }, [cart])

                    return {
                        cart       
                    }
                }
              </code></pre>

              <p>Nos llevamos la primera parte del custom hook relacionada con localStorage a nuestro reducer y la ponemos justo antes de definir el initialState. En el initialState en lugar de que cart sea arreglo vacío, le decimos que sea la nueva función <strong>initialCart()</strong> que nos hemos traído (de ahora en adelante nuestro carrito de compras inicia tomando lo que hay en localStorage o si no hay nada, un arreglo vacío):</p>
              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                
                  <pre><code class="language-js">
                    //useCart.ts
                    const initialCart = () : CartItem[] => {
                      const localStorageCart = localStorage.getItem('cart')
                      return localStorageCart ? JSON.parse(localStorageCart) : []
                  }
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                    <pre data-line="2-5,9"><code class="language-js">
                    //cart-reducer.ts
                    ...
                    const initialCart = () : CartItem[] => {
                        const localStorageCart = localStorage.getItem('cart')
                        return localStorageCart ? JSON.parse(localStorageCart) : []
                    }
                    export const initialState : CartState = {
                        data: db, //nuestra bbdd de guitarra con los datos
                        //cart: [] //antes de usar localStorage iniciábamos el carrito vacío
                        cart: initialCart()
                    }
                  </code></pre>
                </div>
              </div>

              <p>La otra parte, el useEffect, nos la llevamos al compo ppal App.tsx que es donde va a estar nuestro state, lo colocamos justo a continuación y como vemos hace falta que importemos useEffect de react y cambiamos <span class="rojo">cart</span> por <span class="verde">state.cart</span>:</p>

              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //useCart.ts
                    useEffect(() => {
                      localStorage.setItem('cart', JSON.stringify(cart))
                    }, [cart])
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre data-line="1,8,9"><code class="language-js">
                    //App.ts
                    import { useReducer, useEffect } from "react"
                    ...
                    function App() {
                
                      const [state,dispatch] = useReducer(cartReducer, initialState)
                
                      useEffect(() => {
                        localStorage.setItem('cart', JSON.stringify(state.cart))
                      }, [state.cart])
                
                  </code></pre>
                </div>
              </div>

              <p>Ya nuestro custom hook no es necesario, podemos eliminar <span class="file">hooks&gt;useCart.ts</span> pues lo hemos movido todo hacia reducer usando useReducer.</p>
              <p>En nuestro title del index le indicamos las tecnologías usadas en este proyecto: &lt;title&gt;Vite + React + TS + useReducer&lt;/title&gt;</p>
              <p>Hacemos un <span class="destacado">npm run build y así nos aseguramos de que no tenemos ningún error antes de desplegar nuestro proyecto.</span></p>
              
            </div>

        </div>
        <!-- Fin div colapsable-->

      </div>
      <!-- FIN SECCION 11 -->


      <!-- SECCION 10 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
        
        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion10').toggle();">
          <h2>Sección 10: PROYECTO - Contador de Calorías, Consumo y Ejercicios con useReducer</h2>
          <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
        </div>

        <div id="seccion10" class="hidden">
          
          <a class="underline text-rose-600 font-bold" href="https://and....55.github.io/calory-tracker/" target="blank">https://and....55.github.io/calory-tracker/</a>
          <p> <span class="destacado">formularios, useReducer, useState, localStorage</span> Proyecto listo usando useReducer() que es una excelente forma de manejar states más complejos o hacer operaciones en diferentes estados al mismo tiempo. Vemos la <strong>estructura de un reducer</strong>, <strong>para qué utilizamos las acciones</strong>, <strong>para qué utilizamos el dispatch</strong> y <strong>cómo vamos manejando la lógica en nuestro state</strong>.</p>


          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-ficheros').toggle();">
            <h3>FICHEROS FINALES</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-ficheros" class="hidden">            

            <code class="language-html cursor-pointer px-3" onclick="$('#10-ActivityList').toggle();">ActivityList.tsx</code>
            <pre data-line="0" id="10-ActivityList" class="hidden" data-line="0"><code class="language-ts">
              import { useMemo, Dispatch } from &quot;react&quot;
              import { Activity } from &quot;../types&quot;
              import { categories } from &quot;../data/categories&quot;
              import { PencilSquareIcon, XCircleIcon } from &#39;@heroicons/react/24/outline&#39;
              import { ActivityActions } from &quot;../reducers/activity-reducers&quot;
              
              type ActivityListProps = {
                  activities: Activity[]
                  dispatch: Dispatch&lt;ActivityActions&gt;
              }
              
              export default function ActivityList({activities, dispatch}: ActivityListProps) {  
                  
                  const categoryName = useMemo(()=&gt; 
                      (category:Activity[&#39;category&#39;]) =&gt; categories.map( cat =&gt; cat.id === category ? cat.name : &#39;&#39;)
                  , [activities]
                  )
              
                  const isEmptyActivities = useMemo(() =&gt; activities.length === 0, [activities])
              
                  return (
                  &lt;&gt;
                      &lt;h2 className=&quot;text-4xl font-bold text-slate-600 text-center&quot;&gt;Comida y Actividades&lt;/h2&gt;
              
                      {isEmptyActivities 
                          ? &lt;p className=&quot;text-center my-5&quot;&gt;No hay actividades aún&lt;/p&gt; :
                      
                      activities.map(activity =&gt; (
                          &lt;div key={activity.id} className=&quot;px-5 py-10 bg-white mt-5 flex justify-between&quot;&gt;
                              &lt;div className=&quot;space-y-2 relative&quot;&gt;
                                  {/* Muestra actividad: categoría, nombre y calorías */}
                                  &lt;p className={`absolute -top-8 -left-8 px-10 py-2 text-white uppercase font-bold ${activity.category === 1 ? &#39;bg-lime-500&#39; : &#39;bg-orange-500&#39;}`}&gt;
                                      {/* {activity.category} */}
                                      {categoryName(+activity.category)}
                                      
                                  &lt;/p&gt;
                                  &lt;p className=&quot;text-2xl font-bold pt-5&quot;&gt;{activity.name}&lt;/p&gt;
                                  &lt;p className=&quot;font-black text-4xl text-lime-500&quot;&gt;
                                      {activity.calories} {&#39;&#39;}
                                      &lt;span&gt;Calorías&lt;/span&gt;
                                  &lt;/p&gt;
                              &lt;/div&gt;
                              &lt;div className=&quot;flex gap-5 items-center&quot;&gt;
                                  {/* Acciones para editar/eliminar esa actividad */}
                                  &lt;button
                                      className="cursor-pointer"
                                      onClick={() =&gt; dispatch({type:&quot;set-activeId&quot;, payload: {id: activity.id}})}
                                  &gt;
                                      &lt;PencilSquareIcon 
                                          className=&quot;h-8 w-8 text-g&quot;
                                      /&gt;
                                  &lt;/button&gt;
              
                                  &lt;button
                                      className="cursor-pointer"
                                      onClick={() =&gt; dispatch({type:&quot;delete-activity&quot;, payload: {id: activity.id}})}
                                  &gt;
                                      &lt;XCircleIcon 
                                          className=&quot;h-8 w-8 text-red-500&quot;
                                      /&gt;
                                  &lt;/button&gt;
                              &lt;/div&gt;
                              
                          &lt;/div&gt;
                      ))
                      }
                  &lt;/&gt;
                  )
              }                       
            </code></pre>

            <code class="language-html cursor-pointer px-3" onclick="$('#10-calorie').toggle();">CalorieDisplay.tsx</code>
            <pre data-line="0" id="10-calorie" class="hidden"><code class="language-ts">
              type CalorieDisplayProps = {
                calories: number,
                text: string
              }
              
              export default function CalorieDisplay({calories, text}: CalorieDisplayProps) {
                return (        
                  &lt;p className=&quot;text-white font-bold rounded-full grid grid-cols-1 gap-3 text-center&quot;&gt;
                      &lt;span className=&quot;font-black text-6xl text-orange&quot;&gt;{calories}&lt;/span&gt; {text}
                  &lt;/p&gt;
                )
              }      
            </code></pre>            
            
            <code class="language-html cursor-pointer px-3" onclick="$('#10-CalorieTracker').toggle();">CalorieTracker.tsx</code>
            <pre data-line="0" id="10-CalorieTracker" class="hidden"><code class="language-ts">
              import { useMemo } from &quot;react&quot;
              import type { Activity } from &quot;../types&quot;
              import CalorieDisplay from &quot;./CalorieDisplay&quot;
              
              type CalorieTrackerProps = {
                  activities: Activity[]
              }
              
              export default function CalorieTracker({activities}: CalorieTrackerProps) {
              
                  //Contadores
                  const caloriesConsumed = useMemo(() =&gt; activities.reduce((total, activity)=&gt; activity.category === 1 ? total + activity.calories : total, 0), [activities])
                  const caloriesBurned = useMemo(() =&gt; activities.reduce((total, activity)=&gt; activity.category === 2 ? total + activity.calories : total, 0), [activities])
                  const netCalories = useMemo(() =&gt; caloriesConsumed-caloriesBurned, [activities])
              
                  return (
                      &lt;&gt;
                          &lt;h2 className=&quot;text-4xl font-black text-white text-center&quot;&gt;Resumen de calorías&lt;/h2&gt;
              
                          &lt;div className=&quot;flex flex-col-item-center md:flex-row md:justify-between gap-5 mt-10&quot;&gt;
                             
                             &lt;CalorieDisplay 
                              calories={caloriesConsumed}
                              text={&#39;Consumidas&#39;}
                             /&gt;
                             &lt;CalorieDisplay 
                              calories={caloriesBurned}
                              text={&#39;Quemadas&#39;}
                             /&gt;
                             &lt;CalorieDisplay 
                              calories={netCalories}
                              text={&#39;Diferencia&#39;}
                             /&gt;
                              
                          &lt;/div&gt;
                         
                      &lt;/&gt;
                  )
              }              
            </code></pre>            
            
            <code class="language-html cursor-pointer px-3" onclick="$('#10-Form').toggle();">Form.tsx</code>
            <pre data-line="0" id="10-Form" class="hidden"><code class="language-ts">
              import { useState, ChangeEvent, FormEvent, Dispatch, useEffect } from &quot;react&quot;
              import { v4 as uuidv4 } from &#39;uuid&#39;
              import { categories } from &quot;../data/categories&quot;
              import { Activity } from &quot;../types&quot;
              import { ActivityActions, ActivityState } from &quot;../reducers/activity-reducers&quot;
              
              type FormProps = {
                  dispatch: Dispatch&lt;ActivityActions&gt;,
                  state: ActivityState
              }
              
              const initialState : Activity= {
                  id: uuidv4(),
                  category: 1,
                  name: &#39;&#39;,
                  calories: 0
              }
              
              export default function Form({dispatch, state}: FormProps) {
              
                  const[activity, setActivity] = useState&lt;Activity&gt;(initialState) 
              
                  useEffect(() =&gt; {
                     if(state.activeId){
                      //console.log(`ya hay algo en activeId: ${state.activeId}`)
                      const selectActivity = state.activities.filter((actividad)=&gt; actividad.id === state.activeId)[0]
                      //console.log(selectActivity)
                      setActivity(selectActivity)
                     }
                  }, [state.activeId])
              
                  const handleChange = (e: ChangeEvent&lt;HTMLSelectElement&gt; | ChangeEvent&lt;HTMLInputElement&gt; ) =&gt;{   
                      const isNumberField = [&#39;category&#39;,&#39;calories&#39;].includes(e.target.id)
                      setActivity({
                          ...activity,           
                          [e.target.id]: isNumberField ? +e.target.value : e.target.value
                      })
                  }
              
                  const isValidActivity = () =&gt;{
                      const { name, calories } = activity
                      return name.trim() != &#39;&#39; &amp;&amp; calories &gt; 0 //devuelve true cuando ambas se cumplen
                  }
              
                  const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =&gt;{
                      e.preventDefault()
                      dispatch({ type: &#39;save-activity&#39;, payload: {newActivity: activity} })
                      setActivity({
                          ...initialState,
                          id: uuidv4()
                      })
                  }
              
                  return (    
                      &lt;form
                          className=&quot;space-y-5 bg-white shadow p-10 rounded-lg&quot;
                          onSubmit={handleSubmit}
                      &gt;
              
                          &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                              &lt;label htmlFor=&quot;category&quot; className=&quot;font-bold&quot;&gt;Categoría:&lt;/label&gt;
                              &lt;select 
                                  id=&quot;category&quot;
                                  className=&quot;border border-slate-300 p-2 rounded-lg w-full bg-white&quot;
                                  value={activity.category}
                                  onChange={handleChange}
                              &gt;
                                  {categories.map(category =&gt; (
                                      &lt;option
                                          key={category.id}
                                          value={category.id}
                                      &gt;{category.name}&lt;/option&gt;
                                  ))}
                              &lt;/select&gt;
                          &lt;/div&gt;
              
                          &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                              &lt;label htmlFor=&quot;name&quot; className=&quot;font-bold&quot;&gt;Actividad:&lt;/label&gt;
                              &lt;input 
                                  id=&quot;name&quot;
                                  type=&quot;text&quot; 
                                  className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                                  placeholder=&quot;Por ej: Comida, zumo de naranja, ensalada, Ejercicio, Pesas, Bicicleta&quot;
                                  value={activity.name}  
                                  onChange={handleChange}              
                              /&gt;
                          &lt;/div&gt;
              
                          &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                              &lt;label htmlFor=&quot;calories&quot; className=&quot;font-bold&quot;&gt;Calorías:&lt;/label&gt;
                              &lt;input 
                                  id=&quot;calories&quot;
                                  type=&quot;number&quot; 
                                  className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                                  placeholder=&quot;Calorías Por ej: 300, 500&quot;
                                  value={activity.calories}
                                  onChange={handleChange}
                                  /&gt;
                          &lt;/div&gt;
              
                          &lt;input 
                              type=&quot;submit&quot; 
                              className=&quot;bg-gray-800 hover:bg-gray-900 w-full p-2 font-bold uppercase text-white cursor-pointer disabled:opacity-10&quot;
                              value={activity.category === 1 ? &quot;Guardar Comida&quot; : &quot;Guardar Ejercicio&quot;}
                              disabled={!isValidActivity()}
                          /&gt;
                      &lt;/form&gt;  
                  )
              }                     
            </code></pre>            
            
            <code class="language-html cursor-pointer px-3" onclick="$('#10-categories').toggle();">categories.ts</code>
            <pre data-line="0" id="10-categories" class="hidden"><code class="language-js">              
              import type { Category } from "../types"

              export const categories: Category[] = [
                  { id: 1, name: 'Comida'},
                  { id: 2, name: 'Ejercicio'}
              ]      
            </code></pre>            
            
            <code class="language-html cursor-pointer px-3" onclick="$('#10-activity-reducers').toggle();">activity-reducers.ts</code>
            <pre data-line="0" id="10-activity-reducers" class="hidden"><code class="language-js">
              import { Activity } from &quot;../types&quot;

              //ACCIONES - type que va a describir lo que va a pasar en nuestro reducer
              export type ActivityActions = 
                  { type: &#39;save-activity&#39;, payload: { newActivity: Activity } } |
                  { type: &#39;set-activeId&#39;, payload: { id: Activity[&#39;id&#39;] } } |
                  { type: &#39;delete-activity&#39;, payload: { id: Activity[&#39;id&#39;] } } |
                  { type: &#39;restart-app&#39; } 
              
              export type ActivityState = {
                  activities : Activity[], //este state de este reducer se va a llamar activities y va a ser de tipo Activity[](ya lo teníamos definido en types)
                  activeId : Activity[&#39;id&#39;] 
              }
              
              const localStorageActivities = () : Activity[] =&gt;{
                  const activities = localStorage.getItem(&#39;activities&#39;)
                  return activities ? JSON.parse(activities) : []
              }
              //STATE - nuestro state inicial que es un objeto necesita un type (definimos arriba &#39;ActivityState&#39;). En nuestro state de actividades vamos a tener un arreglo.
              export const initialState: ActivityState = {
                  activities: localStorageActivities(),
                  activeId: &#39;&#39;
              }
              
              //REDUCER - que conecta a ambos, nuestras acciones y el state
              export const activityReducer = (
                      state : ActivityState = initialState,
                      action: ActivityActions
                  ) =&gt; {
                  
                  if(action.type === &#39;save-activity&#39;){
                      let updatedActivities : Activity[] = []
                      
                      if(state.activeId){
                          //vamos a iterar sobre cada actividad porque hemos de identificar cual tiene el activeId y pasarle el nuevo payload
                          updatedActivities = state.activities.map( actividad =&gt; actividad.id === state.activeId ? action.payload.newActivity : actividad)
              
                      }else{
                          updatedActivities = [...state.activities, action.payload.newActivity]
                      }
                      
                      return{
                          ...state,
                          //activities: [...state.activities, action.payload.newActivity]
                          activities: updatedActivities,
                          activeId: &#39;&#39;
                      }
                  }
                  
                  if(action.type === &#39;set-activeId&#39;){
                      //Este código maneja la lógica para actualizar el state activeId
                      //console.log(&#39;desde el type de set-activeId&#39;) //console.log(action.payload.id)         
                      return{
                          ...state,
                          activeId: action.payload.id
                      }
                  }
              
                  if(action.type === &#39;delete-activity&#39;){
                      return{
                          ...state,
                          activities: state.activities.filter( activity =&gt; activity.id !== action.payload.id)
                      }
                  }
              
                  if(action.type === &#39;restart-app&#39;){
                      return{
                          activities: [],
                          activeId: &#39;&#39;
                      }
                  }
              
                  return state
              }                   
            </code></pre>            
            
            <code class="language-html cursor-pointer px-3" onclick="$('#10-indexts').toggle();">types&gt;index.ts</code>
            <pre data-line="0" id="10-indexts" class="hidden"><code class="language-js">
              export type Category = {
                id: number
                name: string
              }
              export type Activity = {
                  id: string
                  category: number
                  name: string
                  calories: number
              }              
            </code></pre>
            
            <code class="language-html cursor-pointer px-3" onclick="$('#10-App').toggle();">App.tsx</code>
            <pre data-line="0" id="10-App" class="hidden"><code class="language-js">
              import { useReducer, useEffect, useMemo } from &quot;react&quot;
              import Form from &quot;./components/Form&quot;
              import ActivityList from &quot;./components/ActivityList&quot;
              import { activityReducer, initialState } from &quot;./reducers/activity-reducers&quot;
              import CalorieTracker from &quot;./components/CalorieTracker&quot;
              
              function App() {  
              
                const [state, dispatch] = useReducer(activityReducer, initialState)  
              
                useEffect(() =&gt; {
                  localStorage.setItem(&#39;activities&#39;,JSON.stringify(state.activities))
                }, [state.activities])
              
                const canRestartApp = () =&gt; useMemo(() =&gt; state.activities.length &gt; 0, [state.activities])
              
                return (
                  &lt;&gt;
              
                    &lt;header className=&quot;bg-lime-600&quot;&gt;
                      &lt;div className=&quot;max-w-4xl mx-auto flex justify-between&quot;&gt;
                        &lt;h1 className=&quot;text-center text-lg font-bold text-white uppercase&quot;&gt;
                          Contador de calorías 
                        &lt;/h1&gt;
                        &lt;button 
                          className=&quot;bg-gray-800 hover:bg-gray-900 p-2 font-bold uppercase text-white cursor-pointer rounded-lg text-sm disabled:opacity-10&quot;
                          disabled={!canRestartApp()}
                          onClick={() =&gt; dispatch({type: &#39;restart-app&#39;})}
                          &gt;Reiniciar App&lt;/button&gt;
                      &lt;/div&gt;
                    &lt;/header&gt;
              
                    &lt;div className=&quot;flex max-sm:flex-col&quot;&gt;
                      &lt;section className=&quot;bg-lime-500 py-20 px-5 w-[40%] max-sm:w-full&quot;&gt;
                        &lt;div className=&quot;max-w-4xl mx-auto&quot;&gt;
                          &lt;Form
                            dispatch = {dispatch}
                            state = {state}
                          /&gt;
                        &lt;/div&gt;
                      &lt;/section&gt;
              
                      &lt;section className=&quot;p-10 mx-auto w-[60%] max-sm:w-full&quot;&gt;
                        &lt;ActivityList 
                          activities={state.activities}
                          dispatch={dispatch}
                        /&gt;
                      &lt;/section&gt;
                    &lt;/div&gt;
              
                    &lt;section className=&quot;bg-gray-800 py-10&quot;&gt;
                    &lt;div className=&quot;max-w-4xl mx-auto&quot;&gt;
                      &lt;CalorieTracker 
                        activities = {state.activities}
                      /&gt;
                    &lt;/div&gt;
                    &lt;/section&gt;   
                    
                  &lt;/&gt;
                )
              }
              
              export default App               
            </code></pre>
            
            <code class="language-html cursor-pointer px-3" onclick="$('#10-index').toggle();">index.css y main.tsx</code>
            <pre data-line="0" id="10-index" class="hidden"><code class="language-js">
              //index.css
              @import "tailwindcss";
            
            //main.tsx
              import { StrictMode } from 'react'
              import { createRoot } from 'react-dom/client'
              import './index.css'
              import App from './App.tsx'

              createRoot(document.getElementById('root')!).render(
                &lt;StrictMode&gt;
                  &lt;App /&gt;
                &lt;/StrictMode&gt;,
              )                   
            </code></pre>            
          </div>
          
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-130').toggle();">
            <h3>130. El Proyecto que vamos a construir / 131. Creando el Proyecto / 132. Instalando Tailwindcss</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-130" class="hidden">            

            <p class="mb-3.25">Este proyecto es un contador de calorías para contar las calorías de lo que consumimos y las que quemamos haciendo actividades. Va a ser un poco más complejo pues va a tener <strong>formularios (una de las tareas que más vamos a realizar como Developer)</strong>; leeremos sus datos, lo vamos a procesar y realizar algunas operaciones como validación y mucho más. <strong>Trabajar con formularios en React es complicado. Existen distintas librerías que lo simplifican bastante, y es probable que en el grupo de trabajo se use una librería pero <span class="destacado">nosotros debemos saber trabajar con elementos de formulario, leer y colocar en el state lo que el usuario va metiendo y es la razón de este proyecto</span>.</strong>
              
            <p>También tendrá <strong>localStorage</strong>. Va a ser desarrollado con <strong>UseState</strong> pero también veremos el hook <strong>useReducer</strong> que es un hook especial para manejar states complejos en nuestras apps, como es el caso de este proyecto.</p>   
            
            <ul class="mb-3.75">
              <li><span>Vamos al directorio donde queremos crearlo</span></li>
              <li><span><span class="destacado">npm create vite@latest</span> > <strong>calorie-tracker</strong> > <strong>react TypeScript + SWC</strong> > <span class="destacado">npm install</span></span></li>
              <li><span>arrancamos el servidor de desarrollo <span class="destacado">npm run dev</span> y hacemos limpieza: eliminamos carpeta src>assets, eliminamos src>App.css, borramos el contenido de index.css, en index.html cambiamos el title y eliminamos icono <code class="language-js">&lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt;</code> (borramos también el icono vite.svg de la carpeta public) y limpiamos el compo ppal App.tsx.</span></li>
              <li>instalamos tailwind: <a class="underline" href="https://tailwindcss.com/docs/installation/using-vite" target="_blank">https://tailwindcss.com/docs/installation/using-vite</a> 
                <ul class="mb-3.75">
                  <li><span class="destacado">npm install tailwindcss @tailwindcss/vite</span></li>
                  <li>configurar el plugin: 
                    <pre><code class="language-js">
                      //vite.config.ts
                      import tailwindcss from '@tailwindcss/vite'
                      export default defineConfig({
                        plugins: [
                          tailwindcss(),
                        ],
                      })
                    </code></pre>
                  </li>
                  <li>importar tailwindcss en nuestra css principal: 
                    <pre><code class="language-js">
                      //src>index.css
                      @import "tailwindcss";
                    </code></pre>
                  </li>
                </ul>                   
              </li>
            </ul>
              
            <img class="mx-auto mt-1.25" src="../manual-react/src/assets/img/s1-03.jpg" alt="imagen contador calorias">            
          </div>
            
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-133').toggle();">
            <h3>133. Creando los Contenedores Principales</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-133" class="hidden">
            <p>Agregamos header donde irá nuestro título y el botón para restablecer app y content donde irá nuestro formulario:</p> 
            <p>Creamos nuestro primer componente <strong>Form.tsx</strong> y en nuestro compo ppal App.tsx lo importamos y llamamos a su tag en la sección que acabamos de crear.</p> 
            
            
            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">                
                <pre><code class="language-js">
                  //App.tsx
                  import Form from "./components/Form"
                  function App() {  
    
                    return (
                      &lt;&gt;
                  
                        &lt;header className=&quot;bg-lime-600&quot;&gt;
                          &lt;div className=&quot;flex justify-between max-w-4xl mx-auto&quot;&gt;
                            &lt;h1 className=&quot;text-center text-lg font-bold text-white uppercase&quot;&gt;
                              Contador de calorías 
                            &lt;/h1&gt;
                          &lt;/div&gt;
                        &lt;/header&gt;
                  
                        &lt;section className=&quot;bg-lime-500 py-20 px-5&quot;&gt;
                          &lt;div className=&quot;max-w-4xl mx-auto&quot;&gt;
                            &lt;Form /&lt;
                          &lt;/div&gt;
                        &lt;/section&gt;
                        
                      &lt;/&gt;
                    )
                  }
                  
                  export default App
                </code></pre> 
              </div>
              <div class="w-[50%] max-sm:w-[100%] max-sm:mt-1.25">
                <pre><code class="language-js">
                  //Form.tsx
                  export default function Form() {
                    return (
                      &lt;div&gt;Form&lt;/div&gt;
                    )
                  }
                </code></pre>
                <img class="my-2.5" src="./src/assets/img/133.png" alt="img 133">
              </div>      
            </div>


          </div>
           
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-134').toggle();">
            <h3>134. Agregando el Formulario de Entrada de datos</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-134" class="hidden">
            <p>Trabajar con formularios en React es complicado. Existen distintas librerías que lo simplifican bastante, y es probable que en el grupo de trabajo se use una librería <strong>pero nosotros debemos saber leer y colocar en el state lo que el usuario va metiendo y es la razón de este proyecto</strong>.</p> 
            
            <ul class="mb-3.75">
              <li>Comenzamos a maquetar y darle contenido al componente <span class="file">Form.tsx</span>.</li>
              <li>Para las categorías del select iteramos desde un array de objetos que nos traemos de este <a href="https://gist.github.com/codigoconjuan/d84931241e93bebac46fccc28d096123" class="underline">Gist de categorias</a>. Creamos <strong>data>categories.ts</strong> y el type que van a tener lo vamos a reutilizar así que lo metemos en un archivo genérico de types <strong>types>index.ts</strong></li>
              <li>
                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre><code class="language-js">
                      //type>index.ts
                      export type Category = {
                        id: number,
                        name: string
                      }
                    </code></pre>
                    <pre class="mt-1.25"><code class="language-js">
                      //data>categories.ts
                      import type { Category } from "../types"

                      export const categories: Category[] = [
                          { id: 1, name: 'Comida'},
                          { id: 2, name: 'Ejercicio'}
                      ]                
                    </code></pre>

                    <img class="my-2.5" src="./src/assets/img/134.png" alt="">
                  </div>
                  <div class="w-[50%] max-sm:w-[100%] max-sm:mt-1.25">
                    <pre><code class="language-js">
                      //App.tsx
                      import Form from &quot;./components/Form&quot;
                      function App() {  

                        return (
                          &lt;&gt;

                            &lt;header className=&quot;bg-lime-600&quot;&gt;
                              &lt;div className=&quot;flex justify-between max-w-4xl mx-auto&quot;&gt;
                                &lt;h1 className=&quot;text-center text-lg font-bold text-white uppercase&quot;&gt;
                                  Contador de calorías 
                                &lt;/h1&gt;
                              &lt;/div&gt;
                            &lt;/header&gt;

                            &lt;section className=&quot;bg-lime-500 py-20 px-5&quot;&gt;
                              &lt;div className=&quot;max-w-4xl mx-auto&quot;&gt;
                                &lt;Form /&gt;
                              &lt;/div&gt;
                            &lt;/section&gt;
                            
                          &lt;/&gt;
                        )
                      }

                      export default App
                    </code></pre>
                  </div>
                </div>
              </li>
              <li>
                <pre><code class="language-js">
                  //Form.tsx
                  import { categories } from &quot;../data/categories&quot;

                  export default function Form() {
                    return (    
                      &lt;form
                          className=&quot;space-y-5 bg-white shadow p-10 rounded-lg&quot;
                      &gt;
                  
                          &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                              &lt;label htmlFor=&quot;category&quot; className=&quot;font-bold&quot;&gt;Categoría:&lt;/label&gt;
                              &lt;select 
                                  id=&quot;category&quot;
                                  className=&quot;border border-slate-300 p-2 rounded-lg w-full bg-white&quot;
                              &gt;
                                  {categories.map(category =&gt; (
                                      &lt;option
                                          key={category.id}
                                          value={category.id}
                                      &gt;{category.name}&lt;/option&gt;
                                  ))}
                              &lt;/select&gt;
                          &lt;/div&gt;
                  
                          &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                              &lt;label htmlFor=&quot;name&quot; className=&quot;font-bold&quot;&gt;Actividad:&lt;/label&gt;
                              &lt;input 
                                  id=&quot;name&quot;
                                  type=&quot;text&quot; 
                                  className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                                  placeholder=&quot;Por ej: Comida, zumo de naranja, ensalada, Ejercicio, Pesas, Bicicleta&quot;
                                  /&gt;
                          &lt;/div&gt;
                  
                          &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                              &lt;label htmlFor=&quot;calories&quot; className=&quot;font-bold&quot;&gt;Calorías:&lt;/label&gt;
                              &lt;input 
                                  id=&quot;calories&quot;
                                  type=&quot;number&quot; 
                                  className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                                  placeholder=&quot;Calorías Por ej: 300, 500&quot;
                                  /&gt;
                          &lt;/div&gt;
                  
                          &lt;input 
                              type=&quot;submit&quot; 
                              className=&quot;bg-gray-800 hover:bg-gray-900 w-full p-2 font-bold uppercase text-white cursor-pointer&quot;
                              value=&quot;Guardar Comida o guardar Ejercicio&quot;
                          /&gt;
                      &lt;/form&gt;  
                    )
                  }                  
                </code></pre>
              </li>
            </ul>
            
          </div>
           
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-135').toggle();">
            <h3>135. Creando el State para las Actividades</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-135" class="hidden">
            <p>Vamos a ir almacenando en el state todo lo que el usuario elija/escriba en nuestro formulario. Al tener todo eso en nuestro state va a ser más fácil hacer validaciones.</p>
            <ul class="mb-3.75">
              <li><strong>Importamos useState en nuestro componente Form.tsx.</strong></li>
              <li><strong>Definimos nuestro state.</strong> Como tenemos Categoría, actividad y calorías, normalmente crearíamos un state para cada uno:
                <pre class="border-5 border-red-700"><code class="language-js">
                  //Form.tsx
                  import { useState } from "react"

                  const[category, setCategory] = useState('') 
                  const[name, setName] = useState('')
                  const[calories, setCalories] = useState(0)
                </code></pre>
                  pero como están relacionados entre sí podemos tenerlos en un objeto. <strong>Hagamos un state más genérico que vamos a nombrar como activity</strong>. Inicia como arreglo y vamos a ir definiendo sus propiedades:
                  <pre class="border-5 border-emerald-600"><code class="language-js">
                    //Form.tsx
                    import { useState } from "react"

                    const[activity, setsetActivity] = useState({
                      category: '',
                      name: '',
                      calories: 0
                  }) 
                  </code></pre>
              </li>
              <li><strong>Vamos a conectar las propiedades de nuestro state array 'activity' con los inputs del formulario</strong>:
              
                <ul class="mb-3.75">
                  <li>En el select de category, le añadimos como value<code class="language-js">value={activity.category}</code>
                    
                    <div class="flex max-sm:flex-col">
                      <div class="w-[30%] max-sm:w-[100%]">
                        <pre><code class="language-js">
                          //data>categories.ts
                          export const categories: Category[] = [
                            { id: 1, name: 'Comida'},
                            { id: 2, name: 'Ejercicio'}
                          ]
                        </code></pre>
                      </div>
                      <div class="w-[70%] max-sm:w-[100%] max-sm:mt-1.25">
                        <pre data-line="4"><code class="language-js">
                          //Form.tsx
                          &lt;select 
                              id=&quot;category&quot;
                              className=&quot;border border-slate-300 p-2 rounded-lg w-full bg-white&quot;
                              value={activity.category}
                          &gt;
                        </code></pre> 
                        <p>con lo que si en la propiedad category de nuestro state activity tenemos 1, el select por defecto marca Comida que es el de id1 (si fuera 2 que es el id de ejercicio, por defecto marca Ejercicio)</p>
                        <img class="my-2.5" src="./src/assets/img/135-1.png" alt="">
                      </div>
                    </div> 
                  </li>         
                    
                  <li>El input de actividad (#name --> le hemos dado ese id porque coincidia con el nombre del nuevo state), le añadimos como value <code class="language-js">value={activity.name}</code></li>
                  <li>El input de calorias #calories, le añadimos como value <code class="language-js">value={activity.calories}</code></li>        
                </ul>
              </li>
            </ul>
                
            <pre><code class="language-js">
              //Form.tsx
              import { useState } from &quot;react&quot;
              import { categories } from &quot;../data/categories&quot;
              
              export default function Form() {
              
                  const[activity, setsetActivity] = useState({
                      category: 1,
                      name: &#39;&#39;,
                      calories: 0
                  }) 
              
                return (    
                  &lt;form
                      className=&quot;space-y-5 bg-white shadow p-10 rounded-lg&quot;
                  &gt;
              
                      &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                          &lt;label htmlFor=&quot;category&quot; className=&quot;font-bold&quot;&gt;Categoría:&lt;/label&gt;
                          &lt;select 
                              id=&quot;category&quot;
                              className=&quot;border border-slate-300 p-2 rounded-lg w-full bg-white&quot;
                              value={activity.category}
                          &gt;
                              {categories.map(category =&gt; (
                                  &lt;option
                                      key={category.id}
                                      value={category.id}
                                  &gt;{category.name}&lt;/option&gt;
                              ))}
                          &lt;/select&gt;
                      &lt;/div&gt;
              
                      &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                          &lt;label htmlFor=&quot;name&quot; className=&quot;font-bold&quot;&gt;Actividad:&lt;/label&gt;
                          &lt;input 
                              id=&quot;name&quot;
                              type=&quot;text&quot; 
                              className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                              placeholder=&quot;Por ej: Comida, zumo de naranja, ensalada, Ejercicio, Pesas, Bicicleta&quot;
                              value={activity.name}                
                          /&gt;
                      &lt;/div&gt;
              
                      &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                          &lt;label htmlFor=&quot;calories&quot; className=&quot;font-bold&quot;&gt;Calorías:&lt;/label&gt;
                          &lt;input 
                              id=&quot;calories&quot;
                              type=&quot;number&quot; 
                              className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                              placeholder=&quot;Calorías Por ej: 300, 500&quot;
                              value={activity.calories}
                              /&gt;
                      &lt;/div&gt;
              
                      &lt;input 
                          type=&quot;submit&quot; 
                          className=&quot;bg-gray-800 hover:bg-gray-900 w-full p-2 font-bold uppercase text-white cursor-pointer&quot;
                          value=&quot;Guardar Comida o guardar Ejercicio&quot;
                      /&gt;
                  &lt;/form&gt;  
                )
              }
            </code></pre>

            <p>Si abrimos React Developer tools, al pulsar el componente Form, vemos en hooks nuestro state activity</p>
            <img class="my-2.5" src="./src/assets/img/135-2.png" alt="">
            sin embargo si intentamos cambiar la opción del select categoría o escribir en algún input (actividad o calorías) no nos deja y da error en consola, porque necesitamos un <strong>onChange</strong>
            <img class="my-2.5" src="./src/assets/img/135-3.png" alt="">
                          
          </div>
           
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-136').toggle();">
            <h3>136. Escribiendo en el State / 137. Inferir el type de un evento / 138. Creando el Type de Actividad y seteando los valores en el state</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-136" class="hidden">
            <p>Hemos definido nuestro state y lo hemos conectado con los campos de nuestro formulario (1 select y dos inputs) pero como vimos tenemos en la consola advertencias. Le estamos pasando un value pero <strong>también tenemos que especificarle un onChange (básicamente es como un addEventListener y escuchar por el evento change)</strong>, que se ejecutará cada vez que cambiemos de opción en el select o cada vez que intentemos escribir en los inputs. Podemos hacerlo en el mismo input o tener una función aparte que lo gestione y llamaremos <strong>handleChange</strong>. La llamamos desde cada campo de formulario y ya no tendremos errores:</p>
            <pre><code class="language-js">
              //Form.tsx
              const handleChange = () =>{
                console.log ('algo cambió')
              }
              return ( 
                ...
                onChange={handleChange} // en cada campo del formulario
            </code></pre>
            
            <p>Sin embargo vemos que de momento nada cambia en la vista, y es porque el value del select y los inputs es lo que está en el state y de momento no lo estamos actualizando. Hemos de ir escribiendo en el state para que se vayan actualizando esos values de nuestros campos de formulario ¿como lo hacemos?. <strong>Estamos usando la misma función para un select y dos inputs y hemos de leer lo que el usuario haya metido</strong>. Una técnica muy común es pasarle (e) y hacer un console.log(e.target) para, como vemos en la siguiente captura, identificar sobre qué estamos intentando escribir o hacer cambio: </p>     

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  //Form.tsx
                  const handleChange = (e) =>{
                    console.log (e.target)          
                  }
                  return ( 
                    ...
                    onChange={handleChange} // en cada campo del formulario
                </code></pre>  
                
                <img class="my-2.5" src="./src/assets/img/136-1.png" alt="">
              </div>
              <div class="w-[50%] max-sm:w-[100%] max-sm:mt-1.25">
                <pre><code class="language-js">
                  //Form.tsx
                  const handleChange = (e) =>{
                    console.log (e.target.id)
                  }
                  return ( 
                    ...
                    onChange={handleChange} // en cada campo del formulario
                </code></pre>  
                
                <img class="my-2.5" src="./src/assets/img/136-2.png" alt="">
              </div>
            </div>
            
            <p><span class="destacado">SI NOMBRAMOS LOS ID DE NUESTROS ELEMENTOS DE FORMULARIO CON EL MISMO NOMBRE QUE LAS PROPIEDADES DE NUESTRO STATE...</span> <br>es más sencillo, es como "ir mapeando los datos"</p>
            
            <div class="flex max-sm:flex-col">
              <div class="w-[25%] max-sm:w-[100%]">
                <pre class="verde" data-line="4-6"><code class="language-js">
                  //Form.tsx
                  export default function Form() {
                    
                    const[activity, setsetActivity] = useState({
                      category: 1,
                      name: '',
                      calories: 0
                    }) 
                    
                    const handleChange = (e) =>{
                        //console.log (e.target)
                        console.log (e.target.id)
                      }
                    </code></pre>
                  </div>
                  <div class="w-[25%] max-sm:w-[100%] max-sm:mt-1.25">
                    <pre class="verde" data-line="2"><code class="language-js">
                      //Form.tsx
                      &lt;select 
                      id=&quot;category&quot;
                      className=&quot;border border-slate-300 p-2 rounded-lg w-full bg-white&quot;
                      value={activity.category}
                      onChange={handleChange}
                      &gt;
                      {categories.map(category =&gt; (
                        &lt;option
                        key={category.id}
                        value={category.id}
                        &gt;{category.name}&lt;/option&gt;
                        ))}
                        &lt;/select&gt;
                      </code></pre>
                    </div>
                    
                    <div class="w-[25%] max-sm:w-[100%]">
                      <pre class="verde" data-line="2"><code class="language-js">
                  //Form.tsx
                  &lt;input 
                  id=&quot;name&quot;
                  type=&quot;text&quot; 
                  className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                  placeholder=&quot;Por ej: Comida, zumo de naranja, ensalada, Ejercicio, Pesas, Bicicleta&quot;
                  value={activity.name}  
                  onChange={handleChange}              
                  /&gt;
                </code></pre>
              </div>
              <div class="w-[25%] max-sm:w-[100%] max-sm:mt-1.25">
                <pre class="verde" data-line="2"><code class="language-js">
                  //Form.tsx
                  &lt;input 
                  id=&quot;calories&quot;
                  type=&quot;number&quot; 
                  className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                  placeholder=&quot;Calorías Por ej: 300, 500&quot;
                  value={activity.calories}
                  onChange={handleChange}
                  /&gt;
                </code></pre>
              </div>
            </div>
            
            <p><code class="language-js">e.target.id</code> ¿qué es lo que estoy intentando modificar?¿sobre qué intento actuar?</p>
            <p><code class="language-js">e.target.value</code> ¿qué es lo que estoy escribiendo/cambiando? </p>
            
            <p>La función de nuestro state, 'setActivity' es un objeto así que la llamamos, abrimos corchetes y, usamos el spread operator para que con cada cambio que hagamos en el state al modificar el value de CADA elemento de formulario, siempre mantenga el state que había antes de ese cambio (podemos ver en React Developer tools cómo se comporta el state si no hacemos esto, se cambia con cada intento de cambio en algún elemento del formulario) --> escribe correctamente y no pierde la referencia gracias a que tomamos una copia de lo que tenemos en nuestro state antes de escribir un nuevo state</p>
            
            <pre><code class="language-js">
              //Form.tsx
              const handleChange = (e) =>{        
                setActivity({
                  ...activity,
                  [e.target.id]: e.target.value
                })
              }
            </code></pre>
            
            <p>Podemos hacer así uso de nuestro state en otros lugares como por ejemplo en una validación, una vez que yo presione en guardar comida o guardar ejercicio, validamos eso que tenemos en el state antes de guardarlo.</p>
            
            <p class="esp-15-top esp-0-bottom"><span class="naranja">Inferir el Type de un evento</span></p>           
            
            <p>Si vemos, llevamos arrastrando esta advertencia de que <strong>el parámetro e/evt/event tiene un tipo any implícitamente</strong>.</p>
            
            <img class="my-2.5" src="./src/assets/img/137.png" alt="">
            
            <p>Hemos de especificarle un tipo de dato para que no sea any. Si dejamos anys 'por ahí' vamos a tener más problemas que otra cosa y es como si no estuviéramos usando typescript. Veamos cómo identificar qué tipo de dato le vamos a pasar a este evento, con la ayuda del IS de VSC. Vamos al onChange del elemento select de formulario y en vez de llamar a la función handleChange, cambiamos momentáneamente por un <strong>e =></strong>, de ahí sacamos el tipo <strong>React.ChangeEvent&lt;HTMLSelectElement&gt;</strong> pero solo con ese no nos valdría porque vemos que nos da error en los onChange de los elementos input de nuestro formulario. Si hacemos lo mismo cambiando la llamada a la función por un <strong>e =></strong> sacamos el tipo <strong>React.ChangeEvent&lt;HTMLInputElement&gt;</strong></p>
            
            <img class="my-2.5" src="./src/assets/img/137-2.png" alt="">
            
            <p>Usando un pipe "|" en la definición del tipo de ese parámetro, vamos a indicar que nuestra función handleChange se puede utilizar tanto en un elemento select como en un elemento input. Podemos incluir 'ChangeEvent' en la importación de react y así reducimos la sintaxis del tipado de parámetro</p>
            
            <pre><code class="language-js">
              //Form.tsx
              import { useState, ChangeEvent } from "react"
              
              const handleChange = (e: ChangeEvent&lt;HTMLSelectElement&gt; | ChangeEvent&lt;HTMLInputElement&gt; ) =&gt;{        
                setActivity({
                  ...activity,
                  [e.target.id]: e.target.value
                })
              }
            </code></pre>
            
            <p>Vemos que ya no tenemos avisos de VSC y comprobando el hook de nuestro state activity en las React Developer tools vemos que con cada cambio se guarda adecuadamente lo que modificamos/escribimos. <strong>Sin embargo al cambiar vemos que, tanto la categoría como las calorías me las guarda en el state como string y quiero que sean de tipo número</strong>.</p>
            
            <p class="naranja">Creando el Type de Actividad y seteando los valores en el state</p>
            
            <p>En nuestro objeto state 'activity' vemos que las propiedades category y calories son números mientras que la propiedad name (nombre de la actividad) es un string. De hecho así es si recargamos nuestra app y miramos el state en nuestro compo Form en RDT(React Developer Tools). Pero si cambiamos a Ejercicio (la opción 2 del select que tiene un id de 2) o introducimos por ejemplo 300 calorías vemos que lo asigna todo como string</p>
            
            <img class="my-2.5" src="./src/assets/img/137-3.png" alt="">

            <p>Vamos a agregar un type nuevo para el state de activity en nuestro fichero de types, lo importamos en nuestro componente Form.tsx y se lo asignamos vía generic a nuestro state:</p>

            <pre data-line="8,13"><code class="language-js">
              //types>index.ts
                export type Activity = {
                  category: number,
                  name: string,
                  calories: number
                }
              //Form.tsx
                import { useState, ChangeEvent } from "react"
                import { Activity } from "../types"
                import { categories } from "../data/categories"
                
                export default function Form() {
                
                    const[activity, setActivity] = useState&lt;Activity&gt;({
                        category: 1,
                        name: '',
                        calories: 0
                    }) 
            </code></pre>

            <p>Una vez hecho lo anterior VSC no nos marca errores, porque TS está funcionando bien en esta parte de nuestro compo, en nuestro código, pero no sabe qué es lo que vamos a agregar en ese formulario. <strong>Nosotros hemos de mantener esa integridad de nuestro state activity ¿Como podemos hacer para convertirlos a números antes de setearlos a nuestro state?</strong></p>
            <ul class="mb-3.75">
              <li>Identifiquemos los que queremos que sean números. Creamos una variable de tipo array llamada 'isNumberField' que va a comprobar si donde estoy escribiendo es categoría o calorías: <code class="language-js">const isNumberField = ['category','calories'].includes(e.target.id)</code> --&gt; en caso de que esté escribiendo en category o calories me retorna true</li>
              <li>Teniendo en cuenta la comprobación que hacemos con esta nueva variable, añadimos un ternario a nuestra expresión anterior <code class="language-js">[e.target.id]: e.target.value</code> de manera que si es true convertimos a número con <span class="destacado">+</span> y si no lo dejamos como estaba, que setea string:
              <pre><code class="language-js">
                //Forms.tsx
                const handleChange = (e: ChangeEvent<HTMLSelectElement> | ChangeEvent<HTMLInputElement> ) =>{   
                  const isNumberField = ['category','calories'].includes(e.target.id)
                  setActivity({
                      ...activity,           
                      [e.target.id]: isNumberField ? +e.target.value : e.target.value
                  })
                }
              </code></pre>
              </li>
            </ul>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  //types>index.ts
                    export type Category = {
                      id: number,
                      name: string
                    }
                    export type Activity = {
                        category: number,
                        name: string,
                        calories: number
                    }
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%] max-sm:mt-1.25">
                <pre><code class="language-js">
                  //data>categories.ts
                  import type { Category } from "../types"

                  export const categories: Category[] = [
                      { id: 1, name: 'Comida'},
                      { id: 2, name: 'Ejercicio'}
                  ]  
                </code></pre>
              </div>
            </div>

            <pre><code class="language-js">
              import { useState, ChangeEvent } from &quot;react&quot;
              import { Activity } from &quot;../types&quot;
              import { categories } from &quot;../data/categories&quot;
              
              export default function Form() {
              
                  const[activity, setActivity] = useState&lt;Activity&gt;({
                      category: 1,
                      name: &#39;&#39;,
                      calories: 0
                  }) 
              
                  const handleChange = (e: ChangeEvent&lt;HTMLSelectElement&gt; | ChangeEvent&lt;HTMLInputElement&gt; ) =&gt;{   
                      const isNumberField = [&#39;category&#39;,&#39;calories&#39;].includes(e.target.id)
                      setActivity({
                          ...activity,           
                          [e.target.id]: isNumberField ? +e.target.value : e.target.value
                      })
                  }
              
                return (    
                  &lt;form
                      className=&quot;space-y-5 bg-white shadow p-10 rounded-lg&quot;
                  &gt;
              
                      &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                          &lt;label htmlFor=&quot;category&quot; className=&quot;font-bold&quot;&gt;Categoría:&lt;/label&gt;
                          &lt;select 
                              id=&quot;category&quot;
                              className=&quot;border border-slate-300 p-2 rounded-lg w-full bg-white&quot;
                              value={activity.category}
                              onChange={handleChange}
                          &gt;
                              {categories.map(category =&gt; (
                                  &lt;option
                                      key={category.id}
                                      value={category.id}
                                  &gt;{category.name}&lt;/option&gt;
                              ))}
                          &lt;/select&gt;
                      &lt;/div&gt;
              
                      &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                          &lt;label htmlFor=&quot;name&quot; className=&quot;font-bold&quot;&gt;Actividad:&lt;/label&gt;
                          &lt;input 
                              id=&quot;name&quot;
                              type=&quot;text&quot; 
                              className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                              placeholder=&quot;Por ej: Comida, zumo de naranja, ensalada, Ejercicio, Pesas, Bicicleta&quot;
                              value={activity.name}  
                              onChange={handleChange}              
                          /&gt;
                      &lt;/div&gt;
              
                      &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                          &lt;label htmlFor=&quot;calories&quot; className=&quot;font-bold&quot;&gt;Calorías:&lt;/label&gt;
                          &lt;input 
                              id=&quot;calories&quot;
                              type=&quot;number&quot; 
                              className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                              placeholder=&quot;Calorías Por ej: 300, 500&quot;
                              value={activity.calories}
                              onChange={handleChange}
                              /&gt;
                      &lt;/div&gt;
              
                      &lt;input 
                          type=&quot;submit&quot; 
                          className=&quot;bg-gray-800 hover:bg-gray-900 w-full p-2 font-bold uppercase text-white cursor-pointer&quot;
                          value=&quot;Guardar Comida o guardar Ejercicio&quot;
                      /&gt;
                  &lt;/form&gt;  
                )
              }    
            </code></pre>           
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-139').toggle();">
            <h3>139. Validando el Formulario / 140. Mostrar de forma condicional el Texto si es Ejercicio o comida al guardar / 141. Trabajando con el evento de Submit</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-139" class="hidden">
            <p>Veamos como deshabilitar visualmente este formulario, este input de tipo submit</p>              
            <p>Creamos un arrow function, vamos debugeando lo siguiente con console.log y para ello la llamamos en el disabled del button submit:</p>
            <ul class="mb-3.75">
              <li><strong>name.trim() != ''</strong> el name(de actividad) al recortar espacio de inicio y fin es distinto de 0 <strong>true cuando está relleno</strong></li>
              <li>calories > 0 true cuando calorías es mayor que 0</li> 
              <li>Queremos que el botón esté deshabilitado si esta condición no se cumple, por tanto: <code class="language-js">disabled={!isValidActivity()}</code></li>
            </ul>
            <pre data-line="10"><code class="language-js">
              //Form.tsx
              const isValidActivity = () =>{
                const { name, calories } = activity
                return name.trim() != '' && calories > 0 // devuelve true cuando ambas se cumplen
              }
              ...
              &lt;input 
                  type=&quot;submit&quot; 
                  className=&quot;bg-gray-800 hover:bg-gray-900 w-full p-2 font-bold uppercase text-white cursor-pointer&quot;
                  value=&quot;Guardar Comida o guardar Ejercicio&quot;
                  disabled={!isValidActivity()}
              /&gt;
            </code></pre>

            <p>Con ello aseguramos tener deshabilitado el botón, no pasando esa validación hasta qeu no complete los dos campos qyue he especificado en mi función de validación 'isValidActivity' (si rellenáramos con espacios el campo name de actividad no vale por la comprobación que hace el trim()</p>
            <pre><code class="language-js">
              const str = "   foo  ";
              console.log(str.trim()); // 'foo'
            </code></pre>
            
             
            <div class="mt-3 mb-2 ml-1.5 pl-2.5 pt-0.5 pb-2  border-l-2 border-dashed border-l-stone-600 rounded-tl-2xl rounded-bl-2xl bg-neutral-50 shadow-lg">
              <a class="block underline ml-1.5 mb-1.5" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim" target="_blank">mdn web docs js referency</a>
              <div class="flex">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6 shrink-0">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3" />
                </svg>
                <span class="bg-neutral-200 px-1.5 py-0.5 italic leading-[24px]">El método trim() de valores tipo string elimina los espacios en blanco de ambos extremos de la cadena y devuelve una nueva cadena, sin modificar la cadena original. Para devolver una nueva cadena con espacios recortados solo en un extremo, usamos trimStart() o trimEnd()</span>
              </div>
            </div>


            <p class="esp-15-top esp-0-bottom"><span class="naranja">Mostrar de forma condicional el Texto del botón si es Ejercicio o comida al guardar</span></p>

            <p>Con el siguiente código que ponemos en el botón, React hace un nuevo render cada vez que cambia el state:</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[33%] max-sm:w-[100%]">
                <pre data-line="2"><code class="language-js">
                  //categories.ts --&gt; los datos
                  import type { Category } from "../types"
                  export const categories: Category[] = [
                      { id: 1, name: 'Comida'},
                      { id: 2, name: 'Ejercicio'}
                  ]
                </code></pre>
              </div>
              <div class="w-[33%] max-sm:w-[100%]">
                <pre data-line="3,11"><code class="language-js">
                  //Form.tsx --&gt; el select categoría
                  &lt;label htmlFor=&quot;category&quot; className=&quot;font-bold&quot;&gt;Categoría:&lt;/label&gt;
                  &lt;select 
                      id=&quot;category&quot;
                      className=&quot;border border-slate-300 p-2 rounded-lg w-full bg-white&quot;
                      value={activity.category}
                      onChange={handleChange}
                  &gt;
                      {categories.map(category =&gt; (
                          &lt;option
                              key={category.id}
                              value={category.id}
                          &gt;{category.name}&lt;/option&gt;
                      ))}
                  &lt;/select&gt;                  
                </code></pre>
              </div>
              <div class="w-[33%] max-sm:w-[100%]">
                <pre data-line="2"><code class="language-js">
                  //Form.tsx --&gt; state de actividad
                  const[activity, setActivity] = useState&lt;Activity&gt;({
                    category: 1,
                    name: '',
                    calories: 0
                  }) 
                </code></pre>
              </div>
            </div>            

            <pre data-line="4"><code class="language-js">
            //Form.tsx
              &lt;input 
                type=&quot;submit&quot; 
                className=&quot;bg-gray-800 hover:bg-gray-900 w-full p-2 font-bold uppercase text-white cursor-pointer disabled:opacity-10&quot;
                value={activity.category === 1 ? &quot;Guardar Comida&quot; : &quot;Guardar Ejercicio&quot;}
                disabled={!isValidActivity()}
            /&gt;
            </code></pre>            

            <p class="esp-15-top esp-0-bottom"><span class="naranja">Trabajando con el evento de Submit</span></p>

            <p>Vamos a empezar a trabajar con el submit de nuestro formulario.<p>
            
              <ul class="mb-3.75">
                <li>Añadimos al tag form onSubmit y llamamos a una nueva arrow function 'handleSubmit' que recibe parámetro e.</li>
                <li>Como nos avisa que es un 'any' buscamos el type con la ayuda del IS de VSC (cambiamos en el submit la llamada a nuestra nueva función por <strong>e = &gt;</strong> y nos indica que <code class="language-js">(parameter) e: React.FormEvent&lt;HTMLFormElement&gt;</code> así que importamos FormEvent y así reducimos la sintaxis en el tipado pudiendo quitar el 'react.' previo
                  <pre data-line="1,3-6,11"><code class="language-js">
                    //Form.tsx
                    import { useState, ChangeEvent, FormEvent } from "react"
                    ...
                    const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =&gt;{
                      e.preventDefault()
                      console.log(&#39;Submit...&#39;)
                    }
                
                    return (    
                        &lt;form
                            className=&quot;space-y-5 bg-white shadow p-10 rounded-lg&quot;
                            onSubmit={handleSubmit}
                        &gt;
                        ...
                  </code></pre>
                </li>
              </ul>
          </div>
           
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-142').toggle();">
            <h3>142. Introducción a useReducer</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-142" class="hidden">
            <p>Hasta ahora hemos estado usando un custom hook, pero cuando tenemos states más complejos podemos ir almacenando en algo conocido como <span class="destacado">reducers</span>. Es una forma de almacenar nuestro state, no de manera global digamos, es un archivo a parte y usamos un hook llamado useReducer. Veamos qué es eso.</p>

            <p>Ya tenemos todo listo para empezar a almacenar nuestras actividades, pero vamos a utilizar un enfoque diferente para almacenar el state de nuestra app, vamos a hacerlo por medio de algo llamado <strong>reducers</strong>. Vamos a ver el <strong>hook useReducer y la terminología nueva que vamos a encontrar trabajando con reducers</strong>. Este hook es la base de herramientas como <span class="destacado">Zustand</span> y <span class="destacado">Redux toolkit</span> asíq ue todo lo qeu aprendamos ahora y con los proyectos que vienen nos vendrá bien para el trabajo posterior con ese tipo de herramientas que son más avanzadas.</p>

            <div class="mt-3 mb-2 ml-1.5 pl-2.5 pt-0.5 pb-2  border-l-2 border-dashed border-l-stone-600 rounded-tl-2xl rounded-bl-2xl bg-neutral-50 shadow-lg">
              <p class="destacado">useReducer, un Hook para manejar state</p>
              <div class="flex">
                <svg class="size-6 shrink-0" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                </svg>
                <div class="bg-neutral-200 px-1.5 py-0.5 italic leading-[24px]">
                  <ul>
                    <li>useReducer es una alternativa de useState. Es un hook para manejar el state.</li>
                    <li><strong>useReducer es un Hook de React que te permite agregar un reducer a tu componente</strong>. Es una sintaxis un poco diferente pero una vez entendida hace muy sencillo administrar el state de las apps.</li>
                    <li>El hook  useReducer en React es una alternativa a Usestate que se utiliza para manejar estados más complejos y transiciones de estado que involucran lógica más complicada (que lo que encontrarías en Usestate). Mientras que useState es perfecto para el manejo de estados simples, useReducer es más adecuado para situaciones donde el nuevo estado depende del estado anterior o cuando hay múltiples sub-valores o lógica condicional a considerar (como múltiples states que se actualizan en base a ciertas acciones).</li>
                  </ul>
                </div>
              </div>
            </div>

            <div class="mt-3 mb-2 ml-1.5 pl-2.5 pt-0.5 pb-2  border-l-2 border-dashed border-l-stone-600 rounded-tl-2xl rounded-bl-2xl bg-neutral-50 shadow-lg">
              <p class="destacado">Composición de useReducer</p>
              <div class="flex">
                <svg class="size-6 shrink-0" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                </svg>
                <div>
                  <pre><code class="language-js">
                    const [state, dispatch] = useReducer(reducer, initialState)
                  </code></pre>
                  <div>
                    <p class="bg-neutral-200 px-1.5 py-0.5 italic leading-[24px]">Se utiliza el Hook useReducer y podemos ver que la estructura es similar a useState con algunas pequeñas diferencias:</p>
                    <ul class="mb-3.75">
                      
                      <li>El Hook useReducer toma dos argumentos:
                          <ul class="list-disc">
                            <li><strong>reducer:</strong> es una función que toma el estado actual y una acción, y devuelve un nuevo estado.</li>
                            <li><strong>initialState:</strong> es el estado inicial de nuestro reducer. Podemos pensar en ello como lo que tenemos actualmente en nuestro ejemplo del formulario del proyecto actual (la categoría 1 el name de actividad como string vacío y las calorías en 0)
                              <!-- <pre><code class="language-js">
                                const[activity, setActivity] = useState&lt;Activity&gt;({
                                  category: 1,
                                  name: '',
                                  calories: 0
                              }) 
                              </code></pre> -->
                            </li>
                          </ul>
                      </li>

                      <li class="mt-2.5">Algunos términos cuando trabajamos con useReducer
                        <ul class="list-disc">
                          <li><strong>state:</strong> es el valor del estado cuya lógica se maneja dentro del reducer.</li>
                          <li><strong>initialState:</strong> es el estado inicial con el que es creado el reducer, es similar a los valores de inicio de useState.</li>
                          <li><strong>Actions:</strong> las acciones o funciones que manejan toda la lógica para modificar nuestro state. Básicamente es una función que desde fuera, desde el componente, llega y modifica nuestro state, muy similar a las funciones que exportábamos en nuestro custom Hooks.</li>
                          <li><strong>Payload: </strong> es la información que modifica nuestro state. Similar a la parte de nuestros custom hooks donde teníamos una función y le pasábamos un id o un objeto con la información, eso modifica el state, eso es lo que se conoce como un Payload cuando trabajamos con Reducers.</li>
                          <li><strong>Dispatch:</strong> es la función que manda llamar la acción con el payload. Las acciones las vamos a definir en nuestro reducer, sin embargo el Dispatch es el que las manda llamar.</li>
                        </ul>
                      </li>
                    </ul>
                  </div>
                </div>
              </div>
            </div>           
                          
          </div>
  
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-143').toggle();">
            <h3>143. Definiendo nuestro reducer</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-143" class="hidden">
            <p>Vamos a crear nuestro primer reducer. Creamos src la carpeta nueva "reducers" y un fichero que podemos nombrar de estas dos maneras:</p>
            <ul>
              <li>src&gt;reducer&gt;<strong>activityReducers.ts</strong></li>
              <li>src&gt;reducer&gt;<strong>activity-reducer.ts</strong></li>
            </ul>

            <div class="mt-3 mb-2 ml-1.5 pl-2.5 pt-0.5 pb-2  border-l-2 border-dashed border-l-stone-600 rounded-tl-2xl rounded-bl-2xl bg-neutral-50 shadow-lg">
              <div class="flex">
                <svg class="size-6 shrink-0" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                </svg>             
                <p class="bg-neutral-200 px-1.5 py-0.5 italic leading-[24px]">Nuestro reducer va a constar de varias partes:</p>
                <ul>
                  <li>Acciones que describen lo que está pasando en la aplicación</li>
                  <li>El state inicial</li>
                  <li>Nuestro reducer que conecta tanto el state inicial como nuestras acciones</li>
                </ul>
              </div>
            </div>           

            <p><strong>HASTA AHORA TENÍAMOS</strong> en nuestro Form.tsx y en nuestro fichero de types>index.ts: (<span class="destacado">él indica crear este type pero YA LO TENÍAMOS y además en este vídeo el actual state de Form.tsx no lo muestra tipado con generic como había hecho hasta ahora. Lo vuelve a hacer, pero nosotros de momento no hemos cambiado nada ni de types>index.ts ni de Forms.tsx</span>)</p>
            <pre><code class="language-js">
              //types>index.ts
                export type Activity = {
                  category: number,
                  name: string,
                  calories: number
                }
              
              //Form.tsx
                const[activity, setActivity] = useState&lt;Activity&gt;({
                    category: 1,
                    name: &#39;&#39;,
                    calories: 0
                }) 
            </code></pre>

            <p>Lo importante, así es como queda de momento nuestro reducer <span class="file">activity-reducers.ts</span> recién creado:</p>
            <pre><code class="language-js">
              //activity-reducers.ts
              import { Activity } from "../types"

              //ACCIONES - type que va a contener las acciones, lo que va a pasar en nuestro reducer
              export type ActivityActions = {
              
              }
              
              export type ActivityState = {
                  activities : Activity[] //el state de este reducer se va a llamar activities y va a ser de tipo Activity[](ya lo teníamos definido en types)
              }              
              //STATE - nuestro state inicial que es un objeto necesita un type (definimos arriba 'ActivityState'). En nuestro state de actividades vamos a tener un arreglo.
              export const initialState: ActivityState = {
                  activities: [] //inicia como arreglo vacío
              }
              
              //REDUCER - que conecta a ambos, nuestras acciones y el state
              export const activityReducer = (
                      state : ActivityState = initialState,
                      action: ActivityActions
                  ) => {
                      
                  return state  
              }
            </code></pre>
          </div>
  
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-144').toggle();">
            <h3>144. Definiendo acciones en el Reducer</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-144" class="hidden">

            <div class="mt-3 mb-2 ml-1.5 pl-2.5 pt-0.5 pb-2  border-l-2 border-dashed border-l-stone-600 rounded-tl-2xl rounded-bl-2xl bg-neutral-50 shadow-lg">
              <p><strong>Las acciones nos van a ayudar a describir qué es lo que está pasando y qué información es la que va a modificar qué parte de nuestro state.</strong></p>
              <div class="flex">
                <svg class="size-6 shrink-0" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                </svg>
                <span class="bg-neutral-200 px-1.5 py-0.5 italic leading-[24px]">Aunque suena complicado, básicamente una acción consta de dos partes: el type que es la descripción y el Payload que es la información que vamos a agregar a nuestro state (o que lo modifica). <strong>Dejémonos llevar y veamos las diferentes acciones y funciones de nuestro reducer para que vaya quedando todo más claro.</strong></span>
              </div>
            </div>
           
            
            <p>Una vez que rellenemos el formulario vamos a tener una categoría, una actividad y las calorías. <strong>Cuando presionemos el botón de Guardar (lo que sea) estaremos creando una nueva actividad, ya sea ejercicio o comida.</strong> 
              <pre><code class="language-js">  
                //Form.tsx 
                const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =&gt;{
                  e.preventDefault()
                  //console.log(&#39;Submit...&#39;)
                }
                  return (    
                    &lt;form
                        className=&quot;space-y-5 bg-white shadow p-10 rounded-lg&quot;
                        onSubmit={handleSubmit}
                    &gt;  
                
              </code></pre>

              <p>y lo vamos a conectar con esta otra parte, el reducer, para que ejecute cierta parte de nuestro código:</p>
              <pre><code class="language-js">
                //activity-reducers.ts
                //REDUCER - que conecta a ambos, nuestras acciones y el state
                export const activityReducer = (
                    state : ActivityState = initialState,
                    action: ActivityActions
                  ) => {
                  
                  return state  
                }
              </code></pre>              
              
              <p>Así que en la parte de acciones de nuestro reducer, preparemos nuestro primer action definiendo:
                
              <ul>
                <li>El <strong>type</strong>, que es lo que describe lo que está sucediendo/lo que va a pasar en nuestro reducer. Una vez que hayamos enviado el formulario vamos a decirle a nuestro reducer <strong>"ejecuta el type 'save-activity'"</strong>
                  <pre><code class="language-js">
                    //ACCIONES - type que va a contener las acciones, lo que va a pasar en nuestro reducer
                    export type ActivityActions = 
                        { type: 'save-activity', payload: { newActivity: Activity} } 
                  </code></pre>
    
                  <p>Usando el pipe como unión "|" podríamos tener múltiples actions, todos los que requiramos en  nuestra aplicación:</p>
              
                  <pre><code class="language-js">
                    //ACCIONES - type que va a contener las acciones, lo que va a pasar en nuestro reducer
                    export type ActivityActions = 
                        { type: 'save-activity', payload: { newActivity: Activity} } |
                        { type: 'save-activity', payload: { newActivity: Activity} } |
                        { type: 'save-activity', payload: { newActivity: Activity} } 
                  </code></pre>                
                </li>
                <li>
                  <p>El <strong>payload</strong>; cuando yo genere esta actividad nueva 'save-activity', tenemos que pasarle cierta información, lo que el usuario ingresó en el formulario. Eso es lo que se conoce como el payload, y podemos pensar en ello como <strong>los datos que se van a agregar a nuestro state (actualmente está vacío)</strong>.</p>

                  <p>en la parte del reducer antes se trabajaba con switch, (nunca le han gustado) pero prefiere usar if. Y explica que, desde el momento en que tenemos 'conectado' aquí el state y el action, el autocompletado de VSC nos sugiere las posibles opciones en cuanto comenzamos a trabajr con ello:</p>

                  <img src="./src/assets/img/144.png" loading="lazy" alt="img 144">
      
                  <pre data-line="0"><code class="language-js">
                    //activity-reducers.ts
                    //REDUCER - que conecta a ambos, nuestras acciones y el state
                    export const activityReducer = (
                            state : ActivityState = initialState,
                            action: ActivityActions
                        ) => {
                        
                        if(action.type === 'save-activity'){
                            //Este código maneja la lógica para actualizar el state
                            console.log('desde el type de save-activity')
                        }
      
                        return state
      
                    }
                  </code></pre>
                
                </li>
              </ul>

             

           
          </div>
  
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-145').toggle();">
            <h3>145. Ejecutando las acciones con dispatch</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-145" class="hidden">
            <p><strong>Vamos a llamar nuestra primera acción de nuestro reducer</strong> y en el siguiente apartado veremos como actualizar nuestro state.</p> 
            <p>Abrimos nuestro <span class="file">App.tsx</span> porque aún no tenemos un estado global así que para poder usar nuestro reducer tenemos que importar el Hook useReducer y pasarlo vía props (mientras no tengamos un estado global, tenemos que hacer esto con todas las funciones que requerimos en nuestros componentes). A continuación lo usamos antes de nuestro return. Si recordamos, useReducer toma dos parámetros, el reducer y el state inicial (que también tenemos que importar). Eso lo tenemos en nuestro: <span class="file">activity-reducers.ts</span>:</p>
            
            <img src="./src/assets/img/145.png" alt="">

            <pre data-line="1,3,7"><code class="language-js">
              //App.tsx
              import { useReducer } from "react"
              import Form from "./components/Form"
              import { activityReducer, initialState } from "./reducers/activity-reducers"
              
              function App() {  
              
                const [state, dispatch] = useReducer(activityReducer, initialState)
            </code></pre>

            <p>este arreglo <code class="language-js">const [state, dispatch] =...</code> nos retorna <strong>el state de ese reducer</strong> (puede ser vacío o conforme se vaya actualizando) y <strong>dispatch que es una función especial que nos va a permitir ejecutar las acciones que tengamos en nuestro reducer</strong>. Nuestro proyecto no sabe en qué momento queremos ejecutar esas acciones, pero cuando yo presione en Guardar comida y una vez pase toda la validación descrita en Form.tsx, entonces puedo disparar/ejecutar esas acciones en el momento en que yo las necesite.</p>
              
            <div class="mt-3 mb-2 ml-1.5 pl-2.5 pt-0.5 pb-2  border-l-2 border-dashed border-l-stone-600 rounded-tl-2xl rounded-bl-2xl bg-neutral-50 shadow-lg">              
              <div class="flex">
                <svg class="size-6 shrink-0" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                </svg>
                <span class="bg-neutral-200 px-1.5 py-0.5 italic leading-[24px]"> Supongamos que vamos a utilizar este reducer para consumir una API y queremos mostrar un listado de clientes tan pronto como cargue el componente. Podríamos colocar un useEffect y entonces utilizar dispatch para traernos una acción que hubiéramos definido para traer resultados de una API; entonces como no sabe exactamente en qué momento queremos utilizarlo nos da esta función especial para nosotros mandarlo llamar con nuestro código.</span>
              </div>
            </div>

            <p>Como no tenemos un estado global, tenemos que pasar como prop este dispatch hacia mi componente Form.tsx. </p>
            <pre data-line="10"><code class="language-js">
              //App.tsx
              import { useReducer } from "react"
              import Form from "./components/Form"
              import { activityReducer, initialState } from "./reducers/activity-reducers"

              function App() {  

                const [state, dispatch] = useReducer(activityReducer, initialState)
                ...
                &lt;Form 
                dispatch = {dispatch}
                /&gt;
            </code></pre>
              
            <p>Sale en rojo, <strong>nosotros queremos asignarle nuestras acciones para que el autocompletado de VSC sugiera las acciones que retorna al utilizar el activityReducer del primer parámetro.</strong></p>
            
            <pre data-line="2"><code class="language-js">
              //activity.reducers.ts
              //ACCIONES - type que va a contener las acciones, lo que va a pasar en nuestro reducer
              export type ActivityActions = 
                  { type: 'save-activity', payload: { newActivity: Activity} } 
            </code></pre>
            
            <p>En nuestro componente Form.tsx definimos un type nuevo para las props que le pasamos (en este caso dispatch) en el que le indicamos que ese dispatch es <strong>de tipo Dispatch (se importa automáticamente en la importación de react superior)</strong> y con un generic le vamos a pasar las acciones que tenemos en nuestro reducer (ponemos ActivityActions y automáticamente aparece arriba importado). De esta manera, este dispatch <code class="language-js">type FormProps = { dispatch: ...</code> que se está creando con este useReducer <code class="language-js">... = useReducer(activityReducer,...</code> que viene desde activity-reducer.ts, tiene la información sobre qué acciones tiene el reducer que lo ha creado:</p>
            
            <pre data-line="1,4,6-8"><code class="language-js">
              //Form.tsx
              import { useState, ChangeEvent, FormEvent, Dispatch } from "react"
              import { categories } from "../data/categories"
              import { Activity } from "../types"
              import { ActivityActions } from "../reducers/activity-reducers"

              type FormProps = {
                  dispatch: Dispatch&lt;ActivityActions&gt;
              }
            </code></pre>          
              

            <p>Una vez extraemos y tipamos ese prop en la llamada de la fcn de nuestro componente, ya tenemos acceso a ese dispatch:</p>
            <pre data-line="3"><code class="language-js">  
              type FormProps = {
                  dispatch: Dispatch&lt;ActivityActions&gt;
              }
              export default function Form({dispatch}: FormProps) {
              </code></pre>

              <p>¿Cuando disparamos esa acción? Cuando presionemos en el botón, validación + submit de nuestro formulario:</p>

              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <p>Así que <strong>como argumento del dispatch (y aprovechando el autocompletado) le pasamos la acción que queremos disparar de las que están definidas en nuestro reducer (de momento solo tenemos una)</strong>.</p>
                  <pre data-line="4"><code class="language-js">
                    //Form.tsx
                    const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =>{
                      e.preventDefault()
                      //console.log('Submit...')
                      dispatch({ type: 'save-activity', payload: {newActivity: activity} })
                  }
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <p>como vemos coincide (copy-pasteamos) con la acción que tenemos definida en nuestro reducer</p>
                  <pre data-line="2"><code class="language-js">
                    //activity-reducers.ts                
                    export type ActivityActions = 
                        { type: 'save-activity', payload: { newActivity: Activity} } 
                  </code></pre>
                </div>
              </div>

              <p class="destacado">Recapitulemos:</p>
              
              <ul class="my-3.5">
                <li><span class="file">activity-reducers.ts</span> 
                  <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                  </svg>
                  Definimos nuestro reducer y tenemos nuestras acciones (en nuestro caso solo una, 'save-activity', que toma un payload=la información (es básicamente el parámetro que le estaríamos pasando hacia este reducer) y le decimos que va a tomar una nueva actividad de tipo actividad. Y <strong>en la parte inferior del archivo 'activity-reducers.ts' (en la 3º parte, la del reducer que conecta ambos, las acciones y el state) evaluamos que si el action es de tipo 'save-activity' ejecute el código que está en ese if</strong>.
                  <pre data-line="5,21-24"><code class="language-js">
                    //activity-reducers.ts
                    import { Activity } from "../types"
        
                    //ACCIONES - type que va a contener las acciones, lo que va a pasar en nuestro reducer
                    export type ActivityActions = 
                        { type: 'save-activity', payload: { newActivity: Activity} } 
                    
                    export type ActivityState = {
                        activities : Activity[] //el state de este reducer se va a llamar activities y va a ser de tipo Activity[](ya lo teníamos definido en types)
                    }
                    //STATE - nuestro state inicial que es un objeto necesita un type (definimos arriba 'ActivityState'). En nuestro state de actividades vamos a tener un arreglo.
                    export const initialState: ActivityState = {
                        activities: [] //inicia como arreglo vacío
                    }
                    
                    //REDUCER - que conecta a ambos, nuestras acciones y el state
                    export const activityReducer = (
                            state : ActivityState = initialState,
                            action: ActivityActions
                        ) => {
                        
                        if(action.type === 'save-activity'){
                            //Este código maneja la lógica para actualizar el state
                            console.log('desde el type de save-activity')
                        }
                    
                        return state
                    }
                  </code></pre>
                </li>

                <li><span class="file">App.tsx</span> 
                  <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                  </svg>
                  Para usar este reducer hemos de importar el Hook useReducer de react. Como podemos tener múltiples reducers hemos de pasarle en qué reducer queremos utilizarlo (lo que nos va a dar acceso al state de ese reducer y las funciones de ese type) y un estado inicial
                <pre data-line="1,3,7"><code class="language-js">
                  //App.tsx
                  import { useReducer } from "react"
                  import Form from "./components/Form"
                  import { activityReducer, initialState } from "./reducers/activity-reducers"

                  function App() {  

                    const [state, dispatch] = useReducer(activityReducer, initialState)  
                </code></pre>
                Así ya tenemos acceso al estado:
                  <pre data-line="1-3"><code class="language-js">
                    //activity-reducers.ts
                    export const initialState: ActivityState = {
                      activities: [] //inicia como arreglo vacío
                    }
                  </code></pre>
                  
                ..y al dispatch, que son estas acciones que están conectadas con nuestras acciones:
                  <pre data-line="5-8"><code class="language-js">
                    //activity-reducers.ts              
                    export const activityReducer = (
                            state : ActivityState = initialState,
                            action: ActivityActions
                        ) => {                    
                        if(action.type === 'save-activity'){
                            //Este código maneja la lógica para actualizar el state
                            console.log('desde el type de save-activity')
                        }
                    }
                  </code></pre>
                </li>
                <li><span class="file">Form.tsx</span>
                  <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                  </svg>
                  Como esas acciones se pueden ejecutar en diferentes momentos de nuestra App (no especificados), tenemos acceso a esa función de dispatch que la pasamos como prop hacia nuestro Form.tsx, donde la extraemos y, tras validar nuestro formulario entonces mandamos llamar ese dispatch, diciéndole que queremos ejecutar ese save-activity.
                
                <pre data-line="6-8,10,15"><code class="language-js">
                  //Form.tsx
                  import { useState, ChangeEvent, FormEvent, Dispatch } from "react"
                  import { categories } from "../data/categories"
                  import { Activity } from "../types"
                  import { ActivityActions } from "../reducers/activity-reducers"
                  
                  type FormProps = {
                      dispatch: Dispatch&lt;ActivityActions&gt;
                  }
                  
                  export default function Form({dispatch}: FormProps) {
                    ...
                    const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =>{
                      e.preventDefault()
                      //console.log('Submit...')
                      dispatch({ type: 'save-activity', payload: {newActivity: activity} })
                    } 
                </code></pre>
                  
                  Por lo tanto este dispatch manda llamar de nuevo a mi reducer y evalúa ¿qué código tiene el action.type de 'save-activity' y entonces ejecuta ese código y por eso aparece el console log que dice 'desde el type de save.activity'</li>
              </ul>

              <p>Sí, son muchas cosas a tener en cuenta pero:</p>
              <ul class="my-3.5">
                <li>Tenemos un autocompletado muy bueno que facilita escribir código y evitar errores.</li>
                <li>La forma en la que vamos a manejar el state y nuestras acciones va a hacer que tengamos un código muy bueno, que sea muy sencillo de mantener o agregar más acciones.</li>
                <li>Una forma muy escalable de escribir código.</li>
              </ul>
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-146').toggle();">
            <h3>146. Escribiendo en el reducer / 147. Reiniciando el Formulario después de añadir una actividad</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-146" class="hidden">
            <p>Ya estamos disparando las acciones de nuestro reducer (aparece el console.log('desde el type de save.activity'). Nuestro estate es muy sencillo, pero es un objeto y podríamos tener múltiples elementos (simplemente tendríamos que sincronizarlo con lo definido en su correspondiente type):</p>
            <pre><code class="language-js">
              //activity-reducers-ts
              export type ActivityState = {
                activities : Activity[] //el state de este reducer se va a llamar activities y va a ser de tipo Activity[](ya lo teníamos definido en types)
              }
              //STATE - nuestro state inicial que es un objeto necesita un type (definimos arriba 'ActivityState').
              export const initialState: ActivityState = {
                  activities: [], //inicia como arreglo vacío
                  activities: [], 
                  activities: [], 
                  activities: [], 
                  activities: [], 
              }
            </code></pre>
            <p>Estamos utilizando un dispatch y le estamos pasando la actividad ¿como le hago para poder obtener la información que el usuario está ingresando en el formulario? . La acción de 'save-activity' va a tomar un payload (un payload son los datos) de newActivity que tiene que tener la forma de Activity:</p>
            <pre><code class="language-js">
              //activity-reducers.ts
              //ACCIONES - type que va a contener las acciones, lo que va a pasar en nuestro reducer
              export type ActivityActions = 
              { type: 'save-activity', payload: { newActivity: Activity } } 
            </code></pre>

            <p>Vamos a cambiar el console.log por <code class="language-js">console.log(action.payload.newActivity)</code> y, en cuanto pulsamos el boton, vamos a ver en la consola los datos que hemos ingresado en el formulario:</p>
            <img src="./src/assets/img/146-1.png" alt="">
            <p>le estamos pasando la información desde nuestro dispatch con el payload:
              <div class="mt-3 mb-2 ml-1.5 pl-2.5 pt-0.5 pb-2  border-l-2 border-dashed border-l-stone-600 rounded-tl-2xl rounded-bl-2xl bg-neutral-50 shadow-lg">
                <div class="flex">
                  <svg class="size-6 shrink-0" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                  </svg>
                  <span class="bg-neutral-200 px-1.5 py-0.5 italic leading-[24px]">El payload son los datos que le pasamos junto a la acción. La forma en que lo recuperamos es con action.payload y el nombre del payload que le hemos dado en unestro archivo de reducer <code class="language-js">action.payload.newActivity</code></span>
                </div>
              </div>
            </p>
            
            <p>Escribamos en nuestro state. En estos if siempre hemos de tener un return que va adevolver el estado actualizado, y antes de ese return manejamos toda la lógica de evitar registros duplicados o lo que considremos que sea necesario para tener nuestro state. También de manera habitual al principio del return vamos a tener una copia de lo que ya tenemos en el state porque este tpo de patrones en los reducers nos permiten modificar múltiples propiedades de nuestro state (ahora solo tenemos una) y con la copia <strong>...state</strong> no perdemos nada de lo que ya tuviéramos almacenado) <strong>las líneas marcadas, las vamos a tener en todas las acciones de nuestros reducers:</strong></p>
            <pre data-line="2,4,5"><code class="language-js">
              //activity-reducers.ts
              ...
              if(action.type === 'save-activity'){
                //Este código maneja la lógica para actualizar el state             
                return{
                  ...state,
                  activities: [...state.activities, action.payload.newActivity]
                }
              }
              ...
            </code></pre>
        
            <p>Probémoslo viendo con el RDT el componente donde usamos el reduce (App.tsx) y como vemos cada vez que agregamos, se añade a nuestro state una actividad:</p>
            
            <img src="./src/assets/img/146-2.png" alt="">
            
            <p class="naranja">Reiniciando el Formulario después de añadir una actividad</p>

            <p>Lo ideal es que el formulario se reinice una vez hayamos añadido una actividad al state (para partir de la situación inicial). Vayamos a nuestro Form.tsx y después del dispatch vamos a reiniciar nuestro state 'activity', podemos hacerlo así:</p>
            <pre><code class="language-js">
              //Form.tsx
              const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =&gt;{
                e.preventDefault()
                dispatch({ type: &#39;save-activity&#39;, payload: {newActivity: activity} })
                setActivity({
                    category: 1,
                    name: &#39;&#39;,
                    calories: 0
                })
              }
            </code></pre>

            <p>mejoremos nuestro código definiendo una constante que tenga esos valores y la usamos tanto en el initial state como en este reinicio que hacemos tras el dispatch.</p>
            
            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre class="rojo" data-line="3-7,12-16"><code class="language-js">
                  //Form.tsx
                  export default function Form({dispatch}: FormProps) {

                    const[activity, setActivity] = useState&lt;Activity&gt;({
                        category: 1,
                        name: &#39;&#39;,
                        calories: 0
                    }) 
                    ...
                    const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =&gt;{
                      e.preventDefault()
                      dispatch({ type: &#39;save-activity&#39;, payload: {newActivity: activity} })
                      setActivity({
                          category: 1,
                          name: &#39;&#39;,
                          calories: 0
                      })
                  }
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="1-5,8,13" class="verde"><code class="language-js">
                //Form.tsx
                const initialState = {
                  category: 1,
                  name: &#39;&#39;,
                  calories: 0
                }              
                export default function Form({dispatch}: FormProps) {
                
                  const[activity, setActivity] = useState&lt;Activity&gt;(initialState) 
                  ...
                  const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =&gt;{
                    e.preventDefault()
                    dispatch({ type: &#39;save-activity&#39;, payload: {newActivity: activity} })
                    setActivity(initialState)
                }  
                </code></pre>
              </div>
            </div>

            <p>A continuación veremos como listar lo que tenemos en el state y también tenemos que poder diferenciaros de manera única, de momento no tenemos un identificador único para cada una de esas actividades almacenadas en nuestro state.</p>
          </div>         

          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-148').toggle();">
            <h3>148. Generando ID's unicos</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-148" class="hidden">
            <p>Veamos como mostrar las actividades que vamos creando. Primero, vemos que no tenemos un id único que identifique cada actividad añadida (nos podemos comer una manzana por la mañana y otra por la tarde). Para generar un identificador único, vamos a instalar una dependencia <span class="destacado">npm i uuid</span> y en nuestro Form.tsx la importamos: <code class="language-js">import { v4 as uuidv4 } from 'uuid'</code>. Podríamos crear otro type para una actividad que no ha sido almacenada y entonces asignarle un id o también lo podemos hacer aquí en el state inicial:</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[33%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  //Form.tsx
                  import { useState, ChangeEvent, FormEvent, Dispatch } from "react"
                  import { categories } from "../data/categories"
                  import { Activity } from "../types"
                  import { ActivityActions } from "../reducers/activity-reducers"
      
                  type FormProps = {
                      dispatch: Dispatch&lt;ActivityActions&gt;
                  }
      
                  const initialState = {
                    category: 1,
                    name: '',
                    calories: 0
                  }
                </code></pre>
              </div>
              <div class="w-[33%] max-sm:w-[100%]">
                <pre class="verde" data-line="2,11,12"><code class="language-js">
                  //Form.tsx
                  import { useState, ChangeEvent, FormEvent, Dispatch } from "react"
                  import { v4 as uuidv4 } from 'uuid'
                  import { categories } from "../data/categories"
                  import { Activity } from "../types"
                  import { ActivityActions } from "../reducers/activity-reducers"
      
                  type FormProps = {
                      dispatch: Dispatch&lt;ActivityActions&gt;
                  }
      
                  const initialState : Activity = {
                    id: uuidv4(),
                    category: 1,
                    name: '',
                    calories: 0
                  }
                </code></pre>
              </div>
            
              <div class="w-[33%] max-sm:w-[100%]">
                <p>Tenemos que añadirlo en la correspondiente definición de type:</p>
                <pre class="verde" data-line="1"><code class="language-js">
                  //types&gt;index.tsc
                  export type Activity = {
                    id: string
                    category: number
                    name: string
                    calories: number
                  }
                </code></pre>
              </div>
            </div>          
            
            <p>Si miramos en RDT nuestro componente App, vemos que todas las actividades añadidas tiene el mismo id:</p>
            <img src="./src/assets/img/148.png" alt="img 148">              
                
            <p>Para tener un id único por actividad aún tenemos que hacer esto en nuestro handleSubmit del Form.tsx: modificamos el setActivity para que tome una copia del acutal y le añada un id nuevo a la nueva actividad que estamos almacenando.</p>
            
            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  //Form.tsx
                  const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =&gt;{
                    e.preventDefault()
                    dispatch({ type: &#39;save-activity&#39;, payload: {newActivity: activity} })
                    setActivity(initialState)
                  }
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre class="verde" data-line="4-7"><code class="language-js">
                  //Form.tsx
                  const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =&gt;{
                    e.preventDefault()
                    dispatch({ type: &#39;save-activity&#39;, payload: {newActivity: activity} })
                    setActivity({
                      ...initialState,
                      id: uuidv4()
                    })
                  }
                </code></pre>
              </div>
            </div>
              
            <img src="./src/assets/img/148.png" alt="img 148">          
            
          </div>
           
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-149').toggle();">
            <h3>149. Creando el Componente para listar Actividades y Comidas / 150. Añadiendo más información al listado de Actividades</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-149" class="hidden">
            <p>Veamos cómo mostrar nuestras actividades. ¿Cómo hacemos para mostrar el state ya en nuestros componentes?. App.tsx nos retorna el state y el dispatch. Dispatch es para llamar las acciones de nuestro reducer y state nos devuelve el estado del reducer. Así que como ya lo tenemos coloquemos un console.log(state) y veremos en la consola las actividades que tenemos añadidas:</p>
            <pre><code class="language-js">
              //App.tsx
              const [state, dispatch] = useReducer(activityReducer, initialState) 
              console.log(state)
            </code></pre>

            <p>Así que teniéndolo en este state podemos iterar, crear componentes, etc... Creamos una sección nueva en nuestro App.tsx qeu contiene el tag del nuevo componente que creamos para listar las actividades: <strong>ActivityList</strong>. Le podríamos pasar como prop el state entero <code class="language-js">state={state}</code>, sin embargo como este componente solo va a renderizar la lista de actividades le pasamos como propsolo esas actividades <code class="language-js">activities={state.activities}</code>:</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  //App.tsx
                  import ActivityList from "./components/ActivityList"
                  ...
                  &lt;section className=&quot;p-10 mx-auto max-w-4xl&quot;&gt;
                    &lt;ActivityList 
                      activities={state.activities}
                    /&gt;
                  &lt;/section&gt;
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  //ActivityList.tsx
                  import { Activity } from &quot;../types&quot;

                  type ActivityListProps = {
                      activities: Activity[]
                  }
                  
                  export default function ActivityList({activities}: ActivityListProps) {  
                      //console.log(activities)
                      return (
                      &lt;&gt;
                          &lt;h2 className=&quot;text-4xl font-bold text-slate-600 text-center&quot;&gt;Comida y Actividades&lt;/h2&gt;
                  
                          {activities.map(activity =&gt; (
                              &lt;div key={activity.id} className=&quot;px-5 py-10 bg-white mt-5 flex justify-between&quot;&gt;
                                  &lt;div className=&quot;space-y-2 relative&quot;&gt;
                                      {/* Muestra actividad: categoría, nombre y calorías */}
                                      &lt;p&gt;{activity.category}&lt;/p&gt;
                                      &lt;p className=&quot;text-2xl font-bold pt-5&quot;&gt;{activity.name}&lt;/p&gt;
                                      &lt;p className=&quot;font-black text-4xl text-lime-500&quot;&gt;
                                          {activity.calories} {&#39;&#39;}
                                          &lt;span&gt;Calorías&lt;/span&gt;
                                      &lt;/p&gt;
                                  &lt;/div&gt;
                                  &lt;div&gt;
                                      {/* Acciones para editar esa actividad o eliminarla */}
                  
                                  &lt;/div&gt;
                                  
                              &lt;/div&gt;
                          ))
                          }
                      &lt;/&gt;
                      )
                  }
                </code></pre>
              </div>
            </div>

            <p class="naranja">Añadiendo más información al listado de Actividades</p>
            
            <p>Ahora mismo vemos que nuestra App nos muestra así las actividades que introducimos (usando el id de nuestros datos=diccionario de actividades) y queremos usar el name para que sea un poco más descriptivo:</p>

            <img src="./src/assets/img/150.png" alt="img 150">

            <p>Con el id iteramos sobre nuestras categorías y muestro el label en vez del id. <span class="rojo">COMPLEJO, REPASAR</span></p>

            <pre data-line="11-14,26"><code class="language-js">
              //ActivityList.tsx
              import { Activity } from &quot;../types&quot;
              import { useMemo } from &quot;react&quot;
              import { categories } from &quot;../data/categories&quot;
              
              type ActivityListProps = {
                  activities: Activity[]
              }
              
              export default function ActivityList({activities}: ActivityListProps) {  
                  
                  const categoryName = useMemo(()=&gt; 
                      (category:Activity[&#39;category&#39;]) =&gt; categories.map( cat =&gt; cat.id === category ? cat.name : &#39;&#39;)
                  , [activities]
                  )
              
                  return (
                  &lt;&gt;
                      &lt;h2 className=&quot;text-4xl font-bold text-slate-600 text-center&quot;&gt;Comida y Actividades&lt;/h2&gt;
              
                      {activities.map(activity =&gt; (
                          &lt;div key={activity.id} className=&quot;px-5 py-10 bg-white mt-5 flex justify-between&quot;&gt;
                              &lt;div className=&quot;space-y-2 relative&quot;&gt;
                                  {/* Muestra actividad: categoría, nombre y calorías */}
                                  &lt;p className={`absolute -top-8 -left-8 px-10 py-2 text-white uppercase font-bold ${activity.category === 1 ? &#39;bg-lime-500&#39; : &#39;bg-orange-500&#39;}`}&gt;
                                      {/* {activity.category} */}
                                      {categoryName(+activity.category)}
                                      
                                  &lt;/p&gt;
                                  &lt;p className=&quot;text-2xl font-bold pt-5&quot;&gt;{activity.name}&lt;/p&gt;
                                  &lt;p className=&quot;font-black text-4xl text-lime-500&quot;&gt;
                                      {activity.calories} {&#39;&#39;}
                                      &lt;span&gt;Calorías&lt;/span&gt;
                                  &lt;/p&gt;
                              &lt;/div&gt;
                              &lt;div&gt;
                                  {/* Acciones para editar esa actividad o eliminarla */}
              
                              &lt;/div&gt;
                              
                          &lt;/div&gt;
                      ))
                      }
                  &lt;/&gt;
                  )
              }
            </code></pre>

            <img src="./src/assets/img/150-2.png" alt="img 150-2">

          </div>                  
           
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-151').toggle();">
            <h3>151. Agregando un Icono para Editar</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-151" class="hidden">
            <p>Veamos como editar una actividad que ya hemos metido en el state. Instalamos la dependencia de heroicons <span class="destacado">npm install @heroicons/react</span></p>
          
            <pre><code class="language-js">
              //ActivityList.tsx
              import { PencilSquareIcon } from '@heroicons/react/24/outline'
              ...
              &lt;div className=&quot;flex gap-5 items-center&quot;&gt;
                {/* Acciones para editar esa actividad o eliminarla */}
                &lt;button&gt;
                    &lt;PencilSquareIcon 
                        className=&quot;h-8 w-8 text-g&quot;
                    /&gt;
                &lt;/button&gt;
            &lt;/div&gt;
            </code></pre>
            <p>Para poder editar vamos a tener que registrar un atributo nuevo en nuestro reducer. Ese va a ser el id activo en el cual yo estoy presionando para editar y de esa forma vamos a poder identificar en nuestro formulario qué es lo que estamos editando. De ahí tenemos que pasar las actividades para poder llenar el formulario en automático, es decir, se va a tener que llenar la categoría, la actividad y las calorías (más trabajo para el programador, pero menos para el usuario). Veamos a continuación como identificar a qué actividad le estamos dando click.</p>
          </div>
           
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-152').toggle();">
            <h3>152. Creando la acción para seleccionar la actividad a editar</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-152" class="hidden">
            <p><svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
            </svg> En nuestro reducer, <strong>en la parte de states vamos a crear un nuevo state para identificar cual es el activeId (el correspondiente al icono de editar que se pulsa)</strong> y si presiono en otra se va a ir actualizando así que siempre va a tener una. Lo iniciamos como string vacío y, al definirle arriba el tipo podemos ponerle estring o directamente como el state que ya existe, de tipo Activity pero con un lookup de id:</p>

            <p><svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
            </svg> ¿Cómo vamos a establecer este elemento <code class="language-js">activeId: ''</code> como el id activo?. <strong>Al pulsar en el botón de editar lo primero que he de hacer es registrar una acción, con lo cual creo una acción nueva en laparte de las acciones de nuestro reducer</strong>. <strong>En esta acción vamos a setear qué elemento es el que está activo para luego editarlo, así que el payload simplemente es el id</strong>:</p>

            <p><svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
            </svg> A continuación en la parte del reduce donde definimos los if según las acciones, añadimos el if correspondiente a esta nueva actividad (Fijémonos que el autocompletado en las comillas simples ya nos sugiere nuestro nueva action, no la que ya tenemos definida). ¿Cómo lo definimos? básicamente lo que le pasamos como Payload es lo que define ese state, así que en el return regresamos una copia del state <code class="language-js">...state</code> para que las diferentes actividades que ya estaban se mantengan, y además escribimos en activeId <strong>lo que le estoy pasando como payload <code class="language-js"></code></strong></p>  

            <pre data-line="6,15,33-40"><code class="language-js">
              //activity-reducers.ts
              import { Activity } from "../types"

              //ACCIONES - type que va a describir lo que va a pasar en nuestro reducer
              export type ActivityActions = 
                  { type: 'save-activity', payload: { newActivity: Activity } } |
                  { type: 'set-activeId', payload: { id: Activity['id'] } } 

              export type ActivityState = {
                  activities : Activity[], //este state se va a llamar activities y va a ser de tipo Activity[]
                  activeId : Activity['id']
              }
              //STATE - nuestro state inicial que es un objeto necesita un type (definimos arriba 'ActivityState'). En nuestro state de actividades vamos a tener un arreglo.
              export const initialState: ActivityState = {
                  activities: [],
                  activeId: ''
              }

              //REDUCER - que conecta a ambos, nuestras acciones y el state
              export const activityReducer = (
                      state : ActivityState = initialState,
                      action: ActivityActions
                  ) => {
                  
                  if(action.type === 'save-activity'){
                      //Este código maneja la lógica para actualizar el state activities
                      //console.log('desde el type de save-activity') //console.log(action.payload.newActivity)         
                      return{
                          ...state,
                          activities: [...state.activities, action.payload.newActivity]
                      }
                  }
                  
                  if(action.type === 'set-activeId'){
                      //Este código maneja la lógica para actualizar el state activeId
                      //console.log('desde el type de set-activeId') //console.log(action.payload.id)         
                      return{
                          ...state,
                          activeId: action.payload.id
                      }
                  }

                  return state
              }
            </code></pre>
                
            <p>Veremos a continuación como disparar esta nueva acción, ya nuestros componentes usan el dispatch.</p>


          </div>
           
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-153').toggle();">
            <h3>153. Almacenando el ID a editar</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-153" class="hidden">
            <p><span class="destacado">Nosotros tenemos las acciones que definen lo que va a pasar pero el dispatch es el momento exacto en el que se va a escribir ese state.</span> El dispatch siempre lo vamos a usar en nuestros componentes y en esta caso en concreto con el que estamos, va  a ser cuando el usuario presione el botón de editar que tenemos en nuestro componente ActivityList.tsx. Veamos cómo se relacionan acciones, state y el dispatch de nuestras acciones.</p>

            <p>En el compo ppal App.tsx ya tenemos nuestro dispatch. Es lo mismo, la misma función que pasamos como prop, porque es el mismo state y las mismas acciones <code class="language-js">const [state, dispatch] = useReducer(activityReducer, initialState)</code> (en otros proyectos podríamos tener múltiples reducers y cada uno tendrá su propio dispatch, pero no es el caso) así que lo vamos a pasar hacia el compo ActivityList.tsx como ya hemos hecho antes hacia el compo Form.tsx</p>

            <p>Una vez lo pasamos como prop hacia nuestro compo ActivityList.tsx y lo extraemos y tipamos adecuadamente lo usamos en el onclick del botón para editar.</p>

          
                <pre><code class="language-js">
                  //App.tsx
                  const [state, dispatch] = useReducer(activityReducer, initialState)  
      
                  return (
                  ...
                  &lt;section className=&quot;p-10 mx-auto max-w-4xl&quot;&gt;
                    &lt;ActivityList 
                      activities={state.activities}
                      dispatch={dispatch}
                    /&gt;
                  &lt;/section&gt;
                </code></pre>
              
                <pre data-line="1,5,9,,12,15"><code class="language-js">
                  //ActivityList.tsx
                  import { useMemo, Dispatch } from "react"
                  import { Activity } from "../types"
                  import { categories } from "../data/categories"
                  import { PencilSquareIcon } from '@heroicons/react/24/outline'
                  import { ActivityActions } from "../reducers/activity-reducers"

                  type ActivityListProps = {
                      activities: Activity[]
                      dispatch: Dispatch&lt;ActivityActions&gt;
                  }

                  export default function ActivityList({activities, dispatch}: ActivityListProps) {  
                  ...
                  &lt;button
                    onClick={() =&gt; dispatch({type:&quot;set-activeId&quot;, payload: {id: activity.id}})}
                  &gt;
                    &lt;PencilSquareIcon 
                        className=&quot;h-8 w-8 text-g&quot;
                    /&gt;
                  &lt;/button&gt;
                </code></pre>
              

            <p>Podemos probar tras añadir varias actividades que el active id que se almacena es el correspondiente al de la actividad desde donde pulsamos el lápiz</p>
            
            <img src="./src/assets/img/153.png" alt="">
          
          </div>
                   
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-154').toggle();">
            <h3>154. Llenando el Formulario cuando editamos una actividad</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-154" class="hidden">
            <p>Veamos cómo identificar y llenar nuestro formulario una vez que el usuario presione en una actividad para editarla. <strong>¿Cómo vamos a hacer para que nuestro componente Form.tsx sepa en qué momento nuestro reducer tiene un elemento en el state activeId? Suena complejo, son archivos completamente separados, siendo uno un componente y otro el reducer que maneja el state.</strong></p>

            <p>En nuestro compo ppal App.tsx, en este <strong>state</strong> vamos a tener tanto activities[] como activeId</p>

            <pre><code class="language-js">
              //App.tsx
                function App() {  
                  const [state, dispatch] = useReducer(activityReducer, initialState)
              
              //activity-reducers.ts
                export type ActivityState = {
                    activities : Activity[], //activities va a ser de tipo Activity[](ya lo teníamos definido en types)
                    activeId : Activity['id'] //para tipa este activeId que es un id, usamos el lookup for 'id' en Activity
                }
                //STATE - nuestro state inicial que es un objeto necesita un type (definimos arriba 'ActivityState'). 
                export const initialState: ActivityState = {
                    activities: [],
                    activeId: ''
                }
            </code></pre>

            <p>por lo tanto vamos a pasar como prop a nuestro compo Form.tsx nuestro state. Si abrimos el compo Form.tsx vemos que <span class="destacado">la firma (él se refiere así al type que define los props que le llegan a mi compo)</span> solo tiene el dispatch, pero podemos inferir qué tipo ha de tener el state que estamos pasando si nos colocamos con el IS en la declaración del state del compo ppal App.tsx y vemos que es <strong>ActivityState</strong>, así que usamos esa información para completar la firma y a continuación lo extraemos con destructuring en la declaración de la función ppal del compo para poder usarlo:<p>
              <pre><code class="language-js">
                //Form.tsx --&gt;no tenía exportado desde mi reducer el type ActivityState así que al escribirlo no se importaba automáticamente
                //para que se importe automáticamente como vemos en esta línea de import, tengo que añadir la palabra 'export' al type ActivityState
                //en el reducer (ver prism anterior donde ya lo he puesto)
                import { ActivityActions, ActivityState } from "../reducers/activity-reducers"

                type FormProps = {
                    dispatch: Dispatch<ActivityActions>,
                    state: ActivityState
                }
                ...
                export default function Form({dispatch, state}: FormProps) {...}
              </code></pre>

              <p><span class="destacado">¿Como identificamos en qué momento nuestro state tiene un activeId? Lo podemos hacer con el versátil Hook useEffect</span> (similar al watch en vue.js) que como vimos en el punto 82 (almacenar carrito en localStorage), <span class="destacado">además de ser útil cuando el componente está listo, es muy útil para manejar los "efectos secundarios" de un cambio en nuestro state (cuando cambie mi state ejecutar cierto código).</span> Así que:</p>

              <ul class="my-3.5 list-disc">
                <li>lo importamos en nuestro compo Form.tsx</li>
                <li>lo colocamos tras la declaración de nuestro useState (recordar que  siempre es un callback)</li>
                <li>le indicamos que su dependencia sea el <strong>state.activeId</strong></li>
                <li>se va a ejecutar primero una vez (cuando está listo el componente) y después siempre que esa dependencia cambie, así que comprobamos con un if si hay algo ya en ese activeId y qué:
                <pre><code class="language-js">
                  //Form.tsx
                  export default function Form({dispatch, state}: FormProps) {

                    const[activity, setActivity] = useState&lt;Activity&gt;(initialState) 
                
                    useEffect(() => {
                      if(state.activeId){
                        console.log(`ya hay algo en activeId: ${state.activeId}`)
                      }
                    }, [state.activeId])
                </code></pre>
                </li>
                <li>Como en el state ya tengo también las activities además del activeId, recordar:
                  <pre><code class="language-js">
                    //activity-reducers.ts
                    export type ActivityState = {
                      activities : Activity[]
                      activeId : Activity['id'] 
                  }
                  </code></pre>
                  ¡puedo traérme la actividad y setearla! creo una variable para no hacerlo tdo en una sola línea, se va a llamar selectActivity y, usando el array method filter(), guardamos en esa nueva variable la actividad que tiene el mismo id que el que yo presioné en el lápiz. <strong>Como el .filter() retorna un arreglo, le añado posición 0 para que retorne un objeto [0]</strong>:
                  <pre><code class="language-js">
                    //Form.tsx
                    useEffect(() => {
                      if(state.activeId){
                      //console.log(`ya hay algo en activeId: ${state.activeId}`)
                      const selectActivity = state.activities.filter((actividad)=> actividad.id === state.activeId)[0]
                      //console.log(selectActivity)
                      setActivity(selectActivity)
                      }
                  }, [state.activeId])
                  </code></pre>
                </li>              
              </ul>

              <p>Si probamos a presionar ahora cada icono de editar en las actividades que hemos añadido y aparecen en la parte inferior vemos que se modifica la parte superior de la interfaz actualizando los campos... Otra cosa es que aún no hemos modificado la lógica para que al guardar se modifique la correspondiente (de momento nos añadiría una nueva). <strong>Tenemos que modificar un poco la lógica en el if de nuestro reducer correspondiente a la actividad "save-activity" --> si activeId tiene algo queremos identificar cual y agregarlo nuevo, mientras que si no hay activeId entonces sí es nueva actividad</strong></p>

          </div>
                   
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-155').toggle();">
            <h3>155. Actualizando las actividades</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-155" class="hidden">
            <p>Lo ideal es que si estamos editando reescriba la actividad que ya tenemos y no genere una nueva. <strong>Va a ser el activeId de nuestro state, la bandera que utilicemos para identificar que ésta es la actividad que estamos editando</strong>. Vamos al <code>if(action.type === 'save-activity'){</code> de nuestro reducer y escribimos la lógica que necesitamos antes del return().</p>
            
            <p>Comenta que podríamos(que funciona) tener un return por cada casuística de "si existe el activeId"/"si no existe el activeID", pero que lo normal es solo tener un return() por acción por lo que, con esta nueva lógica hemos de modificar el return que teníamos hasta ahora. Generamos con let una variable 'updatedActivities' de tipo array Activity vacía que en base a una u otra acción se va a llenar:</p>
            <pre data-line="2"><code class="language-js">
              //activity-reducers.ts
              if(action.type === 'save-activity'){
                let updatedActivities : Activity[] = []
                
                if(state.activeId){
                    //vamos a iterar sobre cada actividad porque hemos de identificar cual tiene el activeId y pasarle el nuevo payload
                    updatedActivities = state.activities.map( actividad => actividad.id === state.activeId ? action.payload.newActivity : actividad)
        
                }else{
                    updatedActivities = [...state.activities, action.payload.newActivity]
                }
                
                return{
                    ...state,
                    //activities: [...state.activities, action.payload.newActivity]
                    activities: updatedActivities
                }
              }
            </code></pre>

            <p>Si lo dejamos así y probamos, vemos que, en principio parece funcionar y cuando le damos a editar y guardamos la actividad de abajo se actualiza, sin embargo si justo a continuación añadiéramos otra actividad, nos reescribiría la editada porque <span class="destacado">el activeId sigue activo. ¡¡Tenemos que reiniciarlo después de cada llamada a esa acción <code class="language-js">'save-activity'</code>!! porque si no, sigue siendo el mismo activeId y va a reescribirlo cada vez. Por lo tanto, cada vez que haya una nueva actividad 'save-activity'</span> (sin meterme en problemas de comprobar si estoy agregando una nueva actividad o editando una previa)  voy a reiniciar <code class="language-js">activeId= ''</code></p>
            
            <pre data-line="15"><code class="language-js">
              //activity-reducers.ts
              if(action.type === 'save-activity'){
                let updatedActivities : Activity[] = []
                
                if(state.activeId){
                    //vamos a iterar sobre cada actividad porque hemos de identificar cual tiene el activeId y pasarle el nuevo payload
                    updatedActivities = state.activities.map( actividad => actividad.id === state.activeId ? action.payload.newActivity : actividad)        
                }else{
                    updatedActivities = [...state.activities, action.payload.newActivity]
                }
                
                return{
                    ...state,
                    //activities: [...state.activities, action.payload.newActivity]
                    activities: updatedActivities,
                    activeId= ''
                }
              }
            </code></pre>

            <p><span class="destacado">Gran ventaja de useReducer:</span> <strong>nos permite escribir múltiples states en una sola línea en un mismo return, a diferencia de useState en el cual hay que modificar la función que modifica el state por cada vez que queramos escribir en diferentes partes de nuestro state.</strong>. Algo importante es que justo antes del return de la acción es zona segura para escribir código de typescript que pueda manejar toda la lógica (revisar si un elemento existe, si es así actualizarlo y si es nuevo agregarlo a nuestro arreglo).</p>
            
            <p>Así ya tenemos la edición lista (que suele ser lo que más trabajo toma del <strong>CRUD</strong>: <strong>C</strong>reate <strong>R</strong>ead <strong>U</strong>ptade <strong>D</strong>elete</p>

          </div>
                    
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-156').toggle();">
            <h3>156. Creando la acción para eliminar actividades / 157. Creando el botón para llamar la acción de eliminar / 158. Mostrando un mensaje cuando no hay actividades</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-156" class="hidden">
            <p class="naranja">Creando la acción para eliminar actividades</p>
            <p>Veamos como se haría utilizando nuestro reducer. Creamos nueva acción que concatenamos con un pipe '|' la nombramos adecuadamente y para eliminar solo requerimos el id osea que el resto es igual que la anterior acción:</p>

            <pre data-line="5"><code class="language-js">
              //activity-reducers.ts
              //ACCIONES - type que va a describir lo que va a pasar en nuestro reducer
              export type ActivityActions = 
                  { type: 'save-activity', payload: { newActivity: Activity } } |
                  { type: 'set-activeId', payload: { id: Activity['id'] } } |
                  { type: 'delete-activity', payload: { id: Activity['id'] } } 
            </code></pre>

            <p>Definámosla en el código de nuestro reducer, en su if correspondiente: (podemos crear una variable y aplicar un filter igual que en el ejemplo actual al editar una actividad, o podemos hacerlo directamente) Tomamos una copia del state actual (lo que sea que esté... puede ser que tengamos un elemento activo en el formulario y el usuario presiona en eliminar otro) y a continuación con el array method .filter() accedemos a cada actividad y nos vamos a traer las que sean diferentes a lo que le mandemos como payload:</p>
            <pre><code class="language-js">
              //activity-reducers.ts
              if(action.type === 'delete-activity'){
                return{
                    ...state,
                    activities: state.activities.filter( activity => activity.id !== action.payload.id)
                }
              }
            </code></pre>

            <p class="naranja">Creando el botón para llamar la acción de eliminar</p>

            <p>Vamos a trabajar con el dispatch de la acción para eliminar actividad que acabamos de crear. Si recordamos, en nuestro compo ppal de App.tsx ya le estamos pasando como prop el dispatch al componente ActivityList.tsx que es el que lo utiliza. es el mismo dispatch que tenemos para editar solo que con una acción diferente, así que podemos copy-pastear el mismo button que tenemos para editar y modificarlo un poco:</p>

            <pre><code class="language-js">
              //ActivityList.tsx
              import { PencilSquareIcon, XCircleIcon } from '@heroicons/react/24/outline'
              ...
              &lt;button
                  onClick={() =&gt; dispatch({type:&quot;delete-activity&quot;, payload: {id: activity.id}})}
              &gt;
                  &lt;XCircleIcon 
                      className=&quot;h-8 w-8 text-red-500&quot;
                  /&gt;
              &lt;/button&gt;
            </code></pre>

            <p class="naranja">Mostrando un mensaje cuando no hay actividades</p>

            <p>Vamos al componente de ActivityList.tsx y podemos hacerlo de dos maneras:</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <p>directamente antes del mapeo de activities</p>
                <pre data-line="3,4"><code class="language-js">
                  //ActivityList.tsx
                  return (
                    ...
                  {activities.length === 0 ? 
                    &lt;p className=&quot;text-center my-5&quot;&gt;No hay actividades aún&lt;/p&gt; :
        
                    activities.map(activity =&gt; (
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <p>Igual pero usando una variable que guarda y useMemo() con la dependencia de [activities]</p>
                <pre data-line="1,5-6"><code class="language-js">
                  //ActivityList.tsx
                  const isEmptyActivities = useMemo(() =&gt; activities.length === 0, [activities])

                  return (
                    ...
                    {isEmptyActivities ? 
                      &lt;p className=&quot;text-center my-5&quot;&gt;No hay actividades aún&lt;/p&gt; :
        
                      activities.map(activity =&gt; (
                </code></pre>
              </div>
            </div>

            <p>Vamos a incorporar localStorage a este proyecto</p>          
          </div>          
                    
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-159').toggle();">
            <h3>159. Almacenando las actividades en LocalStorage</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-159" class="hidden">
            <p>Una buena adición y muy simple de implementar para este proyecto es localStorage. Veamos cómo hacerlo. ¿Donde podríamos colocar la función que escriba en localStorage? Mi reducer podría ser un buen lugar?¿dentro del if de 'save-activity' justo antes del return? sincronizando lo que esté en el state, sería una opción. Sin embargo también habría que agregarlo en el if de la acción 'delete-activity' y en más acciones si las agregara.<span class="destacado"> Otra opción, quizás la más sencilla, es hacerlo en el App.tsx y sincronizar únicamente el state de actividades y pasarlo como dependencia en un useEffect()</span>. <strong>La dependencia en el useEffect, lo que nos interesa que 'esté escuchando para actualizar las actividades guardadadas" es [state.activities]</strong></p>

            <pre data-line="7-9"><code class="language-js">
              //App.tsx
              import { useReducer, useEffect } from "react"
              ...
              function App() {  

                const [state, dispatch] = useReducer(activityReducer, initialState)  
              
                useEffect(() => {
                  localStorage.setItem('activities',JSON.stringify(state.activities))
                }, [state.activities])
            </code></pre>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <p>Si miramos en la <strong>pestaña aplicación del WDT</strong> vemos que al añadir una actividad nueva se agrega ahí, y si la editamos se actualiza perfectamente porque está sincronizado con el state.</p>
                <img src="./src/assets/img/159-1.png" alt="img" loading="lazy">
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <p>Sin embargo si recargamos la página se pierde todo y eso es así porque en nuestro activity-reducers.ts estamos especificando que las actividades inicien como un arreglo vacío con lo que se ejecuta ese useEffect con el arreglo vacío y lo setea en el state.</p>
                <pre data-line="2"><code class="language-js">
                  //activity-reducers.ts --&gt; nuestro state de actividades se inicia como arreglo vacío.
                  export const initialState: ActivityState = {
                    activities: [],
                    activeId: ''
                  }
                </code></pre>
                <img src="./src/assets/img/159-2.png" alt="img" loading="lazy">
              </div>
            </div>

            <p class="my-3">Por tanto <span class="destacado">en vez de tener ese valor inicial de arreglo vacío <strong>[]</strong> hemos de tener algo que revise si tenemos algo en localStorage:</span></p>
            
            <ul class="my-3">
              <li>Creamos variable nueva arrow function 'localStorageActivities' (como esto va a residir en localStorage no en nuestro código, TS no puede inferir, así que le especificamos que esta variable arrow function sea de tipo Activity[])</li>
              <li>esta función contiene a su vez una variable 'activities' en la que recuperamos lo que haya en el item 'activities' de localStorage</li>
              <li>return de esa variable; con un ternario especificamos que si tiene algo haga un JSON.parse() de ello y si no sea un arreglo vacío []</li>
              <li>Llamamos a nuestra 'localStorageActivities()' como inicialización de nuestro state</li>
            </ul>
            <pre data-line="1-4,6"><code class="language-js">
              //activity-reducers.ts --&gt; iniciamos nuestro state con esta comprobación de si hay algo en localStorage
              const localStorageActivities = () : Activity[] =>{
                const activities = localStorage.getItem('activities')
                return activities ? JSON.parse(activities) : []
              }
              export const initialState: ActivityState = {
                  activities: localStorageActivities(),
                  activeId: ''
              }
            </code></pre>
            
          
          </div>
                    
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-160').toggle();">
            <h3>160. Creando la acción para reiniciar la app</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-160" class="hidden">
            <p>Vamos a agregar un botón en la parte superior para limpiar todas las actividades, para reiniciar la app:</p>
            <ul class="my-3">
              <li>Vamos a activity-reducer.ts y creamos una actividad nueva que llamamos 'restart-app y como va a ser un botón que uso para reiniciar (vamos a limpiar y reiniciar a sus valores iniciales tanto activities como activeId) no va a tomar ningún payload.
                <pre data-line="5"><code class="language-js">
                  //activity-reducers.ts
                  export type ActivityActions = 
                    { type: 'save-activity', payload: { newActivity: Activity } } |
                    { type: 'set-activeId', payload: { id: Activity['id'] } } |
                    { type: 'delete-activity', payload: { id: Activity['id'] } } |
                    { type: 'restart-app' } 
                </code></pre>
              </li>
              <li>después del action (el if) de 'delete-activity' vamos a definir con su propio if este nuevo action para resetear la app:
                <pre><code class="language-js">
                  //activity-reducers.ts
                  if(action.type === 'restart-app'){
                    return{
                        activities: [],
                        activeId: ''
                    }
                }
                </code></pre>
              </li>
              <li>Vamos a nuestro App.tsx: <strong>creamos el botón y definimos una función para controlar que el botón esté deshabilitado si no hay actividades</strong>. Al botón le añadimos un onClick con el correspondiente dispatch (ojo que hay que poner el callback antes del dispatch, si no nos marca advertencia en el onClick) No toma payload, simplemente espera que ocurra ese evento:
                <pre><code class="language-js">
                  //App.tsx
                  const canRestartApp = () => useMemo(() => state.activities.length > 0, [state.activities])

                  return (
                    ...
                    &lt;button 
                      className=&quot;bg-gray-800 hover:bg-gray-900 p-2 font-bold uppercase text-white cursor-pointer rounded-lg text-sm disabled:opacity-10&quot;
                      disabled={!canRestartApp()}
                      onClick={dispatch({type.})}
                      &gt;Reiniciar App&lt;/button&gt;
                </code></pre>
              </li>
            </ul>

            <p>Es muy similar a un botón de cerrar sesión en el cual limpias todo el state de la aplicación del usuario.</p>
          </div>
                    
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-161').toggle();">
            <h3>161. Creando un Componente para mostrar el total de Calorias / 162. Mostrando las calorias consumidas / 163. Mostrando las calorias quemadas</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-161" class="hidden">
            <p>El siguiente paso de nuestro proyecto es crear una serie de estadísticas, vamos a ir sumando las calorías consumidas, las calorías quemadas haciendo ejercicio y un diferencial (si hemos consumido más de las uqe hemos quemado va a ser la tercera opción. Ya no vamos a hacer nada en el reducer, hemos definido todas nuestras acciones, simplemente vamos a hacr una serie de estadísticas).</p>
            
            <p>En nuestro compo ppal App.tsx creamos un nuevo section tras el form donde vamos a incluir el tag de nuestro nuevo componente <strong>CalorieTracker</strong> que es el que va a mostrar las calorías consumidas, las quemadas por los ejercicios y el balance. Este nuevo componente solo requiere el state de actividades así que se lo pasamos como prop <span class="destacado">TRUQUI: siempre que paso prop, cuando tipo la nueva prop en el compo nuevo para extraerla, se me suele olvidar si es de arreglo añadirle el [] así que FIJARSE EN EL ERROR/ADVERTENCIA DE VSC CUANDO AÑADO LA PROPO AL TAG DEL NUEVO COMPO EN App.tsx PARA INFERIR ESE TYPE CORRECTAMENTE EN EL COMPO SIN QUE SE ME OLVIDE</span>:</p>
              

              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //App.tsx
                    import CalorieTracker from "./components/CalorieTracker"
                    ...
                    &lt;section className=&quot;bg-gray-800 py-10&quot;&gt;
                      &lt;div className=&quot;max-w-4xl mx-auto&quot;&gt;
                        &lt;CalorieTracker 
                          activities={state.activities}
                        /&gt;
                      &lt;/div&gt;
                    &lt;/section&gt;
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //ActivityTracker.tsx
                    import type { Activity } from "../types"

                    type CalorieTrackerProps = {
                        activities: Activity[]
                    }
                    export default function CalorieTracker({activities}: CalorieTrackerProps) {
                      return (
                        &lt;&gt;
                            &lt;h2 className=&quot;text-4xl font-black text-white text-center&quot;&gt;Resumen de calorías&lt;/h2&gt;
                        &lt;/&gt;
                      )
                    }
                  </code></pre>
                </div>
              </div>

              <p class="naranja">Mostrando las calorias consumidas y las calorias quemadas</p>
              <p>Comencemos a calcular las calorías, una forma muy sencilla de hacerlo es con reduce()</p>
              <p>En nuestro nuevo componente CalorieTracker.tsx, antes del return bajo el comentario <code class="language-js">//contadores</code> creamos las  variables para calcular las calorías consumidas 'caloriesConsumed' y las  calorías quemadas 'caloriesBurned' y voy a usar useMemo() pasándole como dependencia activities, para que cada vez que haya cambio en actividades el código especificado en cada una de esas variables se vuelva a ejecutar <code class="language-js">const caloriesConsumed = useMemo(() => , [activities])</code> <code class="language-js">const caloriesBurned = useMemo(() => , [activities])</code>. ¿Como lo vamos a calcular? tenemos el state de activities, y tenemos un arreglo y almacenamos la categoría; la categoría de calorías consumidas es la nº 1 y la de quemadas es la nº2 si recordamos nuestros datos en categories.ts:</p>
              <pre data-line="1"><code class="language-js">
                //categories.ts
                export const categories: Category[] = [
                    { id: 1, name: 'Comida'},
                    { id: 2, name: 'Ejercicio'}
                ]
              </code></pre>

              <p>así que calorías consumidas = actividades con categoría 1 y calorías quemadas =  actividades con categoría 2. Con el reduce en un solo paso revisamos la actividad actual en cada caso:</p>
              <ul>
                <li> ¿tiene el id nº1? ¿si? entonces ese sí lo sumo, en caso contrario paso el total como está al siguiente objeto para que lo sume y compruebe lo mismo, si pertenece a comida entonces lo suma y si no, pase al siguiente elemento...</li>
                <li>¿tiene el id nº2? ¿si? entonces ese sí lo sumo, en caso contrario paso el total como está al siguiente objeto para que lo sume y compruebe lo mismo, si pertenece a comida entonces lo suma y si no, pase al siguiente elemento...</li>
              </ul></p>
              <pre><code class="language-js">
                //Contadores
                const caloriesConsumed = useMemo(() => activities.reduce((total, activity)=> activity.category === 1 ? total + activity.calories : total, 0), [activities])
                const caloriesBurned = useMemo(() => activities.reduce((total, activity)=> activity.category === 2 ? total + activity.calories : total, 0), [activities])
                ...
                &lt;div className=&quot;flex flex-col-item-center md:flex-row md:justify-between gap-5 mt-10&quot;&gt;
                  &lt;p className=&quot;text-white font-bold rounded-full grid grid-cols-1 gap-3 text-center&quot;&gt;
                      &lt;span className=&quot;font-black text-6xl text-orange&quot;&gt;{caloriesConsumed}&lt;/span&gt; Consumidas
                  &lt;/p&gt;
                  &lt;p className=&quot;text-white font-bold rounded-full grid grid-cols-1 gap-3 text-center&quot;&gt;
                      &lt;span className=&quot;font-black text-6xl text-orange&quot;&gt;{caloriesBurned}&lt;/span&gt; Quemadas
                  &lt;/p&gt;
                &lt;/div&gt;
              </code></pre>
              
              <img class="max-sm:mx-auto" src="./src/assets/img/162.png" alt="img" loading="lazy">

              <p>Como vemos tenemos 2 textos y 2 cantidades, si nos pidieran cambiar cualquiera de esos texto habríamos de cambiarlo en dos lugares... Ya que tenemos contenedores con los mismos estilos veamos como construir un componente reutilizable para consumidas, quemadas y también el balance...</p>
              
          </div>

      
                    
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-164').toggle();">
            <h3>164. Creando un Componente para las cantidades</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-164" class="hidden">
            <p>Creamos el componente CalorieDisplay.tsx. Como vamos a pasarle desde CalorieTracker.tsx como props estas 4 cosas que son lo que varían con respecto a esa estructura común:</p>
            <img src="./src/assets/img/164.png" alt="img" loading="lazy">
            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <p>usamos el tag del nuevo compo y le pasamos en cada llamada como prop lo adecuado:</p>
                <pre><code class="language-js">
                  //CalorieTracker.tsx
                  ...
                  &lt;CalorieDisplay 
                    calories={caloriesConsumed}
                    text={&#39;Consumidas&#39;}
                  /&gt;
                  &lt;CalorieDisplay 
                    calories={caloriesBurned}
                    text={&#39;Quemadas&#39;}
                  /&gt;
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <p>definimos un type para esas props en el nuevo componente ylas extraemos con destructuring como siempre para usarlas en la maquetación del compo:</p>
                <pre><code class="language-js">
                  //CalorieDisplay.tsx
                  type CalorieDisplayProps = {
                    calories: number,
                    text: string
                  }
                  
                  export default function CalorieDisplay({calories, text}: CalorieDisplayProps) {
                    return (        
                      &lt;p className=&quot;text-white font-bold rounded-full grid grid-cols-1 gap-3 text-center&quot;&gt;
                          &lt;span className=&quot;font-black text-6xl text-orange&quot;&gt;{calories}&lt;/span&gt; {text}
                      &lt;/p&gt;
                    )
                  }
                </code></pre>
              </div>
            </div>
          </div>
                    
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-165').toggle();">
            <h3>165. Mostrando el diferencial de Calorias</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-165" class="hidden">
            <p>Vamos a ver las calorías totales para tener un balance de calorías. Básicamente van a ser las consumidas menos las calorías quemadas</p>
            <pre><code class="language-js">
              //CalorieTracker.tsx
              const netCalories = useMemo(() => caloriesConsumed-caloriesBurned, [activities])
              ...
              &lt;CalorieDisplay 
                calories={netCalories}
                text={&#39;Diferencia&#39;}
               /&gt;
            </code></pre>

            <p>Así ya tenemos este proyecto listo usando useReducer() que es una excelente forma de utilizar estados más complejos o hacer operaciones en diferentes estados al mismo tiempo. Vimos la estructura de un reducer, para qué utilizamos las acciones, para qué el dispatch y cómo vamos manejando la lógica en nuestro state. Vamos a seguir dandole a useReducer, a continuación migraremos a useReducer el proyecto de guitarras.</p>
          </div>
                    
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-166').toggle();">
            <h3>166. Build y Deployment de la App</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-166" class="hidden">
            <p>Hacemos el run npm build y nos llevamos a mano a netlify la carpeta dist para nuevo site. En este punto, manual de deply automático en netlify de <strong>mi Diario.</strong></p>
          </div>

          


                   
        
        


        </div>
        <!-- Fin div colapsable-->  
     
      </div>
      <!-- FIN SECCION 10 -->

      
      <!-- SECCION 9-->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
      
        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer"
          onclick="$('#seccion9').toggle();">
          <h2>Sección 9: PROYECTO - Calculadora de propinas con TypeScript</h2>
          <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
        </div>
      
        <div id="seccion9" class="hidden">
          <a class="underline text-rose-600 font-bold" href="https://and....55.github.io/calculadora_propinas/" target="blank">https://and....55.github.io/calculadora_propinas/</a>
         
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-104105').toggle();">
            <h3>104. El Proyecto que vamos a construir / 105. Creando el proyecto</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-104105" class="hidden">
      
            <div class="block md:flex">
              <img class="w-50 w-100-m mr-1.25" src="./src/assets/img/s1-02.jpg" alt="Calculadora de proyectos">
              <div class="w-50 w-100-m">
                <p>Esta calculadora de propinas y consumos es un proyecto 100% TS, con nuestra carpeta de Data, algunos
                  Helpers, Hook personalizado, archivo de Types. Todos los proyectos de ahora en adelante.</p>
                <p>Vemos un botón de Guardar orden, para que el restaruante tenga un control de las ventas diarias (como aún
                  no hemos visto APIS simularemos que lo almacena en algún sitio.</p>
                <p>Este proyecto va a ser 100% TypeScript desde el inicio (no vamos a escribir js y después convertirlo sino
                  directamente ts), estaremos practicando mucho sobre el state, custom hook y demás.</p>
              </div>
            </div>
      
            <p class="mt-1.25 mb-0"><span class="naranja">Creamos proyecto nuevo:</span></p>
            <ul class="mb-3.75">
              <li>Tengo todos mis proyectos de React dentro de <strong>Curso React</strong> así que me ubico ahí y para
                crearlo</li>
              <li><span class="destacado">npm create vite@latest</span> crea el proyecto con la última versión de vite</li>
              <li>Lo nombro <strong>calculadora_propinas</strong></li>
              <li>Elijo framework <span class="destacado">React</span></li>
              <li>Elijo variante <span class="destacado">TypeScript + SWC</span> (puede que a futuro ya no salga "SWC" porque
                es el compilador que van a usar)</li>
              <li>Nos ubicamos en el nuevo directorio creado <strong>calculadora_propinas</strong> e instalamos las
                dependencias del proyecto con <span class="destacado">npm install</span></li>
              <li>Abrimos nuestro proyecto en Visual Studio Code (con botón derecho agrego la nueva carpeta en el área de
                trabajo)</li>
              <li>Arrancamos el servidor de desarrollo con <span class="destacado">npm run dev</span> --&gt; <a
                  href="http://localhost:5174/" target="blank">http://localhost:5174/</a> (<a href="http://localhost:5173/"
                  target="blank">http://localhost:5173/</a> la suelo usar para el manual)</li>
            </ul>
            <img class="my-2.5" src="./src/assets/img/105.png" alt="" />
      
            <p><span class="destacado">Hagamos limpieza de algunos archivos</span>:</p>
            <ul class="mb-3.75">
              <li>Eliminamos el .svg: public&gt;<strong>vite.svg</strong></li>
              <li>Eliminamos la carpeta entera assets: src&gt;<strong>assets</strong></li>
              <li>Eliminamos la css: src&gt;<strong>App.css</strong></li>
              <li>Limpiamos src&gt;<strong>App.tsx</strong> dejandolo así:
                <script type="text/plain" class="language-js">
                          function App() {
      
                            return (
                              <>
                                <h1>Hola mundo</h1>
                              </>
                            )
                          }
                          
                          export default App
                        </script>
              </li>
              <li>Eliminamos todo el contenido de la css src&gt;<strong>index.css</strong></li>
              <li>Dejamos como está el src&gt;<strong>main.tsx</strong>. Importante la llamada que aquí se hace a nuestra css
                <strong>index.css</strong> porque <span class="destacado">vamos a instalar el framework TailwindCSS</span>
                <pre data-line="2"><code class="language-js">
                          import &lcub; StrictMode &rcub; from &apos;react&apos;
                          import &lcub; createRoot &rcub; from &apos;react-dom/client&apos;
                          import &apos;./index.css&apos;
                          import App from &apos;./App.tsx&apos;
                          
                          createRoot(document.getElementById(&apos;root&apos;)!).render(
                            &lt;StrictMode&gt;
                              &lt;App /&gt;
                            &lt;/StrictMode&gt;&comma;
                          )
                        </code></pre>
              </li>
            </ul>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-106107').toggle();">
            <h3>106. Introducción a TailwindCSS / 107. Instalando TailwindCSS y extensión para VSCode</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-106107" class="hidden">
            <p>Es un framework de CSS pero está basado en utilidades</p>
            <ul class="mb-3.75">
              <li><strong>Tailwind CSS es lo que se conoce como un framework de CSS, pero está basado en utilidades</strong>
              </li>
              <li><strong>A diferencia de Bootstrap, que es otro framework de CSS donde una clase contiene diferentes
                  propiedades de CSS</strong> (Por ejemplo, para crear un botón utilizas una clase llamada btn y si quieres
                cambiar el color utilizas btn danger; Esos van a tener muchas propiedades de CSS, solo da la apariencia de
                botón.) <strong>En el caso de Tailwind, cada clase es una propiedad de CSS que tiene un nombre
                  similar</strong>. <span class="destacado">Bootstrap descargas una css de 10000 líneas y usas las css vs
                  Tailwind modo JIT (Just In Time) solo las clases que utilices en tus js, tsx, ts, js se van a utilizar para
                  generar la css final, lo cual nos va a dar una css lo más ligera posible.</span></li>
              <li>Su ventaja principal es que escribes el código CSS en tus componentes sin hojas externas. ¿Que se deja de
                utilizar el componente? se elimina tambi´ne su código de css (a diferencia de lo que pasa en las hojas de
                estilos generales con miles de líneas y mal mantenidas).</li>
              <li>Otra ventaja es que tampoco es necesario por la herencia en CSS (especificidades, !important infinitos,
                pisado de código de otras partes del proyecto)</li>
              <li>Nos olvidamos del problema de cómo nombrar nuestras clases.</li>
              <li>La documentación es excelente: hay bastantes ejemplos muy gráficos muy visuales que van a permitirte saber
                qué clase es la que puedes utilizar.</li>
              <li>La extensión de Visual Studio Code también es excelente. El autocompletado es muy bueno y también te dice
                qué valor o cuánto se está aplicando en ciertas propiedades de CSS enfocadas a tamaño, por ejemplo el font
                size, etcétera.</li>
            </ul>
      
            <p class="mt-1.25 mb-0"><span class="naranja">Instalando TailwindCSS y extensión para VSCode: </span>
              Vamos al link de <strong><a href="https://tailwindcss.com/" target="blank"
                  class="text-[#000000]">https://tailwindcss.com/</a> > docs > installation > Framework guides:</strong>
              contiene guías específicas de framework para instalar TailwindCSS en un gran número distinto de entornos Vite /
              Next.js / Angular / Ruby on Rails / Parcel / Symfony / Astro / ... nosotros elegimos Vite. A partir de aquí los
              pasos varían con respecto a lo que indica en el vídeo porque la versión es más nueva, ver <a
                class="text-[#000000]" href="https://tailwindcss.com/docs/installation/using-vite"
                target="_blank">https://tailwindcss.com/docs/installation/using-vite</a>:
            </p>
      
            <ul class="mb-3.75">
              <li>Creación del proyecto y ubicarse en la carpeta ya lo hicimos</li>
              <li>Instalamos Tailwind CSS: instalamos las dependencias 'tailwindcss' y '@tailwindcss/vite' via npm:
                <pre><code class="language-js">
                          npm install tailwindcss @tailwindcss/vite
                        </code></pre>
              </li>
              <li><strong>Configurar el plugin de vite:</strong> añadimos el plugin '@tailwindcss/vite' a nuestra
                configuración de vite en <span class="file">vite.config.ts</span>
                <pre data-line="1,8"><code class="language-js">
                      import { defineConfig } from 'vite'
                      import tailwindcss from '@tailwindcss/vite'
                      import react from '@vitejs/plugin-react-swc'
                      
                      // https://vite.dev/config/
                      export default defineConfig({
                        plugins: [
                          react(),
                          tailwindcss()
                        ],
                      })
                    </code></pre>
              </li>
              <li><strong>Importar Tailwind CSS en nuestra css:</strong> <span class="file">src&gt;index.css</span> <code
                  class="language-css">@import "tailwindcss";</code></li>
              <li><strong>Comenzar a utilizar las utility classes de Tailwind CSS para dar estilo a nuestro contenido</strong>
                <script type="text/plain" class="language-html">
                      <h1 className="text-3xl font-bold underline">
                        Hello world!
                      </h1>
                    </script>
              </li>
            </ul>
      
            <p><span class="destacado">Instalamos la extensión Tailwind CSS IntelliSense en el Visual Studio Code</span>.</p>
            <p><strong>Le veo de momento un par de inconvenientes: no cubren todas las casuísticas de tamaños (por cuenta
                ajena si el diseño viene marcado desde agencia o Dpto con tamaños no contemplados en este FW estamos haciendo
                un pan con unas tortas. Además ¡OJO! hay nombres de clases que PARA NADA son descriptivos de lo que hacen como
                por ejemplo font-black que lo que hace es actuar sobre un font-weight!!!)</strong></p>
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-112').toggle();">
            <h3>108. Creando el Header / 109. Agregando los Productos / 110. Agregando los contenedores principales / 111.
              Extensiones par React / 112. Listano los productos del menú</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-112" class="hidden">
            <p class="mt-1.25 mb-0"><span class="naranja">Creamos el Header</span></p>
            <p>En el return de nuestro <span class="file">App.tsx</span> agregamos el header pero simplemente como tag html5
              semántico y practicamos algo de Tailwind CSS.</p>
            <script type="text/plain" class="language-html">
                    <header className="bg-teal-400 py-5">
                      <h1 className="text-center text-4l font-black">Calculadora de propinas y consumo</h1>
                    </header>
                  </script>
      
            <p class="mt-1.25 mb-0"><span class="naranja">Agregando los productos</span> - <a class="text-[#000000]"
                href="https://gist.github.com/codigoconjuan/7ff5b34a0a0773f8c48fd13b51a508aa" target="blank">Gist de
                Productos</a></p>
            <p>Aún no hemos visto como consumir una API, consultar una BBDD, todo eso lo veremos más adelante. Así que de
              momento vamos a trabajar como el proyecto anterior, <strong>con un archivo plano que tiene un arreglo de
                productos</strong>. Vamos a consumirlo y mostrarlo.</p>
      
            <p>Vamos a crear 2 archivos .ts (no .tsx que tienen código html y/o eventos de React:</p>
            <ul class="mb-3.75">
              <li>Creamos <strong>src&gt;db&gt;<span class="file">db.ts</span></strong>: metemos en su interior lo que
                copiamos en formato raw del <a class="text-[#000000]"
                  href="https://gist.github.com/codigoconjuan/7ff5b34a0a0773f8c48fd13b51a508aa" target="blank">Gist de
                  Productos</a>. Con el IS vemos que TS infiere cual es el tipo de dato de cada propiedad así que tenemos un
                array de objetos y eso está bien, pero <strong>está aún mejor crear un type personalizado "MenuItem" y
                  asignárselo para tener un mejor autocompletado y para que, en caso de que alguna de mis propiedades no
                  cumpla con lo tipado, nos lo marque como error</strong>.
                <pre data-line="0,2"><code class="language-js">
                      import type { MenuItem } from "../types" 
      
                      export const menuItems : MenuItem[] = [
                          {
                            "id": 1,
                            "name": "Pizza a la Leña Chica",
                            "price": 30
                          },                     
                    </code></pre>
              </li>
              <li>Creamos <strong>src&gt;types&gt;<span class="file">index.ts</span> en donde creamos este primer type
                  MenuItem</strong>
                <pre><code class="language-js">
                  //src>types>index.ts
                      export type MenuItem = {
                        id: number,
                        name: string,
                        price: number
                    }
                    </code></pre>
              </li>
              <li>En nuestra <span class="file">App.tsx</span> vamos a importar los datos y si hacemos un console.log ya vemos
                que tenemos disponibles esos datos.
                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre><code class="language-js">
                      //App.tsx
                        import { menuItems } from "./data/db"
      
                        function App() {
      
                        console.log(menuItems)
      
                        return (
                        </code></pre>
                  </div>
                  <div class="w-[50%] max-sm:w-[100%]">
                    <img class="my-2.5" src="./src/assets/img/109.png" alt="" />
                  </div>
                </div>
              </li>
            </ul>
      
            <p class="mt-1.25 mb-0"><span class="naranja">Agregando los contenedores principales:</span> acabamos de crear
              nuestro primer type (MenuItem) y se lo hemos agregado a nuestros datos. Vamos a ver como mostrar la información
              en pantalla, como renderizar lo que ahora mismo vemos en consola <code
                class="language-js">console.log(menuItems)</code>para que se vea en nuestra interfaz.</p>
      
            <p>En el return de nuestro <span class="file">App.tsx</span> agregamos el main pero simplemente como tag html5
              semántico y seguimos practicando algo de Tailwind CSS <span class="destacado">revisar/empollar uso de Tailwind:
                <a class="text-[#ffffff]" href="https://certidevs.com/tutorial-tailwindcss-introduccion"
                  target="_blank">Tutorial certidevs</a></span> por ejemplo Mediaquerys en Tailwind: las clases como
              <strong>sm:, md:, lg:, xl:, y 2xl:</strong> permiten aplicar estilos específicos basados en el tamaño de la
              pantalla. ¿Como funciona? queremos 2 columnas a partir del tamaño md: ponemos <strong>md:grid-cols-2</strong>
            </p>
            <pre><code class="language-html">
                      &lt;main className=&quot;max-w-7xl mx-auto py-20 grid grid-cols-2&quot;&gt;
                        &lt;div&gt;
                          &lt;h2&gt;Menú&lt;/h2&gt;
                        
                        &lt;/div&gt;
                
                        &lt;div&gt;
                          &lt;h2&gt;Consumo&lt;/h2&gt;
                        
                        &lt;/div&gt;
                      &lt;/main&gt;
                    </code></pre>
      
            <p>Ya con nuestro div para el menú vamos a renderizar lo que ahora vemos en la consola <code
                class="language-js">console.log(menuItems)</code> que es como una pequeña base de datos</p>
      
            <ul class="mb-3.75">
              <li>Creamos <strong>components&gt;MenuItem.tsx</strong></li>
              <li>Antes de empezar a picar recomienda instalar estas dos <span class="naranja">extensiones para React en
                  VSCode: </span> <strong>ES7+ React/Redux/React-Native snippets</strong> y <strong>Simple React
                  Snippets</strong>. Con esto por ejemplo si escribimos en <span class="file">MenuItem.jsx</span>
                <strong>rfc</strong> vemos que nos autocompleta la estructura básica de nuestro componente, tanto con el
                export default como con el return: (con <strong>rafc</strong> la crearía como arrow function). El import react
                no es necesario así que lo eliminamos
                <pre class="rojo" data-line="0"><code class="language-js">
                      import React from 'react'
      
                      export default function MenuItem() {
                        return (
                          <div>MenuItem</div>
                        )
                      }
                    </code></pre>
              </li>
              <li> En nuestro <span class="file">App.tsx</span> renderizamos nuestro nuevo componente MenuItems una vez por
                cada elemento que tengamos en nuestro array que simula la base de datos:
                <pre><code class="language-js">
                      {menuItems.map(item =&gt; (
      
                        &lt;MenuItem 
                          key = {item.id} //siempre que iteramos, recordar añadir key único
                        /&gt;            
                      ))}
                    </code></pre>
                <p>En este punto si miramos la renderización nos aparece "menuItem" 12 veces (porque es lo que ahora mismo nos
                  renderiza el return del componente: &lt;div&gt;MenuItem&lt;/div&gt;</p>
              </li>
            </ul>
      
            <p class="mt-1.25 mb-0"><span class="naranja">Listando los productos del menú:</span> Veamos como pasarle los
              props y escribir el type para este componente, hacerlo dinámico para que imprima la información de nuestra
              pequeña BBDD.</p>
            <p>En el tag de llamada al componente del return de nuestro <span class="file">App.tsx</span> creamos un prop
              llamado item y le pasamos el objeto de item <code class="language-js">item={item}</code>. Nos da error porque el
              componente de momento no espera ninguna propiedad. Si, en nuestro <span class="file">MenuItem.tsx</span>
              aplicamos destructuring para que reciba ese item: <code
                class="language-ts">export default function MenuItem({item}) {</code> vamos a ver que es de tipo Any
              implícito, (mientras que ese item que pasamos como prop en App.tsx sí es de tipo item)<strong>, <span
                  class="destacado">osea se pierde la referencia entre nuestros componentes App.tsx y MenuItem.tsx</strong> y
              nosotros tenemos que especificarle qué tipo de dato va a ser</span>. Para ello vamos a crear en el <span
                class="file">MenuItem.tsx</span> un type nuevo <strong>MenuItemProps</strong>(que solo va a usarse en este
              compo por lo que no tenemos que crearlo en archivo común de types):</p>
      
            <pre><code class="language-js">
                    import type { MenuItem } from &quot;../types&quot;
      
                    export type MenuItemProps = {
                        item: MenuItem
                    }
                    
                    export default function MenuItem({item}: MenuItemProps) {
                      return (
                        &lt;&gt;
                            &lt;p&gt;{item.name}&lt;/p&gt;
                            &lt;p className=&quot;font-black&quot;&gt;{item.price}&lt;/p&gt;
                        &lt;/&gt;
                      )
                    }
                  </code></pre>
      
            <p>La idea es que al ir presionando en cada elemento se vaya colocando a la derecha. Para ello tenemos que
              agregarles un evento y por buenas prácticas no debemos hacerlo en el p así que convertimos el fragment
              &lt;&gt;&lt;/&gt; en un botón &lt;button&gt;&lt;/button&gt; que es donde vamos a tener un evento que veremos
              como registrarlo. Seguimos practicando algo de Tailwind CSS dándole estilos a nuestros contenedores <span
                class="destacado">revisar/empollar uso de Tailwind</span> Quedan de la siguiente manera: </p>
      
            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">                
                <pre><code class="language-js">
                  //App.tsx
                  import MenuItem from &quot;./components/MenuItem&quot;
                  import { menuItems } from &quot;./data/db&quot;
                  
                  function App() {
                  
                    return (
                      &lt;&gt;
                        
                        &lt;header className=&quot;bg-teal-400 py-5&quot;&gt;
                          &lt;h1 className=&quot;text-center text-4l font-black&quot;&gt;Calculadora de propinas y consumo&lt;/h1&gt;
                        &lt;/header&gt;
                  
                        &lt;main className=&quot;max-w-7xl mx-auto py-20 grid grid-cols-2&quot;&gt;
                          &lt;div className=&quot;p-5&quot;&gt;
                            &lt;h2 className=&quot;text-4xl font-black&quot;&gt;Menú&lt;/h2&gt;
                  
                            &lt;div className=&quot;space-y-2 mt-10&quot;&gt;
                              {menuItems.map(item =&gt; (
                                &lt;MenuItem
                                  key = {item.id} //siempre que iteramos, recordar añadir key único
                                  item = {item}
                                /&gt;
                              ))}
                            &lt;/div&gt;
                          
                          &lt;/div&gt;
                  
                          &lt;div&gt;
                            &lt;h2&gt;Consumo&lt;/h2&gt;
                          
                          &lt;/div&gt;
                        &lt;/main&gt;
                        
                      &lt;/&gt;
                    )
                  }
                  
                  export default App
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  //MenuItem.tsx
                  import type { MenuItem } from &quot;../types&quot;

                  export type MenuItemProps = {
                      item: MenuItem
                  }
                  
                  export default function MenuItem({item}: MenuItemProps) {
                    return (
                      &lt;button className=&quot;border-2 border-teal-400 hover:bg-teal-200 w-full p-3 flex justify-between&quot;&gt;
                          &lt;p&gt;{item.name}&lt;/p&gt;
                          &lt;p className=&quot;font-black&quot;&gt;{item.price}&lt;/p&gt;
                      &lt;/button&gt;
                    )
                  }                       
                </code></pre>
              </div>      
            </div>
      
            <p>A continuación vamos a crear un custom Hook para ir almacenando nuestra orden.</p>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-113').toggle();">
            <h3>113. Creando un Hook para la orden <span class="destacado">Generics en TS</span></h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-113" class="hidden">
            <p>Creamos nuestro <span class="file">useOrder.ts</span> <strong>hooks&gt;useOrder.ts</strong>
            <pre><code class="language-js">
                    export default function useOrder() {
      
                      return{
                          
                      }
                    }     
                  </code></pre>
            </p>
            <p>Definimos un state en el que vamos colocando los elementos que forman parte de nuestra orden. Iniciamos como un
              arreglo vacío. Si vemos, así lo hicimos en el anterior proyecto de las guitarras pero con el IS vemos que nos da
              que order es de tipo Never por lo que lo ideal es aplicarle un tipo de dato en específico.</p>
            <pre><code class="language-js">
                    import { useState } from "react"
      
                    export default function useOrder() {
                      const [order, setOrder] = useState([])
      
                      return{
                        
                      }
                    }
                  </code></pre>
            <p>En nuestro fichero de types vamos a crear un tipe nuevo <span class="type">OrderItem</span> para la orden y va
              a requerir lo mismo que el tipo <span class="type">MenuItem</span> pero además tiene que tener cantidad por lo
              que lo declaramos así <span class="file">types&gt;index.ts</span>:</p>
            <pre data-line="5-7"><code class="language-js">
                    export type MenuItem = {
                      id: number,
                      name: string,
                      price: number
                    }
                    export type OrderItem = MenuItem & {
                      quantity: number
                    }
                  </code></pre>
      
            <p>Lo importamos en nuestro hook <span class="file">useOrder.ts</span> <code
                class="language-ts">import { OrderItem } from "../types"</code>. ¿Cómo hacemos para asignar a ese state
              'order' nuestro type OrderITem y que tenga esos atributos definidos incluyendo quantity? <span
                class="destacado">Generics en TypeScript: es una característica que nos va a permitir escribir código más
                flexible y reutilizable</span>. Veamos estos 3 states para ver que, en los casos en que nuestros tipos son un
              poco más complejos (y no solo tenemos un valor inicial de state sencillo como puede ser un
              number/string/boolean..) viene bien especificarle con el generic nuestro type. Así todo lo que agreguemos a ese
              state order, React va a revisar que tenga la estructura del tipo definido. En el caso de los que tienen un valor
              inicial más sencillo que TS puede inferir bien, no es necesario el generic:</p>
            <pre><code class="language-js">
                    const [order, setOrder] = useState&lt;OrderItem[]&gt;([]) //Nuestro tipo (OrderItem) es más complejo y queremos especificarle que sea ese, sí requiere generic
                    const [total, setTotal] = useState&lt;number&gt;(0) //No sería necesario el generic es redundante porque con el valor inicial se infiere bien
                    const [auth, setAuth] = useState&lt;boolean&gt;(false) //No sería necesario el generic es redundante porque con el valor inicial se infiere bien
                  </code></pre>
      
            <p>Los generics por tanto son muy útiles cuando tenemos estructuras propias o más complejas porque TS no sabe qué
              queremos hacer y de esta manera le decimos "sí, esto va a ser un arreglo/objeto pero tiene que tener estas
              propiedades</p>
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-114').toggle();">
            <h3>114. Creando la función para Añadir articulos a la orden</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-114" class="hidden">
            <p>Creamos en nuestro hook un arrow function nueva para agregar items y la exportamos en el return. </p>
            <pre><code class="language-js">
                    export default function useOrder() {
                      const [order, setOrder] = useState<OrderItem[]>([])
                  
                      const addItem = () => {
                          console.log('Añadiendo item')
                      }
                  
                          return{
                              addItem
                          }
                  }
                  </code></pre>
      
            <p>La importamos en nuestra <span class="file">App.tsx</span>, vamos a ver como tener un estado global. Vemos a
              continuación como usando destructuring extraigo de nuestro custom hook useOrder la nueva función addItem, que a
              su vez hemos de pasar como prop a nuestro componente MenuItem.jsx (porque cada vez que presione uno de esos
              menús es una función con valores diferentes).</p>
            <pre><code class="language-js">
                    import useOrder from "./hooks/useOrder"
      
                    function App() {
                    
                        const { addItem } = useOrder() 
                  </code></pre>
            <p>Si nos colocamos en el destructuring encima de ese addItem vemos con el IS que es un arrow function () => void.
              Usamos esa información para <strong>completar el type exclusivo que definimos en nuestro componente <span
                  class="file">MenuItem.tsx</span></strong> y añadimos el segundo parámetro en la declaración de nuestra
              función de componente y el onClick con la llamada a la función, como callback porque tengo que pasarle qué es lo
              que quiero agregar.</p>
            <pre data-line="2,5,9"><code class="language-js">
                    type MenuItemProps = {
                      item: MenuItem,
                      addItem: () => void // muy común cuando pasamos una fcn vía props. VOid significa que no retorna nada. A veces sí tomará parámetro y a veces retornaraá un valor
                  }
                  
                  export default function MenuItem({item, addItem}: MenuItemProps) {
                    return (
                      &lt;button 
                        className=&quot;border-2 border-teal-400 hover:bg-teal-200 w-full p-3 flex justify-between&quot;
                        onClick = {() =&gt; addItem()}
                        &gt;
                  </code></pre>
      
            <p>En <span class="file">App.tsx</span> tenemos que pasarle esa función a nuestro componente vía props</p>
            <pre data-line="5"><code class="language-js">
                    &lt;div className=&quot;space-y-2 mt-10&quot;&gt;
                      {menuItems.map(item =&gt; (
                        &lt;MenuItem
                          key = {item.id} //siempre que iteramos, recordar añadir key único
                          item = {item}
                          addItem = {addItem}
                        /&gt;
                      ))}
                    &lt;/div&gt;
                  </code></pre>
      
            <p>Una vez que presionemos en ese botón queremos añadir ese elemento con el nombre, con el id y con el precio.</p>
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-115').toggle();">
            <h3>115. Agregando el signature a la función de agregar articulo con TypeScript</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-115" class="hidden">
            <p>Vamos a ver como escribir en el state de useOrder, ahora mismo solo estamos sacando un mensaje en consola al
              pulsar. Tenemos que pasarle un argumento desde la llamada del onClick en el componente hasta nuestro custom
              hook. Para ello en nuestro hook tenemos que decirle que la función addItem va a tomar un elemento, le ponemos
              como parámetro 'item' y vemos que se nos pone en color rojo, si vamos a la App.tsx vemos que también en rojo nos
              indica el IS "bueno tú le estás pasando un item que actualmente tiene el tipo de dato Any y tu firma, lo que tú
              has colocado, es una función que no toma nada y que no retorna nada (la firma nos dice que tiene muy pocos
              argumentos)": </p>
      
            <img class="my-2.5" src="./src/assets/img/115.png" alt="">
      
            <p>Vamos a nuestro componente <span class="file">MenuItem.tsx</span> y en el type <span
                class="type">MenuItemProps</span> también le añadimos el parámetro item al definir el tipo de la función, se
              pone inmediatamente en rojo y el IS nos indica que es un any y hemos de corregirlo, además en el arrow function
              del onclick nos marca en rojo también la llamada a la función porque, habiendo especificado que le pasamos algo
              como argumento aún no lo hemos indicado:</p>
      
            <img class="my-2.5" src="./src/assets/img/115-2.png" alt="">
      
            <p><span class="destacado">Vayamos siguiendo los errores para corregirlos:</span> indicamos en nuestro type <span
                class="type">MenuItemProps</span> que el parámetro item que pasamos como argumento es de tipo <span
                class="type">MenuItem</span> y en la arrow function del onClick le especificamos el parámetro item.</p>
      
            <pre data-line="4,11"><code class="language-js">
                    import type { MenuItem } from &quot;../types&quot;
      
                    type MenuItemProps = {
                        item: MenuItem,
                        addItem: (item: MenuItem) =&gt; void
                    }
                    
                    export default function MenuItem({item, addItem}: MenuItemProps) {
                      return (
                        &lt;button 
                          className=&quot;border-2 border-teal-400 hover:bg-teal-200 w-full p-3 flex justify-between&quot;
                          onClick = {() =&gt; addItem(item)}
                          &gt;
                            &lt;p&gt;{item.name}&lt;/p&gt;
                            &lt;p className=&quot;font-black&quot;&gt;{item.price}&lt;/p&gt;
                        &lt;/button&gt;
                      )
                    }
                  </code></pre>
      
            <p><span class="destacado">Hemos de irle diciendo siempre <span class="type">qué tipo de dato vamos a tener
                  tanto</span> en nuestras funciones como en los parámetros que le vamos pasando</span>. En <span
                class="file">useOrder.ts</span> nos queda por corregir especificar el tipo de dato de item (<strong>Vemos que
                al declararlo como type <span class="type">MenuItem</span> al no estar importado en el fichero, el IS nos da
                la opción de corregirlo y automáticamente aparece en las importaciones de arriba</strong>). Ya en el console
              logo podemos indicarle {item}</p>
      
            <pre data-line="1,6"><code class="language-js">
                    import { useState } from &quot;react&quot;
                    import { MenuItem, OrderItem } from &quot;../types&quot;
                    
                    export default function useOrder() {
                        const [order, setOrder] = useState&lt;OrderItem[]&gt;([])
                    
                        const addItem = (item: MenuItem) =&gt; {
                            console.log({item})
                        }
                    
                            return{
                              addItem
                            }
                    }
                  </code></pre>
      
            <p><span class="destacado">Importante:</span> nuestra función del custom hook <span
                class="file">useOrder.ts</span> <code class="language-js">export default function useOrder() {</code>: </p>
            <pre><code class="language-js">
                    const addItem = (item: MenuItem) => {
                      console.log({item})
                    } 
                  </code></pre>
            <p>toma un item de tipo MenuItem, sin embargo cuando desde nuestra <span class="file">App.tsx</span> pasa como
              prop al componente <span class="file">MenuItem.tsx</span> se pierde esa referencia y nosotros tenemos que,
              digamos, recuperar o reasignar esa referencia para que TS sepa que tiene que hacer y sobre todo qué atributos de
              ese type es a los uqe va a tener acceso. Si probamos la App veremos que cada vez que presionamos un producto nos
              aparece en consola el item correspondiente con lo que la comunicación es correcta. A continuación vamos a
              empezar a escribir en nuestro state de nuestro hook de useOrder().</p>
      
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-116').toggle();">
            <h3>116. Añadiendo elementos al state de Orden</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-116" class="hidden">
            <p>Vamos a escribir en nuestro state de órdenes pero recordemos que <span class="file">useOrder.ts</span> este
              estate order <code class="language-js">const [order, setOrder] = useState&lt;OrderItem[]&gt;([])</code> lo
              definimos con un <strong>generic</strong> como un array de tipo <span class="type">OrderItem</span>, y ese tipo
              tenía una cantidad 'quantity'.</p>
      
            <pre><code class="language-js">
                    export type OrderItem = MenuItem & {
                      quantity: number
                  }
                  </code></pre>
      
            <p>Entonces lo que tenemos que hacer es castear o cambiar el valor pero tenemos que agregarle una cantidad así que
              veamos como hacerlo.</p>
      
            <p>Quitamos el console.log y llamamos a la función del state para, como es un arreglo, tomar una copia de lo
              previo y le pasamos el item, pero podemos ver que en seguida nos saca error. ¿por qué?</p>
      
            <img class="my-2.5" src="./src/assets/img/116.png" alt="">
      
            <p>Estamos intentando pasar como argumento un 'item' que es de tipo <span class="type">MenuItem</span> que tiene
              estos atributos:</p>
      
            <pre><code class="language-js">
                    export type MenuItem = {
                      id: number,
                      name: string,
                      price: number
                    }
                  </code></pre>
      
            <p>mientras que nuestro state de order es de tipo <span class="type">OrderItem</span> que, recordemos tiene los
              atributos de <span class="type">MenuItem</span> más la cantidad 'quantity'</p>
      
            <pre><code class="language-js">
                    export type MenuItem = {
                      id: number,
                      name: string,
                      price: number
                  }
                  export type OrderItem = MenuItem & {
                    quantity: number
                  }
                </code></pre>
      
            <p>Lo resolvemos creando una variable nueva <strong>newItem</strong> que va a ser un objeto y en el que incluyo
              una copia del item que paso + quantity inicializada a 1 para la primera vez que añado una orden (más adelante
              iremos ajustando esta cantidad según casuística). Le pasamos ese newItem a la función del state y ya no tenemos
              errores. Si nos ponemos encima de esta nueva variable vemos con el IS que tiene los atributos de <span
                class="type">OrderItem</span> más no es como tal un OrderItem, podríamos castearlo especificando el tipo:
              <code class="language-js">const newItem: OrderItem = {...item, quantity: 1}</code> aunque no es necesario y él
              no lo hace porque en la declaración de nuestro state ya especificamos con el generic que las órdenes van a tener
              ese tipo de dato.</p>
      
            <pre><code class="language-js">
                  import { useState } from &quot;react&quot;
                    import { MenuItem, OrderItem } from &quot;../types&quot;
                    
                    export default function useOrder() {
                      const [order, setOrder] = useState&lt;OrderItem[]&gt;([])
                      
                      const addItem = (item: MenuItem) =&gt; {
                        //console.log({item})
                        const newItem = {...item, quantity: 1}
                        setOrder([...order, newItem])
                      }
                      console.log(order)
                      
                      return{
                        addItem
                      }
                    }
                  </code></pre>
      
            <p>Añadimos un console.log de order para ver que si repetimos en alguna orden se añade varias veces.</p>
            <img class="my-2.5" src="./src/assets/img/116-2.png" alt="">
            <p>Lo ideal es que no se repita sino controlar eso con la cantidad. Por la inmutabilidad de React es un poco más
              complicado así que vemos como hacerlo a continuación</p>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-117').toggle();">
            <h3>117. Evitando duplicados</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-117" class="hidden">
            <p>Vamos a revisar si una orden existe en el arreglo:</p>
            <ul class="mb-3.75">
              <li><strong>¿No existe?:</strong> este código está bien:
                <pre><code class="language-js">
                        const newItem: OrderItem = {...item, quantity: 1}
                        setOrder([...order, newItem])
                      </code></pre>
              </li>
              <li><strong>¿Existe?:</strong> hemos de revisar cantidad</li>
            </ul>
      
            <p>Usamos el array method <strong>.find()</strong> para encontrar un elemento de un array en base a una condición
              y empleamos dentro del find un arrow function <strong>(recordar que el parámetro aquí usado (una variable
                temporal en la ejecución de este find) lo llamamos COMO QUERAMOS en este ejemplo 'orderItem' y hace referencia
                a cada uno de los objetos que AHORA MISMO HAY en nuestro state array order)</strong>. <span
                class="destacado">Ojo al escribir el código de la comprobación, cómo funciona el autocompletado de VSC para
                cada uno de los 2 objetos implicados (el que hace referencia a cada uno de los elementos del state order
                actual 'orderItem' y el que hace referencia al item que la pasamos al clickar).</span> Así es como queda
              nuestro código de momento con un console.log que nos avise si pulsamos en una orden que ya existe:</p>
      
            <pre><code class="language-js">
                    const addItem = (item: MenuItem) => {
                        
                      const itemExist = order.find(orderItem => orderItem.id === item.id) // buscamos en el state order el elemento cuyo id sea igual al id del item que estamos pasando
                      if (itemExist) {
                        console.log('El item ya existe') 
                      } else {
                          const newItem: OrderItem = {...item, quantity: 1}
                          setOrder([...order, newItem])
                      }
                      
                  }
                  </code></pre>
      
            <p>Si existe el elemento que intentamos agregar, hay que encontrar cual es, incrementar su cantidad pero siempre
              sin mutar el state. Para ello utilizamos el <strong>.map() y algunos spreads</strong></p>
      
            <pre><code class="language-js">
                    export default function useOrder() {
                      const [order, setOrder] = useState&lt;OrderItem[]&gt;([])
                  
                      const addItem = (item: MenuItem) =&gt; {
                          
                          const itemExist = order.find( orderItem =&gt; orderItem.id === item.id )
                          if (itemExist) { //El item ya existe         
                            const updatedOrder = order.map( orderItem =&gt; orderItem.id === item.id ? // identificamos el elemento duplicado, busca el elemento de la orden cuyo id sea igual al id del elemento que viene en item (click)
                              {...orderItem, quantity: orderItem.quantity + 1} : //toma una copia de lo que tenemos en nuestra orden e incrementa la cantidad en 1
                              orderItem)//contiene el resto de artículos de la orden que no cumplen el condicional del ternario (los no duplicados)
                              //gracias al .map() nos retorna un arreglo nuevo y podemos setear nuestra orden
                              setOrder(updatedOrder)
                          } else { // El item no existe
                              const newItem: OrderItem = {...item, quantity: 1}
                              setOrder([...order, newItem])
                          }
                          
                      }
                      console.log(order)
                  
                          return{
                            addItem
                          }
                    }
                  </code></pre>
      
            <p>Veamos cómo mostrar el state order en pantalla (ahora solo podemos verlo en consola o en React Developer tools)
            </p>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-118').toggle();">
            <h3>118. Mostrando el Consumo de la orden</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-118" class="hidden">
            <p>Estamos escribiendo en nuestro state de órdenes, ahora queremos ir mostrando a la derecha todo lo que yo pulso
              a la izquierda. Vamos así a comunicar distintos componentes con las interacciones del usuario para crear apps
              que sean más dinámicas. Vamos al <span class="file">App.tsx</span> y creamos un div con estas propiedades de
              estilo usando tailwindcss (dentro de él llamamos al nuevo componente que creamos a continuación): </p>
            <pre><code class="language-js">
                    import OrderContents from "./components/OrderContents"
      
                    &lt;div className=&quot;border border-dashed border-slate-300 p-5 rounded-lg space-y10&quot;&gt; 
                      &lt;OrderContents /&gt;
                    &lt;/div&gt;
                  </code></pre>
            <p>Creamos un componente nuevo <span class="file">OrderContents.tsx</span> en el cual creamos el componente con el
              snippet <strong>rfc</strong> le ponemos un título y en él iteraremos sobre nuestra orden:</p>
            <pre><code class="language-js">
                    export default function OrderContents() {
                      return (
                        &lt;div&gt;
                            &lt;h2 className=&quot;font-black text-4xl&quot;&gt;Consumo&lt;/h2&gt;
                    
                        &lt;/div&gt;
                      )
                    }
                  </code></pre>
            <p>y lo llamamos desde nuestra App.tsx</p>
            <p>A continuación exportamos "order" desde nuestro Hook <span class="file">useOrder.ts</span>:</p>
            <pre data-line="23"><code class="language-js">
                    //useOrder.ts
                    import { useState } from &quot;react&quot;
                    import { MenuItem, OrderItem } from &quot;../types&quot;
                    
                    export default function useOrder() {
                        const [order, setOrder] = useState&lt;OrderItem[]&gt;([])
                        const addItem = (item: MenuItem) =&gt; {
                            
                            const itemExist = order.find( orderItem =&gt; orderItem.id === item.id )
                            if (itemExist) { //El item ya existe         
                              const updatedOrder = order.map( orderItem =&gt; orderItem.id === item.id ? // identificamos el elemento duplicado, busca el elemento de la orden cuyo id sea igual al id del elemento que viene en item (click)
                                {...orderItem, quantity: orderItem.quantity + 1} : //toma una copia de lo que tenemos en nuestra orden e incrementa la cantidad en 1
                                orderItem)//contiene el resto de artículos de la orden que no cumplen el condicional del ternario (los no duplicados)
                                //gracias al .map() nos retorna un arreglo nuevo y podemos setear nuestra orden
                                setOrder(updatedOrder)
                            } else { // El item no existe
                                const newItem: OrderItem = {...item, quantity: 1}
                                setOrder([...order, newItem])
                            }
                            
                        }
                        console.log(order)    
                            return{
                              order,
                              addItem
                            }
                    }
                  </code></pre>
      
            <p><span class="destacado">Aún no hemos visto como tener un estado global (¿en al App.tsx?)</span> así que no lo
              podemos importar directamente en nuestro <strong>OrderContents.tsx</strong> porque es como tener una clase nueva
              entonces pierde la referencia??. En <span class="file">App.tsx</span>, que importamos nuestro Hook, en el
              destructuring de nuestro hook <strong>useOrder</strong> <span class="destacado">extraemos también la orden que
                vamos a pasar como prop al nuevo componente</span>:</p>
            <pre data-line="5"><code class="language-js">
                      //App.tsx
                      import useOrder from "./hooks/useOrder"
                      import OrderContents from "./components/OrderContents"
      
                      function App() {
      
                        const { order, addItem } = useOrder()
                    </code></pre>
      
            <p>Si somos limpios usando el mismo orden que usamos en el Hook para declarar y retornar las variables será más
              fácil tenerlo todo controlado; si vemos nuestro hook:</p>
            <pre data-line="2,3,8,9"><code class="language-js">
                    //useOrder.ts
                    export default function useOrder() {
                      const [order, setOrder] = useState&lt;OrderItem[]&gt;([])
                      const addItem = (item: MenuItem) =&gt; {      
      
                          ....
                  
                          return{
                            order,
                            addItem
                          }
                    }
                  </code></pre>
      
            <p>Al asignarle la prop me marca un error porque, esa propiedad que enviamos desde App.tsx hacia OrderContents.tsx
              hemos de tiparla, no tenemos ningún type asociado.</p>
      
            <pre class="rojo" data-line="2"><code class="language-js">
                    //App.tsx
                    &lt;OrderContents 
                    order = { order }
                  /&gt;
                  </code></pre>
      
            <p><strong>En nuestro nuevo componente OrderContents.tsx creamos un nuevo type específico y en su definición
                indicamos que la order es del tipo array OrderItem (hemos de importar ese tipo)</strong>.</p>
      
            <div class="flex">
              <div class="w-50">
                <pre><code class="language-js">
                        //OrderContents.tsx
                        export default function OrderContents() {
                          return (
                            &lt;div&gt;
                                &lt;h2 className=&quot;font-black text-4xl&quot;&gt;Consumo&lt;/h2&gt;
                        
                            &lt;/div&gt;
                          )
                        }
                      </code></pre>
              </div>
              <div class="w-50">
                <pre><code class="language-js">
                        //OrderContents.tsx
                        import { OrderItem } from &quot;../types&quot;
      
                        type OrderContentsProps = {
                            order: OrderItem[]
                        }
                        
                        export default function OrderContents({order}: OrderContentsProps) {
                          return (
                            &lt;div&gt;
                                &lt;h2 className=&quot;font-black text-4xl&quot;&gt;Consumo&lt;/h2&gt;
                        
                            &lt;/div&gt;
                          )
                        }
                      </code></pre>
              </div>
            </div>
      
            <p>Comentamos el console.log(order) de nuestro hook para comenzar a mostrarlo en nuestro componente. Añadimos este
              contenedor con esta comprobación:</p>
      
            <pre><code class="language-js">
                    //OrderContents.tsx
                    &lt;div className=&quot;space-y-3 mt-5&quot;&gt;
                      { order.length === 0 ? 
                          &lt;p className=&quot;text-center&quot;&gt;La orden está vacía&lt;/p&gt;
                          : 
                          //&lt;p className=&quot;text-center&quot;&gt;La orden tiene algo&lt;/p&gt;
                          ( order.map( item =&gt; (
                              &lt;div key={item.id}&gt;
                                  &lt;p&gt;{item.name}&lt;/p&gt;
                              &lt;/div&gt;
                              )
                          ))
                      }
                    &lt;/div&gt;
                  </code></pre>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-119').toggle();">
            <h3>119. Formateando el Consumo y mostrando cantidades</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-119" class="hidden">
      
            <p>Sigamos con nuestro html, vamos a mostrar nombre, precio, cantidad y un botón para eliminar los elementos.
              Añadimos el precio y en vez de poner a pelo el signo del $, crea carpeta y fichero <span
                class="file">helpers&gt;index.ts</span> donde mete la función '<strong>formatCurrency()</strong>':</p>
            <pre><code class="language-js">
                    //helpers>index.ts
                    export default function formatCurrency(quantity: number){
                      return new Intl.NumberFormat('en-US', {
                          style: 'currency', currency: 'USD'
                      }).format(quantity)
                  }
                  </code></pre>
            <pre><code class="language-js">
                    //OrderContents.tsx
                    (order.map( item =&gt; (
                      &lt;div 
                          className=&quot;flex justify-between items-center border-t border-gray-200 py-5 last-of-type:border-b&quot;
                          key={item.id}
                      &gt;
                          &lt;div&gt;
                              &lt;p className=&quot;text-lg&quot;&gt;
                                  {item.name} - {formatCurrency(item.price)}
                              &lt;/p&gt;
                              &lt;p className=&quot;font-black&quot;&gt;
                                  Cantidad: {item.quantity} - {formatCurrency(item.price * item.quantity)}
                              &lt;/p&gt;
                          &lt;/div&gt;
                          &lt;button className=&quot;bg-red-600 h-8 w-8 rounded-full text-white font-black&quot;&gt;X&lt;/button&gt;
                      &lt;/div&gt;
                      )
                    ))
                  </code></pre>
      
            <img class="my-2.5" src="./src/assets/img/119.png" alt="Imagen 119">
      
      
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-120').toggle();">
            <h3>120. Eliminando articulos de la orden</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-120" class="hidden">
            <p>Creamos función nueva para eliminar items de la orden y vemos todos los cambios necesarios en App.tsx, nuestro
              custom hook y el componente implicado.</p>
            <pre><code class="language-js">
                    //useOrder.ts 
                    // - creamos una nueva función para borrar items
                    // - le ponemos como parámetro id y lo tipamos como MenuItem con un lookup para id 
                    // - (lo podríamos poner como number pero si cambiáramos la BBDD a Mongo DB que son string, la liamos sin ese "seguimiento de tipados" del lookup)
                    // - en el console.log comprobamos la comunicación ¿OK? --&gt; seteamos ese state en base a nuestra condición. Accedemos a nuestro state 'order' y usamos el array method filter para crear un nuevo array con los elementos del order actual de los que se exluye el elemento cuyo id coincida con el que le pasamos como argumentoal pulsar el click.
                    // - la exportamos en el return para hacerla disponible en nuestros componentes
                      import formatCurrency from "../helpers"
                      import { MenuItem, OrderItem } from "../types"
                      export default function useOrder() {
                        const [order, setOrder] = useState&lt;OrderItem[]&gt;([])
                      ...
                      const removeItem = (id: MenuItem['id']) => { 
                        //console.log('Eliminando', id)
                        setOrder(order.filter(item => item.id != id))
                      
                      }
                      return{
                          order,
                          addItem,
                          removeItem
                      }
      
                    //App.tsx 
                    //- extraemos de nuestro hook con destructuring esta nueva función
                      const { order, addItem, removeItem } = useOrder()
      
                    //- en el tag de nuestro compocreamos un prop nuevo 'removeItem' que le pasa esa fcn el compo desde donde se va a utilizar "OrderContents.tsx"    
                      &lt;OrderContents 
                        order = { order }
                        removeItem = {removeItem}
                      &gt;
                      // saldrá en rojo hasta que en el componente donde se usa "OrderContents.tsx" hagamos lo siguiente: 
      
                    //OrderContents.tsx 
                    //- lo incluimos como parámetro (necesitamos incluirlo en el tipo personalizado type OrderContentsProps) 
                    //- recibe un parámetro que tipamos como lookup for 'id' del type MenuItem
                    //- añadimos la llamada a la función para borrar desde el onclick del botón y le pasamos como argumento el id del item.
                    
                      type OrderContentsProps = {
                        order: OrderItem[],
                        removeItem: (id: MenuItems['id']) => void
                      }
                      ...
                      export default function OrderContents({order,removeItem}: OrderContentsProps) {
                      ...
                      &lt;button 
                          className=&quot;bg-red-600 h-8 w-8 rounded-full text-white font-black&quot;
                          onClick={() =&gt; removeItem(item.id)}
                      &gt;X&lt;/button&gt;
                  </code></pre>
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-121').toggle();">
            <h3>121. Creando el Componente con los totales</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-121" class="hidden">
            <p>Vamos a crear un nuevo componente para los totales que irá justo debajo de la lista de contenidos de nuestra
              orden. A diferencia del proyecto anterior en donde también la fcn para totales la teníamos en nuestro custom
              hook, dado que en este caso solo se va a requerir su uso en el componente totales la vamos a especificar ahí.
            </p>
      
            <pre><code class="language-js">
                    //OrderTotals.tsx (nuevo componente para totales)
      
                    //App.tsx
                    //-importamos nuestro componente
                    //-Lo renderizmaos en el return() a continuación del componente &lt;MenuItem /&gt;
                      import OrderTotals from "./components/OrderTotals"
                      ...
                      &lt;OrderTotals /&gt;
      
                    //OrderTotals.tsx
                    //- div con las cantidades 
                    //- button para almacenar o reiniciar la orden (mas adelante veremos como conectar BBDD con servidor de node de momento simulamos que la almacenamos )
                      export default function OrderTotals() {
                        return (
                          &lt;&gt;
                      
                            &lt;div className=&quot;space-y-3&quot;&gt;
                              &lt;h2 className=&quot;font-black text-2xl&quot;&gt;Totales y propina:&lt;/h2&gt;
                              &lt;p&gt;Subtotal a pagar:
                                &lt;span className=&quot;font-bold&quot;&gt;$0&lt;/span&gt;
                              &lt;/p&gt;
      
                              &lt;p&gt;Propina:
                                &lt;span className=&quot;font-bold&quot;&gt;$0&lt;/span&gt;
                              &lt;/p&gt;
                      
                              &lt;p&gt;Total a pagar: 
                                &lt;span className=&quot;font-bold&quot;&gt;$0&lt;/span&gt;
                              &lt;/p&gt;
                            &lt;/div&gt;
                      
                            &lt;button&gt;&lt;/button&gt;
                      
                          &lt;/&gt;
                        )
                      }
      
                  </code></pre>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-122').toggle();">
            <h3>122. Calculando el Consumo y más TypeScript</h3>
            <span class="cambiaicono ico_chevron_up_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-122" class="hidden">
            <p><strong>Calculemos el subtotal a pagar en base al precio de los artículos y sus cantidades.</strong> Si
              agregamos varios elementos, vemos que el subtotal tiene que ser el resultado de sumar cada precio por la
              cantidad. Eso antes era más complejo hacerlo pero <strong>gracias a las "nuevos"(2015) array methods como
                <strong>useMemo() o reduce() </strong>es más sencillo simplifican el código, evitando tener que tener renders
                adicionales</strong>. Como ese cálculo viene desde <strong>order</strong> vamos a nuestro App.tsx</p>
            <pre><code class="language-js">
                    //App.tsx
                    //- en el tag de nuestro nuevo componente &lt;OrderTotals/&gt; le pasamos como propiedad la order para que esté conectado y sepa cuáles son los contenidos de nuestra orden (lo podemos hacer en el hook o en el componente, con react tenemos siempre distintas formas)
                      &lt;OrderTotals 
                      order = { order }/&gt;
                  </code></pre>
      
            <pre><code class="language-js">
                  //OrderTotals.tsx  
                  //- importamos useMemo y nuestra función formatCurrency() de helpers que los vamos a usar
                    import { useMemo } from "react"
                    import formatCurrency from "../helpers"
      
                  //- como esa prop 'order' va a ser de tipo array OrderItem, importamos ese type
                  //- nuestro componente va a recibir como parámetro esa prop así que creamos type personalizado para este componente
                    import {OrderItem} from &quot;../types&quot;
                    type OrderTotalsProps = {
                      order: OrderItem[]
                    }
      
                    export default function OrderTotals({order}: OrderTotalsProps) {
      
                    //- creamos función nueva 'subtotalAmount' para calcular el subtotal a pagar en base al precio de los artículos y sus cantidades:
                      const subtotalAmount = useMemo(() => order.reduce( (total, item) => total + (item.quantity * item.price), 0), [order])
      
                      //- usamos useMemo; va a ser siempre un callback y la dependencia es lo que hay tras la coma --&gt; useMemo(()=&gt; ,[]order).
                      // nos permite que el código se renderice o se ejecute cada vez que cambia la dependencia (en nuestro caso cada vez que cambia la orden).
                      //- usamos el array method .reduce() que es uno de los pocos que toma dos parámetros (acumulado temporal y el item sobre el  que iteramos): 
                        // total(temporal) es un acumulado, en cada iteración que se va dando va almacenando en memoria (en nuestro caso la suma del total temporal con (menuItems.quantity * item*price))
                        // item(elemento sobre el que estamos iterando) --&gt; tras la coma, 0 es el valor inicial de la iteracion
                  
                    //- usando en el return{} nuestra función formatCurrency() de helper, ya podemos ver el subtotal:
                      return (
                        &lt;&gt;
                          &lt;p&gt;Subtotal a pagar:
                            &lt;span className=&quot;font-bold&quot;&gt;{ formatCurrency(subtotalAmount) }&lt;/span&gt;
                          &lt;/p&gt;
      
                    
      
                    
                    
                    
      
                      
                      
      
                  </code></pre>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-123').toggle();">
            <h3>123. Primeros pasos con las propinas / 124. Añadiendo la cantidad seleccionada de Propina</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-123" class="hidden">
            <p>Vamos a tener un formulario en el que vamos a indicar cuánto queremos dejar de propina. Creamos componente
              nuevo <span class="file">TipPercentageForm.tsx</span> en el que usamos como const <a
                href="https://gist.github.com/codigoconjuan/93fd42da96258357fc9f78eb1d17a6b3" class="underline"
                target="_blank">Gist Arreglo con objetos (id, value, label) para iterarlo y mostrarlo en el formulario</a></p>
            <pre><code class="language-js">
                    //App.tsx
                    import TipPercentageForm from "./components/tipPercentageForm"
      
                    &lt;TipPercentageForm /&gt;
                  </code></pre>
            <pre><code class="language-js">
                    //TipPercentageForm.tsx
                    const tipOptions = [
                    {
                      id: &#39;tip-10&#39;,
                      value: .10,
                      label: &#39;10%&#39;
                    },
                    {
                      id: &#39;tip-20&#39;,
                      value: .20,
                      label: &#39;20%&#39;
                    },
                    {
                      id: &#39;tip-50&#39;,
                      value: .50,
                      label: &#39;50%&#39;
                    },
                  ]
      
                  export default function TipPercentageForm() {
                    return (
                      &lt;&gt;
                          &lt;h3 className=&quot;font-black text-2xl&quot;&gt;Propina:&lt;/h3&gt;
      
                          &lt;form&gt;
                              {tipOptions.map( tipOption =&gt; (
                                  &lt;div
                                      key={tipOption.id}
                                      className=&quot;flex gap-2&quot;
                                  &gt;
                                      &lt;label htmlFor={tipOption.id}&gt;{tipOption.label}&lt;/label&gt;
                                      &lt;input 
                                          id={tipOption.id} 
                                          type=&quot;radio&quot;
                                          name=&quot;tipOption&quot;
                                          value={tipOption.value}
                                      /&gt;
                                  &lt;/div&gt;
                              ))}  
                          &lt;/form&gt;
                      &lt;/&gt; 
                    )
                  }
                  </code></pre>
      
            <p class="naranja">Añadiendo la cantidad seleccionada de Propina</p>
      
            <p>vamos a colocar el state de propina en nuestro hook useOrder():</p>
            <pre><code class="language-js">
                    //useOrder.ts 
                    export default function useOrder() {
                        const [order, setOrder] = useState<OrderItem[]>([])
                        const [tip, setTip] = useState(0)
      
                        return{
                          order,
                          tip,
                          setTip,
                          addItem,
                          removeItem
                      }
      
                    //App.tsx
                    - extraigo ambos: tip y setTip para tenerlos disponibles Y
                    - pasarlos como propiedades del componente 
      
                      const { order, addItem, removeItem, tip, setTip } = useOrder()
      
                        &lt;TipPercentageForm 
                          setTip = {setTip}
                        /&gt;
                      
                    //TipPercentageForm.tsx
                    //- definimos type nuevo específico para la función setTip que estamos pasando ¿donde lo miramos? dejamos que VSC nos lo infiera
                    //y con el Intellisense de VSC lo copiamos 'setTip: React.Dispatch&lt;React.SetStateAction&lt;number&gt;&gt;' 
                    // significa funcion que dispara la accion de modificar el state de tipo number
                    
      
                        type TipPercentageFormProps = {
                          setTip: React.Dispatch&lt;React.SetStateAction&lt;number&gt;&gt;
                        }
                        
                        export default function TipPercentageForm({setTip}:TipPercentageFormProps) {
      
                    //También podríamos reducir un poco nuestro código del nuevo type para esta propor importando de react los dos types:
                        import type { Dispatch, SetStateAction } from "react"
      
                        type TipPercentageFormProps = {
                          setTip: Dispatch<SetStateAction<number>>
                      }
      
                    // - usamos setTip en nuestro input, en el onChange modificamos el value, sin embargo vemos que al escribir onChange={ e =&gt; setTip(e.target.value)}
                    // nos marca en rojo, TS escanea nuestro código y setTip es number y el value de un input es string. Lo podemos solucionar de dos manera:
                    //  * signo + antes de lo que lee como string, lo convierte a number  onChange={ e =&gt; setTip(+e.target.value)}
                    //  * añadirle el sufijo AsNumber onChange={ e =&gt; setTip(e.target.valueAsNumber)} PERO ESTO NO FUNCIONA CON LAS INPUT RADIO!!!
                      &lt;form&gt;
                        {tipOptions.map( tipOption =&gt; (
                            &lt;div
                                key={tipOption.id}
                                className=&quot;flex gap-2&quot;
                            &gt;
                                &lt;label htmlFor={tipOption.id}&gt;{tipOption.label}&lt;/label&gt;
                                &lt;input 
                                    id={tipOption.id} 
                                    type=&quot;radio&quot;
                                    name=&quot;tipOption&quot;
                                    value={tipOption.value}
                                    //onChange={ e =&gt; setTip(e.target.value)}
                                    onChange={ e =&gt; setTip(+e.target.value)}
                                /&gt;
                            &lt;/div&gt;
                        ))}  
                      &lt;/form&gt;
                  </code></pre>
            <img class="my-2.5" src="./src/assets/img/124.png" alt="imagen 124">
      
            <p>Veamos como pasar ese tip o el porcentaje hacia OrderTotals.tsx para hacer los dos últimos cálculos, propinas y
              total a pagar.</p>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-125').toggle();">
            <h3>125. Calculando el Total de la propina / 126. Calculando el Total a pagar</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-125" class="hidden">
            <pre><code class="language-js">
                    //App.tsx
                      &lt;OrderTotals 
                        order = {order}
                        tip = {tip}
                      &gt;
                  </code></pre>
            <pre><code class="language-js">
                    //OrderTotals.tsx
                    //- completamos el type de propiedades de ese componente con la nueva que pasamos, tip que es de tipo number
                    //- la extraemos
                    //- como tip solo tiene el % (0.1 para 10% y así...) creamos variable nueva para formatearlo: 'tipAmount' y usamos useMemo() porque esa propina puede cambiar:
                    //  * cuando cambiemos la propina marcada 'tip'
                    //  * cuadno cambie nuestra orden 'order'
                    // por tanto empleamos esas dos dependencias para que, tanto cuando cambiemos el radio de la propina como cuando añadamos o eliminemos de nuestra orden, todo se Actualicemos
                    // - creamos nueva variable para el total 'totalAmount' y también usamos useMemo()
                      import { useMemo } from "react"
                      import { OrderItem } from &quot;../types&quot;
                      import formatCurrency from &quot;../helpers&quot;
      
                      type OrderTotalsProps = {
                        order: OrderItem[]
                        tip: number
                      }
      
                      export default function OrderTotals({order, tip}: OrderTotalsProps) {
      
                        const subtotalAmount = useMemo(() =&gt; order.reduce( (total, item) =&gt; total + (item.quantity * item.price), 0), [order])
                        const tipAmount = useMemo(() =&gt; subtotalAmount * tip, [tip, order])
                        const totalAmount = useMemo(()=&gt; subtotalAmount + tipAmount, [tip, order])
      
                        return (
                          &lt;&gt;
      
                            &lt;div className=&quot;space-y-3&quot;&gt;
                              &lt;h2 className=&quot;font-black text-2xl&quot;&gt;Totales y propina:&lt;/h2&gt;
                              &lt;p&gt;Subtotal a pagar:
                                &lt;span className=&quot;font-bold&quot;&gt; {formatCurrency( subtotalAmount )}&lt;/span&gt;
                              &lt;/p&gt;
                              &lt;p&gt;Propina:
                                &lt;span className=&quot;font-bold&quot;&gt; {formatCurrency( tipAmount )}&lt;/span&gt;
                              &lt;/p&gt;
                              &lt;p&gt;Total a pagar: 
                                &lt;span className=&quot;font-bold&quot;&gt; {formatCurrency( totalAmount )}&lt;/span&gt;
                              &lt;/p&gt;
                            &lt;/div&gt;
                            &lt;button&gt;&lt;/button&gt;
      
                          &lt;/&gt;
                        )
                      }
                  </code></pre>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-127').toggle();">
            <h3>127. Diferencia entre useMemo y useCallback</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-127" class="hidden">
            <p>Existe otra funcíón que es exactamente igual que useMemo() pero su sintaxis es diferente: useCallback()
              <strong>simplemente es añadir los () en cada llamada que se haga a las distintas funciones. El código anterior
                de nuestro componente OrderTotals.tsx quedaría así: </strong></p>
      
            <pre><code class="language-js">
                    //OrderTotals.tsx
                      import { useMemo, useCallback } from "react"
      
                      export default function OrderTotals({order, tip}: OrderTotalsProps) {
      
                        const subtotalAmount = useCallback(() =&gt; order.reduce( (total, item) =&gt; total + (item.quantity * item.price), 0), [order])
                        const tipAmount = useCallback(() =&gt; subtotalAmount() * tip, [tip, order])
                        const totalAmount = useCallback(()=&gt; subtotalAmount() + tipAmount(), [tip, order])
                      
                        return (
                          &lt;&gt;
                      
                            &lt;div className=&quot;space-y-3&quot;&gt;
                              &lt;h2 className=&quot;font-black text-2xl&quot;&gt;Totales y propina:&lt;/h2&gt;
                              &lt;p&gt;Subtotal a pagar:
                                &lt;span className=&quot;font-bold&quot;&gt; {formatCurrency( subtotalAmount() )}&lt;/span&gt;
                              &lt;/p&gt;
                              &lt;p&gt;Propina:
                                &lt;span className=&quot;font-bold&quot;&gt; {formatCurrency( tipAmount() )}&lt;/span&gt;
                              &lt;/p&gt;
                              &lt;p&gt;Total a pagar: 
                                &lt;span className=&quot;font-bold&quot;&gt; {formatCurrency( totalAmount() )}&lt;/span&gt;
                              &lt;/p&gt;
                            &lt;/div&gt;
                            &lt;button&gt;&lt;/button&gt;
                      
                          &lt;/&gt;
                        )
                      }
                  </code></pre>
      
          </div>
      
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-128').toggle();">
            <h3>128. Reiniciando la Orden / 129. Deployment del Proyecto</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-128" class="hidden">
            <p>Vamos a trabajar con e botón del final de nuestro componente OrderTotals.tsx</p>
            <pre><code class="language-js">
                    // OrderTotals.tsx
                    // - le damos estilos y lo deshabilitamos si el total es 0. 
                    // - aprovehamos las clases de tailwind para formatear aspecto cuando esté deshabilitado
                    &lt;button 
                      className=&quot;w-full bg-black p-3 uppercase text-white font-bold mt-10 rounded-sm cursor-pointer disabled:opacity-10 disabled:cursor-auto&quot;
                      disabled={totalAmount === 0 }
                      &gt; 
                      Guardar Orden
                    &lt;/button&gt;
                  </code></pre>
      
            <p>Creamos función nueva de tipo arrow 'placeOrder' y recordar el orden de propagación: <br>
              <span class="destacado">hook</span> <strong>useOrder.ts</strong> -> <span class="destacado">compo ppal</span>
              <strong>App.tsx</strong> -> <span class="destacado">compo donde se utiliza</span>
              <strong>OrderTotal.tsx</strong>
            </p>
      
            <pre><code class="language-js">
                    //useOrder.ts
                        const placeOrder = () => {
                          console.log('guardando...')
                      }
                      return{
                          order,
                          tip,
                          setTip,
                          addItem,
                          removeItem,
                          placeOrder
                      }
      
                    //App.tsx
                      function App() {
      
                        const { order, tip, setTip, addItem, removeItem, placeOrder } = useOrder()
                      
                        return (
                          &lt;&gt;
                          &lt;OrderTotals 
                            order = {order}
                            tip = {tip}
                            placeOrder = {placeOrder}
                          /&gt;
      
                    //OrderTotals.tsx
                      type OrderTotalsProps = {
                        order: OrderItem[]
                        tip: number,
                        placeOrder: ()=>void
                      }
                      
                      export default function OrderTotals({order, tip, placeOrder}: OrderTotalsProps) {   
                        
                        &lt;button 
                          className=&quot;w-full bg-black p-3 uppercase text-white font-bold mt-10 rounded-sm cursor-pointer disabled:opacity-10 disabled:cursor-auto&quot;
                          disabled={totalAmount === 0 }
                          onClick={placeOrder}
                          &gt; 
                          Guardar Orden
                        &lt;/button&gt;
                  </code></pre>
      
            <p>Si probamos se restablece todo, pero el radio queda marcado ¿como conseguimos que no queda marcado? Hemos de
              pasarle al componente TipPercentageForm.tsx como propiedad desde App.tsx la propina tip para poder añadirle al
              input esta comprobación: <code class="language-js">checked={tipOption.value === tip}</code>. <strong>Cuando
                restablecemos la orden el state tip cambia porque tiene las dos dependencias mencionadas antes con lo cual
                deja de cumplirse la condición para que permanezca marcado</strong></p>
      
            <pre><code class="language-js">
                    //App.tsx
                    &lt;TipPercentageForm 
                      tip = {tip}
                      setTip = {setTip}
                      &gt;
      
                    //TipPercentageForm.tsx
                      type TipPercentageFormProps = {
                        tip: number,
                        setTip: Dispatch&lt;SetStateAction&lt;number&gt;&gt;
                      }
                      export default function TipPercentageForm({tip, setTip}:TipPercentageFormProps) {
                        return (
                          &lt;&gt;
                              &lt;h3 className=&quot;font-black text-2xl&quot;&gt;Propina:&lt;/h3&gt;
                      
                              &lt;form&gt;
                                  {tipOptions.map( tipOption =&gt; (
                                      &lt;div
                                          key={tipOption.id}
                                          className=&quot;flex gap-2&quot;
                                      &gt;
                                          &lt;label htmlFor={tipOption.id}&gt;{tipOption.label}&lt;/label&gt;
                                          &lt;input 
                                              id={tipOption.id} 
                                              type=&quot;radio&quot;
                                              name=&quot;tip&quot;
                                              value={tipOption.value}
                                              onChange={ e =&gt; setTip(+e.target.value)}
                                              checked={tipOption.value === tip}
                                          /&gt;
                                      &lt;/div&gt;
                                  ))}  
                              &lt;/form&gt;
                          &lt;/&gt; 
                        )
                      }    
                  </code></pre>
      
            <p>Cuando le damos a "Guardar Orden" (simulando ese envío a BBDD) y se restablece... si la orden está vacía,
              probablemente no tenga sentido cargar nada de esto:</p>
            <img class="my-2.5" src="./src/assets/img/128.png" alt="">
      
            <p>Vemos que en OrderContents.tsx. teníamos un ternario para mostrar "La orden está vacía" o en caso de que bo lo
              estuviera el/los elementos agregados:</p>
            <pre><code class="language-js">
                    //OrderContents.tsx
                      &lt;div className=&quot;space-y-3 mt-10&quot;&gt;
                        //{ order.length === 0 ? 
                          //&lt;p className=&quot;text-center&quot;&gt;La orden está vacía&lt;/p&gt;
                          //: 
                            {order.map( item =&gt; (
                              &lt;div 
                                  className=&quot;flex justify-between items-center border-t border-gray-200 py-5 last-of-type:border-b&quot;
                                  key={item.id}
                              &gt;
                                &lt;div&gt;
                                    &lt;p className=&quot;text-lg&quot;&gt;
                                        {item.name} - {formatCurrency(item.price)}
                                    &lt;/p&gt;
                                    &lt;p className=&quot;font-black&quot;&gt;
                                        Cantidad: {item.quantity} - {formatCurrency(item.price * item.quantity)}
                                    &lt;/p&gt;
                                &lt;/div&gt;
                                &lt;button 
                                    className=&quot;bg-red-600 h-8 w-8 rounded-full text-white font-black cursor-pointer&quot;
                                    onClick={() =&gt; removeItem(item.id)}
                                &gt;X&lt;/button&gt;
                              &lt;/div&gt;
                            )}
                          ///))}
                        //}
                        
                        &lt;/div&gt;
                  </code></pre>
      
            <p>Cambiemos el compo ppal App.tsx para meter aquí la comprobación, mejorando así el rendimiento porque en caso de
              que la orden esté vacía no se renderiza ninguno de los 3 componentes:</p>
            <pre><code class="language-js">
                    &lt;div className=&quot;border border-dashed border-slate-300 p-5 rounded-lg space-y10&quot;&gt;    
                      &lt;h2 className=&quot;font-black text-4xl&quot;&gt;Consumo&lt;/h2&gt;
                      {order.length &gt; 0  ? (
                        &lt;&gt;
                          &lt;OrderContents 
                            order = { order }
                            removeItem = {removeItem}
                          /&gt;            
                          &lt;TipPercentageForm 
                            tip = {tip}
                            setTip = {setTip}
                          /&gt;
                          &lt;OrderTotals 
                            order = {order}
                            tip = {tip}
                            placeOrder = {placeOrder}
                          /&gt;
                        &lt;/&gt;
                      ) : (
                        &lt;p className=&quot;text-center&quot;&gt;La orden está vacía&lt;/p&gt;
                      )}  
                    &lt;/div&gt;
                  </code></pre>
      
            <p>Hemos estado viendo performance (useMemo, useCallback) tips sobre cómo inferir el tipo de dato. Más adelante
              retomaremos este proyecto para ver cómo almacenarlo en una BBDD, y así poder incluirlo en nuestro portfolio.</p>
      
          </div>
      
      
        </div>
        <!-- Fin div colapsable-->
      
      </div>
      <!-- FIN SECCION 9 -->

     
      <!-- SECCION 8 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">

          <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion08').toggle();">
            <h2>Sección 8: PROYECTO - Carrito de Compras - Migrando a TypeScript paso a paso</h2>
            <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
          </div>

          <div id="seccion08" class="hidden">
        

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-91').toggle();">
                  <h3>91. ¿Qué es TypeScript y sus ventajas?</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-91" class="hidden">
                  <p class="font-bold">Typescript ¿qué es? y ventajas</p>
                  <ul class="mb-3.75">
                    <li>Es un lenguaje de programación de código abierto. Sí, es un lenguaje completo, desarrollado y mantenido por Microsoft. También se le conoce como un <strong>superconjunto tipado para JavaScript, lo que significa que cualquier código de JavaScript válido es también código de TypeScript válido</strong>.</li>                    
                    <li>La principal característica de TypeScript es que agrega un sistema de tipos estático a JavaScript, lo que permite detectar errores y proporcionar herramientas de desarrollo más sólidas.</li>
                  </ul>

                  <p class="font-bold">¿Cuáles son las ventajas de implementar TypeScript?</p>
                  <ul class="mb-3.75">
                    <li>El sistema de tipado de tipos de TypeScript permite al programador especificar los tipos de variable, parámetros de función, valores de retorno y más. Esto va a brindar la capacidad de realizar la comprobación de tipos durante la compilación (cuando estás escribiendo tu código) y detectar posibles errores antes de que el código sea ejecutado. --&gt; Entonces su principal ventaja es que no necesitas que el proyecto esté en producción para revisar que todo esté bien. Con TypeScript puedes tener la garantía de que tu código va a funcionar correctamente.</li>
                    <li>Mejora enormemente el autocompletado o Intellisense que vas a obtener con Visual Studio Code (Ver presentación 10.html del curso de Angular).
                    <img class="my-2.5" src="./src/assets/img/91.png" alt="" />
                    </li>
                  </ul>

                  <p class="font-bold">Typescript y Javascript / React</p>

                  <ul class="mb-3.75">
                    <li>Una vez que has escrito el código en TypeScript, este código siempre se compila a JavaScript. Como tal, el navegador no soporta TypeScript, por lo tanto se tiene que compilar siempre hacia código de JavaScript</li>
                    <li>React y Vite incluyen soporte a TypeScript también, lo que ayuda bastante en el desarrollo de proyectos. Una vez que esté listo tu proyecto, lo construyes con build, se va a compilar a código de JavaScript y entonces puede ser publicado en Internet.</li>
                    <li>Hoy en día, TypeScript se ha convertido en un estándar para crear aplicaciones React, Angular y View. Incluso se pide en vacantes de Junior Developer por lo que es el momento adecuado para comenzar a aprender TypeScript.</li>
                  </ul>
                  

                </div>
                <!-- Fin bloque desplegable interior-->

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-92').toggle();">
                  <h3>92. Creando el Proyecto con TypeScript</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-92" class="hidden">
                  <p>Vamos a crear un proyecto nuevo <span class="destacado">npm create vite@latest</span> lo nombramos <strong>guitarla-ts</strong> que sea <strong>react con el nuevo compilador</strong>. Vamos a la carpeta e instalamos las dependencias con <span class="destacado">npm install</span>. Lanzamos el servidor de desarrollo con <strong>npm run dev</strong>.</p>

                  <p>Vemos que básicamente la estructura del proyecto es como la que hemos visto hasta ahora con algunas diferencias:</p>
                  <ul class="mb-3.75">
                    <li>vemos que hay 3 ficheros de configuración de typescript con extensión .json: tsconfig.app.json,tsconfig.json y tsconfig.node.json. Normalmente no tocaremos nada en ellos.</li>
                    <li>Si abrimos la carpeta src veremos que la extensión ya no es .jsx sino tsx.</li>                
                  </ul>

                  <p>Aunque el resto de proyectos los haremos desde cero con typescript, ahora vamos a convertir el proyecto de carrito de compras de guitarras <strong>guitarla-useCart</strong> a typescript. Copiamos entre proyectos de ese a este nuevo <strong>guitarla-ts</strong>:</p>

                  <ul class="mb-3.75">
                    <li>borramos el archivo public/vite.svg</li>
                    <li>copiamos y pegamos la carpeta public/img</li>
                    <li>En la carpeta principal del proyecto, borro src del nuevo y copio src.</li>
                    <li>Cambiamos todos los .jsx --> .tsx y los .js --> .ts. veremos que nos empieza a marcar en rojo en muchos archivos. Si abrimos el componente Header.tsx por ejemplo vemos que los errores los resalta en los parámetros que toma este componente. Ahí es "donde entra typescript" en los parámetros, objetos que vamos creando vamos a ir definiendo el tipo de dato que le estamos pasando a nuestras funciones, componentes... Vamos a ir viéndolo paso a paso.</li>
                    <li>Error del main.tsx --> document.getElementById('root'). Veamos la explicación de esto. Si creamos una variable en ese mismo <span class="file">main.tsx</span>y le asignamos eso <code class="language-js">const div = document.getElementById('root')</code>, vemos en el Intellisense que TypeScript <span class="destacado">INFIERE</span> que el tipo de dato de ese elemento es un HTMLElement o null.<br>
                      
                      <img class="my-2.5" src="./src/assets/img/92.png" alt="" />

                      <p>Es decir, <span class="destacado">TypeScript nos marca eso como error porque estamos utilizando un parámetro que puede ser null. Para eliminar esa posibilidad, fijamos el tipo de dato de esta manera:</span> <code class="language-js">const div = document.getElementById('root') as HTMLElement</code> y entonces podríamos quitar ese error como se hacía hasta no hace mucho aunque no se considera buena práctica porque con <code class="language-js">as HTMLElement</code> le estamos diciendo a typeScript "confia en mí, este va a ser el tipo de dato":</p>

                      <pre class="verde" data-line="0"><code class="language-js">
                        ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
                          &lt;React.StrictMode&gt;
                            &lt;App /&gt;
                          &lt;/React.StrictMode&gt;&comma;
                        )
                      </code></pre>                      
                        <p><span class="verde">Otra manera es utilizar el <strong>operador de Assertionnot null = non null assertion operator "!"</strong> que es una manera de asegurarle a TypeScript que ese elemento no va a ser null:</span></p>
                        <pre class="verde" data-line="0"><code class="language-js">
                          ReactDOM.createRoot(document.getElementById('root')!).render(
                            &lt;React.StrictMode&gt;
                              &lt;App /&gt;
                            &lt;/React.StrictMode&gt;&comma;
                          )
                        </code></pre>
                    </li>                 
                  </ul>

                  <p>Vamos a ir viendo como solucionar el resto de errores que nos aparecen en los ficheros.</p>
                </div>
                <!-- Fin bloque desplegable interior-->
                

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-93').toggle();">
                  <h3>93. Introducción a TypeScript - Primitive Types</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-93" class="hidden">
                  <p>Vamos a comenzar a solucionar los errores que encuentra Typescript en el código. Vemos que en App.tsx, Guitar.tsx, Header.tsx, useCard.ts se van pintando en rojo algunos de estos archivos. No es que el código esté mal escrito (si arrancamos el servidor de desarrollo y probamos vemos que todo funciona bien) sino que más bien tneemos que darle más información a TypeScript. esa información normalmente se la pasamos con algo llamado <span class="destacado">Primitive Type</span>.</p>

                  <ul class="mb-3.75">
                    <li>Los Primitive Types son los tipos de datos que soporta TypeScript de forma nativa.</li>
                    <li>Estos son number, string, boolean, null y undefined. Cuando creamos un objeto, hemos de especificar qué tipo de dato (primitive type) es el que tiene cada propiedad de ese objeto. De igual manera si creamos una variable o si le pasamos parámetros a una función.</li>
                    <li>En el caso de arrays hay una sintaxis especial para crearlos</li>
                  </ul>

                  <p>Abrimos nuestro <span class="file">App.tsx</span> y tras importar state <code class="language-js">import { useCart } from './hooks/useCart'</code>, creamos un nuevo state para verificar si un usuario está autenticado, así es como lo hemos hecho hasta ahora poniendole como valor inicial que el usuario no está logado: <code class="language-js">const [auth, setAuth] = useState(false)</code>. Si nos ponemos encima de auth el intellisense nos muestra que TypeScript infiere que el tipo de auth va a ser boolean, pero si le cambiamos el valor inicial a '20' y volvemos a ponernos encima de auth el IS nos muestra que TS infiere que el valor es number. Si inmediatamente hago un <code class="language-js">setAuth(true)</code> nos lo marca como error y el IS nos indica algo como "no le puedes asignar un booleano porque tú dijiste que era un número". <span class="destacado">En este tipo de acciones es donde TypeScript nos va a proteger, el evitarnos que estemos asignando diferente tipo de dato nos va a permitir escribir un mejor código.</span></p>

                  <img class="my-2.5" src="./src/assets/img/93.png" alt="" />
                  

                  <p>Explica que hay algunos casos de uso para especificar el tipo entre tags <span class="destacado">&lt;&gt;</span> por ejemplo: <code class="language-js">const [auth, setAuth] = useState&lt;number&gt;(20)</code> Pero que no lo hacemos así porque es dar información redundante.</p>

                  <p>Si abrimos nuestro <span class="file">data&gt;db.ts</span> y nos ponemos encima de db vemos como TypeScript infiere el tipo de dato para cada elemento id, name,... Poría decirse que va a escanear nuestro código y va a ser nuestro mejor asistente. De hecho si al segundo elemento de nuestro array le dijeramos que el id es "2" y volviéramos a consultar el IS, veríamos lo que aparece a la derecha de la siguiente captura, que <strong>TS nos especifica que puede ser un number o un string</strong>:</p>
                  <img class="my-2.5" src="./src/assets/img/93-2.png" alt="" />

                  <p>Sin embargo estas guitarras y lo que tenemos en useCart.ts en nuestro carrito es básicamente lo mismo, vamos agregando nosotros las guitarras salvo con algunas excepciones y <span class="destacado">cuando trabajas con objetos, la recomendación es no dejar que TypeScript infiera ese tipo de dato sino que nosotros crearemos nuestros propios grupos de tipo de dato que se les conoce como Types e Interfaces.</span></p>

                </div>
                <!-- Fin bloque desplegable interior-->
                

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-94').toggle();">
                  <h3>94. Introducción a TypeScript - Types e Interfaces</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-94" class="hidden">
                  <p>Si nos colocamos en la variable db vemos un objeto que tiene diferentes propiedades. Cuando tenemos una estructura de este tipo lo mejor es crear lo que se conoce como un Type o Interface. Básicamente es lo mismo, pero veamos un poco más de información de este tema.</p>

                  <ul class="mb-3.75">
                    <li>Types e Interfaces son dos de las características que más vamos a utilizar en TypeScript.</li>                  
                    <li>Ambas pueden ser utilizadas incluso de forma intercambiable, hay muy pocas diferencias entre ambos y en la comunidad vas a encontrar ejemplos con ambos (La verdad es que la comunidad está dividida, unos dicen utilizar interfaces, otros types...) Cuál vas a utilizar en un proyecto? Bueno, el que ya estén utilizando.</li>
                    <li><strong>Es una forma de crear una estructura y definir qué tipo de dato tiene cada propiedad de un objeto o agrupar propiedades de un objeto</strong>.</li>                
                  </ul>

                  <p>Veamos algunos ejemplos. Creemos nuestro primer type para nuestras guitarras. <span class="file">db.ts</span>: la convención de nombrado es con la primera mayúscula.</p>

                  <pre data-line="0-6,7"><code class="language-js">
                    type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  export const db : Guitar[] = [
                      {
                          id: 1,
                          name: 'Lukather',
                          image: 'guitarra_01',
                          description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                          price: 299,
                      },
                  </code></pre>

                  <p>Definimos nuestra estructura Types, la aplicamos a nuestra información y si el tipo de dato no es el correcto nos va a marcar el error. si cambiáramos el tipo de id a string veríamos que nos saca un error y ahí es donde TS nos va a yudar mucho, no vamos a necesitar compilar el proyecto para ver si tiene errores, desde le momento en que estamos escribiendo TS ya nos va marcando si tenemos algún error.</p>

                  <p>La sintaxis para definir nuestra interface es similar usando la palabra interface y sin el "="</p>

                  <pre data-line="0,7"><code class="language-js">
                    interface Guitar {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  export const db : Guitar[] = [
                      {
                          id: 1,
                          name: 'Lukather',
                          image: 'guitarra_01',
                          description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                          price: 299,
                      },
                  </code></pre>

                  <p>La preferencia es types porque es mas corto de escribir pero ambos valen igual. <span class="destacado">Como hemos visto, a nuestra constante db le estamos añadiendo el type Guitar: <code class="language-js">export const db : Guitar[] = [</code> y de hecho si abrimos nuestro <span class="file">useCart.ts</span> vemos que ahí estamos seteando ese db <code class="language-js">const [data] = useState(db)</code>. Si nos ponemos encima de data el IS nos dice que tiene el type Guitar[] por tanto se propaga en nuestro código ese tipo de dato.</span></p>

                  <img class="my-2.5" src="./src/assets/img/93-3.png" alt="" />

                  <p>Si nos ponemos encima de cart el IS nos dice tipo de dato any; en otros componentes como <span class="file">Guitar.jsx</span> vemos que si nos ponemos encima de addToCart el IS nos dice tipo de dato any implícito. <span class="destacado">any en TypeScript es veneno.</span> Veamos cómo solucionarlo.</p>

                  <img class="my-2.5" src="./src/assets/img/93-4.png" alt="" />

                </div>
                <!-- Fin bloque desplegable interior-->
                

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-95').toggle();">
                  <h3>95. Asignar Types a tus Props - Inline Type</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-95" class="hidden">
                  <p>Si nos llenamos de Any es como si no estuviéramos utilizando TS. Hemos de facilitar más información a TS. Vamos a <span class="file">Guitar.tsx</span> donde tenemos <code class="language-js">export default function Guitar({guitar, addToCart}) {</code> ese guitar que es un objeto y el addToCart que es una función. ¿Cómo convertimos esos props hacia TS? hay dos opciones:</p>

                  <ul class="mb-3.75">
                    <li><strong>inline type</strong></li>
                    <li><strong>separate type</strong></li>
                  </ul>

                  <p class="font-bold">inline type</p> 
                  
                  <p>en nuestro <span class="file">Guitar.tsx</span> <span class="destacado">añadimos el type</span></p> 
                  <pre><code class="language-js">
                    type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  </code></pre>
                  <p><span class="destacado">y a continuación especificamos el tipado a esas dos props que toma como parámetro la función de nuestro componente (objeto "guitarra" y funcion "addToCart"). Para especificar el tipo de dato usamos la sintaxis con ":"</span></p>

                  <pre><code class="language-js">                    
                  export default function Guitar({guitar, addToCart} : {guitar : Guitar, addToCart: (item: Guitar) => void}) {
                  </code></pre>

                  <p><span class="destacado">El primer parámetro es un objeto de tipo Guitar</span> y en cuanto lo tipamos vemos que del parámetro ya nos desaparece el aviso/error (antes el IS nos lo marcaba como any y ya nos aparece que es de tipo Guitar); </p>
                      
                  <img class="my-2.5" src="./src/assets/img/95-1.png" alt="" />

                  <p>Fijémonos que todas las propiedades que definimos en nuestro type </p>
                  <pre><code class="language-js">
                    type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }                      
                  </code></pre>

                  <p>si en el return() de nuestro componente Guitarra (la parte de la vista) sustituyéramos por ejemplo <code class="language-js">{name}</code> por <code class="language-js">{guitar.}</code> vemos como en el IS solo me aparecen disponibles esas opciones (los tipos de datos que yo definí en ese objeto es lo que puedo imprimir ahí), no tenemos que enviarlo a la consola, ya lo tenemos disponible en VSC y eso va hacer que escribamos código más rápidamente:</p>

                  <img class="my-2.5" src="./src/assets/img/95-2.png" alt="" />
                  
                  <p>Para definir el tipo del segundo parámetro (función addToCart que toma una guitarra), nos vamos al fichero <span class="file">App.tsx</span> e inspeccionamos el aviso del IS al ponernos encima del prop addToCart que aún no hemos tipado --&gt; <strong>item(any) =&gt; void</strong>.</p>
                    
                  <img class="my-2.5" src="./src/assets/img/95-3.png" alt="" />

                  <p>Copiamos ese código. "void" es algo muy común en java, se usa cuando una función no devuelve nada. El any vamos a quitarlo: cuando yo agrego un elemento con el onClick del botón, le paso una guitarra completa:</p> 

                  <script type="text/plain" class="language-js">
                    <button 
                      type="button"
                      className="btn btn-dark w-100"
                      onClick={() => addToCart(guitar)}
                  >Agregar al Carrito</button>
                  </script>

                  <p>así que cambiamos ese any por Guitar, le decimos así que el item que maneja esa función que agrega tiene que ser una guitarra de tipo Guitarra. <span class="destacado">Y en definitiva estamos tipando ese parámetro como una función que toma un objeto Guitarra y no retorna nada.</span></p>
                      
                  <img class="my-2.5" src="./src/assets/img/95-1.png" alt="" />

                  <p>Ya desaparecen los errores/avisos. Estamos tipando fuertemente. Si por ejemplo me voy a la <span class="file">App.tsx</span> y le quitamos la propiedad addToCart de aquí:</p>

                  <script type="text/plain" class="language-js">
                    <div className="row mt-5">
                      {data.map((guitar) => (
                          <Guitar 
                            key={guitar.id}
                            guitar={guitar}
                            addToCart={addToCart}
                          />
                      ))}              
                  </div>
                  </script>

                  <p>vemos que nos marca un error. Por tanto nos va a indicar si le falta algo, si escribimos algo mal, si le pasamos un valor de forma incorrecta</p>
                    
                  <img class="my-2.5" src="./src/assets/img/95-4.png" alt="" />

                  <p>Vamos a ver la otra sintasis de <strong>separate type</strong> que él indica que le gusta más.</p>

                </div>
                <!-- Fin bloque desplegable interior-->
                

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-96').toggle();">
                  <h3>96. Asignar Types a tus Props - Type Separado</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-96" class="hidden">
                  <p class="font-bold">separate type</p> 
                  <p>Veamos esta otra sintaxis que es menos confusa: podríamos hacer salto de línea a lo que tenemos ahora mismo para que quedara un poco más ordenado:</p>

                  <pre><code class="language-js">
                    export default function Guitar({guitar, addToCart} : {
                      guitar : Guitar, 
                      addToCart: (item: Guitar) => void
                  }) {
                  </code></pre>

                  <p>Sin embargo es mejor tener un type (o una interface) y tenerlo separado para minimizar la posibilidad de cometer errores:</p>

                  <pre><code class="language-js">
                    type GuitarProps = {
                      guitar : Guitar, 
                      addToCart: (item: Guitar) => void
                  }                
                  export default function Guitar({guitar, addToCart} : GuitarProps) {
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
                

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-97').toggle();">
                  <h3>97. Creando un Archivo de Types ¿Donde y como hacerlo?</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-97" class="hidden">
                  <p>Vamos a crear un archivo que centralice los types que se van a compartir más de una vez. Si nos fijamos ahora mismo el type Guitar que hemos creado lo tenemos tanto en <span class="file">db.ts</span> como en <span class="file">Guitar.tsx</span>, si tuviéramos que modificarlo porque el proyecto por ejemplo crece, el mantenimiento se hace complicado. <span class="destacado">Cuando tenemos un type que se comparte en diferentes componentes o Hooks lo mejor es ponerlo en su propio archivo</span>, hay dos maneras de hacerlo.</p>

                  <p>Si en en src creamos un archivo nuevo <strong>types.d.ts</strong> y metemos ahí nuestro types, creado así con ese nombre no necesitaríamos importarlo. Sin embargo ¡¡el equipo de desarrollo de TS no recomienda hacerlo de esta forma!!!</p>

                  <p>Creamos carpeta y archivo <strong>types>types.ts</strong> (también se podría llamar index.ts). En el solo metemos el type Guitar al cual le ponemos delante la palabra export:</p>

                  <pre><code class="language-js">
                    export type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  </code></pre>

                  <p>importamos ese type en los ficheros donde se va a utilizar: <span class="file">db.ts</span> y <span class="file">Guitar.tsx</span> </p>
                  
                  <ul class="mb-3.75">
                    <li>si hemos nombrado el fichero como <strong>index.ts</strong> lo importaremos así: <code class="language-js">import type {Guitar} from '../types'</code></li>
                    <li>si hemos nombrado el fichero como <strong>types.ts</strong> lo importaremos así: <code class="language-js">import type {Guitar} from '../types/types'</code></li>                  
                  </ul>
                  
                  <p>Como vemos no metemos en ese archivo exclusivo de types el otro type GuitarProps, porque no se trata de un type que vayamos a utilizar en diferentes componentes o diferentes Hooks; en este caso es un type exclusivo del componente <span class="file">Guitar.tsx</span>. <span class="destacado">Habitualmente así es como vamos a definir nuestros types, en el componente donde se requieren y en el caso de que se vaya a compartir en mas sitios (otros componentes y/o Hooks) entonces se mueve al archivo específico de types.</span></p>

                  <p>Como vemos, ya están completamente tipados nuestro <span class="file">db.ts</span> y nuestro componente de guitarra<span class="file">Guitar.tsx</span>. Migremos a continuación nuestro Hook personalizado para solucionar esos Any que aparecen en nuestro cart.</p>
                </div>
                <!-- Fin bloque desplegable interior-->


                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-98').toggle();">
                  <h3>98. Añadiendo un Type para los elementos del Carrito / 99. Heredar y extender un Type</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-98" class="hidden">
                  <p>Si miramos nuestro custom Hook <span class="file">useCart.ts</span> vemos que tenemos dos states: data tiene el type Guitar pero cart tiene un tipo Any.</p>
                  <pre><code class="language-js">
                    const [data] = useState(db)
                    const [cart, setCart] = useState(initialCart)
                  </code></pre>
                  <p><span class="destacado">Algo muy común en TS es que cuando obtenemos datos externos, sea de localStorage o de una consulta con FetchAPI, a TS se le hace muy complicado inferir el tipo de dato.</span> ¿Como hacemos para indicar que este const initialCart va a ser de tipo Guitar (o un tipo de elemento en un carrito)?</p>
                  <pre><code class="language-js">
                    const initialCart = () => {
                      const localStorageCart = localStorage.getItem('cart')
                      return localStorageCart ? JSON.parse(localStorageCart) : []
                  }
                  </code></pre>

                  <p>Importamos nuestro type <code class="language-js">import type { Guitar } from '../types/types'</code> Le especificamos a ese initialCart que el tipo de dato va a ser Guitar[] (pero array, que es un carrito):</p>

                  <pre data-line="0"><code class="language-js">
                    const initialCart = () : Guitar[] => {
                      const localStorageCart = localStorage.getItem('cart')
                      return localStorageCart ? JSON.parse(localStorageCart) : []
                  }
                  </code></pre>

                  <p>sin embargo inmediatamente vemos en nuestro código que TS se queja: <strong>"oye, estas diciendo que esto es un tipo Guitar, pero hasta en 3 funciones de tu Hook se intenta utilizar una propiedad "quantity" que no existe en ese tipo Guitar"</strong>. Cuando intentamos agregar una guitarra al carrito, sí es un objeto Guitar pero tiene una propiedad adicional llamada "quantity" que se requiere para estar en el carrito</p>
                  <img class="my-2.5" src="./src/assets/img/98.png" alt="" />
                  
                  <p>Podríamos resolverlo, añadiendo un nuevo type en nuestro archivo <span class="red">types.ts</span>:</p>
                  <pre><code class="language-js">
                    export type CartItem = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                      quantity: number
                    }
                  </code></pre>
                  <p>Importamos nuestro type <code class="language-js">import type { CartItem } from '../types/types'</code> Le especificamos a ese initialCart que el tipo de dato va a ser CartItem[] (pero array, que es un carrito):</p>
                  
                  <pre data-line="0"><code class="language-js">
                    const initialCart = () : CartItem[] => {
                      const localStorageCart = localStorage.getItem('cart')
                      return localStorageCart ? JSON.parse(localStorageCart) : []
                    }
                  </code></pre>
                  
                  <p>así ya nos desaparecen los errores con el quantity que teníamos en nuestras funciones (aunque aún quedan algunos errores en parámetros que los veremos). </p>
                  <img class="my-2.5" src="./src/assets/img/98-2.png" alt="" />

                  <p>Este código funciona pero se puede mejorar porque los atributos id, name, image, description, price son exactamente iguales en los dos types Guitar y CartItem.</p>
                  
                  <pre data-line="1-5,8-12"><code class="language-js">
                    export type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  export type CartItem = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                      quantity: number
                  }
                  </code></pre>

                  <p>TypeScript nos permite heredar como si fuera de una clase a otra y podemos hacerlo heredando todos esos atributos dentro de cartItem</p>

                  <p class="naranja">Heredar y extender un Type</p>

                  <p>Ya hemos definido nuestro segundo tipo de dato. Teníamos <strong>Guitar</strong> pero como nuestro carrito de compras tiene una propiedad adicional "quantity" hemos creado un type llamado <strong>CartItem</strong>. Ambos comparten muchos atributos por lo que apliquemos herencia para simplicar el código, también para que si cambia alguno de ellos el mantenimiento sea más sencillo. Como es un poco diferente en types e interfaces veos ambos.</p>

                  <p class="font-bold">herencia en types</p>

                  <p><span class="destacado">Borramos los atributos duplicados del type que hereda y en su declaración tras el "=" añadimos el nombre del type del que queremos que herede seguido de "&"</span></p>

                  <pre data-line="7"><code class="language-js">
                    export type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  export type CartItem = Guitar & {
                      quantity: number
                  }
                  </code></pre>

                  <p><strong>Podríamos perfectamente generar una interface y heredar de nuestro type:</strong> <span class="destacado">el "=" se cambia por la palabra "extends", de manera similar a lenguages como Java o php y se elimina el "&"</span></p>
                  <pre data-line="7"><code class="language-js">
                    export type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  export interface CartItem extends Guitar {
                      quantity: number
                  }
                  </code></pre>

                  <p>Existe otra forma de hacerlo, con los <span class="destacado">utility types</span>, solo se puede hacer con la sintaxis de type</p>
                
                </div>
                <!-- Fin bloque desplegable interior-->


                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-100').toggle();">
                  <h3>100. Utility Types en TypeScript</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-100" class="hidden">
                  <p>Acabamos de ver como se aplica herencia utilizando types e interfaces pero eso hereda todo el tipo de dato y sus atributos completos. Si bien podríamos hacer algo como cambiarle el number por string al atributo id del type original (no lo tengo muy claro que haga lo que dice por lo que veo en el IS)</p>

                  <pre data-line="1,9"><code class="language-js">
                    export type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  export type CartItem = Guitar & {
                      quantity: number
                      id: string
                  }
                  </code></pre>

                  <p>Otras veces lo que vamos a querer es, manteniendo los mismos tipos de datos simplemente tener algunos atributos de un type y/o omitir otros. Para eso es muy útil lo que se conoce como <span class="destacado"><a class="text-[#ffffff]" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" target="_blank">Utility Types</a></span>. Hay unos cuantos, en cada nueva versión se agregan más, va a hacer que nuestro código sea más corto y son muy útiles cuando comenzamos a tener varios  types interdependientes que comparten atributos. Pone como ejemplo estos dos para explicar sintaxis y como se utilizan <strong>Pick&lt;Type&comma; Keys&gt;</strong> y <strong>Omit&lt;Type&comma; Keys&gt;</strong></p>

                  <p>En el siguiente ejemplo el Utility Type Pick selecciona del type Guitar los atributos id, name y price y los coloca en este nuevo type CartItem:</p>
                  <script type="text/plain" class="language-js">
                    export type CartItem = Pick<Guitar, 'id' | 'name' | 'price'>
                  </script>

                  <p>aquí le agregaríamos el atributo extra "quantity" que no existe en ese type Guitar:</p>
                  <script type="text/plain" class="language-js">
                    export type CartItem = Pick<Guitar, 'id' | 'name' | 'price'> & {
                      quantity: number
                    }
                  </script>

                  <p>Omit es para lo contrario, excluir los atributos que se especifiquen:</p>
                  <script type="text/plain" class="language-js">
                    export type CartItem = Omit<Guitar, 'id' | 'name' | 'price'> & {
                      quantity: number
                  }
                  </script>

                  <p>Veamos a continuación como especificar type a los parámetros que aún nos marca en nuestro código como aviso/error</p>
                </div>
                <!-- Fin bloque desplegable interior-->
                          

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-101').toggle();">
                  <h3>101. Agregando el Nuevo Type a nuestro código / 102. Creando un Type para el ID de la guitarra</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-101" class="hidden">
                  <p>Vamos a nuestro Hook <span class="file">useCart.ts</span>para "terminar de migrar a TS" nuestras funciones:</p>
                  
                  <p class="font-bold">function addToCart(item){}</p>
                  <p>Importamos nuestro type Guitar y le especificamos al parámetro de la fcn que es de tipo Guitar</p>
                  <pre data-line="0"><code class="language-js">
                    function addToCart(item : Guitar) {
                      const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                      if(itemExists >= 0 ) { // existe en el carrito
                          if(cart[itemExists].quantity >= MAX_ITEMS) return
                          const updatedCart = [...cart]
                          updatedCart[itemExists].quantity++
                          setCart(updatedCart)
                      } else {
                          item.quantity = 1
                          setCart([...cart, item])
                      }
                  }
                  </code></pre>
                  <p>Vemos que nos marca estos errores ¿por qué?</p>
                  <img class="my-2.5" src="./src/assets/img/101-1.png" alt="" />
                  
                  <p>Si miramos nuestro fichero de <span class="file">types.ts</span> vemos que el type Guitar no tiene ninguna propiedad quantity, sin embargo sí habíamos definido un nuevo type CartItem que heredaba del type Guitar al que le añadíamos esa propiedad:</p>          
                  <pre><code class="language-js">
                    export type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                    }
                    export type CartItem = Guitar & {
                      quantity: number
                    }
                  </code></pre>
                  
                  <p><span class="destacado">Vamos a castear: tomar un tipo de dato y convertirlo a otro:</span> <strong>creamos una nueva variable newItem de tipo CartItem que toma una copia de lo que le estamos pasando a esta función item (usamos el operador spread) y además tiene la nueva propiedad quantity</strong>:</p>
                  
                  <pre class="verde" data-line="8,9"><code class="language-js">
                    function addToCart(item : Guitar) {
                      const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                      if(itemExists >= 0 ) { // existe en el carrito
                        if(cart[itemExists].quantity >= MAX_ITEMS) return
                        const updatedCart = [...cart]
                        updatedCart[itemExists].quantity++
                        setCart(updatedCart)
                      } else {
                        const newItem : CartItem = {...item, quantity : 1}
                        setCart([...cart, newItem])
                      }
                    }
                  </code></pre>        
                  
                  <p class="naranja">Creando un Type para el ID de la guitarra</p>
        
                  <p>Si nos fijamos en nuestro archivo <span class="file">types.ts</span> vemos que el id de las guitarras es de tipo number con lo que podríamos solucionar fácilmente nuestro "problema" en las tres funciones que nos quedan por migrar de nuestro custom Hook <span class="file">useCart.ts</span> tipando como <strong>number</strong> los tres parámetros id de las funciones:</p>
                  <pre><code class="language-js">
                    function removeFromCart(id) { --> function removeFromCart(id : number) {
                      function decreaseQuantity(id) { --> function decreaseQuantity(id : number) {
                        function increaseQuantity(id) { --> function increaseQuantity(id : number) {
                        </code></pre>

                  <p>pero <strong>¿qué pasaría si a futuro migramos y digamos que ya dejamos de utilizar MySQL o PostgreSQL, que tienen los IDS como tipo number y nos vamos hacia MongoDB que utiliza strings?</strong> pues que tendríamos que tener cuidado de cambiar el tipo string en nuestro fichero de types y también en todos los lugares en donde en nuestro custom Hook usáramos esos ids. <strong>Normalmente queremos que los posibles cambios repercutan en los menores lugares posibles, buscamos un código sencillo con buen mantenimiento.</strong> Por ello podemos:</p>
                  
                  <ul class="mb-3.75">
                    <li>Crear un nuevo type empleando el <span class="destacado">Utility Type Pick</span>, de manera que si eso cambia a futuro solo tenemos que tocar el type Guitar: <code class="language-js">export type GuitarID = Pick&lt;Guitar &comma; &apos;id&apos;&gt;</code></li>
                    <li>Crear un nuevo type empleando algo que se conoce como <span class="destacado">Lookup:</span> <code class="language-js">export type GuitarID = Guitar['id']</code>. En vez de tenerlo en este archivo de types lo podemos utilizar tal cual en nuestro Hook:
                    <pre><code class="language-js">
                    function removeFromCart(id) { --> function removeFromCart(id : Guitar['id']) {
                    function decreaseQuantity(id) { --> function decreaseQuantity(id : Guitar['id']) {
                    function increaseQuantity(id) { --> function increaseQuantity(id : Guitar['id']) {
                    </code></pre></li>
                  </ul>
                  
                  <p>Este evento no es necesario porqeu se setea en automático así que lo quitamos (la e):</p>
                  
                  <img class="my-2.5" src="./src/assets/img/101-2.png" alt="" />

                  <p><strong>Los que vemos que TS infiere bien, como por ejemplo los states derivados isEmpty (retorna un boolean) y carTotal (devuelve un number), no hay que ser redundantes y no hacemos nada más.</strong> Si TS no lo puede inferir como era el caso con LocalStorage nosotros intervenimos, y de esa forma tenemos completamente tipado nuestro Hook.</p>

                  <p>En el siguiente vídeo vamos a typar los props del Header, algunas son funciones y tienen una sintaxis particular.</p>              
                </div>
              <!-- Fin bloque desplegable interior-->
              

              <!-- Bloque desplegable interior-->
              <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-103').toggle();">
                <h3>103. Typando los Props del Header y Building del proyecto</h3>
                <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
              </div>
                <div id="seccion8-103" class="hidden">
                  <p>Añadamos TS a nuestro <span class="file">Header.tsx</span> que tiene entre otras cosas nuestro cart y los states derivados. Vamos a crear el type no inline (que es mas complicado en cuanto a sintaxis) sino separado y además solo en este .tsx (no lo metemos en el fichero de definición de types) porque es exclusivo para Header:</p>

                  <pre data-line="0,2,3,7"><code class="language-js">
                    import type { CartItem, Guitar } from '../types/types'

                    type HeaderProps = {                      
                    }
                    export default function Header({
                      cart, removeFromCart, decreaseQuantity, 
                      increaseQuantity, clearCart, isEmpty, cartTotal
                  } : HeaderProps) {
                  </code></pre>

                  <p>Para el siguiente prop <strong>removeFromCart</strong>, que es una función miramos en App.tsx, en la parte de la vista donde el tag del componente Header que es donde se envía ese prop; el IS nos dice que es una función que envía un id de tipo number y no devuelve nada. Pues eso mismo es lo que vamos a especificar en la definición de nuestro type HeaderProps. Y hacemos lo mismo con las siguientes props funciones <strong>decreaseQuantity</strong> e <strong>increaseQuantity</strong></p>

                  <pre><code class="language-js">
                    type HeaderProps = {
                        cart: CartItem[] //el carrito cart es de tipo CartItem como arreglo
                        removeFromCart: (id: Guitar['id']) => void
                        decreaseQuantity: (id: Guitar['id']) => void
                        increaseQuantity: (id: Guitar['id']) => void
                        clearCart: () => void
                        isEmpty: boolean
                        cartTotal: number
                    }

                    export default function Header({
                      cart, removeFromCart, decreaseQuantity, 
                      increaseQuantity, clearCart, isEmpty, cartTotal
                  } : HeaderProps) {
                  </code></pre>

                  <p>Comenta que una vez que hemos agregado <code class="language-js">type HeaderProps = {}</code> que se le conoce como el <span class="destacado">function signature o firma</span> estamos mucho más protegidos por parte de TS para que no pasemos cosas indebidas a nuestros componentes etc. Vemos ese tipo de posibles errores desde el momento en que estamos escribiendo el código, sin necesidad de esperar a compilar.</p>

                  <p>Compilamos nuestro proyecto. Vemos en el <span class="file">package.json</span> en el bloque de scripts>build que se llama a "tsc && vite build". <strong>tsc es el TypeScript Compiler</strong>. <span class="destacado">npm run build</span> construye nuestro proyecto haciendo todas las transformaciones de typescript hacia javascript. <span class="destacado">Ya con el build listo podemos subirlo a Netlify o Vercel o Github</span>.</p>

                </div>
                <!-- Fin bloque desplegable interior-->
                

              
          </div>
          <!-- Fin div colapsable-->

      </div>
      <!-- FIN SECCION 8 -->  
       
   	
      <!-- SECCION 7 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
        
        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion07').toggle();">
          <h2>Sección 7: PROYECTO - Carrito de Compras - Crear tus propios Hooks</h2>
          <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
        </div>

        <div id="seccion07" class="hidden">          

          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion85-90').toggle();">
            <h3>85. Ventajas y Como crear tus propios Hooks / 86. Instalando dependencias / 87. Creando el Hook de useCart</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion85-90" class="hidden">
            <p class="naranja">Ventajas y Como crear tus propios Hooks</p>
            
            <p class="font-bold">Crear nuestro propios Hooks</p>
            <ul class="mb-3.75">
              <li><strong>Existe una gran ventaja de crear tus propios hooks, y esta es la de incorporar state y otros hooks de React en tu propio código para poderlo reutilizar en otros proyectos:</strong> esta es una gran ventaja porque actualmente nuestro código reside en nuestros componentes y nuestros componentes tienen cierta presentación, lo que lo hace que nuestro código no sea muy reutilizable para otros proyectos. Sin embargo, con un hook personalizado podemos copiar y adaptar todo lo que requerimos.</li>
              <li><strong>Otra gran ventaja es la de organizar tu código:</strong> de esta forma el hook se va a encargar de toda la lógica, mientras que tu componente solamente se encarga de mostrar la información, la vista, solamente se encarga de mostrar la presentación y el código HTML.</li>
              <li><strong>Nuestro código personalizado tendrá todas las ventajasde React, como son tener su propio State, podremos agregar Effects, integrar otros hooks de React y el performance que esto incluye.</strong></li>
              <li><strong>Va a ser reutilizable con otros proyectos</strong></li>
              <li>va a ser fácil de escribir testing de escribir las pruebas para tu código.</li>
            </ul>

            <p class="font-bold">¿Cómo vamos a crear nuestros propios hooks?</p>
            <ul class="mb-3.75">
              <li>Los hooks son funciones de JavaScript, pero tienen algunas reglas como vimos anteriormente.</li>
              <li><strong>Nuestros hooks deben seguir la convención de nombrado que utiliza React, que es <span class="destacado">use</span> seguido del nombre de nuestro hook, como vimos anteriormente con los hooks <strong>Usestate, useEffect, etcétera</strong></strong> de esta forma React escanea tu código en búsqueda de posibles problemas con las reglas de los hooks y se segura de que nuestro código personalizado cumpla los estándares de React.</li>
              <li><span class="destacado">Importante!</span> un hook normalmente solo debe de tener lógica y no presentación, porque para la parte de presentación están los componentes.</li>
            </ul>

            <p class="naranja">Instalando dependencias y Creando el Hook de useCart</p>
            <p>Vamos a convertir el proyecto que llevamos hasta ahora de guitarla para que use un <strong>custom hook</strong>. Descargamos la carpeta (guitarla-useCart), la agregamos al area de trabajo en VSC, boton derecho "abrir en terminal integrado" e instalamaos dependencias con <span class="destacado">npm install</span> que son en base al sistema operativo.</p>

            <p>Vamos a estar moviendo todo el código de antes del return() del App.jsx que maneja bastante lógica a un custom Hoook, para dejar limpio nuestro componente y hacerlo más reutilizable</p>

            <p><span class="destacado">Creamos carpeta hooks donde se colocan los custom hooks</span>. Dentro creamos nuestro archivo hook personalizado que llamamos <strong>useCart.ts</strong> (recordar que no es .jsx porque eso tiene parte de vista es el template). Los hooks son funciones de js con lo cual podemos definirlo como función "normal" o función arrow function pero <span class="destacado">siempre el nombre tiene que tener la palabra use y así React "escanea" el código para posibles violaciones de las reglas de los hooks</span>:</p>
            <span class="file">useCart.ts</span><br>
            <pre><code class="language-js">
              function useCart(){
                
              }
            </code></pre>
            <pre><code class="language-js">
              const useCart = () => {

              }
            </code></pre>

            <p>aquí es donde vamos a tener toda la lógica, todo lo que está antes de los return() del App.js y Header.jsx. Todo eso vamos a exportarlo para poder importarlo en otros componentes o donde sea que vamos a utilizar nuestro custom hook, pudiendo exportarlo de todas las maneras que se hacen exports en js:</p>
            <pre><code class="language-js">
              const useCart = () => {

              }
              export default useCart
            </code></pre>
            <pre><code class="language-js">
              const useCart = () => {
                
              }
              export {
                useCart//de esta forma cuando lo importemos tenemos que usar ese mismo nombre
              }
            </code></pre>
            <pre><code class="language-js">
              export const useCart = () => {
                console.log('Desde useCart')  
              }                 
            </code></pre>

            <p>Para usar el custom Hook en nuestra App.jsx hemos de importarlo <code class="language-js">import { useCart } from './hooks/useCart'</code>. Si quisiéramos llamarlo dentro de nuestro componente principal de aplicación App.jsx hay que llamar a la función de igual manera que hacíamos con los otros hooks: <code class="language-js">useCart()</code></p>
          </div>
          <!-- Fin bloque desplegable interior-->

          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion88').toggle();">
            <h3>88. Definir Valores y extraerlos en el Hook</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion88" class="hidden">
            <p>¿Como hacemos para que el comportamiento de nuestro custom hook sea mas similar digamos al useState en <code class="language-js">const[data] = useState(db)</code> devolviendo algo. Supongamos que creamos una variable <code class="language-js">const auth = true</code> ¿como hacemos para que esté disponible en nuestro App.jsx? <strong>tenemos que agregar un return a continuación, que puede ser un Array pero se recomienda que sea un objeto.</strong> <span class="destacado">La ventaja de que sea un objeto es, que el mismo nombre con el que nombremos nuestras variables, funciones o state va a ser el mismo nombre para usarlo en nuestro componente.</span> Si usáramos un arreglo los retorna por posición, pero como normalmente vamos a tener en nuestro hook personalizado diferentes funciones/variables/states personalizados, lo ideal es que podamos acceder a ellos por medio de su nombre específico.</p>
            
            <span class="file">useCart.ts</span>
            <pre><code class="language-js">
              export const useCart = () => {

                const auth = true
                return {
                  auth //de esta forma esta variable estará disponible donde yo esté utilizando mi custom hook
                }
              }
            </code></pre>

            <p>Por tanto. Una vez creada mi variable llamada auth, y colocada en el return de mi custom hook, en mi componente accedo a ella de la siguiente manera:</p>

            <span class="file">App.jsx</span>
            <pre data-line="3"><code class="language-js">
              import { useCart } from './hooks/useCart'

              function App() {
                const { auth } = useCart()
                console.log(auth)
            </code></pre>

            <p>De hecho si hacemos la prueba en nuestro componente de extraer una nueva variable <strong>carrito</strong> que en mi custom hook sí he definido pero no he metido en el return, obtengo un <strong>Undefined</strong> porque no podemos acceder a ese valor. Hemos de meterla en el return, separada por coma del resto de variables/funciones. Es muy similar a un export de los módulos de ECMAScript.</p>

            <span class="file">useCart.ts</span>
            <pre><code class="language-js">
              export const useCart = () => {

                const auth = true
                const carrito = []
                return {
                  auth,
                  carrito
                }
              }
            </code></pre>
            <span class="file">App.jsx</span>
            <pre data-line="3"><code class="language-js">
              import { useCart } from './hooks/useCart'

              function App() {
                const { auth, carrito } = useCart()
                console.log(auth)
            </code></pre>

            <p>Por tanto si tenemos distintas variables/funciones/states en nuestro custom hook hemos de colocarlas separadas por "," en el return de nuestro custom hook y, en nuestro componente, vamos a acceder a todo ello en estas "{}" de aquí ¡con el mismo nombre que tienen! <code class="language-js">const { auth, carrito } = useCart()</code></p>

            <p>Veamos como migrar la lógica de nuestro carrito para usar nuestro custom hook</p>
            
          </div>
          <!-- Fin bloque desplegable interior-->


          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion89').toggle();">
            <h3>89. Migrando el Código hacia useCart / 90. Finalizando el Hook y Consideraciones</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion89">
            <ul class="mb-3.75">
              <li>Tomamos toda la lógica de antes del return de nuestro componente principal App.jsx y nos la llevamos a nuestro custom kook useCart.ts.</li>
              <li>Como los Hooks useState,useEffect y useMemo ya no se usan en los componentes sino en nuestro hook personalizado useCart.ts, quitamos el import de nuestros componentes y nos llevamos ahí la importación. También hacemos lo mismo con los datos:
                <span class="file">useCart.ts</span>
                <pre><code class="language-js">
                  import { useState, useEffect, useMemo } from 'react'
                  import { db } from '../data/db'

                  //necesitamos exportar toda esa funcionalidad para hacerla disponible donde quiera que yo importe mi custom hook
                  return {
                    data,
                    cart,
                    addToCart,
                    removeFromCart,
                    decreaseQuantity,
                    increaseQuantity,
                    clearCart,
                    isEmpty,
                    cartTotal
                }
                </code></pre>
                </li>
                <li>
                <p>
                  <span class="file">App.jsx</span> Esta sería la expresión total para usar nuestro custom Hook y las funciones que tiene disponibles:</p>
                  <pre><code class="language-js">
                    import { useCart } from './hooks/useCart'
                  
                    function App() {                      
                      const { data, cart, addToCart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart, isEmpty, cartTotal } = useCart()
                  </code></pre>
                  
                  <p>También quitamos del tag Guitar el prop <strong>setCart={setCart}</strong> porque esa función <code class="language-js">const [cart, setCart] = useState(initialCart)</code>ya no está disponible al haberlo migrado a nuestro custom hook junto al resto de la funcionalidad:</p>
                  <pre class="rojo" data-line="3"><code class="language-js">
                    &lt;Guitar 
                    key=&lcub;guitar.id&rcub;
                    guitar=&lcub;guitar&rcub;
                    setCart=&lcub;setCart&rcub;
                    addToCart=&lcub;addToCart&rcub;
                  /&gt;	
                  </code></pre>
                <p>Como vemos nuestro Hook tiene todas estas funciones. Algunos Hooks tienen más funciones otros menos, por ejemplo useState nos devuelve dos valores (state y funcion) y useEffect no devuelve nada es más toma como parámetro un callback. Si probamos de nuevo nuestra app vemos como funciona todo correctamente.</p>
                
              </li>
              <li><p>Movamos también la lógica que tenemos presente en el componente que tiene la vista del carrito Header.jsx: tanto el import de useMemo como este código nos lo llevamos a nuestro custom Hook <code class="language-js">import { useMemo } from 'react'</code></p>
              <pre><code class="language-js">
                // State Derivado
                const isEmpty = useMemo( () => cart.length === 0, [cart])
                const cartTotal = useMemo( () => cart.reduce( (total, item ) => total + (item.quantity * item.price), 0), [cart] )
              </code></pre>
              </li>
              <p>Recordemos que también tenemos que hacer disponibles estas dos funciones, añadiéndolas a la "lista objeto" de exportación que aparece en el return de nuestro Hook</p>

              <p>Si probamos, vemos que tenemos muchos errores. Podríamos pensar en importar en nuestro componente Header.jsx el custom Hook y crear una nueva variable para usar las dos funciones isEmpty y cartTotal del custom Hook useCart(). Pero en ese caso vemos que no nos agrega guitarras al carrito ni funciona ¿por qué? <span class="destacado">Porque los custom Hooks funcionan como instancias de una clase, de esa manera con una variable en cada componente haciendo lo siguiente, en cada componente estaríamos creando un carrito distinto:</span></p>
              <span class="file">App.jsx</span><br>
              <pre data-line="2"><code class="language-js">
                import { useCart } from './hooks/useCart'
                function App() {                    
                  const { data, cart, addToCart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart} = useCart()
              </code></pre>
              <span class="file">Header.jsx</span><br>
              <pre data-line="2"><code class="language-js">
                import { useCart } from './hooks/useCart'
                function App() {                    
                  const { sEmpty, cartTotal } = useCart()
              </code></pre>
              <p>Los carritos no saben de la existencia uno del otro, no están conectados, no están sincronizados. Sí, toda esa lógica está solo en nuestro custom Hook useCart.ts que es único, pero cada vez que instanciamos (ver los dos códigos anteriores) estamos creando un nuevo data y un nuevo cart:</p>

              <span class="file">useCart.ts</span>
              <pre><code class="language-js">
                const [data] = useState(db)
                const [cart, setCart] = useState(initialCart)
              </code></pre>

              <p>No funcionaría porque es como si estuviéramos creando nuevos objetos que siempre van a ser diferentes. <span class="destacado">Por tanto solo podemos tener una instacia de nuestro carrito de compras.</span> Eliminamos ese código de Header.jsx y extraemos en App.jsx esas dos nuevas funciones carTotal y isEmpty que acabamos de añadir en nuestro custom Hook, las pasamos via props y las extraemos en el Header:</p>
              
              <span class="file">App.jsx</span>
              <pre data-line="0,10-11"><code class="language-js">
                const &lcub; data&comma; cart&comma; addToCart&comma; removeFromCart&comma; decreaseQuantity&comma; increaseQuantity&comma; clearCart&comma; isEmpty&comma; cartTotal &rcub; = useCart()

                return (
                &lt;&gt;
                  &lt;Header 
                  cart=&lcub;cart&rcub;
                  removeFromCart=&lcub;removeFromCart&rcub;
                  decreaseQuantity=&lcub;decreaseQuantity&rcub;
                  increaseQuantity=&lcub;increaseQuantity&rcub;
                  clearCart=&lcub;clearCart&rcub;
                  isEmpty=&lcub;isEmpty&rcub;
                  cartTotal=&lcub;cartTotal&rcub;
                  /&gt;
              </code></pre>

              <span class="file">Header.jsx</span>
              <pre><code class="language-js">
                export default function Header({cart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart, isEmpty, cartTotal}) {
                  return (
              </code></pre>

              <p>Y así finalmente no vamos a tener errores y va a estar sincronizado nuestro state con las funciones de nuestro custom Hook. Aquí comenta que para manejar múltiples instancias de un objeto se maneja con un administrador global del estado como puede ser Redux toolkit, sustance, context API que lo vamos a ver un poco mas adelante</p>

              <p>Como vemos nuestros componentes quedan limpios sin lógica, <strong>aún habrá ciertos casos donde necesitemos poner código antes del return de nuestro componente como apps con múltiples páginas usando React Router DOM o quieres ejecutar algún query una vez cargues en cierto componente.</strong></p>
            </li>
            </ul>
            

          </div>
          <!-- Fin bloque desplegable interior-->           

           
        </div>
        <!-- Fin div colapsable-->
      
      </div>
      <!-- FIN SECCION 7 -->
      
      
      <!-- SECCIÓN 6 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
      
        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion6').toggle();">	
          <h2>Sección 6: PROYECTO - Carrito de Compras - Creando el Carrito, introducción a Hooks y más</h2>				
          <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
        </div>
        
        <div id="seccion6" class="hidden">        
              
              
          <!-- BLOQUE CÓDIGO PROVISIONAL -->
          <div>
            <p class="rojo">App.jsx</p>
            <script type="text/plain" class="language-js h-300">
              import { useState, useEffect } from "react"
              import Guitar from "../components/Guitar"
              import Header from "../components/Header"
              import { db } from "./data/db"
              
              function App() {
                  //console.log(db)
                  // const [data, setData] = useState([])
                  // useEffect( () => {
                  //     setData(db)
                  // },[])
              
                  const initialCart = () => {
                      const localStorageCart = localStorage.getItem('cart') // lo primero es recuperar de localStorage
                      //a continuación comprobamos si hay algo en esa variable:
                      return localStorageCart ? JSON.parse(localStorageCart): []
                  }
                  const [data] = useState(db)    
                  const [cart, setCart] = useState(initialCart)
                  const MAX_ITEMS = 5
                  const MIN_ITEMS = 1
              
                  useEffect(() => {
                      localStorage.setItem('cart', JSON.stringify(cart))
                  }, [cart])
                  
              
                  function addToCart(item){
                      const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                      if(itemExists >= 0){//existe en cart
                          if(cart[itemExists].quantity >= MAX_ITEMS) return
                          const updatedCart = [...cart] //copia nueva de mi state, no modifica mi carrito       
                          updatedCart[itemExists].quantity++
                          setCart(updatedCart)
                      } else{//NO EXISTE en cart
                          item.quantity = 1
                          setCart(prevCart =>[...prevCart, item])
                      }       
                  }
              
                  function removeFromCart(id){
                      //console.log('Eliminando...', id)      
                      setCart(prevCart => prevCart.filter(guitar => guitar.id !== id))
                  }    
              
                  function decreaseQuantity(id){
                      //console.log('Decrementando...', id)
                      const updatedCart = cart.map( item => {
                          if(item.id === id && item.quantity > MIN_ITEMS){
                              return{
                                  ...item,//ponemos esto porque no queremos perder la referencia de lo que ya tenemos en el cart
                                  quantity: item.quantity -1 //si pusiéramos solo esto solo nos devolvería la cantidad
                              }
                          }
                          return item //cuando no se cumple la condición: mantiene el resto de elementos sobre los que no dimos click en decrementar cantidad
                      })
                      setCart(updatedCart)
                  }
              
                  function increaseQuantity(id){
                      //console.log('Incrementando...', id)
                      const updatedCart = cart.map ( item => {
                          if(item.id === id && item.quantity < MAX_ITEMS){
                              return{
                                  ...item,//ponemos esto porque no queremos perder la referencia de lo que ya tenemos en el cart
                                  quantity: item.quantity + 1 //si pusiéramos solo esto solo nos devolvería la cantidad
                              }
                          }
                          return item //cuando no se cumple la condición: mantiene el resto de elementos sobre los que no dimos click en aumentar cantidad
                      })
                      setCart(updatedCart) //esa variable la seteamos al carrito
                  }
              
                  function clearCart(){
                      setCart([]) //seteamos un arreglo vacío
                  }
              
                  return (
                      <>   
                      <Header
                          cart = {cart}
                          removeFromCart = {removeFromCart}
                          decreaseQuantity = {decreaseQuantity}
                          increaseQuantity = {increaseQuantity}
                          clearCart = {clearCart}           
                      />
                    
                      <main className="container-xl mt-5">
                          <h2 className="text-center">Nuestra Colección</h2>
              
                          <div className="row mt-5">
                              {data.map((guitar) => (                    
                                  <Guitar
                                      key = {guitar.id} 
                                      propguitar = {guitar} 
                                      setCart = {setCart}    
                                      addToCart = {addToCart}                     
                                  />
                              )
                              )}         
                          </div>
                      </main>
              
                      <footer className="bg-gray-300 mt-5 py-5">
                          <div className="container-xl">
                              <p className="text-white text-center fs-4 mt-4 m-md-0">GuitarLA - Todos los derechos Reservados</p>
                          </div>
                      </footer>        
                      </>
                  )
              }
              
              export default App                         
            </script>
          </div>

          <div class="flex block-s">                 
            <div class="w-50 w-100-s">
              <p class="rojo">Guitar.jsx</p>
              <script type="text/plain" class="language-js">
                export default function Guitar({propguitar, addToCart}){

                  //console.log(propguitar)
                  const { id, name, image, description, price } = propguitar
              
                  const handleClick = (guitar) => {
                      //setCart([...cart, guitar])
                      
                  }
              
                  return(
                      <div className="col-md-6 col-lg-4 my-4 row align-items-center">
                          <div className="col-4">
                              <img className="img-fluid" src={`/img/${image}.jpg`} alt="imagen guitarra" />
                          </div>
                          <div className="col-8">
                              <h3 className="text-black fs-4 fw-bold text-uppercase">{name}</h3>
                              <p>{description}</p>
                              <p className="fw-black text-primary fs-3">${price}</p>
                              <button 
                                  type="button"
                                  className="btn btn-dark w-100"
                                  onClick={() => addToCart(propguitar)}
                              >Agregar al Carrito</button>
                          </div>
                      </div>
                  )
              }       
              </script>
            </div>
            <div class="w-50 w-100-s">
              <p class="rojo">Header.jsx</p>
              <script type="text/plain" class="language-js">
                import { useMemo } from 'react'

                export default function Header({cart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart}){
                
                    //State derivado
                    const isEmpty = useMemo( () => cart.length === 0, [cart])
                    const cartTotal = useMemo( () => cart.reduce( (total, item) => total + (item.quantity * item.price), 0), [cart])
                    
                    return(
                
                        <header className="py-5 header">
                            <div className="container-xl">
                                <div className="row justify-content-center justify-content-md-between">
                                    <div className="col-8 col-md-3">
                                        <a href="index.html">
                                            <img className="img-fluid" src="/img/logo.svg" alt="imagen logo" />
                                        </a>
                                    </div>
                                    <nav className="col-md-6 a mt-5 d-flex align-items-start justify-content-end">
                                        <div className="carrito">
                                            <img className="img-fluid" src="/img/carrito.png" alt="imagen carrito" />
                
                                            <div id="carrito" className="bg-white p-3">
                                                
                                                {isEmpty ? (
                                                    <p className="text-center">El carrito esta vacio</p>                                            
                                                ):(    
                                                    <>                          
                                                    <table className="w-100 table">
                                                        <thead>
                                                            <tr>
                                                                <th>Imagen</th>
                                                                <th>Nombre</th>
                                                                <th>Precio</th>
                                                                <th>Cantidad</th>
                                                                <th></th>
                                                            </tr>
                                                        </thead>
                                                    
                                                        <tbody>
                                                            {cart.map( guitar =>( 
                                                            <tr key={guitar.id}>
                                                                <td>
                                                                    <img className="img-fluid" src={`/img/${guitar.image}.jpg`} alt="imagen guitarra" />
                                                                </td>
                                                                <td>{guitar.name}</td>
                                                                <td className="fw-bold">
                                                                        ${guitar.price}
                                                                </td>
                                                                <td className="flex align-items-start gap-4">
                                                                    <button
                                                                        type="button"
                                                                        className="btn btn-dark"
                                                                        onClick={() => decreaseQuantity(guitar.id)}>
                                                                        -
                                                                    </button>
                                                                        {guitar.quantity}
                                                                    <button
                                                                        type="button"
                                                                        className="btn btn-dark"
                                                                        onClick={() => increaseQuantity(guitar.id)}>
                                                                        +
                                                                    </button>
                                                                </td>
                                                                <td>
                                                                    <button
                                                                        className="btn btn-danger"
                                                                        type="button"
                                                                        onClick={() => removeFromCart(guitar.id)}>
                                                                        X
                                                                    </button>
                                                                </td>
                                                            </tr>
                                                            ))}
                                                        </tbody>
                                                    </table>
                                                    <p className="text-end">Total pagar: <span className="fw-bold">${cartTotal}</span></p>
                                                    </>
                                                )}
                
                                                
                                                <button 
                                                    className="btn btn-dark w-100 mt-3 p-2"
                                                    onClick={clearCart}
                                                >Vaciar Carrito</button>
                                            </div>
                                        </div>
                                    </nav>
                                </div>
                            </div>
                        </header>
                
                    )
                
                }       
              </script>
            </div>
          </div>
          <!-- FIN BLOQUE CÓDIGO PROVISIONAL -->

      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-52').toggle();">	
            <h3>52. La estructura de archivos de React</h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-52" class="hidden">
            <p><strong>index.html:</strong> Archivo html sobre el cual se monta la app de React. </p>	
            <p><strong>App.jsx:</strong> nuestro componente principal de aplicación. Es donde estaremos agregando nuestros componentes.</p>	
            <p><strong>index.css:</strong> para código css que aplique en toda la app</p>	
            <p><strong>main.jsx:</strong> donde importamos la hoja de estilo y el componente ppal para que se inyecten en ese index.html</p>	

              
            <p>React es una librería de JS por tanto todo el código de JS que se genera es inyectado en el div <code class="language-html">&lt;div id="root"&gt;&lt;/div&gt;</code>. Por tanto es un DOM virtual, es código html que fue generado Unicamente con js. En este index podemos meter las google fonts o librerías de animaciones de css. Es nuestro archivo principal pero usualmente no vamos a hacer cambios aquí (solo el title)</p>
            <p><strong>package-lock.json:</strong> no tocamos se genera a partir del package.json y las dependencias indicadas ahí</p>
            <p><strong>package.json:</strong> dependencias y qué versiones están instaladas y utiliza este proyecto. De hecho en la parte de scripts, vemos que el de dev manda ejecutar <span class="destacado">vite</span>.</p>
            <pre><code class="language-js">
              "scripts": {
                "dev": "vite",
                "build": "vite build",
                "lint": "eslint .",
                "preview": "vite preview"
                },
            </code></pre>	
              
            <p>Si vamos añadiendo dependencias se van colocando aquí en el bloque siguiente de dependencias de proyecto y en el siguiente dependencias de desarrollo.</p>
            <p>Nos fijamos en los dos logos que aparecen en la página de inicio. carpeta public --> 'vite.svg' y carpeta src>assets --> 'react.svg'. Vemos en nuestro <strong>App.jsx</strong> como se llaman esos logos usando la sintaxis propia de react conocida como <span class="destacado">jsx</span>: que nos permite combinar código html con código js. <span class="destacado">Importante como se importa cada cosa en función de donde esté (solo / si en public vs ./ si en src)</span></p>
            <pre><code class="language-js">
              import reactLogo from './assets/react.svg'
              import viteLogo from '/vite.svg'
            </code></pre>
            <pre><code class="language-html">
              &lt;a href=&quot;https://vite.dev&quot; target=&quot;&lowbar;blank&quot;&gt;
              &lt;img src=&lcub;viteLogo&rcub; className=&quot;logo&quot; alt=&quot;Vite logo&quot; /&gt;
              &lt;/a&gt;
              &lt;a href=&quot;https://react.dev&quot; target=&quot;&lowbar;blank&quot;&gt;
              &lt;img src=&lcub;reactLogo&rcub; className=&quot;logo react&quot; alt=&quot;React logo&quot; /&gt;
              &lt;/a&gt;							
            </code></pre>

            <p>Vemos como el componente principal se llama App.jsx y también tenemos una css que se llama igual que ese componente App.css</p>
            <p>Eliminamos la css, los logos y sus importaciones y uso en App.js, también el import y la const del state (mas adelante veremos) y dejamos solo lo siguiente:</p>
            <pre><code class="language-js">		
              function App() &lcub;
              
                return (
                &lt;&gt;
                  
                  &lt;h1&gt;GuitarLA&lt;/h1&gt;
                  
                &lt;/&gt;
                )
              &rcub;
              
              export default App
            </code></pre>

            <p><strong>main.jsx:</strong> es el archivo principal de nuestra aplicación de React. Recordemos que en index.html todo se agrega en el div <code class="language-html">&lt;div id="root"&gt;&lt;/div&gt;</code>. Este main.jsx lee ese div y entonces monta toda nuestra aplicación de React en ese div. Si nos fijamos en el main.jsx vemos que importamos dos librerias React (librería ligera) y react-dom que es lo que nos permite la integración con nuestro html (hay otra react-native para crearr apps para android y iphone). También aquí se importa el archivo css <strong>index.css</strong> que nos permite agregar estilos globales a todo nuestro proyecto. Lo vaciamos (y así el h1 ya no sale centrado verticalmente)</p>
            <pre><code class="language-js">
              import &lcub; StrictMode &rcub; from &apos;react&apos;
              import &lcub; createRoot &rcub; from &apos;react-dom/client&apos;
              import &apos;./index.css&apos;
              import App from &apos;./App.jsx&apos;
              
              createRoot(document.getElementById(&apos;root&apos;)).render(
                &lt;StrictMode&gt;
                &lt;App /&gt;
                &lt;/StrictMode&gt;&comma;
              )	
            </code></pre>
          </div>
          <!-- Fin bloque desplegable interior-->

          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-53').toggle();">	
            <h3>53. Copiando el código HTML estatico a React</h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-53" class="hidden">
            
          </div>
          <!-- Fin bloque desplegable interior-->

    
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-54').toggle();">	
            <h3>54. Como Escribir código CSS en React</h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-54" class="hidden">
            <p></p>
            
          </div>
          <!-- Fin bloque desplegable interior-->


          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-55').toggle();">	
            <h3>55. ¿Qué son los Componentes en React?</h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-55" class="hidden">
            <p>Una vez copiado (estructurado) el código estático de guitarras que descargamos, sigue siendo estático. Este App.jsx ya es un componente:</p>
            <ul class="mb-3.75">
              <li>Es una función y su nombre empieza por mayúsculas (para evitar problemas en la compilación). Lo que esté entre las llaves es el contenido de ese componente pero podemos pasarlo a otros por medio de algo llamado props (lo veremos mas adelante)</li>
              <li>Tiene un return que devuelve lo que se ve en pantalla</li>
              <li>Lo que está antes del return se utiliza para algo</li>
              <li>lo que está después tiene otro fin</li>
              <li>Básicamente es tener HTML y JS en un solo archivo</li>
              <li><strong>¿Qué son los coponentes en React?</strong> React utiliza componentes para la creación de aplicaciones y sitios web. Actualmente nuestro App.jsx tiene demasiado código; (tiene mas de 100 líneas, podemos pensar en dividirl en componentes)</li>
              <li><strong>Un componente puede tener la extensión <span class="destacado">.jsx (si utilizamos js)</span> o <span class="destacado">.tsx (si utilizamos typescript)</span>.</strong> .js taambién es posible pero se recomiendan las dos primeras</li>
              <li><strong>Un componente normalmente tiene dos propósitos:</strong> ser reutilizable y/o separar la funcionalidad. Si se cumplen ambas mejor.</li>
              <li><strong>Siempre tiene que tener un <span class="destacado">return()</span> que es lo que se muestra en pantalla</strong></li>
              <li></li>
            </ul> 

            <p>Creemos en una nueva carpeta que llamamos "components" nuestro primer componente: <strong>Header.jsx</strong>. Si en el return metemos un h1, vemos que en la app no se muestra nada porque nuestro componente principal App.jsx no sabe de la existencia de este nuevo componente Header.jsx. Hay que exportarlo e importarlo. podemos poner al final del archivo <strong>export default Header</strong> o mejor, colocarlo antes de la palabra function y lo tenemos en una sola línea <span class="destacado">export default function Header(){}</span>. Ahora ya podemos importarlo en cualquier otro componente:</p>
            <pre><code class="language-js">
              export default function Header(){

                return(
                  <h1>Desde Header</h1>
                )
                
              }							
            </code></pre>
              
            <p>Lo importamos en nuestro componente ppal de Aplicación App.jsx usando al ppio la palbra import y con el autocompletado ya nos sale nuestro Header.</p>
            <p>Aún tenemos que renderizarlo (como si fueran tags HTML). Importante:</p>

            <pre><code class="language-html">
              &lt;Header/&gt; &lt;!-- sintaxis de componente React --&gt;
              &lt;header&gt; &lt;!-- tag HTML --&gt;							
            </code></pre>
            
            <p>Si volvemos a nuestro primer componente y nos fijamos en lo que hay dentro del return() vemos que tenemos un tag de html h1. Esto de primeras parece un poco raro, veamos qué es el jsx</p>
          </div>
          <!-- Fin bloque desplegable interior-->


          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-56').toggle();">	
            <h3>56. ¿Qué es JSX? / 57. Renombrando class a className de nuestro proyecto / 58. Creando un Componente para cada Guitarra </h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-56" class="hidden">

            <ul class="mb-3.75">
              <li><span class="destacado">JSX</span> <strong>Javascript Syntax Extension:</strong> es una extensión del lenguage desarrollada también por META (Facebook) para React y es una sintaxis especial para poder agregar HTML y JS en un solo lugar. Al ppio parece un poco complicado pero se ven los beneficios conforme comenzamos a trabajar con ella.</li>
              <li>Parece JS (los componentes son funciones) pero muestra código HTML. Básicamente <strong>es un lenguage de Templates/Vistas</strong> que muestra HTML pero tiene todas las funciones de Javascript (todo js puede usarse en los archivos .jsx)</li>
              <li><strong>Una vez compilado son archivos JS con funciones y objetos</strong></li>
            </ul>

            <p>En la parte anterior del return() podemos colocar código js, probemos con una variable const = name. Para comunicar esto en nuestra vista (dentro del return) <span class="destacado">hay que hacerlo entre llaves {}</span>. <br><span class="rojo">Ojo!</span> si intentamos poner solo {name} sin ningún tag nos da error. También si pongo dos o mas tags html seguidos!!!! Veamos las reglas de JSX y evitar estos errores</p>

            <ul class="mb-3.75">
              <li>A diferencia de HTML, <strong>en JSX si un elemento HTML tiene tag de apertura ha de tener también el de cierre (los tag &lt;link&gt; &lt;img&gt;A o &lt;input&gt; habr&aacute; que cerrarlas con /&gt;)</strong></li>
              <li><strong>Cada componente debe tener un return</strong></li>
              <li><strong>En el return solo puede haber un elemento (un tag) en el nivel superior=máximo</strong> --&gt; podría tener un &lt;div&gt; padre englobando todo en el return pero al final cargaríamos nuestro código con divs innecesarios. Para evitar eso usamos los <span class="destacado">Fragment</span>. esta sintaxis que vemos en el ejemplo de nuestro componente principal de aplicación App.jsx es una de las 3 maneras de usar Fragment: <strong>&lt;&gt;</strong>
                <ul class="mb-3.75">
                  <li><code class="language-js">import { Fragment } from "react"</code> <code class="language-html">&lt;Fragment&gt;&lt;/Fragment&gt;</code></li>
                  <li><code class="language-js">import React from "react"</code> <code class="language-html">&lt;React.Fragment&gt;&lt;/React.Fragment&gt;</code></li>
                  <li>Sin hacer ninguna importación simplemente usamos: <code class="language-html">&lt;&gt;&lt;/&gt;</code></li>
                </ul>
              
              </li>
            </ul>

            <p>Veamos un resumen de lo que es un componente:</p>

            <img class="my-2.5" src="./src/assets/img/56.jpg" alt="" />
            <p>Si vemos la consola nos sale este mensaje de error y es porque en React "class" es una palabra reservada del lenguage js. Con objeto de no mezclar el uso de ese "class" (que es de estilos) con el uso de la palabra reservada de js cuando definamos states, variables..., se soluciona sustituyendolo por className:</p>

            <img class="my-2.5" src="./src/assets/img/57.jpg" alt="" />

            <p><span class="destacado">Se recomienda usar tags HTML semantico pero en lugar de class usamos className</span> (eso conecta en automático con el archivo de css de nuestro proyecto). Esto es solo de cara a desarrollo, una vez que compila el proyecto se agregan clases normales. Nos llevamos todo el códiog del header al nuevo componente Header.</p>

            <p>Creamos un nuevo componente <strong>Guitar.jsx</strong> con el contenido de la primera guitarra y borramos las otras del App.jsx. Lo llamamos desde nuestro App.jsx (la integración con VSCode es muy buena, no hace falta que tecleemos la línea de importar ese cpomponente, con solo escribirlo y enter en el autocompletado nos añade la línea.)</p>

            <p>Veamos a continuación que son los React Hooks que nos van a permitir Integrar toda las funcionalidades de React con nuestra interfaz</p>
            
          </div>
          <!-- Fin bloque desplegable interior-->
    
    
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-59').toggle();">	
            <h3>59. Introducción a los React Hooks / 60. ¿Qué es el State en React? y useState / 61. Reglas de los Hooks / 62. ¿Qué es useEffect?</h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-59" class="hidden">
            <p>Los <span class="destacado">React Hooks</span> son la base de React. Nos van a permitir Integrar toda las funcionalidades de React con nuestra interfaz.</p>
            <ul class="mb-3.75">
              <li><strong>Los Hooks permiten usar las diferentes funciones de React en nuestros componentes. React tiene una serie de Hooks pero también podemos crear los nuestros.</strong></li>
              <li><strong>Los Hooks están disponibles desde la versión 16.8 de React, previo a ello se tenían que crear Classes para crear y modificar el state, con los Hooks no es necesario.</strong></li>
              <li><strong>Existen muchos y se dividen entre Básicos y adicionales</strong></li>
              <li>Son los siguientes (como vemos, el nombre de todos empieza con la palabra <strong>use</strong>). Los básicos que están en casi todos los proyectos son los 3 de la izquierda. Los otros son más avanzados que se utilizan para librerías o casos más específicos.</li>
              <li><img class="my-2.5" src="./src/assets/img/hooks.jpg" alt="" /></li>
              
              <li>También podemos crear nuesros propios Hooks así podremos separar nuestro código en funciones reutilizables y sacar todo el beneficio de lo que React ofrece.</li>
            </ul>

            <p>Comenzamos utilizando el más común de todos <span class="destacado">useState</span>. Tiene un <a href="https://gist.github.com/codigoconjuan/f333ee8422b0b8c4fde227e81e626cce" target="_blank">Gist con todas las guitarras</a> preparado para utilizarlo en nuestra App simulando una base de datos, pero primero hemos de ver el Hook más común de todos <strong>useState()</strong> y ello nos lleva a ver qué es el <span class="destacado">state en React</span> que es la pieza central de React.</p>

            <p class="font-bold naranja">¿Qué es el State en React?</p>
            <ul class="mb-3.75">
              <li><strong>El Estado o State en React es una variable con información relevante en nuestra aplicación de React</strong>, algunas veces el state pertenece a un componente en específico y otras veces quieres que sea compartido a lo largo de diferentes componentes.</li>
              <li><strong>Pensemos en el state como el resultado de alguna interacción en el sitio o aplicación web: el listado de clientes, la imagen a mostrar en una galería, si un usuario está autenticado o no,...</strong></li>
              <li><strong>El state es creado con el Hook useState()</strong>. Veamos un ejemplo:</li>
            </ul>

            <p>Importamos el Hook <code class="language-js">import { useState } from "react"</code> y la forma en que vamos a definir nuestro state es así: <code class="language-js">const [customer, setCustomer] = useState({});</code> Creamos una variable const y colocamos entre corchetes [] (useState siempre va a devolver un Array (aquí estamos aplicando Array Destructuring)) y podemos ver que estamos nombrando nuestro state como <strong>customer</strong> y usamos <strong>setCustomer</strong> (este nombre, usar "set", es una convención) a continuación un = seguido de un objeto dentro de paréntesis <strong>({})</strong>, es lo que se conoce como el valor inicial. Veamos más ejemplos de state y cómo, el valor inicial será una u otra cosa en función de qué tipos de datos tengamos:</p>
            <pre><code class="language-js">
              const [customer, setCustomer] = useState({})
              const [total, setTotal] = useState(0)
              const [products, setProducts] = useState([])
              const [modal, setModal] = useState(false)	
            </code></pre>

            <p class="font-bold">Anatomía de useState: state, función y valor inicial</p>
            <p><code class="language-js">
              const [customer, setCustomer] = useState({});</code></p>
            <ul class="mb-3.75">
              <li><strong>customer</strong> es el state, la variable que va a tener toda la información</li>
              <li><strong>setCustomer</strong> es la función que modifica el state, es la fcn que siempre vamos a usar cuando queramos realizar cambios en nuestro state (en este ejemplo customer)</li>
              <li><strong>useState</strong> es el Hook que nos da React</li>
              <li>el objeto vacío <strong>({})</strong> es el valor inicial</li>	
            </ul>

            <p class="font-bold">React reacciona en base al state</p>
            <ul class="mb-3.75">
              <li>Cada vez que el state cambia, la aplicación de React va a renderizar y actualizarse con esos cambios, no es necesario hacer nada más (recargar página o actualizar el DOM) y nuestra interfaz siempre va a estar sincronizada con el state.</li>
              <li>Para modificar el state, se utiliza la función que extraemos cuando declaramos el state en nuestro componente.</li>
            </ul>

            <p>Para implementar useState en nuestra App Guitarlab, cerramos todo y dejamos abierto únicamente el componente principal de App, <strong>App.jsx</strong>.</p>
            <ul class="mb-3.75">
              <li><code class="language-js">import { useState } from "react"</code></li>
              <li><strong>El state hay que definirlo en nuestro componente, ni fuera de él ni dentro del return() sino justo antes del return</strong>. Hay ciertas reglas para los Hooks que estaremos viendo a continuación. </li>
              <li>lo más básico que nos da react es esto: <code class="language-js">const [] = useState()</code> pero <strong>nosotros tenemos que definir nombre del state, nombre de la función y su valor inicial.</strong>. Supongamos que vamos a crear un state para revisar si un usuario está autenticado o no, si lo está le mostramos un componente y si no lo llevamos al panel de iniciar sesión. <code class="language-js">const [auth, setAuth] = useState(false)</code>. Si sacamos un console.log del state lo vemos (y de hecho 2 veces, uno desde el Componente ppal App.jsx y otro desde el InstallHook.jsx, no nos preocupemos, React forzó en nuevas versiones este doble render para garantizar que se hace buen uso de React). Pero en vez de por consola usemos React developer tools.</li>
              <li><strong><a href="https://chromewebstore.google.com/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=es&pli=1" target="_blank">React developer tools: </a></strong> una vez instalado y reiniciado chrome, en web developer tools tenemos una pestaña nueva llamada components, en la que vamos a ver intuitivamente el árbol de componentes de nuestro proyecto de React (App, Header, Guitar). Si pulsamos en App, vemos en el apartado de Hooks el state y su valor.</li>
            </ul>                    

            <p class="naranja">Reglas de los Hooks</p>

            <p>Vamos a crear más states. Va a ser muy normal que una App tengamos varios states o el uso de varios Hooks:</p>
            <pre><code class="language-js">
              const [auth, setAuth] = useState(false)
              const [total, setTotal] = useState(0)	
              const [cart, setCart] = useState([])
            </code></pre>

            <p class="font-bold">Reglas de los Hooks en React</p>
            <ul class="mb-3.75">
              <li><strong>Los Hooks se colocan en la parte superior de los componentes de React.</strong> ni dentro de bucles/interacciones, ni dentro de funciones.</li>
              <li><strong>No se deben colocar dentro de condicionales ni después de un return:</strong> los Hooks no se pueden registrar en base a una condición porque esa condición puede cambiar en algún momento y entonces tendremos un error.</li>
            </ul>

            <p class="naranja">¿Qué es el Hook useEffect?</p>
            <ul class="mb-3.75">
            <li>Tras el useState, <strong>useEffect es el segundo Hook más común que vamos a usar, es muy versátil y lo usaremos mucho</strong>. </li>
            <li><strong>useEffect siempre es un callback</strong> que, dependiendo como lo declares, va a realizar diferentes acciones.</li>
            <li>Es el Hook más versátil, sustituto de lo que, en versiones previas de React donde había Clases y métodos del ciclo de vida, era conocido como <strong>componentDidMount()</strong> y <strong>componentDidUpdate()</strong></li>
            </ul>

            <p>Importamos el Hook <code class="language-js">import { useEffect } from "react"</code> y para usar este Hook, dentro del () vemos que tiene un calllback que se puede poner como function o como arrow function. Los corchetes del final es lo que se llama <strong>arreglo de dependencias</strong> que ahora veremos:</p>
            <pre><code class="language-js">
              useEffect( () => {
                console.log('El componente está listo')
              }, [])	
            </code></pre>

            <p class="font-bold">Usos de useEffect()</p>
            <ul class="mb-3.75">
              <li>Al ejecutarse automáticamente cuando el componente está listo, es un buen lugar para colocar código para consultar una API o para obtener datos del LocalStorage.</li>
              <li>Debido a que le podemos pasar una dependencia (que usualmente va a ser un state) va a estar escuchando por los cambios que suceden en una variable, pudiendo actualizar el componente (o ejecutar ciertas funciones) cuando ese cambio ocurra (podemos estar sincronizando con LocalStorage por ejemplo).</li>
              <li>Dependiendo del valor que pasemos en el array de dependencias (o si no pasamos nada) el Hook userEffect va a hacer algo diferente:
                <ul class="mb-3.75">
                  <li>Si dejamos el arreglo de dependencias vacío (significa que no tiene dependencias) el código especificado en el Hook solo se ejecuta una vez, y lo hace cuando el componente esté listo. Si sacamos un console.log por consola veremos que solo sale 1 vez (sale 2 pero por loq ue decíamos de la comprobación del modo estricto en el main incluido por el equipo de React en versiones recientes)
                    <pre><code class="language-js">					
                      useEffect ( () => {
                        console.log('Componente listo')
                      }, [])					
                    </code></pre>
                  </li>
                  <li>Si le pasamos un state (o varios), cada vez que cambie cada uno de esos states se ejecuta el efecto (la función) que especifiquemos en el Hook useEffect. En este caso añadimos un setTimeout que nos cambia el state Auth pasados 3 segundos. Veremos que se ejecuta una vez cuando el componente está listo (vemos esas 2 del modo estricto del main.jsx) y pasados 3 sg al cambiar el state auth se vuelve a ejecutar:
                    <pre><code class="language-js">
                      useEffect ( () => {
                        console.log('Componente listo o escuchando por auth')
                      }, [auth])
                    
                      setTimeout(() => {
                        setAuth(true)
                      }, 3000); 
                    </code></pre>
                  </li>
                </ul>
                
                <p>De esta forma, podemos tener funciones que se ejecuten cuando cambie algún state en nuestra aplicación, para eso es el useEffect(). Es muy útil.</p>
                <p>¿podríamos hacer lo siguiente? meter un condicional para ejecutar un código solo en el caso de que el usuario esté autenticado? (comenta que hay gente que dice que no se puede usar eso dentro de un useEffect, pero él afirma que se utiliza muchas veces y que es correcto)</p>
                <pre><code class="language-js">
                  const [auth, setAuth] = useState(false)
                
                  useEffect ( () => {
                    if(auth){
                      console.log('Componente listo o escuchando por auth')
                    }
                  }, [auth])
                  
                  setTimeout(() => {
                    setAuth(true)
                  }, 3000);				
                </code></pre>

              </li>
            </ul>
          </div>
          <!-- Fin bloque desplegable interior-->


          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-63').toggle();">	
            <h3>63. Añadiendo los Productos al State / 64. Iterando sobre los productos en React / 65. Props / 66. Mostrando la Información de cada Guitarra- 
              <a class="text-[#000000]" href="https://gist.github.com/codigoconjuan/f333ee8422b0b8c4fde227e81e626cce" target="_blank">Gist Guitarras</a></h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-63" class="hidden">
            <p>Veamos como incorporar este <a href="https://gist.github.com/codigoconjuan/f333ee8422b0b8c4fde227e81e626cce" target="_blank">listado de Gist que simula ser una pequeña base de datos de guitarras</a> para hacer nuestra interfaz dinámica y no mostrar una única guitarra. Sobre todo también hacer el componente <strong>Guitar</strong> más inteligente.</p>

            <p>Creamos en src una carpeta para los datos y un .js con los datos de ese git copiados en raw: <strong>data/db.js</strong>. Es una pequeña base de datos con 12 guitarras cada una con un id, descripción y precio; las imágenes están mapeadas con nuestra carpeta de imágenes. Vamos a nuestro componente principal <strong>App.jsx</strong> e importamos esta base de datos ayudándonos del autocompletado: <code class="language-js">import { db } from "./data/db"</code>. Si hacemos un console.log(db) podemos ver esa bbdd local. Hagámoslo al estilo de React. Se puede hacer de dos formas:</p>

            <ul class="mb-3.75">
              <li>Como es un archivo local, podemos ponerle que el valor inicial del state data es lo que tengamos en db
                <pre><code class="language-js">const [data, setData] = useState(db)</code></pre>. Vemos en la pestaña de componentes, en el compo App > hooks toda la información de nuestro state. Está bien porque es un archivo local, lo va a leer, importar montar y después montar nuestro componente.</li>
              <li>Si trabajáramos con una API usualmente usaremos un useEffect, esto en caso de hacerlo sin dependencias (hay muchas dependencias enfocadas a consumir APIS que se integran bastante bien con React y que lo hacen con un rendimiento excelente aunque es más para grandes proyectos, pero no es nuestro caso). <span class="destacado">Con mi arreglo de dependencias vacío, una vez el componente esté listo especificamos setData(db), es decir seteo en mi state mi base de datos que tenemos en el archivo indicado en la importación.</span>
              <pre><code class="language-js">
                const [data, setData] = useState([])
                useEffect( () => {
                  setData(db)
                },[])			
              </code></pre>
              si miramos en la pestaña componentes del web developer vemos que se coloca la información de las guitarras dentro del state.
              <img class="my-2.5" src="./src/assets/img/63-db-productos-en-state.jpg" alt="" /></li>
            </ul>	

            <p>Si esto lo haces desde una API esta forma es la más recomendada porque una API va a conectarse y traerse la información, no sabemos cuando, entonces quieres que se mande llamar una vez que el componente esté listo. Un poco más adelante cuando veamos cómo integrar APIS con React volveremos sobre esto.</p>

            <p>Una vez tenemos en nuestro state la información de la BBDD de nuestras guitarras, veamos cómo iterar sobre él y comenzar a mostrar la información de nuestras guitarras.</p>

            <p class="naranja">Iterando sobre los productos en React</p>

            <p>¿Como sabemos cual es el valor inicial de nuestro state? En nuestro caso es un arreglo y tenemos dos elementos. Hay muchas formas de iterar un arreglo, un for, un forEach. <span class="destacado">Es importante mencionar que antes de nuestro return() podemos escribir lo que se conoce como statements o expresiones, sin embargo dentro del return solo podemos escribir expresiones</span></p>

            <ul class="mb-3.75">
              <li><strong>Statement</strong> Una app de js es una serie de statements. Cada statement es una instrucción para hacer algo. Algunos statements muy comunes son <strong>creación de variables</strong>, <strong>códigos condicionales con if</strong>, <strong>lanzar errores con throw new Error()</strong>, <strong>Iterar con While o For</strong></li>
              <li><strong>Expressions</strong> Una expresión es algo que produce un valor. Algunos ejemplos de Expressions son <strong>ternarios</strong>, <strong>utilizar un Array method que genere un nuevo array</strong>, <strong>map() que genera un nuevo array a diferencia de forEach</strong></li>
            </ul>

            <p>Por tanto, tenemos un Array queremos iterar sobre él y como hemos visto un bucle For o un While no se puede usar en la parte del return() pero sí un .map(). Podríamos usar un for para iterar en la parte superior sobre data, pero queremos hacerlo en pantalla por lo que tenemos que hacerlo en el return() del componente, por tanto usamos para ello la expresión .map() que cada vez que lo utilicemos nos genera un array nuevo. El map() va a ejecutarse una vez por cada elemento en nuestro Array. Veamos el siguiente código y como aparece 12 veces el párrafo especificado. Sustituyamos ese párrafo por el componente que teníamos hecho:</p>

            <pre><code class="language-js">
              const [data, setData] = useState(db)
            </code></pre>
            <pre><code class="language-html">
              &lcub;data.map(() =&gt; (
                //&lt;p&gt;Desde Guitarra&lt;/p&gt;
                &lt;Guitar/&gt;	
              )
              )&rcub;
              
            </code></pre>

            <p>¿qué hemos hecho? accedemos a data que es parte de nuestro state, utilizamos el array method map() y al comenzar a iterar generamos un componente Guitar por cada elemento presente en el arreglo (12 elementos). Nos aparece 12 veces el mismo componente estático &lt;Guitar/&gt;. <strong>En el siguiente vídeo con el uso de props  haremos nuestro componente estático más inteligente, más dinámico.</strong></p>

            <p class="naranja">¿Qué son los Props en React?</p>

            <p><strong>Props en React:</strong> es una forma de compartir inofrmación entre componentes</p>
            <ul class="mb-3.75">
              <li><strong>Los componentes de React utilizan Props para comunicarse entre ellos</strong>. Puedes pasarle información de un componente padre al hijo por medio de estos props. </li>
              <li><strong>Los props se parecen mucho a los atributos HTML, la sintaxis es muy similar, pero puedes pasarle arrays, objetos o funciones</strong></li>
              <li><strong>Los Props de pasan del padre al hijo, nunca se pueden pasar del hijo al padre</strong>
                <ul class="mb-3.75">
                  <li>Si tenemos un state que se va a pasar por diferentes componentes, lo mejor es colocarlo en el archivo principal</li>
                  <li>Cada Nivel de Componentes deberá tomar y pasar el Prop hacia otros componentes. Tecnologías como Redux, Zustand, Jotai o Context evitan tener que hacerlo de esta forma (aunque implementar estas tecnologías para algo tan simple no es recomendado. Algunas las estaremos viendo en este curso)</li>
                  <li></li>
                </ul>
              </li>
            </ul>

            <p>Supongamos que tenemos un componente llamdo &lt;Header/&gt;. La sintaxis de los Props es como sigue: la parte de la izquierda del "=" es como lo vamos a llamar y poder acceder en el componente hijo, es decir en Header. Lo del lado derecho entre llaves es la información necesaria para ese componente que le vamos a pasar (datos, state, funciones, objetos...).</p>

            <pre><code class="language-js">
              &lt;Header
                nombreProp=&lcub; datos / state o Funciones &rcub;
              /&gt;
            </code></pre>

            <p>Podemos tener múltiples Props, veamos un componente llamado Users:</p>
            <pre><code class="language-js">
              &lt;Users
                users=&lcub; users &rcub;
                setUsers=&lcub; setUsers &rcub;
                title="Listado de Usuarios"
              /&gt;
            </code></pre>

            <p>Implementemos Props en nuestro componente de guitarras &lt;Guitar /&gt;. Le añadimos este Props a nuestro componente:</p>
            <pre><code class="language-js">
              &lcub;data.map(() =&gt; (                    
                &lt;Guitar
                  price = &lcub;100&rcub;
                /&gt;
              )
              )&rcub;		
            </code></pre>

            <p>A nuestro componente Guitar.jsx hemos de añadirle como parámetro la palabra reservada <strong>props</strong>. Si hacemos un console log (antes del return()) de ese props veremos en la consola  ese {price: 100}; viene como un objeto porque le podemos pasar múltiples props. También lo podemos ver en la pestaña de components de React Developer Tools</p>
            <pre><code class="language-js">
              export default function Guitar(props){
                console.log(props)
                return(
            </code></pre>

            <img class="my-2.5" src="./src/assets/img/63-props1.jpg" alt="" />

            <p>Pasémosle más de un props:</p>
            <pre><code class="language-js">
              &lcub;data.map(() =&gt; (                    
                &lt;Guitar
                  price = &lcub;100&rcub;
                  auth = true;
                /&gt;
              )
              )&rcub;		
            </code></pre>
            <p>¿Cómo puedo acceder individualmente a estos valores <strong>price</strong> y <strong>auth</strong>? Como es un objeto:</p>
            <pre><code class="language-js">
              export default function Guitar(props){
                console.log(props.price)
                console.log(props.auth)
                return(
            </code></pre>

            <p>Pero incluso mejor, podemos aplicar destructuring:</p>
            <pre><code class="language-js">
              export default function Guitar({price,auth}){
                console.log(price)
                console.log(auth)
                return(
            </code></pre>

            <p class="naranja">Mostrando la Información de cada Guitarra</p>

            <p>Tenemos el array db.js y cada uno tiene un objeto con la información de cada guitarra. Estamos utilizando un map() para iterar en él así que vamos a acceder a cada uno de esos objetos (en la función de flecha le ponemos el nombre que queramos por ejemplo <strong>guitar</strong>). Creamos el prop guitar y le pasamos como valor el objeto guitar (explica que no hay ningún inconveniente en tener mismo nombre de prop que del objeto que deseas pasarle al prop):</p>

            <pre><code class="language-js">
              const &lsqb;data&comma; setData&rsqb; = useState(db)

              &lcub;data.map((guitar) =&gt; (                    
                &lt;Guitar
                  guitar = &lcub;guitar&rcub; 
                  key = &lcub;guitar.id&rcub; // Cuando iteremos en una lista, React nos requiere que siempre utilicemos un prop especial llamado <strong>key</strong> y pasarle un valor único.                      
                /&gt;
              )
              )&rcub; 
            </code></pre>
            <p>Si hacemos un console.log(props) veremos que tenemos un prop que va a tener el objeto de guitarra</p>
            <pre><code class="language-js">
              export default function Guitar(props){
              console.log(props)
            </code></pre>

            <p>Si aplicamos destructuring quedaría así y en la consola ya vemos que aparece la información propia de cada guitarra:</p>
            <pre><code class="language-js">
              export default function Guitar({guitar}){
              console.log(guitar)
            </code></pre>
            <img class="my-2.5" src="./src/assets/img/66-1.jpg" alt="" />

            <p>Para cada elemento html que teníamos en el código estático (nombre, imagen, precio...) que queremos que cargue de forma dinámica hacemos el reemplazo por ejemplo el nombre de la  guitarra que está en el h3, 'Lukather', lo cambiamos por <code class="language-js">{guitar.name}</code>. Si actualizamos el navegador vemos que cada guitarra ya muestra un nombre diferente, porqeu ya estamos leyendo la información de nuestra pequeña base de datos. <span class="destacado">Así vemos el beneficio de los props junto al state junto a emplear array methods para iterar en nuestro state --> crear componentes reutilizables optimizando el código a escribir</span></p>

            <p>En vez de llamar cada dato así <code class="language-js">{guitar.name}</code>, creemos una variable cont nueva para hacer destructuring del objeto guitar que recibimos como propiedad del compoennte padre App.jsx y simplificar el código de la siguiente manera:</p>
              
            <pre><code class="language-js">
              export default function Guitar({guitar}){

                const { id, name, image, description, price } = guitar		
            </code></pre>

            <p>Hago unos leves cambios de nombre con respecto a lo explicado para rastrear mejor lo que estoy haciendo:</p>

            <img class="my-2.5" src="./src/assets/img/66-2.jpg" alt="" />

            <p>En el siguiente video comenzamos con el carrito de la compra.</p>
          </div>
          <!-- Fin bloque desplegable interior-->


          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-67').toggle();">	
            <h3>67. Eventos en JSX / 68. Creando un State de Carrito / 69. Agregando Guitarras al Carrito / 70. Detectar si un elemento existe en el carrito / 71. Agregando guitarras al Carrito con Cantidad / 72. Incrementando cantidad si un articulo ya estaba agregado</h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-67" class="hidden">

            <p class="naranja">Eventos en JSX</p>

            <p>Cuando presione en cada guitarra se tienen que ir listando en el carrito. En ese carrito tenemos que poder ajustar la cantidad y eliminar los que queramos. Si tienes exp en js eso se hace con un addEventListener</p>

            <p class="font-bold">Sobre los eventos en React</p>
            <ul class="mb-3.75">
              <li>La forma en que React maneja los eventos es muy similar a como lo hace JavaScript de forma nativa con algunos cambios.</li>
              <li><strong>Los eventos son camelCase</strong>, es decir en lugar de <strong>onclick</strong> <span class="destacado">onClick</span>, en lugar de <strong>onchange</strong>, <span class="destacado">onChange</span></li>
              <li>A diferencia de JS y HTML en los que se coloca el nombre de la función en un string, <strong>en React (JSX) se utiliza la función entre llaves <span class="destacado">{}</span></strong></li>
              <li>Ejemplo click en HTML: <code class="language-html">&lt;button onclick=&quot;getLatestOrders()&quot;&gt;Descargar pedidos&lt;/button&gt;</code></li>
              <li>Ejemplo click en React(JSX): <code class="language-js">&lt;button onClick=&lcub;getLatestOrders()&rcub;&gt;Descargar pedidos&lt;/button&gt;</code><br>Esa función se recomienda que esté <strong>en el mismo componente antes del return()</strong> o <strong>en un Hook personalizado, otro archivo</strong></li>
              <li>Ejemplo submit en HTML: agregarCliente() es la función que va a procesar un formulario de ajax o FetchAPI; también le colocamos un return false): 
              <pre><code class="language-html">
                &lt;form onsubmit=&quot;agregarCliente()&semi; return false&quot;&gt;
                  &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
                &lt;/form&gt;
              </code></pre>
              </li>
              <li>Ejemplo submit en React(JSX): como vemos hay una convención (similar a cuando en los states nombramos las funciones correspondientes del estate con la palabra<strong><span class="destacado">set</span>NombreState</strong>), y para eventos se recomienda usar la palabra <strong><span class="destacado">handle</span>NombreEvento</strong>
                <pre><code class="language-html">
                  &lt;form onSubmit=&lcub;handleSubmit&rcub;&gt;
                  &lt;button type=&quot;submit&quot;&gt;A&ntilde;adir cliente&lt;/button&gt;
                &lt;/form&gt;				
                </code></pre>
                </li>
            </ul>

            <p class="font-bold">Vamos a registrar un evento en nuestras guitarras</p>
            <p>Como cuando yo presione en agregar al carrito quiero realizar una acción, <strong>vamos a agregarle/registrarle a nuestro botón el evento de onClick</strong>:</p>

            <pre><code class="language-js">
              const handleClick = () => {
                console.log('Diste click')
              }
            </code></pre>
            <pre><code class="language-html">
              &lt;button 
              type=&quot;button&quot;
              className=&quot;btn btn-dark w-100&quot;
              onClick={handleClick}
            &gt;Agregar al Carrito&lt;/button&gt;		
            </code></pre>

            <p>Me gustaría poder identificar desde qué guitarra estoy haciendo click. ¿Cómo le pasamos un valor para identificar un parámetro o um argumento? Podríamos añadir paréntesis con el id dentro <code class="language-js">onClick={handleClick(id)}</code> ya que el id lo tenemos en la destructuración del prop "propguitar" <code class="language-js">const { id, name, image, description, price } = propguitar</code>. Hagamos que la función handleClick reciba ese argumento y lo vemos en consola. Vemos en la consola que salen TODOS los clicks porque esta expresión <code class="language-js">onClick={handleClick(id)}</code> está mandando llamar la función, no espera que ocurra el evento</p>

            <p><strong>Cuadno tenemos argumentos, si tenemos funciones que toman parámetros, hay que colocar en la llamada un callback, por ejemplo un arrow function, <code class="language-js">onClick={() =>handleClick(id)}</code> y de esa forma ya no se manda llamar en automático sino que espera el evento.</strong></p>

            <p>Mejor vamos a pasarle como argumento, en vez de solo el id, todo el objeto de guitarra: <code class="language-js">onClick={() => handleClick(guitar)}</code> y miramos la consola donde nos sale toda la información:</p>
            
            <div class="flex">
              <div class="w-50 w-100-s">	
                <p class="verde">Guitar.jsx</p>:
                <pre><code class="language-js">
                  export default function Guitar({propguitar}){

                    const { id, name, image, description, price } = propguitar
                  
                    const handleClick = (algo) => {
                      console.log('Diste click', algo)
                    }
                  
                    return(
                      &lt;div className=&quot;col-md-6 col-lg-4 my-4 row align-items-center&quot;&gt;
                        &lt;div className=&quot;col-4&quot;&gt;
                          &lt;img className=&quot;img-fluid&quot; src=&lcub;&grave;/img/$&lcub;image&rcub;.jpg&grave;&rcub; alt=&quot;imagen guitarra&quot; /&gt;
                        &lt;/div&gt;
                        &lt;div className=&quot;col-8&quot;&gt;
                          &lt;h3 className=&quot;text-black fs-4 fw-bold text-uppercase&quot;&gt;&lcub;name&rcub;&lt;/h3&gt;
                          &lt;p&gt;&lcub;description&rcub;&lt;/p&gt;
                          &lt;p className=&quot;fw-black text-primary fs-3&quot;&gt;$&lcub;price&rcub;&lt;/p&gt;
                          &lt;button 
                            type=&quot;button&quot;
                            className=&quot;btn btn-dark w-100&quot;
                            onClick=&lcub;() = &gt;handleClick(propguitar)&rcub;
                          &gt;Agregar al Carrito&lt;/button&gt;
                        &lt;/div&gt;
                      &lt;/div&gt;
                    )
                  }
                </code></pre>	
                <img class="my-2.5" src="./src/assets/img/67.png" alt="" />
              </div>

              <div class="w-50 w-100-s">
                <p class="verde">App.jsx:</p>
                <pre><code class="language-js">
                  import &lcub; useState&comma; useEffect &rcub; from &quot;react&quot;
                  import Guitar from &quot;../components/Guitar&quot;
                  import Header from &quot;../components/Header&quot;
                  import &lcub; db &rcub; from &quot;./data/db&quot;
                  
                  function App() &lcub;
                  
                    //console.log(db)
                    const &lsqb;data&comma; setData&rsqb; = useState(db)
                  
                    // const &lsqb;data&comma; setData&rsqb; = useState(&lsqb;&rsqb;)
                    // useEffect( () =&gt; &lcub;
                    //     setData(db)
                    // &rcub;&comma;&lsqb;&rsqb;)
                  
                    return (
                      &lt;&gt;   
                      &lt;Header/&gt;
                    
                      &lt;main className=&quot;container-xl mt-5&quot;&gt;
                        &lt;h2 className=&quot;text-center&quot;&gt;Nuestra Colecci&oacute;n&lt;/h2&gt;
                  
                        &lt;div className=&quot;row mt-5&quot;&gt;
                          &lcub;data.map((guitar) =&gt; (                    
                            &lt;Guitar
                              propguitar = &lcub;guitar&rcub; 
                              key = &lcub;guitar.id&rcub;                       
                            /&gt;
                          )
                          )&rcub;         
                        &lt;/div&gt;
                      &lt;/main&gt;
                  
                      &lt;footer className=&quot;bg-gray-300 mt-5 py-5&quot;&gt;
                        &lt;div className=&quot;container-xl&quot;&gt;
                          &lt;p className=&quot;text-white text-center fs-4 mt-4 m-md-0&quot;&gt;GuitarLA - Todos los derechos Reservados&lt;/p&gt;
                        &lt;/div&gt;
                      &lt;/footer&gt;        
                      &lt;/&gt;
                    )
                  &rcub;
                  
                  export default App
                </code></pre>
              </div>
            </div>

            <p class="naranja">Creando un State de Carrito</p>

            <p>Veamos como agregar nuestras guitarras. Hagamos un state nuevo de carrito. No es bueno tener 30 o 40 states (en esos casos quizás sean mejores otras opciones como sustain, J, Context API o como Redux Toolkit). Sin embargo, tampoco se recomienda tener un solo state muy grande, porque tener un state muy grande te va a llevar a tener que escribir una lógica muy grande cuando quieras actualizar o modificar ese state.</p>

            <p>lo creamos en nuestro componente de App.jsx (no lo creamos en Guitar.jsx. cada guitarra es un componente distinto y si crearar ahí un state de carrito tendría 12 diferentes :D). Como va a ser un carrito de compras su valor inicial será un Array vacío <code class="language-js">const [cart, setCart] = useState([])</code> de manera que vamos a tener acceso a ciertos métodos de array para agregar elementos, eliminarlos, revisar si ya existe un elemento y evitar duplicados, si está vacío. <span class="destacado">Son muchos los beneficios de utilizar el tipo de dato adecuado a nuestro state inicial</span>. Si abrimos la pestaña componentes de React Developer Tools vemos que en el componente App tenemos nuestro state de guitarras, pero también este nuevo state de carrito que está vacío (con lo cual, se registró correctamente).</p>

            <p>¿Cómo agregamos elementos a nuestro carrito? tenemos varias formas de hacerlo:</p>

            <ul class="mb-3.75">
              <li>la más simple: para agregar elementos a nuestro state "cart" vamos a tener que utilizar simepre la función "setCart". El evento de agregarlos se está presentando en el componente Guitar.jsx. Recordemos que podemos pasar vía props desde el componente padre App.jsx strings, objetos y <strong>funciones</strong>, así que pasamos nuestra función setCart del state cart <span class="verde">App.jsx:</span>
                <pre><code class="language-js">
                  &lcub;data.map((guitar) =&gt; (                    
                    &lt;Guitar
                      key = &lcub;guitar.id&rcub; 
                      propguitar = &lcub;guitar&rcub; 
                      setCart = &lcub;setCart&rcub;                          
                    /&gt;
                  )
                  )&rcub;
                </code></pre>
                <span class="verde">Guitar.jsx:</span> <code class="language-js">export default function Guitar({propguitar, setCart}){</code>
              <img class="my-2.5" src="./src/assets/img/68-1.png" alt="" /></li>
              <li>otra forma de hacerlo: tenemos en el botón nuestro <code class="language-js"> onClick={() => handleClick(propguitar)}</code> modificamos la función para pasarle la guitarra a nuestro state cart: <span class="destacado">esperamos que ocurra el click, cuando pinchas se le pasa la guitarra y seteamos al carrito</span>
              <pre><code class="language-js">
                const handleClick = (guitar) => {
                  setCart(guitar)
                }			
              </code></pre>
              <p>cada vez que pinchamos se modifica el state agregando el objeto guitarra, pero si presiono otro reemplaza lo que hay, y en un carrito no queremos reemplazar sino agregar. Lo está escribiendo correctamente pero tenemos que mantener lo que ya teníamos en el carrito. En vez de un objeto quiero que me escriba un array pero nos seguirá pasando lo mismo, cada vez que pulsemos una guitarra reemplazará a la anterior en el state cart:</p>
              <img class="my-2.5" src="./src/assets/img/68-2.png" alt="" />
              <p>¿Como hago para que los datos que agregué al carrito persistan? Tenemos que tener la referencia de nuestro state de carrito cart, así que lo pasamos desde nuestro componente padre App.jsx al componente Guitar.jsx: <span class="verde">App.jsx:</span></p>
              <pre><code class="language-js">
                &lcub;data.map((guitar) =&gt; (                    
                  &lt;Guitar
                    key = &lcub;guitar.id&rcub; 
                    propguitar = &lcub;guitar&rcub; 
                    cart = &lcub;cart&rcub;
                    setCart = &lcub;setCart&rcub;                          
                  /&gt;
                )
                )&rcub;
              </code></pre>
              <span class="verde">Guitar.jsx:</span> <code class="language-js">export default function Guitar({propguitar, cart, setCart}){</code>
              <img class="my-2.5" src="./src/assets/img/68-3.png" alt="" />
              </li>
              <li>Otra manera: eliminemos la función 
                <pre><code class="language-js">
                  const handleClick = (guitar) => {
                    setCart([...cart, guitar])
                  }			
                </code></pre>
                y llamarla directamente en el onClick: <code class="language-js">onClick={() => setCart([...cart, propguitar])}</code>. <span class="destacado">Algo importante es que ese <strong>setCart</strong> ya sabe lo que hay en el state. Desde que declaramos el state de cart esa función setCart siempre va a estar asociada con ese estate de carrito (sabe de su existencia, sabe qué hay, sabe que tiene que escribir en ese cart, nunca se va a mezclar con otras de otros states.) Por tanto no haría falta pasarle como propiedad el carrito (la función ya sabe lo que tiene).</span> En la nueva función de flecha nótese la convención de nombre <strong>prev</strong>Cart por tanto quedaría así <br><code class="language-js">onClick={() => setCart(prevCart =>[...prevCart, propguitar])}</code><br> No tenemos que pasar el state, la función setCart toma la copia del state actual</li>
              </ul>

            
              <p class="naranja">Agregando Guitarras al Carrito</p>

              <p>Con el enfoque actual, se hace un poco complicado porque tendríamos que añadir lógica en la llamada del onclick para revisar si un registro está duplicado o no etc... y no queremos lógica en nuestros templates. Para tener lógica usamos la parte de antes del return() o un Hook aparte. Cambiemos el enfoque y modifiquemos nuesto código:</p>

              <p>En App.jsx antes del return creamos una nueva función intermedia que sea más descriptiva de loq ue se está haciendo y en donde con cierta lógica podamos evitar problemas ocmo elementos duplicados etc: <strong>function addToCart(){}</strong> y la pasamos como prop para que esté disponible para otros componentes de manera que se pueda agregar ese elemento al carrito. Al parámetro lo llamamos <strong>item</strong> también por convención para reutilización de lógica de carrito.</p>

              <pre><code class="language-js">
                function addToCart(item){
                  setCart(prevCart =>[...prevCart, item])
                }
              </code></pre>

              <p class="naranja">Detectar si un elemento existe en el carrito</p>

              <p>No queremos tener registros duplicados en un carrito de compras ¿como lo evitamos? antes de setear al carrito de compras hemos de verificar si ese elemento ya existe en el Array, si existe actualizaremos la cantidad y si no existe lo agregamos. Esto nos lleva a un tema que es muy importante en React <span class="destacado">¿Qué significa la inmutabilidad en React?</span> ¿qué significa que un state es inmutable? Si vemos la función que acabamos de crear. setCart(prevCart =>[...prevCart, item]) <strong>no estamos modificando el state, tomamos una copia del state y agregamos el nuevo elemento</strong>. Otros array methods que nos permiten añadir elementos a un array serían por ejemplo <strong>cart.push(item): sin embargo esto modifica el state original</strong>. Y nuestro state tiene que ser inmutable. Por eso siempre se utiliza la función asociada al state. Incluso si utilizáramos la función e hiciéramos algo como setCart(prevCart => cart.push(item) estaríamos modificando el state original. Para saber qué array methods de js mutan el state original y cuales no consultamos: <a href="https://doesitmutate.xyz/" class="text-[#000000]" target="blank">https://doesitmutate.xyz/</a>
              </p>

              <p>Para saber si ya existe un elemento en un array vamos a usar el método de arrays <span class="destacado">.findIndex()</span> que no provoca mutación; va a iterar sobre nuestro carrito de compras cart y va ir creando un objeto temporal que por ejemplo llamamos "guitar" (no lo llamamos item porque nuestra función ya tiene un parámetro que se llama así y provocaríamos confusión). En la parte derecha del arrow function añadimos la comprobación de si el elemento nuevo que estamos añadiendo es el mismo que ya existe en mi state. <strong>Si el elemento está presente en el array devuelve el índice que ocupa en el array y si no lo encuentra devuelve -1</strong>. En este punto nuestra función va así y hagamos un console.log() para entenderlo.</p>

              <pre><code class="language-js">
                function addToCart(item){
                  const itemExists = cart.findIndex(guitar => guitar.id === item.id) // ese "guitar" es el nombre que queramos poner
                  console.log(itemExists)
              
                  setCart(prevCart =>[...prevCart, item])
                }			
              </code></pre>

              <p>Como vemos haga lo que haga, de momento seguimos seteando elementos al state. Tendremos que meter una comprobación para antes de setear, si existe en el array actualizaremos la cantidad y si no existe lo agregamos.</p>

              <p class="naranja">Agregando guitarras al Carrito con Cantidad</p>

              <p>Agreguemos la cantidad de guitarras para poder reflejarlo en el carrito.</p>
              <pre><code class="language-js">
                function addToCart(item){
                  const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                  if(itemExists >= 0){//existe en cart
                    console.log('ya existe')            
                  } else{
                    //console.log('NO EXISTE, agregando...')
                    item.quantity = 1
                    setCart(prevCart =>[...prevCart, item])
                  }       
                }	
              </code></pre>

              <p class="naranja">Incrementando cantidad si un artículo ya estaba</p>
              <p>Cuando ya existe, hemos de tener cuidado en no romper ciertas reglas del state. Por ejemplo si en nuestra función añadiéramos esto cuando el elemento existe:
              <code class="language-js">cart[itemExists].quantity++</code> <span class="rojo">¡estaríamos modificando directamente nuestro state!</span></p>
              <pre><code class="language-js">
                function addToCart(item){
                  const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                  if(itemExists >= 0){//existe en cart
                    console.log('ya existe')  
                    cart[itemExists].quantity++ //estaríamos modificando nuestro estate ¡Y EL STATE ES INMUTABLE!!         
                  } else{
                    //console.log('NO EXISTE, agregando...')
                    item.quantity = 1
                    setCart(prevCart =>[...prevCart, item])
                  }       
                }
              </code></pre>

              <p>creamos una copia del carrito usando el spread operator, incrementamos la cantidad y seteamos:</p>
              <pre><code class="language-js">
                function addToCart(item){
                  const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                  if(itemExists >= 0){//existe en cart
                    const updatedCart = [...cart] //copia nueva de mi state, no modifica mi carrito       
                    updatedCart[itemExists].quantity++
                    setCart(updatedCart)
                  } else{//NO EXISTE en cart
                    item.quantity = 1
                    setCart(prevCart =>[...prevCart, item])
                  }       
                }
              </code></pre>
            
          </div>
          <!-- Fin bloque desplegable interior-->

          
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-81').toggle();">	
            <h3>73. Mostrando los Contenidos del carrito / 74. Detectando si el carrito está vacío / 75. State derivado / 76. Calculando el Total a pagar / 77. useMemo para mejorar el performance de nuestro código / 78. Eliminando artículos del carrito / 79/80. Creando una Función para Incrementar las cantidades y RETO 01 / 81. Función limpiar carrito</h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-81" class="hidden">
            <p>Vamos a empezar a hacer dinámica la sección del carrito de compra. Está en nuestro Header.jsx, vamos a hacer dinámica esta parte y sincronizarla con nuestro state. En nuestro componente App.jsx, al Header le vamos a pasar el carrito <strong>el prop se va a llamar cart y el valor también cart, para no tener que pensar en nombres diferentes es recomendable ponerl el mismo que tiene ese state</strong>.</p>
            <pre><code class="language-js">
              &lt;Header
              cart = &lcub;cart&rcub;
            /&gt;
            </code></pre>

            <pre><code class="language-js">
              export default function Header({cart}){
            </code></pre>

            <p>la estructura del carrito es con una tabla. Iteramos en el tbody para que genere un tr por cada elemento en nuestro carrito:</p>
            <pre><code class="language-js">
              &lcub;cart.map( guitar =&gt;( 
                &lt;tr&gt;
                  &lt;td&gt;
                    &lt;img className=&quot;img-fluid&quot; src=&quot;./public/img/guitarra&lowbar;02.jpg&quot; alt=&quot;imagen guitarra&quot; /&gt;
                  &lt;/td&gt;
                  &lt;td&gt;SRV&lt;/td&gt;
                  &lt;td className=&quot;fw-bold&quot;&gt;
                      $299
                  &lt;/td&gt;
                  &lt;td className=&quot;flex align-items-start gap-4&quot;&gt;
                    &lt;button
                      type=&quot;button&quot;
                      className=&quot;btn btn-dark&quot;
                    &gt;
                      -
                    &lt;/button&gt;
                      1
                    &lt;button
                      type=&quot;button&quot;
                      className=&quot;btn btn-dark&quot;
                    &gt;
                      &plus;
                    &lt;/button&gt;
                  &lt;/td&gt;
                  &lt;td&gt;
                    &lt;button
                      className=&quot;btn btn-danger&quot;
                      type=&quot;button&quot;
                    &gt;
                      X
                    &lt;/button&gt;
                  &lt;/td&gt;
                &lt;/tr&gt;
              ))&rcub;
            </code></pre>

            <p>Comenta sobre la posibilidad de que este tr lo hiciéramos componente y habla sobre el inconveniente de tener demasiados componentes pequeños, tener que andar enviando y manejando demasiados props (que se podría manejar con Redux toolkit o manejador de estado global pero aún no hemos visto ese tema ni conviene para un proyecto tan pequeño como este.) </p>

            <img class="my-2.5" src="./src/assets/img/73.png" alt="" />

            <p>no lo estoy pasando via props, pero el objeto <strong>guitar</strong> existe dentro de ese paréntesis y puedo acceder a sus propiedades. Si vemos en consola nos da un aviso de id único para Header. Tenemos que darle un key único al tr.</p>
            
            <pre><code class="language-js">
              &lt;tbody&gt;
              &lcub;cart.map( guitar =&gt;( 
              &lt;tr key=&lcub;guitar.id&rcub;&gt;
                &lt;td&gt;
                  &lt;img className=&quot;img-fluid&quot; src=&lcub;&grave;/img/$&lcub;guitar.image&rcub;.jpg&grave;&rcub; alt=&quot;imagen guitarra&quot; /&gt;
                &lt;/td&gt;
                &lt;td&gt;&lcub;guitar.name&rcub;&lt;/td&gt;
                &lt;td className=&quot;fw-bold&quot;&gt;
                    $&lcub;guitar.price&rcub;
                &lt;/td&gt;
                &lt;td className=&quot;flex align-items-start gap-4&quot;&gt;
                  &lt;button
                    type=&quot;button&quot;
                    className=&quot;btn btn-dark&quot;
                  &gt;
                    -
                  &lt;/button&gt;
                    &lcub;guitar.quantity&rcub;
                  &lt;button
                    type=&quot;button&quot;
                    className=&quot;btn btn-dark&quot;
                  &gt;
                    &plus;
                  &lt;/button&gt;
                &lt;/td&gt;
                &lt;td&gt;
                  &lt;button
                    className=&quot;btn btn-danger&quot;
                    type=&quot;button&quot;
                  &gt;
                    X
                  &lt;/button&gt;
                &lt;/td&gt;
              &lt;/tr&gt;
              ))&rcub;
            &lt;/tbody&gt;
            </code>
            </pre>

            <p class="naranja">Detectando si el carrito está vacío</p>
            <p>¿Hemos de crear un state para eso? no es necesrio crear un state para cada cosa. Veamos un par de alternativas para hacer esto. Estamos pasando como prop desde App.jsx nuestro cart, y en el código del componente Header.jsx iteramos el tr sobre cart. <span class="destacado">En este punto podemos escribir un ternario</span>. <strong>Como vimos en la parte de statements y expresiones, no podemos tener un if pero sí un ternario</strong>:</p>
            <pre><code class="language-js">
              &lcub;cart.length === 0 ? (
                &lt;p className=&quot;text-center&quot;&gt;El carrito esta vacio&lt;/p&gt;                                            
                ):( 
                //El resto de la tabla
              )&rcub;
            </code></pre>
            <p>También podemos usar un state derivado en lugar de ese <code class="language-js">cart.length === 0</code></p>

            <p class="naranja">State derivado</p>

            <p>Algunas veces queremos derivar el state. Actualmente tenemos nuestro state de carrito <code class="language-js">const [cart, setCart] = useState([])</code>. En lugar de crear un state nuevo que estemos revisando y su valor dependa de que cart tenga algo, podemos crear una variable/funcion cuyo valor vaya a depender mucho de este otro state. Lo podemos tener ¿en el return del App.jsx? o en el Header.jsx donde lo usamos (opta por esta). La idea es mantener la lógica fuera del template:</p>

            <pre><code class="language-js">
              export default function Header({cart}){

                //State derivado
                const isEmpty = () => cart.length === 0

                {isEmpty() ? (
                  &lt;p className=&quot;text-center&quot;&gt;El carrito esta vacio&lt;/p&gt;                                            
                ):( 
                //El resto de la tabla
                )}        
            </code></pre>

            <p class="naranja">Calculando el Total a pagar</p>			
            <p>Metemos el párrafo en la parte del ternario que renderiza la tabla. <strong>nos dará error porque necesitamos tener un único elemento en el nivel superior, metemos un fragment que englobe a la tabla+p</strong>. Para calcular el total a pagar vamos a utilizar un array method llamado <span class="destacado">reduce()</span>. Lo utilizamos para construir este state derivado de lo que tenemos en el carrito de compras:</p>

            <pre><code class="language-js">
              const isEmpty = () => cart.length === 0
              const cartTotal = () => cart.reduce( (total, item) => total + (item.quantity * item.price), 0)
            </code></pre>

            <p>Es uno de los pocos array methods que toma dos parámetros, uno es el total ,es decir un acumulado, va a ir iterando sobre cada elemento que tenemos en el carrito; el segundo parámetro <strong>item</strong> es el elemento actual. En el arrow function siguiente al total acumulado le vamos sumando el resultado de multiplicar la cantidad de item * precio de item. el valor <strong>0</strong> es el valor inicial; el carrito inicia en 0 y a apartir de ahí sumamos.</p>

            <p>Si no quisiéramos llamar estas funciones isEmpty() y carTotal() podríamos hacer uso de un Hook que se llama useMemo que también es bastante común</p>

            <p class="naranja">useMemo para mejorar el performance de nuestro código</p>

            <p>Si tenemos experiencia con Vue.js sabremos que hay algo que se llama compute properties y useMemo hace algo bastante similar:</p>
            <ul class="mb-3.75">
              <li>Simplifica los templates un poco</li>
              <li>Es un Hook enfocado al performance porqeu evita que este código se ejecute (los 2 states derivados vistos) si alguna de las dependencias que vamos a deifnir en ese useMemo no ha cambiado.</li>
            </ul>
            <p><strong>Importamos esl Hook useMemo en nuestro componente Header.jsx:</strong> <code class="language-js">import { useMemo } from 'react'</code>. Vamos a usarlo en nuestro state derivado isEmpty. useMemo es una función que toma dos parámetros (un factory que es la función y el array de dependencias), los vemos explicados si nos colocamos en VSC encima de useMemo:</p>
            <img class="my-2.5" src="./src/assets/img/77-useMemo.png" alt="" />
            <pre><code class="language-js">
              const isEmpty = useMemo( () => cart.length === 0, [cart])
            </code></pre>

            <p>Este código no va a cambiar hasta que cambien ciertas partes de nuestro código. ¿Qué imporancia tiene esto? React siempre va ahacer un render completo de nuestra aplicación. Si presionamos en agregar al carrito, hace un render completo donde tengas el state. Eso puede suponer mucho coste en términos de rendimiento, hacer que nuestra aplicación sea más lenta...entonces <span class="destacado">useMemo es una forma de decirle: "no haghas render completo de mi aplicación hasta que no cambie algo que yo te voy a decir qué es; para eso es el arreglo de dependencias y en concreto este código anterior le dice "vuelve a ejecutar este código, a hacer el render cuando cart cambie, cada vez que añadamos, eliminemos, modificamos algo del carrito"</span>. Como isEmpty ya no es una función, eliminamos en nuestro template esto <code class="language-js"> isEmpty() </code>y en su lugar lo llamamos así <code class="language-js"> isEmpty</code></p>

            <p>Hacemos lo mismo con el state derivado carTotal, porque queremos que el Total se calcule solo cuando el carrito cambie:</p>
            <pre><code class="language-js">
              const isEmpty = useMemo( () => cart.length === 0, [cart])
            </code></pre>

            <p>useMemo no es un Hook que vayamos a utilizar en todos sitios, es un Hook enfocado a performance pero por el hecho de que cachea esos resultados entre renders, <strong>a veces puede ser contraproducente cachear tanto. Hay que probar según el caso y vigilar nuestro state. Si no se actualiza como esperamos lo quitamos y/o valorar otras opciones apra trabajar con caché en nuestros componentes</strong>.</p>

            <p class="naranja">Eliminando artículos del carrito</p>

            <p>Lo primero que tenemos que hacer es crear una función. El carrito está en el componente <strong>App.jsx</strong> y el botón para eliminar está en el componente <strong>Header.jsx</strong>. Creemos la función en el componente principal y la pasaremos via <strong>props</strong>. Comprobemos de momento con un console.log() sin más que la comunicación entre nuestro botón eliminar del Header y la nueva función creada es correcta. <span class="destacado">Como ya hemos hecho antes, al pasar el prop lo nombramos igual que nuestra función así nos quitamos de tener que pensar en varios nombres (yo en un ejemplo anterior con el objeto guitar le puse al nombre del prop "propguitar" pero era mientras me acostumbraba  a todo esto para no perder la referencia de lo que estaba haciendo).</span></p>

            <pre><code class="language-js">
              //antes del return
              function removeFromCart(){
                console.log('Eliminando...')
              }
              
              //en el return llamando a nuestro componente
              &lt;Header
              cart = &lcub;cart&rcub;
              removeFromCart = &lcub;removeFromCart&rcub;
            /&gt;      
            </code></pre>

            <p>Nos vamos ahora a nuestro componente Header.jsx y primero vamos a tomar esa función, aplicamos destructuring a esa función:</p>

            <pre><code class="language-js">export default function Header({cart, removeFromCart}){</code></pre>

            <p>la asociamos con el botón de eliminar. Vamos a esperar que el usuario presione en él por tanto colocamos en el un onClick y pasamos el nombre de la función: <code class="language-js"></code></p>

            <pre><code class="language-html">
              &lt;button
                className=&quot;btn btn-danger&quot;
                type=&quot;button&quot;
                onClick=&lcub;removeFromCart&rcub;&gt;
              X
              &lt;/button&gt;
            </code></pre>

            <p>Si pulsamos ya vemos en la consola el mensaje que hemos puesto para verificar que hay comuniación. ¿Cçomo eliminamos elementos? Estamos almacenando todo en este arreglo de cart. <span class="destacado">Vamos a utilizar un array method que nos permita sacar elementos de ese arreglo y uno muy común que no muta nuestro state es .filter()</span> Nos va a permitir filtrar en base a una condición. Por ejemplo pensemos en los id. Para ello tenemos que pasarle un parámetro:</p>
            <ul class="mb-3.75">
              <li>le pasamos un parámetro a la función:
                <pre><code class="language-js">
                  //antes del return
                  function removeFromCart(id){
                    console.log('Eliminando...', id)
                  }
                </code></pre></li>
              <li><span class="destacado">si le pasamos un parámetro en el onclick hay que ponerle un callback y le pasamos guitar.id, y de esa forma vamos a poder identificar qué elemento es el que estamos presionando para eliminarlo de nuestro carrito de compras.</span>
                <pre><code class="language-html">
                  &lt;button
                    className=&quot;btn btn-danger&quot;
                    type=&quot;button&quot;
                    onClick=&lcub;() =&gt; removeFromCart(guitar.id)&rcub;
                  X
                  &lt;/button&gt;
                </code></pre>          
              </li>
            </ul>

            <p>podríamos crear una nueva variable con lo que nos retorna el filter() pero también podemos hacerlo en una sola función: si lo pasamos como callback aquí vamos a tener el valor previo de nuestro carrito. Le aplicamos el método filter() y le indicamos que nos filtre las guitarras cuo id sea diferente al que le pasamos; ello regresa el nuevo arreglo y lo setea en nuestra función.</p>

            <pre><code class="language-js">
              function removeFromCart(id){
                //console.log('Eliminando...', id)      
                setCart(prevCart => prevCart.filter(guitar => guitar.id !== id))
            }
            </code></pre>

            <p>Si probamos a eliminar una guitarra vemos que se elimina del carrito y que además el total se actualiza. Recordemos que <strong>carTotal es un state derivado, tiene un useMemo y como dependencia el cart, también se vuelve a ejecutar y calcula el total a pagar de nuestro carrito de compra.</strong>. Si las eliminamos todas vemos que sale lo de que el carrito está vacío, porque también se ejecuta nuestro otro state derivado <strong>isEmpty</strong>.</p>

            <p>Vemos lo sencillo que es con react mantener sincronizado nuestro state con nuestra interfaz, no hay que llamar a ninguna función para refrescar nuestra interfaz, automáticamente lo hace por nosotros.</p>

            <p class="naranja">Creando una Función para Incrementar las cantidades y RETO 01</p>
            <p>Creamos una nueva función intermedia desriptiva que nos sirva para manejar la lógica. toma un id porque requerimos identificar el elemento. Como está en el Header, la pasamos via prop usando el mismo nombre:</p>

            <pre><code class="language-js">
              function increaseQuantity(id)&lcub;
              console.log(&apos;Incrementando...&apos;&comma; id)
            &rcub;
            
            return (
              &lt;&gt;   
              &lt;Header
                cart = &lcub;cart&rcub;
                removeFromCart = &lcub;removeFromCart&rcub;
                increaseQuantity = &lcub;increaseQuantity&rcub;
              /&gt;
            </code></pre>

            <p>Extraemos la nueva prop en la declaración de la función de nuestro componente Header: <code class="language-js">export default function Header({cart, removeFromCart, increaseQuantity}){</code>. En el código del return donde está el botón "+" para incrementar le añadimos el onClick con su función de flecha que llama a ese prop pasándole como argumento el id de la guitarra que se pulsa:</p>

            <pre><code class="language-js">
              &lt;button
              type=&quot;button&quot;
              className=&quot;btn btn-dark&quot;
              onClick=&lcub;() =&gt; increaseQuantity(guitar.id)&rcub;&gt;
              &plus;
            &lt;/button&gt;
            </code></pre>

            <p>Cada vez que agregábamos un elemento al carrito (ver en nuestro componente App.jsx la función addToCart) estábamos incrementando esta propiedad de cantidad "item.quantity". <strong>Actualicemos nuestra función teniendo esto en mente y que vamos a tener que actualizar esa propiedad de cantidad con cada agregado.</strong> Creamos una variable nueva "updatedCart" y usamos el .map() (recordemos que a diferencia de forEach(), nos va a devolver un array nuevo. Ambos sirven para iterar un arreglo pero .map() nos genera una copia nueva que va a estar en esta variable). Con cart.map( ) accedemos a cada elemento del carrito. También limitamos como número máximo 5 por guitarra. En este punto menciona el libro "Clean Code" y aconseja tanto seguir buenas prácticas ocmo tener preferencias personales; para este caso el es partidario de crear una constante con el valor máximo y es la que llamaremos en nuestra condición <strong>const MAX_ITEMS = 5</strong>:</p>

            <pre><code class="language-js">
              const &lsqb;data&comma; setData&rsqb; = useState(db)
              const &lsqb;cart&comma; setCart&rsqb; = useState(&lsqb;&rsqb;)
              const MAX&lowbar;ITEMS = 5
              const MIN&lowbar;ITEMS = 1

              function increaseQuantity(id){
                //console.log('Incrementando...', id)
                const updatedCart = cart.map ( item => {
                    if(item.id === id &amp;&amp; item.quantity &lt; MAX&lowbar;ITEMS){
                        return{
                            ...item,//ponemos esto porque no queremos perder la referencia de loq ue ya tenemos en el cart
                            quantity: item.quantity + 1 //si pusiéramos solo esto solo nos devolvería la cantidad
                        }
                    }
                    return item //para que mantenga el reto de elementos sobre los que no dimos click en aumentar cantidad
                })
                setCart(updatedCart) //esa variable la seteamos al carrito
            }
            </code></pre>

            <p class="naranja">Reto 01: Decrementar cantidades</p>

            <ul class="mb-3.75">
              <li>Hacer funcional el botón de decrementar cantidades.</li>
              <li>Crear la función, pasarla via props, identificar el elemento a actualizar y añadirlo al state, así como añadir un límite para nunca seleccionar menos de un elemento.</li>
              <li>Seguir la convenciones de nombres de incrementar cantidad.</li>
            </ul>

            <pre><code class="language-js">
              const &lsqb;data&comma; setData&rsqb; = useState(db)
              const &lsqb;cart&comma; setCart&rsqb; = useState(&lsqb;&rsqb;)
              const MAX&lowbar;ITEMS = 5
              const MIN&lowbar;ITEMS = 1
              
              function decreaseQuantity(id){
                //console.log('Decrementando...', id)
                const updatedCart = cart.map( item => {
                    if(item.id === id && item.quantity > MIN_ITEMS){
                        return{
                            ...item,//ponemos esto porque no queremos perder la referencia de lo que ya tenemos en el cart
                            quantity: item.quantity -1 //si pusiéramos solo esto solo nos devolvería la cantidad
                        }
                    }
                    return item //cuando no se cumple la condición: mantiene el resto de elementos sobre los que no dimos click en decrementar cantidad
                })
                setCart(updatedCart)
            }
            </code></pre>

            <p>Si presiono rápidamente en agregar cualquier guitarra podemos ver que nos pasamos del límite máximo de 5 que tenemos establecido por la variable <strong>const MAX_ITEMS = 5</strong>. <span class="destacado">Añadamos una nueva condición a la función addToCart() para que, en caso de que la posición actual de cart su cantidad sea mayor que el límite establecido no ejecute nada</span>. Vemos que en caso de que existiera ejecutábamos el código en el que <strong></strong>creábamos una nueva variables const updatedCart en la que hacíamos copia del cart actual con el spread operator y a continuación incrementábamos la cantidad del item y lo seteábamos en nuestro state de cart</strong>. No queremos que haga eso si en la posición actual del cart la cantidad supera el límite establecido. Añadimos <code class="language-js">if(cart[itemExists].quantity >= MAX_ITEMS) return</code>:</p>

            <pre><code class="language-js">
              function addToCart(item){
                const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                if(itemExists >= 0){//existe en cart
                    if(cart[itemExists].quantity >= MAX_ITEMS) return
                    const updatedCart = [...cart] //copia nueva de mi state, no modifica mi carrito       
                    updatedCart[itemExists].quantity++
                    setCart(updatedCart)
                } else{//NO EXISTE en cart
                    item.quantity = 1
                    setCart(prevCart =>[...prevCart, item])
                }       
            }
            </code></pre>

            <p class="naranja">Agregando la función de Limpiar Carrito</p>

            <p>Poríamos utilizar la función de nuestro state cart <strong>setCart()</strong> pero <span class="destacado">vamos a crear una función intermedia para borrar el carrito <span class="destacado">function clearCart(){}</span> en la que seteamos un arreglo vacío: setCart([])</span>. Esta es una de las grandes ventajas de los Hooks (por ejemplo para un usuario que se encontrara logado haríamos lo mismo seteando a false un supuesto state auth)</p>

            <pre><code class="language-js">
              function clearCart(){
                setCart([]) //seteamos un arreglo vacío
            }
            </code></pre>
            <p>como el botón donde vamos a llamar a esta función está en el componente Header.jsx, pasamos esa función vía props:</p>
            <pre><code class="language-js">
              &lt;Header
              cart = &lcub;cart&rcub;
              removeFromCart = &lcub;removeFromCart&rcub;
              decreaseQuantity = &lcub;decreaseQuantity&rcub;
              increaseQuantity = &lcub;increaseQuantity&rcub;
              clearCart = &lcub;clearCart&rcub;           
            /&gt;
            </code></pre>
          
          </div>
          <!-- Fin bloque desplegable interior-->
      


          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-82').toggle();">	
            <h3>82. Carrito persistente con LocalStorage - Almacenando</h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-82" class="hidden">
            <p class="naranja">Carrito persistente con LocalStorage - Almacenando</p>
            <p>Tener un carrito persistente es un buen truco para mantener los mismos elementos en el carrito aunque recarguemos navegador. ¿Cómo hacemos para tener sincronizado nuestro carrito de compras <code class="language-js">const [cart, setCart] = useState([])</code> con localStorage</p>
            
            <p>localStorage es una API muy sencilla que solo permite almacenar strings (ni objetos ni arrays). Como nuestro carrito es un array lo podemos convertir a string con <span class="destacado">JSON.stringify(cart)</span></p>

            <pre><code class="language-js">
            function saveLocalStorage(){
              localStorage.setItem('cart', JSON.stringify(cart))
            }
            </code></pre>

            <pre data-line="11"><code class="language-js">
              function addToCart(item){
                const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                if(itemExists >= 0){//existe en cart
                    if(cart[itemExists].quantity >= MAX_ITEMS) return
                    const updatedCart = [...cart] //copia nueva de mi state, no modifica mi carrito       
                    updatedCart[itemExists].quantity++
                    setCart(updatedCart)
                } else{//NO EXISTE en cart
                    item.quantity = 1
                    setCart(prevCart =>[...prevCart, item])
                } 
                saveLocalStorage()
            }
            </code></pre>

            <p>Si vamos a las web developer tools, en la pestaña <strong>aplicación>storage</strong> podemos ver el Local Storage. Vemos que si añadimos un primer elemento al carrito agrega algo pero vacío, y ya la segunda vez sí agrega:</p>
            
            <img class="my-2.5" src="./src/assets/img/82-01.png" alt="" />
            
            <p>El estado o state en React ¿es síncrono?¿o es asíncrono y por qué? Pos...es asíncrono, es decir, no se actualiza inmediatamente sino hasta algunos milisegundos después. ¿por qué es asíncrono? Si fuera síncrono (que todas las funciones se ejecuten en orden una tras otra) eso haría que no podríamos interaccionar con la pantalla hasta que no escriba ese estate, lo que nos dejaría sin respuesta en especial si es un state muy grande. <strong>Revisar:</strong> esa función saveLocalStorage() se manda llamar inmediatamente (mientras que el resto de nuestra función addToCart() es síncrona. Es decir cuadno la estamos llamando aún no ha sido escrito el cart por primera vez y es por eso que lo toma como un arreglo vacío</p>

            <p>¿como lo solucionamos? usando el versátil <strong>Hook useEffect()</strong> (similar al watch en vue.js). Vimos su uso cuando el componente está listo pero también tiene el siguiente caso de uso (cuando cambie mi carrito ejecutar cierto código). Es muy útil para manejar los "efectos secundarios" de un cambio en nuestro state. <strong>Eliminamos la función que hemos creado y no obstante la usamos dentro del Hook que va a estar observando por nuestro state cart; cada vez que este cambie, ejecutará lo que le especificamos (lo que antes teníamos en la función).</strong>. React se va a encargar de actualizar el localStorage una vez que ese state haya completado su acción de actualizarse en base a las funciones que teNemos definidas para ese state en lo que llevamos hecho, no hemos de preocuparnos de crear una función. Abrimos chrome y limpiamos el local storage (boton derecho borrar) y podemos comprobar que si añadimos ahora elementos al carrito, ya desde la primera vez se actualiza el local storage.</p>

            <pre><code class="language-js">
              import { useState, useEffect } from "react" // importamos el Hook useEffect
              //lo añadimos tras nuestras variables MIN_ITEMS, MAX_ITEMS
              useEffect(() => {
                localStorage.setItem('cart', JSON.stringify(cart))
              }, [cart])
            </code></pre>                               

            <p class="naranja">Carrito persistente con LocalStorage - Recuperar los productos y mostrarlos</p>

            <p>Si recargo me aparece el carrito vacío, veamos cómo hacemos que persista. Esto pasa porque el useEffect que empleo para el almacenamiento local cada vez que carrito cambie también se ejecuta por primera vez cuando el componente esta listo, es decir de manera similar a cuando no tiene ninguna dependencia. Debemos revisar si hay algo en localStorage ese va a ser nuestro valor inicial y si no colocamos un arreglo vacio. <strong>const inicialCart</strong> (en algunos ejemplos la nombran como inicialState pero no lo recomienda en caso de tener varios states)</p> 

            <p>vamos a comprobar si hay algo en este elemento <strong>localStorageCart</strong>. (Si no hay nada devuelve un null) Si tiene algo lo convertimos de string a arreglo con JSON.parse()</p>

              <pre data-line="5"><code class="language-js">
                const initialCart = () => {
                  const localStorageCart = localStorage.getItem('cart') // lo primero es recuperar de localStorage
                  //a continuación comprobamos si hay algo en esa variable:
                  return localStorageCart ? JSON.parse(localStorageCart): []
              }
              const [data, setData] = useState(db)    
              const [cart, setCart] = useState(initialCart)
              </code></pre>
            
          </div>
          <!-- Fin bloque desplegable interior-->


          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-84').toggle();">	
            <h3>84. Últimos Ajustes y Deployment</h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-84" class="hidden">
            <p>Veamos los últimos ajustes para realiszar el deployment de nuestro proyecto. Revismoas avisos en la terminal por si tenemos rutas a img mal puestas y también eliminamos funciones y/o variables que no se estén utilizando. En este caso como vemos, la función del state data "setData" no se está usando así que la podemos eliminar: <code class="language-js">const [data, setData] = useState(db) </code></p>

            <img class="my-2.5" src="./src/assets/img/84.png" alt="" />

            <p>¿Como podemos subir este proyecto? <span class="destacado">Este tipo de proyectos de React.js Vue.js Angular.js se tienen que construir</span>. Si abrimos el <strong>package.json</strong> vemos la línea de "build": "vite build". Todo loque tenemos está en desarrollo pero cuando construimos, este comando se va a encargar de realizar una serie de mejoras, de performance (subir versiones minificadas, más ligera...). Vamos a la terminal y escribimos <span class="destacado">npm run build</span> nos genera la carpeta <span class="destacado">dist</span>. En la consola nos da una serie de información "convertí 34 módulos" incluyendo nuestros componentes, nuestros archivos y también algunas d elas dependencias que imporamos en la parte superior, entonces Vite en automático se encarga de hacerlo. En esa carpeta dist genera nuestro index.html, la hoja de estilos y la js que contiene una versión de React. Pero si damos doble click a ese html eso no funciona, hay que subirlo a algún sitio. La mejor versión hoy día es Netlify. Si nos logamos de nuevas comenta que si la cuenta es muy nueva en Github va a haber errores (lo hacen para protegerse del spam) y presionamos en iniciar sesión con email.</p>

            <p>A continuación veamos cómo crear nuestros propios Hooks y por qué es bueno hacerlo. Lo haremos con uno que centralice todas las funciones de nuestro carrito de compra.</p>
            
          </div>
          <!-- Fin bloque desplegable interior-->
                     
        </div>
        <!-- Fin div colapsable-->
      
      </div>	
      <!-- FIN SECCIÓN 6 -->
    
  
      <!-- SECCION 3 y 4-->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
        <div class="row">
          <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion3').toggle();">	
            <h2>Sección 3 y 4: PROYECTO - Carrito de compras. Introducción / Herramientas / Creando el proyecto en Windows</h2>				
            <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
          </div>
          
          <div id="seccion3" class="hidden">
              
            <div class="row">
              <div class="col-12">	
                
                
                
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion3-46').toggle();">	
                  <h3>46. Introducción. El proyecto a construir GuitarLA</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion3-46" class="hidden">
                  <p class="font-bold">Proyecto carrito de compras GuitarLA</p>
      
                  <p>En este proyecto estaremos aprendiendo los fundamentos de React: <span class="destacado">Componentes, Eventos y State</span>, mientras creas un carrito de compras real con cantidades, precios, y más, tomaremos este mismo carrito para mostrarte como crear tus propios Hooks y como transformarlo a código de TypeScript y cuales son sus beneficios. Carrito de compra persistente sincronizando con localStorage (aprenderemos todas esas acciones agregar elementos, cambiarlos, cambiar cantidades, vaciar carrito...)</p>							
                  <img class="my-2.5" src="./src/assets/img/s1-01.jpg" width="" height="" alt=""/> 
                  
                </div>
                <!-- Fin bloque desplegable interior-->
      
      
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion3-47').toggle();">	
                  <h3>47. Herramientas para crear aplicaciones en React.js</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion3-47" class="hidden">
                  <p class="font-bold">Tecnologías para crear aplicaciones en React</p>
                  <p>Permiten Crear una App En React en Minutos. Existen muchas formas de crear una app en React, incluso tu puedes crear tu propio ambiente de desarrollo con herramientas como Babel, Parcel, Webpack, Vite, etc</p>
      
                  <p>Pero también existe una gran cantidad de herramientas ya disponibles para crear aplicaciones en React en minutos sin conocer esta configuración</p>
                  
                  
                  <p class="font-bold">Ventajas de utilizar una herrmaienta ya existente: <strong>La mayoría de Herramientas ya existentes para crear aplicaciones en React son estables y siguen un enfoque muy claro: No tener que preocuparte por la configuración.</strong> Tú puedes crear tu propio ambiente de desarrollo pero tienes que asegurarte de que cada versión nueva de React, cada version de diferentes librerias sea compatible con tu proyecto y despues tienes que encontrar una forma de compilar código de css (sass etc) ...entonces vamos a gasta r más tiempo en solucionar este tipo de cosas que tirando código. Por eso se recomienda usar una herramienta ya existente</p>
      
                  <p>Cada una de estas herramientas ya existentes va desde básicas hasta avanzadas. Requieren tener instalado <span class="destacado">Node.js (NPM) o YARN</span>. Existen otros entornos hoy día como <strong>¿bum?</strong> Node.js con npm es bastante estable y es la que estaremos usando</p>
                  
                  <p>Opciones modernas para crear Apps en React. Los más populares hoy en día son<span class="destacado">Vite</span> y <span class="destacado">Next.js</span>. También Remix Run y Astro (que usaba en versiones anteriores del curso. Remix Run fue adquirido recientemente por shopify y están haciendo muchos cambios y no está listo)</p>
                  
                  <p class="font-bold">Recomendaciones del equipo de React</p>
      
                  <p>En su documentación recomiendan comenzar por Next.js o Remix para nuevos proyectos. Entonces ¿ya no se deben crear proyectos von Vite? Cuando creas proyectos con Vite tendrás que instalar dependencias para Routing, Consultas HTTP y más (herramientas como Next.js y Remix ya lo tienen incluido)</p>
      
                  <p><strong>Usualmente siempre hay que aprender primero la herramienta/lenguage de programación y después el framework por lo que esa recomendación es un poco rara, porque cuando estes creando un proyecto ya sea en Next.js o Remix tal vez estés escribiendo un código y no sabes si eso es React o si eso es Next. Y esa es la explicación de por qué los proyectos en este curso utilizan Vite y al final tendremos un proyecto con Next quedando más claro qué es React y qué es Next.js</strong></p>						
                </div>
                <!-- Fin bloque desplegable interior-->
      
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion4-48').toggle();">	
                  <h3>48. Instalando node y npm</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion4-48" class="hidden">
                  <p><a class="rojo" href="https://nodejs.org/es/" target="_blank">https://nodejs.org/es/</a> Requerimos node para crear nuestros proyectos pero también para instalar dependencias con npm</p>	
                
                  <p>Una vez instalado abrimos la terminal y comprobamos las versiones del entorno(node.js) <span class="destacado">node -v</span> y de las dependencias(npm) <span class="destacado">npm -v</span></p>
                  
                </div>
                <!-- Fin bloque desplegable interior-->
      
      
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion4-49').toggle();">	
                  <h3>49. Creando el primer proyecto</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion4-49" class="hidden">
                  <p>Abrimos terminal, vamos al escritorio (que es donde voy a crear los proyectos) y ponemos <span class="destacado">npm create vite@latest</span> (si es la primera vez nos pedirá instalar la dependencia de vite le decimos que "y"). A continuación nos pide nombre y lo llamamos <strong>guitarla</strong>. A continuación nos pide que elijamos framework (Vanilla, Vue, <strong>React</strong>, Preact, Lit, Svelte, Solid, Qwik, Others) y elegimos React. Nos pide elegir variante, normalmente y como él ha trabajado este curso es <strong>Typescript + SWC</strong>(SWC es un compilador nuevo de los de Vite basado en Ros, muy rápido)  pero al ser el primer proyecto elegiremos <strong>Javascript + SWC</strong>. Remix es una alternativa a Next.JS de los creadores de shopify pero este curso no incluye remix porque la compra fue hace poco y están modificando/agregando muchas cosas</p>
                
                <img class="my-2.5" src="./src/assets/img/49-1.png" alt="" />
      
                <p>ejecutamos los 3 comandos que nos indica para situarnos en la nueva carpeta del proyecto <span class="destacado">cd guitarla</span>, instalar las dependencias <span class="destacado">npm install</span>y arrancar el proyecto <span class="destacado">npm run dev</span></p>
      
                <img class="my-2.5" src="./src/assets/img/49-2.png" alt="" />
      
                <p>Cuando generamos un proyecto en React con Vite vemos que la estructura por defecto es muy simple:</p>					
                <ul class="mb-3.75">
                  <li><strong>carpeta "node_modules":</strong> las dependencias del proyecto. Va creciendo conforme instalamos más dependencias</li>
                  <li><strong>carpeta public:</strong> colocaremos por ej imagenes que seran accesibles para los visitantes de nuestro sitio web o app</li>
                  <li><strong>carpeta src:</strong> colocaremos todo nuestro código. Si revisamos la página de inicio de nuestro proyecto <strong>http://localhost:5173/</strong> nos dice: <strong>Edit src/App.jsx and save to test HMR</strong>. Así que abramos ese jsx, que es la página de inicio. 
                    <img class="my-2.5" src="./src/assets/img/49-3.png" alt="" /><br>
                    En esta carpeta <strong>src</strong> es donde vamos a pasar la mayor parte del tiempo escribiendo código (colocaremos nuestros customs hooks, librerías, componentes...).
                  </li>
                  <li>.gitignore: va a ignorar algunos archivos</li>
                  <li><strong>index.html:</strong> básicamente lo que hace es inyectar React en el div <code class="language-html">&lt;div id="root"&gt;&lt;/div&gt;</code>. Si abrimos el <strong>main.jsx</strong> vemos el siguiente código donde se busca ese div con id="root" donde monta toda la aplicación de React. En el index.html podemos poner algún bg-gray-200, agregar algunos tags mas de html que sean importantes para nuestro proyecto, pero no vamos a escribir código html ahí habitualmente.
                  <pre><code class="language-js">
                    createRoot(document.getElementById(&apos;root&apos;)).render(
                      &lt;StrictMode&gt;
                        &lt;App /&gt;
                      &lt;/StrictMode&gt;&comma;
                      )						
                  </code></pre>
                  </li>
                  <li><strong>package.json:</strong> ahí está el comando de "dev" que ejecutamos para arrancar y tiene algunos comandos para construir proyecto, previsualizarlo, y es donde se instalan las dependencias del proyecto y las de desarrollo. Al tener esas dependencias y sus versiones indicadas nos aseguramos que el equipo de trabajo sepa qué depndencias hay que tener para funcionar correctamente.</li>
                </ul>
                
                  
                </div>
                <!-- Fin bloque desplegable interior-->
      
                    
              </div>			
            </div><!--Fin row-->
      
          </div>
          <!-- Fin div colapsable-->
      
      
        </div>
      </div>	
      <!-- FIN SECCION 3 y 4-->	


      <!-- SECCION 2 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">	
        <div class="row">
          <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion2').toggle();">	
            <h2>Sección 2: Introducción a JavaScript para React</h2>				
            <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
          </div>
          
          <div id="seccion2" class="hidden">
      
            <div class="row">
              <div class="col-12 pl-1.25">	


                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-9').toggle();">
                  <h3>9. Variables creadas con let / 10. Variables creadas con const</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-9" class="hidden"> 

                  <p><span class="destacado">Los nombres de variables han de ser descriptivos y no pueden iniciar con * ni números ni caracteres especiales.</span></p>
                  <p>Podemos usar comillas dobles o simples para asignar valor string a una variable (pero no mezclar tipo de comillas, nos da error)</p>   
                  <p class="naranja">Variables creadas con let</p>               
                                
                  <ul class="mb-3.75">
                    <li>Pueden ser inicializadas con un valor o sin valor:
                      <pre><code class="language-js">
                        /*Podemos inicializarlas con un valor y después reasignarle otro valor. Con const no se puede hacer eso con otros lenguages no podríamos hacer esto pero Javascript es un lenguage de tipo dinámico donde el tipo de dato se asigna por su valor y no por la variable)*/
                        let cliente ="Juan"
                        cliente=30
                      </code></pre>                  
                      <pre><code class="language-js">
                        //Podemos inicializarlas sin valor y asignarlo después
                        let precio
                        precio = 200
                      </code></pre>
                    </li>
                  </ul>             
                  
                  <p>Si la inicializamos y no le asignamos valor y hacemos un console.log vemos que sale <span class="destacado">"Undefined"</span> <strong>es un tipo de dato en Javascript que nos indica que la variable fue inicializada pero nunca tuvo ningún valor</strong></p>
                  <p><strong>si hacemos un console.log de una variable "cantidad" que no hemos definido</strong> nos da el error <span class="destacado">"cantidad is not defined"</span></p>                   
                  <pre><code class="language-js">
                    var //(versiones anteriores, ya no se usan)
                    let
                    const

                    console.log('Hola Mundo')
                    console.log(2+2)
                    
                    let cliente = 30
                    cliente="Juan"                  
                    let calzado
                    
                    console.log(cliente)
                    console.log(calzado)
                    console.log(cantidad)                 
                  </code></pre>

                  <p class="naranja">variables creadas con const</p>
                  <ul class="mb-3.75">
                    <li>Tienen que ser inicializadas con un valor</li>
                    <li>No se pueden reasignar. si lo intentamos en la consola nos sale el error <span class="destacado">"Asignment to constant variable"</span></li>
                  </ul>
                  <p></p>
                    <pre><code class="language-js">
                      const cliente = 30 
                      cliente="Juan" 
                    </code></pre>
                    
                    <p>¿entonces let es mejor porque nos da mas flexibilidad de posibilidades? No.<br>
                    <span class="destacado">
                      Vamos a utilizar mas veces const que let. Lo normal es querer tener en nuestro código variables const
                      y let será una "excepción" cuando queramos inicializar sin valor y/o reasignar
                    </span></p>
                </div>
                <!-- Fin bloque desplegable interior-->
                
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-11').toggle();">
                  <h3>11. Tipos de Datos en JavaScript</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-11" class="hidden">
                  <pre><code class="language-js">
                    /* Tipos de dato

                    Javascript tiene pocos tipos de datos: string, number, 
                    
                    para saber el tipo de dato de una variable, operador typeof antes de la variable
                    console.log (typeof cliente)
                    
                    si nos ponemos encima de esta variable let alumno = "Juan" con el IntelliSense (IS) de Visual Studio si te pones encima de la variable te dice el tipo de dato --&gt; string 
                    (con let, con const no rula esto en Visual Studio code pero usamos el typeof)
                    El Undefined lo marca como any (que es específico de Typescript. Lo veremos y veremos por qué hay que evitarlo)
                    */
                    
                    //Undefined
                    let cliente
                    console.log (cliente)
                    console.log (typeof cliente)
                    
                    //Strings o cadenas de texto. Sirven para representar el nombre de un producto, categoría, reviews....
                    let alumno = "Juan"
                    const producto = 'Monitor 49 pulgadas'
                    console.log(alumno)
                    console.log(typeof alumno)
                    console.log(producto)
                    
                    //Numbers
                    const numero = 40
                    const numero2= 40.40
                    const numero3 = -100
                    console.log(numero)
                    console.log(numero2)
                    console.log(numero3)
                    console.log(typeof numero3)
                    
                    //BigInt
                    const numeroGrande = BigInt(1263472832934827342938427348274)
                    console.log(numeroGrande)
                    
                    //Boolean (true o false) --&gt; El usuario está bloqueado o no / autenticado o no / producto agotado o no....
                    const descuento = true;
                    console.log(typeof descuento)
                    
                    //Null
                    const descuento2 = null 
                    console.log(descuento2) //lo estoy asignando pero no existe no es nada. Es probable que queramos asignar null a una variable
                    
                    let precio
                    console.log(precio)     //--&gt; variable declarada pero no tiene valor
                    
                    //Symbol --&gt; son buenos para librerias. normlamente no los usaremos. Cada Symbol es distinto a otro no hay dos iguales. Son únicos, aunque los comparemos y tengamos el mismo valor, siem,pre son diferentes
                    const primerSymbol = Symbol(30)
                    const segundoSymbol = Symbol(30)
                    console.log(primerSymbol)
                    console.log(primerSymbol == segundoSymbol)
                    
                    //Objetos --&gt; veremos en su propio vídeo. La parte más importante en Javascript y una de las características que más vamos a trabajar sea con React, Node, Vue.js...
                    //Arrays o Arreglos también terminan siendo objetos                  
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-12').toggle();">
                  <h3>12. Objetos y Destructuring / 13. Manipulación de objetos</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-12" class="hidden">
                  <p>Los <span class="destacado">Objetos</span> son la parte más importante en Javascript y una de las características con las que más vamos a trabajar sea con React, Node, Vue.js...  Los Arrays=Arreglos también terminan siendo objetos</p>
                  <ul class="mb-3.75">
                    <li>Un objeto es una colección de propiedades; pueden tener múltiples propiedades SEPARADAS POR ","</li>
                    <li>Una propiedad es una asociación entre un nombre=clave(key) y un valor(value)</li>
                    <li>Sintaxis con llaves --&gt; <code class="language-js">let producto = {  }</code> / <code class="language-js">const producto = {}</code> /</li>
                  </ul>
                  <p>Por tanto siempre que veamos esta sintaxis estaremos viendo un objeto, una colección de propiedades (asociaciones key+value)</p>

                  <p class="mt-1.25 mb-0"><span class="naranja">Generar Objetos:</span> cada <span class="destacado">propiedad</span> de un objeto está formada por una asociación <span class="destacado">clave/valor</span> o pareja key/value. Las propiedades van separadas por comas.</p>
                  <pre><code class="language-js">
                    const producto = {
                        nombre : "Tablet",   // Esto es una propiedad. nombre es "key", "Tablet" es el "value". 
                        precio : 300,
                        disponible : false
                    }
                    console.log(producto); //veamos en la consola como se ven los objetos. dandole al triangulito expandimos y vemos las propiedades del mismo
                    console.log(typeof producto)
                    console.table(producto) //para objetos muy grandes y también para arrays podemos usar console-table para verlos formateados en la consola
                  </code></pre>

                  <p class="mt-1.25 mb-0"><span class="naranja">Acceder a Objetos:</span> Una de las características de los objetos es que podemos <span class="destacado">acceder a cada una de las propiedades de un objeto usando la sintaxis de "."</span> y vemos como nos aparece el autocompletado de VSCode y podemos elegir la propiedad (asociación key/value) que queramos. <strong>Si tratamos de acceder a una propiedad que no existe nos devuelve un Undefined</strong>.</p>
                  <pre><code class="language-js">                   
                    console.log(producto.nombre)
                    console.log(producto.precio)
                    console.log(producto.autenticado) // si tratamos de acceder a una propiedad que no existe nos devuelve Undefined
                  </code></pre>
                
                  <p class="mt-1.25 mb-0"><span class="naranja">Destructuring:</span> en versiones recientes de JS desde ECMAS6 agregaron "Destructuring" lo que nos permite en una sola línea de código extraer un valor y generar una variable. Está pensado para reducir código y usarlo siempre que podamos. Antes, en versiones anteriores de JS era muy común crear una variable y asignarle la propiedad de un objeto, por ejemplo:</p>
                  <pre><code class="language-js">                     
                    const nombre = producto.nombre
                    const precio = producto.precio
                    const disponible = producto.disponible
                    console.log(nombre)
                    console.log(precio)
                    console.log(disponible)                  

                    //Con "Destructuring" una sola línea de código extraemos un valor del objeto que hay tras el = y generamos variable.
                    const {} = //lo que hay detrás del igual es el objeto sobre el cual queremos aplicar destructuring, extraer un valor
                    const { nombre } = producto //nombre es la variable
                    console.log(nombre)
                  </code></pre>
                  
                  <pre><code class="language-js">
                    //La sintaxis del Destructuring
                    const { nombre, precio, disponible } = producto // aquí lo estamos haciendo en una sola línea, extrayendo el valor y generando las variables 
                    console.log(nombre)
                    console.log(precio)
                    console.log(disponible)
                  </code></pre> 

                  <p class="mt-1.25 mb-0"><span class="naranja">Object Literal Enhacement:</span> también pensado para reducir código. Sirve para colocar dentro de un objeto. ¿En qué casos es util? cuando tenemos una función que realiza ciertas operaciones y en lugar de devolver un monton de variables, devuelves un objeto con todo agrupado. Supongamos que tenemos las dos variables siguientes:</p>
                  <pre><code class="language-js">
                    const autenticado2 = true
                    const usuario = "Juan"

                    const nuevoObjeto = {
                        autenticado2 : autenticado2,
                        usuario: usuario
                    }

                    //si el key y el value se llaman igual puedo hacer esto
                    const nuevoObjeto = {
                        autenticado2 
                        usuario
                    }
                    console.log(nuevoObjeto)
                  </code></pre> 

                  <p class="mt-1.25 mb-0"><span class="naranja">Manipulación de objetos</span> El object de JS es muy grande y si abrimos la documentación de MDN vemos todos los métodos que podemos usar con el constructor de object <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object</a>
                </p>

                  <pre><code class="language-js">
                    //¿Como evitamos que se pueda manipular un objeto? Con TS es fácil, con JS usemos un par de métodos
                    Object.freeze(producto) //Evita que se manipule ninguna propiedad del objeto (ni ninguna existente, ni añadir una nueva ni eliminar ninguna)
                    Object.seal(producto) //Permite modificar las existentes en el objeto pero ni añadir ni eliminar ninguna propiedad

                    //Reescribir un valor
                    producto.disponible = true

                    //Si no existe la propiedad la va a añadir
                    producto.imagen = 'image.jpg'

                    //Eliminamos propiedad
                    delete producto.precio

                    console.log(producto)
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-14').toggle();">
                  <h3>14. Destructuring de 2 o más objetos</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-14" class="hidden">
                  <pre><code class="language-js">
                    // OBJETOS Destructuring de dos o más objetos:
                    const producto = {
                        nombre : "Tablet",   // Esto es una propiedad. nombre es "key" "Tablet" es el "value". las propiedades van separadas por comas
                        precio : 300,
                        disponible : false
                    }
                    
                    const cliente = {
                        nombre: "Juan",
                        premium: true,
                        direccion: {
                            calle: "Calle Nuevo Mexico"
                        }
                    }
                    
                    const { nombre } = producto
                    //const { nombre } = cliente //-->esto nos daba error. veamos a continuación como renombramos ese valor para evitar colisión de nombres
                    //const { nombre: nombreCliente, direccion: calle } = cliente
                    const { nombre: nombreCliente, direccion: { calle } } = cliente
                    
                    /*analizando la notación anterior:
                    
                        nombre: nombreCliente --> renombra la variable
                        direccion: { calle } --> entra a ese objeto y entra a calle
                    */
                    
                    
                    console.log(nombre)
                    console.log(nombreCliente)
                    console.log(calle)
                    
                    // Muchas veces instalaremos varias dependencias y cuando devuelven valores, resulta que las variables se llaman igual. Para evitar colisión de nombres 
                    // Viene bien saber como poder renombrarlas de esta manera.
                  </code></pre>
                

                </div>
                <!-- Fin bloque desplegable interior-->
              
                
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-15').toggle();">
                  <h3>15. Unir dos o más objetos</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-15" class="hidden">
                  <pre><code class="language-js">
                    // OBJETOS unir dos o mas objetos, técnicas y sintaxis que marca diferencia. Le dedica mucho tiempo a losobjetos porque es lo que más se utiliza en React:
                    const producto = {
                        nombre : "Tablet",   // Esto es una propiedad. nombre es "key" "Tablet" es el "value". las propiedades van separadas por comas
                        precio : 300,
                        disponible : false
                    }
                    
                    const cliente = {
                        nombre: "Juan",
                        premium: true    
                    }
                    
                    //supongamos que añadimos el objeto producto a un carrito
                    const carrito = {
                        cantidad: 1,
                        //si lo hacemos así nos agrega el objeto producto DENTRO de este objeto carrito, pero queremos unirlo
                        //producto 
                        // para que las key del objeto producto sean key de este objeto carrito (que el objeto carrito sea plano) Usamos para ello el "spread operator":
                        ...producto 
                    }
                    console.log(carrito)
                    
                    //este código tiene 2 objetos dentro (obtiene una copia)
                    const nuevoObjeto = {
                        producto: {...producto},
                        cliente: {...cliente},
                    }
                    console.log(nuevoObjeto)
                    
                    //podríamos obtener exactamente lo mismo que antes simplificando la sintaxis usando el 'object literal enhancement' diciendo:
                    // 'genérame un key de producto con el objeto producto y un key de cliente con el objeto cliente':
                    const nuevoObjeto2 = {
                        producto,
                        cliente
                    }
                    console.log(nuevoObjeto2)
                    
                    //si hago esto va a ser completamente diferente, un objeto plano pero ¡OJO! el key nombre del objeto producto no está!!!! porque el key nombre del objeto cliente reescribe el anterior
                    const nuevoObjeto3 = {
                        ...producto,
                        ...cliente
                    }
                    console.log(nuevoObjeto3)
                    
                    //lo anterior lo podemos hacer con menos código usando el Object.assign
                    const nuevoObjeto4 = Object.assign(producto, cliente)
                    console.log(nuevoObjeto4)
                    
                    //En react existe el término "inmutabilidad" es decir, no modificas directamente un objeto sino en base a ciertas funciones.
                    //Es importante entender las diferentes funciones que nos ofrece para poder cambiar algunos valores. Eso nos va a quedar más claro con los proyectos de React.
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-16').toggle();">
                  <h3>16. Template Strings y Concatenación</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-16" class="hidden">
                  <pre><code class="language-js">
                    //Template Strings y Concatenación

                    const producto = "Tablet de 12 pulgadas"
                    const precio = 400
                    const marca = "Orange"
                    
                    //como se hacía antes en js este tipo de concatenación (con + o ,)
                    console.log('El producto es: ' + producto) 
                    console.log(producto + "$" + precio + " Dolares, marca " + marca) 
                    
                    //hagamos este mismo código con los Template Strings como se hace ahora (con ``)
                    console.log(`El producto es ${producto}`)
                    console.log(`${producto} ${precio} Dolares, marca ${marca} `)
                    
                    //En React se utiliza básicamente así. Algo muy similar: "jsx" que nos permite mezclar html con js en React
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-17-19').toggle();">
                  <h3>17. Arrays / 18. Modificar Arrays / 19. Destructuring de Arrays</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-17-19" class="hidden">
                  <p>Los Arrays (Arreglos) junto con objetos es de lo que más se utiliza en nuestro código. Es un objeto similar a un listado que tiene métodos para realizar varias operaciones. Diferencias: </p>                
                  <ul class="mb-3.75">
                    <li>corchetes en vez de llaves</li>
                    <li>no tienen clave/valor sino solo valor</li>
                    <li>su llave va a ser el índice que se asigna automáticamente en base a su posición en el arreglo</li>
                  </ul>
                  <p>Los arreglos pueden mezclar tipos de datos en su interior pero se recomienda que un arreglo contenga estructura y que sea acorde para tener un mejor orden en el código</p>

                  <pre><code class="language-js">
                    const tecnologias = [20,30,40]

                    console.log(tecnologias)
                    console.table(tecnologias)
                    
                    console.log(tecnologias[1])                  
                  </code></pre>

                  <p class="mt-1.25 mb-0"><span class="naranja">Modificar Arrays</span></p>

                  <pre><code class="language-js">
                    const tecnologias = ['HTML','CSS','Javascript','React.js','Node.js']

                    tecnologias[5] = 'Nest.js'
                    tecnologias.push('Nest.js')
                    console.log(`tecnologias:`)
                    console.table(tecnologias)                  
                  </code></pre>

                  <p><strong>si vamos al navegador consola y desplegamos el [[prototype]] vemos todos los métodos disponibles para ese array</strong>. Cada tipo de datos tiene sus métodos. <span class="destacado">¡¡¡¡IMPORTANTE!!!!</span> En React siempre hemos de escribir nuestro código con funciones que no modifiquen directamente los valores de lo que se conoce como el "state". En esta página <a href="https://doesitmutate.xyz/" target="blank">https://doesitmutate.xyz/</a> podemos consultar si los métdos que nos aparecen en <strong>[[prototype]]</strong> de la consola del navegador modifican o no nuestro array. Como vemos si buscamos ahí por ejemplo el método "push()", sí modifica (mutates) nuestro arreglo por lo que no se recomienda utilizar push() con react. </p>

                  <p class="font-bold">Alternativa a push</p>
                  <pre><code class="language-js">
                    const nuevoArreglo = [...tecnologias, 'Nest.js'] // básicamente esos "..." copian tecnologías y a continuación indicamos optro valor más que es  'Nest.js'
                    //si lo quisiéramos al inicio --&gt; const nuevoArreglo = ['Nest.js', ...tecnologias]
                    console.log(`nuevoArreglo: alternativa a push() ${nuevoArreglo}`)                  
                  </code></pre>
                  
                  <p class="font-bold">método shift() elimina el primer elemento de un array. Modifica el array</p>
                  <pre><code class="language-js">
                    const tecnologias2 = ['HTML','CSS','Javascript','React.js','Node.js']
                    tecnologias2.shift();
                    console.table(`tecnologias2: usamos shift para eliminar primer valor ${tecnologias2}`)
                  </code></pre>  
                  
                    <p class="font-bold">alternativa a shift() --&gt; usamos filter() que no modifica nuestro arreglo</p>
                    <pre><code class="language-js">
                    console.log(`tecnologias3: alternativa a shift, uso de filter()`)
                    const tecnologias3 = tecnologias.filter(function(tech){
                        //console.log(tech)
                        if(tech!=='HTML'){ 
                            return tech 
                        }
                    })
                    console.table(tecnologias3)
                    </code></pre>
                    
                    <p class="font-bold">map() que itera sobre TODOS los elementos de nuestra colección</p>

                    <pre><code class="language-js">
                    //veamos como modificar un valor sin cambiar el array original, por ejemplo tecnologias[5] = 'Nest.js'. 
                    // Usamos map() que itera sobre TODOS los elementos de nuestra colección
                    console.log(`tecnologias4: uso de map()`)
                    const tecnologias4 = tecnologias.map(function(tech){
                        //console.log(tech)
                        //Queremos buscar el valor 'Node.js' para modificarlo por 'Nest.js' pero queremos mantener el resto
                        if(tech === 'Node.js'){
                            return 'Nest.js'
                        } else { // si no ponemos este else, vemos en consola que cuando no se cumple la condición devuelve undefined
                            return tech
                        }
                    })
                    console.table(tecnologias4)
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-19').toggle();">
                  <h3>19. destructuring arrays</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-19" class="hidden">
                  <pre><code class="language-js">
                    const tecnologias = ['HTML','CSS','Javascript','React.js','Node.js']

                    //variable con la posicion 3 del array
                    
                    const react = tecnologias[3]
                    console.log(react)
                    
                    // El destructuring de arrays los va a ir extrayendo en base a la posición
                    const [html, estilos, script] = tecnologias
                    console.log(html) //--> HTML
                    console.log(estilos) // --> CSS
                    //si quisiéramos sacar el valor de una única posición, por ej 'React.js' usando esta sintaxis de destructuring hemos de usar comas dejando los espacios
                    //(contar como en las tablas de colaboradores!!!! :D)
                    
                    const [ , , , reactjs] = tecnologias
                    console.log(reactjs)
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-20').toggle();">
                  <h3>20. Recorriendo arrays con for / 21. Recorriendo arrays con forEach, map y for ... of</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-20" class="hidden">
                  <pre><code class="language-js">
                    //recorriendo/iterar arrays

                    const tecnologias = ['HTML','CSS','Javascript','React.js','Node.js']
                    
                    // console.log(tecnologias[0])
                    // console.log(tecnologias[1])
                    // console.log(tecnologias[2])
                    // console.log(tecnologias[3])
                    // console.log(tecnologias[4])
                    
                    //igual que map() para iterar un array o filter() para sacar o mantener elementos de un arreglo existen métodos/funciones para iterar una array fácilmente
                        // for(let i = 0; i &lt; 5; i++) { 
                        //     //console.log(i) 
                        //     console.log(tecnologias[i]) 
                        // }
                    
                    /*si añadiéramos un nuevo valor al array sin modificar el bucle, por ejemplo al final vemos que no nos sale.
                    un arreglo va a crecer o ser mas pequeño en fcn de lo que el usuario haga en nuestra App. por ejemplo un carrito de compras, que se inicia con un arreglo vacío,
                    en función de lo que haga un usuario u otro se han podido añadir 3 elementos, 8, ninguno...
                    por tanto SIEMPRE TENEMOS QUE ESCRIBIR NUESTRO CÓDIGO DE FORMA DINÁMICA, QUE SE ADPATE A TODOS LOS ESCENARIOS*/
                    
                    //revisemos cuántos elementos hay en el arreglo para que el iterador se ejecute esa cantidad de veces
                    
                        // for(let i = 0; i &lt; tecnologias.length; i++) { 
                        //     //console.log(i) 
                        //     console.log(tecnologias[i]) 
                        // }
                    
                    //aunque un for (que se usa en C#, php, Java) no tiene nada de malo, js ha hecho 3 iteradores que son mas sencillos y claros de usar
                    
                    //forEach()  --&gt; MÉTODO QUE EJECUTA UNA FUNCIÓN INDICADA POR CADA ELEMENTO DEL ARREGLO
                    
                        // tecnologias.forEach(function(){
                        //     console.log('Desde la función')
                        // })
                    
                        //dentro de ese function podemos pasarle lo que queramos como parámetro, antes usamos 'tech' but podemos ponerle por ejemplo la letra 'a' y veremos que aparecen cada uno de esos valores
                        // tecnologias.forEach(function(a){
                        //     console.log(a)
                        // })
                    
                        //normalmente el nombre del parámetro ha de ser descriptivo de los valores que contenga el array, por ejemplo array de automóviles--&gt;parámetro 'automovil'. 
                        // Así que en este caso lo dejamos en 'tech'. Como vemos es mas sencillo que el bucle loop. Ya sabe cuantas veces ejecutarse porqeu ya sabe la extensión del
                        //array sobre el que se está ejecutando
                        // tecnologias.forEach(function(tech){
                        //     console.log(tech)
                        // })
                    
                    //map() --&gt; sirve para iterar pero su característica ppal es que CREA UN NUEVO ARREGLO, en base a las condiciones de la fcn. 
                    
                        // tecnologias.map(function(tech){
                        //     console.log(tech)
                        // })
                    
                        //Veamos esta característica diferencial con el siguiente código. El primer console.log (en el que intentamos return tech usandi forEach) nos dará un undefined
                        const arrayforEach = tecnologias.forEach(function(tech){
                            //return tech
                            console.log(tech)
                        })
                        const arrayMap = tecnologias.map(function(tech){
                            return tech
                        })
                    
                        console.log(arrayforEach)
                        console.log(arrayMap)
                    
                        // map() es el más utilizado con React. Por tanto DIFERENCIA:
                        /*
                        forEach() ejecuta una función dada tantas veces como valores  tiene un arreglo
                        map() genera un array nuevo en base a la condicion/fcn que le estás pasando
                        */
                    
                    // for ... of --&gt; EJECUTA UN BLOQUE DE CÓDIGO POR CADA ELEMENTO DE UN ARREGLO. Se parece mucho al for y tiene algo del forEach
                    
                    for(let tech of tecnologias){
                        console.log(tech)
                    }
                    // for(let i = 0; i &lt; tecnologias.length; i++) { 
                    //     console.log(tecnologias[i]) 
                    // }
                    
                    //tecnologias.forEach(function(){
                    //     console.log('Desde la función')
                    // })//recorriendo/iterar arrays
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-22').toggle();">
                  <h3>22. Funciones: Function declaration / Function Expression / Arrow Functions</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-22" class="hidden">
                  <p>Las funciones nos van a permitir escribir código reutilizable en js y en cualquier lenguage de programación. Vamos a separar el código en pequeñas funciones con su propósito. <strong>Ojo con los nombres (mismas restricciones que nombres de variables, no empezar por números, guiones...)</strong></p>
                  <p class="mt-1.25 mb-0"><span class="naranja">Funciones - Function declaration:</span> </p>
                  <pre><code class="language-js">
                    function sumar(){
                          console.log(1+1)
                      }
                    //Llamamos a la fcn, y además como son reutilizables, tantas veces como queramos. Se la puede llamar antes de declararla.
                      sumar()
                      sumar()
                    
                      function sumar(){
                          console.log(1+1)
                      }
                  </code></pre>

                  <p>Hemos de escribir funciones "inteligentes" que manejen <span class="destacado">parámetros:</span> es una variable especial que se utiliza en una función y cuyo valor se refiere a valores que vienen del exterior. <span class="destacado">En el ejemplo siguiente: numero1 y numero2 es un parámetro mientras que '10' es un argumento</span></p>
                  <pre><code class="language-js">
                    function sumar(numero1, numero2){   
                      console.log(numero1)
                      console.log(numero2)
                      console.log(numero1+numero2)
                    }
                    sumar(10, 20)
                    sumar(100, 131)
                  </code></pre>
                  <p>Hemos de saber qué tipo y cuantos argumentos mandarle a nuestra función (tanto conociendo la librería que importemos como haciedo uso del helper=Intellisense de Visual Studio) por ejemplo si a la fcn anterior le mandamos un único argumento numérico, como espera 2 números trata de sumar un número con NADA y devuelve 'NaN' (Not a Number). Para estos casos podríamos utilizar los <strong>parámetros por default</strong>, cuando un valor no está presente utilizar esos valores.</p> 
                    <pre><code class="language-js">
                      function sumar(numero1 = 0, numero2 = 0){
                        console.log(numero1+numero2)
                      }                   
                    </code></pre>
                  
                  <p class="mt-1.25 mb-0"><span class="naranja">Funciones - Function Expression:</span> Sintaxis similar, hacen lo mismo, but en este caso si intentamos llamar a la función antes de declararla nos devuelve error</p>

                  <pre><code class="language-js">
                    sumar(10, 20)
                    // sumar(300, 1)
                    // sumar(100)

                    const sumar = function (numero1 = 0, numero2 = 0){   
                      console.log(numero1+numero2)
                    }
                  </code></pre>
                  <pre><code class="language-js">
                  // En este caso podemos sí podemos llamar a la función antes de declararla. No están ni mucho menos deprecadas y se siguen utilizando mucho.
                  sumar(10, 20)
                  sumar(300, 1)
                  sumar(100)

                  function sumar(numero1 = 0, numero2 = 0){ 
                    console.log(numero1+numero2)
                  }
                  </code></pre>

                  <p class="mt-1.25 mb-0"><span class="naranja">Funciones - Arrow function:</span> Al igual que las function expressions si intentamos llamarla antes de declararla nos da error. La sintaxis es como las function expressions sin la palabra "function" y añadiendo "=>" entre el ")" y la "{"</p>

                  <pre><code class="language-js">
                    //const sumar = function(numero1 = 0, numero2 = 0) {

                    const sumar = (numero1 = 0, numero2 = 0) => {
                        console.log(numero1 + numero2)
                    }
                  
                    sumar(10, 20)
                    sumar(300, 1)
                    sumar(100)
                  </code></pre>

                  <p>Si nuestras funciones solo tienen una línea, podemos eliminar las llaves:</p>
                  <pre><code class="language-js">
                    const sumar = (numero1 = 0, numero2 = 0) => console.log(numero1 + numero2)
                  </code></pre>

                  <p><span class="destacado">Todas las fcnes que hemos visto devuelven valores</span>. A continuación veremos la otra característica que tienen las arrow functions y funciones que devuelven valores</p>
                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-25').toggle();">
                  <h3>25. Funciones que retornan valores</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-25" class="hidden">
                  <p>A continuación veremos la otra característica que tienen las arrow functions y funciones que devuelven valores</p>
                  <pre><code class="language-js">
                    // Funciones que devuelven valores. Veámoslo con los 3 tipos de funciones
                    const sumar = function (numero1 = 0, numero2 = 0){   
                        //console.log(numero1 + numero2)
                        return numero1 + numero2
                    }
                
                    function sumar(numero1 = 0, numero2 = 0){ 
                        //console.log(numero1+numero2)
                        return numero1 + numero2
                    }
                
                    //const sumar = (numero1 = 0, numero2 = 0) => console.log(numero1 + numero2)
                    const sumar = (numero1 = 0, numero2 = 0) => numero1 + numero2 //cuando solo tienen una línea no hace falta que usemos "return"
                
                    /* si tenemos múltiples líneas en la arrow function usamos return 
                    
                    const sumar = (numero1 = 0, numero2 = 0) => {
                        return numero1 + numero2
                    }                  
                    */              
                    const resultado = sumar(10, 20)
                    console.log(resultado)
                  </code></pre>
                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-26').toggle();">
                  <h3>26. Array Methods</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-26" class="hidden">
                <pre><code class="language-js">
                  //Array methods
                  const tecnologias = ['HTML','CSS','Javascript','React.js','Node.js']
                  const numeros = [10, 20, 30]
                  
                  //Filter
                      const nuevoArray = tecnologias.filter(function(tec) {
                          console.log(tec)
                      })
                  
                      // const nuevoArray2 = numeros.filter(function (nume) {
                      //     console.log(nume)
                      // })
                  
                      //también podríamos hacerlo así (sacando la función que va entre "()" fuera):
                  
                      // function ejemploFilter(nume) {
                      //     console.log(nume)
                      // }
                  
                      //esta sintaxis normalmente no se usa, no se crean funciones aparte
                      // const ejemploFilter = (nume) => console.log(nume)    
                      // const nuevoArray2 = numeros.filter(ejemploFilter)
                  
                      //Estos array methods se utilizan mucho y lo que hacen es iterar sobre cada uno de los elementos del array. 
                      //En base a ciertas condiciones podemos hacer algunas operaciones con ellos
                  
                      //IMPORTANTE --&gt; ventajas de uso de arrow function:
                      // (no usamos "function", como es una línea quitamos "{}", no usamos "return" porque se da por implícito que es return en base a la condición indicada
                  
                          // const nuevoArray2 = tecnologias.filter((tech) => tech === 'HTML' )
                          const nuevoArray2 = tecnologias.filter((tech) => tech !== 'HTML' )
                          console.log(nuevoArray2)
                  
                          //recuperando el ejemplo que vimos en 18.js, vemos que hacíamos lo miosmo sin arrow functions
                          const tecnologias2 = tecnologias.filter(function(tech){
                              //console.log(tech)
                              if(tech!=='HTML'){ 
                                  return tech 
                              }
                          })
                          console.log(tecnologias2)
                  
                      //Otra característica de los arrow functions es que si solo es un parámetro podemos eliminar los "()"
                      const nuevoArray3 = tecnologias.filter(tech => tech === 'HTML')
                      console.log(nuevoArray3)
                      //Filter también se puede usar para arrays de tipo numérico
                      const resultado = numeros.filter( num => num !== 10 )
                      console.log(resultado)
                  
                  //Includes --&gt; va a revisar si existe un elemento en un arreglo. En este caso como vemos la implementación es más sencilla, y en consola vemos que devuelve true
                  const resultado2 = tecnologias.includes('CSS')
                  console.log(resultado2)
                  
                      //Podemos ver todos los que hay tanto en la documentación https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array
                      //como en el prototype de la consola
                  
                      //Veamos más array methods. Algunos de ellos tienen un "callback" (una función de order superior=higher order function)
                  
                      //Some --&gt; devuelve si cumple la condición
                      const resultado3 = numeros.some( num => num > 15 ) //revisa si al menos uno de los valores del array numeros cumple la condición. Tengo dos de hecho. decuelve true
                      console.log(resultado3)
                  
                      /*usando este método reducimos código si por ejemplo quisiéamos mostrar un texto cuando se cumple condición, frente a por ejemplo el código a usar si tiramos del método filter
                              if(resultado.length>0){ 
                                  console.log('Si hay elementos')
                          
                              if(resultado3){ 
                                  console.log('Si hay elementos')
                              }
                      */
                  
                  //Find --&gt; devuelve el primer elemento que cumple una condición
                      const resultado4 = numeros.find( num => num > 15 )
                      console.log(resultado4)
                      
                  //Every --&gt; devuelve true o false si todos cumplen la condición
                      const resultado5 = numeros.every( num => num > 8 )
                      const resultado6 = numeros.every( num => num > 15 )
                      console.log(resultado5)
                      console.log(resultado6)
                  
                  //Reduce --&gt; devuelve un acumulado del total. Es de los mas complejos. Toma 2 parámetros.
                      //nos va a permitir hacer el cálculo en carritos de la compra de manera muy simple
                    const resultado7 = numeros.reduce( (total, numero) => { // total y numero(numero actual). El total va a servir como un acumulado
                          console.log('total iteracion: '+total) // solo con esta línea, en consola nos sale 0 y 2 undefined, porque tras el valor inicial no sabe que hacer la vez siguiente
                          console.log('numero iteracion: '+numero) // añadiendo esta línea ya aparecen los números del array alternados con un undefined
                  
                          //console.log(total) funciona como un acumulado. Hagamos por ejemplo que sume el primer valor del array a mi valor inicial 0, y a ese resultado le sume el siguiente valor....
                          //útil si construimos un carrito de compra, para mostrarle al usuario cual es el total a pagar de todos los elementos que tiene en el carrito
                          return total+numero // en 'total' va acumulando y 'numero' es el valor numérico actual del elemento del array numérico en cada iteración 
                    }, 0) //entre las llaves y el paréntesis ponemos un valor inicial de 0
                  
                    //También podríamos escribirla así: 
                    const resultado8 = numeros.reduce( (total, numero) => total + numero, 0 )
                  
                    console.log('resultado7: '+resultado7)     
                    console.log('resultado8: '+resultado8)  
                  
                </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-28-30').toggle();">
                  <h3>28. Condicionales en JavaScript / 29. Comparando con Comprador Estricto / 30. Logical Or y Logical And</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-28-30" class="hidden">
                <pre><code class="language-js">
                  //Condicionales
                  const disponible = 4000
                  const retirar = 200
                  
                  const auth = true
                  
                  if (auth){
                      //se cumple la condición
                      console.log('Acceso al sistema..')
                  } else {
                      //no se cumple la condición
                      console.log('No tienes permiso, inicia sesión')
                  }
                  
                  /*
                  &gt; mayor&comma; &lt; menor&comma; &gt;= mayor o igual&comma; &lt;= menor o igual&comma; == igual&comma; === igual estricto&comma; !==diferente a 
                  */
                  
                  if (disponible > retirar){
                      //se cumple la condición
                      console.log('Puedes sacar dinero')
                  } else {
                      //no se cumple la condición
                      console.log('No puedes sacar dinero')
                  }
                  
                  const numero1 = 20
                  const numero2 = 20
                  const numero3 = "20"
                  
                  console.log(typeof numero1,typeof numero2)
                  if (numero1 == numero2){
                      console.log('Son iguales')
                  } else {
                      console.log('No son iguales')
                  }
                  
                  console.log(typeof numero1,typeof numero3)
                  if (numero1 == numero3){
                      console.log('Son iguales')
                  } else {
                      console.log('No son iguales')
                  }
                  
                  //SIEMPRE VAMOS A QUERER UTILIZAR EL OPERADOR TRIPLE --> el operador estricto revisa tanto el valor como el tipo de dato. 
                  //Como vemos en ambos casos devuelve que sí se cumple porque el operador que no es estricto revisa el valor 20 y 20
                  console.log(typeof numero1,typeof numero3)
                  if (numero1 === numero3){
                      console.log('Son iguales')
                  } else {
                      console.log('No son iguales')
                  }
                  
                  //Logical Or '||' y Logical And '&&'
                  const saldo = 1000
                  const pagar = 500
                  const tarjeta = false
                  
                  // if( saldo > pagar){ //si mi saldo es mayor
                  //     console.log('Puedes pagar')
                  // } else if (tarjeta) { //si llevo mi tarjeta
                  //     console.log('Puedes pagar')
                  // } else {
                  //     console.log('No puedes pagar')
                  // }
                  /*se ejecuta la primera que se cumpla*/
                  
                  if( saldo > pagar || tarjeta){ //si se cumple una de las dos
                      console.log('Puedes pagar')
                  } else {
                      console.log('No, no puedes pagar')
                  }                
                </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                
              



      
      <!-- Bloque desplegable interior -->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-31').toggle();">	
                  <h3>31. Ternarios</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-31" class="hidden">
                  <p></p>
                  <pre>
                    <code class="language-js">
                      /*Ternarios --&gt; un if en una versión mas corta. En React se usa mucho porque en los templates no podemos escribir un if en la poarte que se muestra en pantalla
                      pero sí un ternario*/
                      
                      const auth = true
                      
                      const saldo = 1000
                      const pagar = 1200
                      const tarjeta = false
                      
                      // if (auth){
                      //     console.log('User autenticado..')
                      // } else {
                      //     console.log('No auntenticado, ir a Login')
                      // }
                      
                      //con un operador ternario vamos a poder tener todo lo anterior en una línea. Sintaxis algo compleja
                      
                      auth ? 
                        console.log('User autenticado..') : 
                        console.log('No auntenticado, ir a Login')
                      
                      //otra manera combinando operadores que vimos antes
                      
                      saldo > pagar ?
                        console.log('sí puedes pagar') :
                        console.log('no, no puedes pagar')
                      
                      //ternario anidado (al igual que los if se ejecuta la primera condición que se cumpla). 
                      saldo > pagar ?
                        console.log('sí puedes pagar') :
                        tarjeta ?
                          console.log('puedes pagar con tarjeta') :
                          console.log('no, no puedes pagar')
                      
                      //PERO MEJOR QUE TERNARIOS ANIDADOS ES HACER USO DE OPERADORES PARA MEJOR MANTENIMIENTO DE CÓDIGO
                      saldo > pagar || tarjeta ?
                        console.log('sí puedes pagar') :    
                        console.log('no, no puedes pagar')
                    </code>
                  </pre>						
                </div>
      <!-- Fin bloque desplegable interior -->
      
      <!-- Bloque desplegable interior -->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-32').toggle();">	
                  <h3>32. Optional chaining (?) y Nullish coolescing operator (??)</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-32" class="hidden">
                  <p>Son un par de características de las más nuevas que han añadido a js</p>
                  <p><strong class="text-[#609ad2]">Optional chaining (?) :</strong></p> 
                  <ul class="mb-3.75">
                    <li>permite llamar las propiedades de un objeto o llamar métodos sin tener que verificar si existen o no</li>
                    <li>además de ahorrarnos código, se usa mucho en respuestas rest API o repsuestas de BBDD en las uqe mkuchas veces no está todo relleno como esperamos</li>
                    
                  </ul>
                  <pre>
                    <code class="language-js">								
                      //Optional chaining (?) 
                        
                        const alumno = {
                          nombre: 'Juan',
                          clase: 'Programación 1',
                          aprobado: true,
                          examenes: {
                            examen1: 9
                          }
                        }
                        console.log(alumno)
                        console.log('Despues de ALUMNO')
      
                        //si hiciera esto me daría error porque esa propiedad examen1 no está definida, y el resto de mi js deja de funcionar (no saca lo de 'después de ALUMNO'):
                          //console.log(alumno.examenes.examen1)
                        
                        //para esto utilizamos el optional chaining, para ver si existe la propiedad examenes y entonces que nos imprima examen1 (evitamos usar ifs y más código)
                          console.log(alumno.examenes?.examen1)
                          console.log('Despues de ALUMNO')
                      </code>
                    </pre>
                    <p><strong class="text-[#609ad2]">Nullish coolescing operator (??):</strong> operador lógico que devuelve el valor del lado dcho cuando el valor izdo es nulo o undefined</p> 
                    <pre>
                      <code class="language-js">	
                      //Nullish coolescing operator (??) 
                        // por ejemplo se usa mucho cuadno se trabaja con un paginador desde la url. Cuando en la urlpage no tenemos esto: "?page=1"
                        const pagina = null ?? 1
                        // si tuviéramos este ejemplo "?page=10" 
                        // const pagina = 10 ?? 1 --&gt; este nos devolveria 10
                        console.log(pagina)
                      </code>
                    </pre>
                </div>
      <!-- Fin bloque desplegable interior -->
      
                
      <!-- Bloque desplegable interior -->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-34').toggle();">	
                  <h3>34-36. Introducción a ECMAScript Modules, más sobre módules y export default</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>					
                <div id="seccion2-34" class="hidden">						
                  <p>Se utilizan mucho en React y en el desarrollo web hoy en día ya que normalmente cuando instalas una dependencia/librería, esa dep. te permite importar ciertas funciones
                    el mismo React te permite importar sus funciones para que puedas utilizarlas en tu código
                    Supongamos que estamos creando un proyecto y vamos teniendo cada vez más y más funciones (pone el ejemplo de los tropecientos .js en nuestro html) --> eso se soluciona con los 
                    módulos de ECMAScript, que nos permiten separar nuestro código.</p>
        
                  <p>creamos un nuevo "funciones.js" donde metemos nuestras funciones y en nuestro html le indicamos al js que es de type module, y ello nos va a habilitar el poder importar.
                  dentro de nuestro .js de funciones le añadimos un "export" antes de cada función. En el .js donde queramos usar las funciones usamos un import</p>
                  
                  <pre>
                    <code class="language-js">
                      //ESTOS MODULOS ESTAN PRESENTES EN TODAS LAS TECNOLOGÍAS DE JS VUE, NODE, REACT... NOS PERMITEN SEPARAR NUESTRO CÓDIGO Y UN MEJOR MANTENIMIENTO
                      // export function sumar (n1, n2){
                        //     return n1 + n2
                        // }
                        // export function restar (n1, n2){
                        //     return n1 - n2
                        // }
                        // export default function multiplicar (n1, n2){
                        //     return n1 * n2
                        // }
                        // export function dividir (n1, n2){
                        //     return n1 / n2
                        // }
                        
                        export const sumar = ( n1, n2 ) => n1 + n2
                        export const restar = ( n1, n2 ) => n1 - n2 
                        
                        const multiplicar = ( n1, n2 ) => n1 * n2 
                        export default multiplicar
                        
                        export const dividir = ( n1, n2 ) => n1 / n2 
      
                        /* Ambos tipos de export requieren que al importarlos se llamen entre llaves y con el mismo nombre (salvo que usemos un alias)
                        Como vamos a importar muchas funciones, variables... de muchas librerias ¿como hacemos para evitar la colisión de nombres? utilizamo "alias" --> import {sumar as funcionSumar} 
      
                        Existe otro export que es el export default: solo puede haber uno por archivo. Lo importas sin llaves y nombras como queramos
      
                        export default function multiplicar (n1, n2){
                          return n1 * n2
                        }
                        */
                    </code>
                  </pre>   
                  
                  <pre>
                    <code class="language-js">
                  import agusmultiplica, { sumar, restar, dividir } from './funciones.js' // esta es la mejor manera de importar las funciones que nos ofrecen las dependencias/librerías
      
                  const resultadoSumar = sumar(25, 30)
                  const resultadoRestar = restar(25, 30)
                  const resultadoMultiplicar = agusmultiplica(25, 30)
                  const resultadoDividir = dividir(100, 10)
                  console.log(resultadoSumar + '\n' + resultadoRestar + '\n' + resultadoMultiplicar + '\n' + resultadoDividir);
                    </code>
                  </pre>   								
                </div>
      <!-- Fin bloque desplegable interior -->
      
      <!-- Bloque desplegable interior -->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-37').toggle();">	
                  <h3>37. Fetch API con Promises</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-37" class="hidden">
                  <p>Proporciona una interfaz para poder recuperar recursos y obtener datos a través de la red. Es la versión moderna de las dos tecnologías 
                    XMLHttpRequest(sintaxis muy difícil) y $.ajax. Usaremos esta herramienta {JSON Placeholder} 
                    <a class="text-[#cc3333]" href="https://jsonplaceholder.typicode.com" target="_blank">https://jsonplaceholder.typicode.com</a>. Podemos ver este ejemplo de uso en esa misma url:</p>
                  <pre>
                    <code class="language-js">
                      fetch('https://jsonplaceholder.typicode.com/todos/1')
                      .then(response => response.json())
                      .then(json => console.log(json))
                    </code>
                  </pre>
                  
                  <p>Vamos a trabajar con el json de 'Comments' <a href="https://jsonplaceholder.typicode.com/comments" class="blank">https://jsonplaceholder.typicode.com/comments</a>. Un json es muy parecido a un XML nos da unos datos con una estructura que podemos renderizar en nuestras aplicaciones.</p>
                  <p>También con FetchAPI es posible obtener datos de un archivo .txt</p>
                  <p>Para usarlo tenemos dos opciones, o ponerlo directamente en el código o meterlo en una función y mandarla llamar.<br>
                  fetch() utiliza promises, que fueron agregados en la versión de js moderno ECMAScript6. Podemos pensar en los promises como un objeto que va a estar disponible a futuro o no. Los promises cuentan con varios pasos y también con varios estados. Esos pasos se representan por una sintaxis que es <span class="destacado">.then()</span> siendo la lectura algo como "quiero obtener los datos de esta url, entonces tengo mi respuesta...voy a hacer..." El .then toma automáticamente un callback, una función que podemos nombrar como queramos <strong>then((response) => {})</strong></p>
                  <pre>
                    <code class="language-js">								
                      fetch(url)
                        .then((response) => {
                          console.log(response)
                        })
                    </code>
                  </pre>
                  <p>En la respuesta de la consola vemos en el Response que el ok es true y el status 200 --> la url existe (si no existiera tendríamos false y 404). Type cors lo veremos mas adelante, es complicado. Podremos ver como personalizar nuestros estados. Las APIS se comunican entre sí con estados numéricos, también los veremos en detalle.</p>
      
                  <img class="my-2.5" src="./src/assets/img/37-1.png" alt="" />
      
                  <p>Vemos qe no aparecen los datos por ningún sitio, pero si abrimos el prototype sí vemos los métodos <strong>json() y text()</strong>, que sirven apra decirle qué tipo de datos es el que estoy obteniendo (o un txt o un json). Como es un json le especificamos en el callback que retorne la respuesta como json <span class="destacado">return response.json()</span> lo cual nos dará acceso a otro promise con el que obtendremos los datos:</p>
      
                  <pre><code class="language-js">
                    fetch(url)
                      .then((response) => {									
                        return response.json()
                      })
                      .then(data => {
                        console.log(data)
                      })							
                  </code></pre>
                  
                  <p>Como vemos tenemos un .then() y otro .then() y así funcionan los promises, estamos llamando a esa url y no sabemos si vamos a poder obtener los datos o no. En este caso esta url que estamos usando es pública para aprender pero no podemos obtener los datos de por ejemplo instagram, youtubbe... solo haciendo un llamado a una url, en esos casos va a fallar la petición. Como no sabemos el tipo de respuesta que vamos a tener por eso tenemos estos pasos: </p>
                  <ul class="mb-3.75">
                    <li>trato de conectarme a un servidor</li>
                    <li>entonces, si tengo respuesta la quiero como json y estos comentarios son 500 (el tiempo de respuesta no va a ser igual si tengo 2 respuestas que si tengo 500)</li>
                    <li>una vez que finalice de ejecutarse el código del primer promise, tengo acceso a los datos con el segundo</li>
                  </ul>	
      
                  <p>Si la url fuera incorrecta, recordemos que el ok saldrá a false, response 200 y tendremos un segundo objeto vacío (del 2º promise). Podemos añadir un catch para intentar especificar algo en caso de error, sin embargo como veremos en la consola no se ejecuta el console log del catch ¿por qué? porque con el fetch() así especificado, el catch solo se ejecuta cuando hay problemas de red (podemos forzarlo quitando la wifi).</p>
      
                  <pre><code class="language-js">
                    const url = 'https://jsonplaceholder.typicode.com/urlerronea'
                    fetch(url)
                      .then((response) => {	
                        //console.log(response)								
                        return response.json()
                      })
                      .then((data) => {
                        console.log(data)
                      })	
                      .catch(error=>{
                        console.log(error)
                      })
                  </code></pre>
      
                  <p>Hagamos lo siguiente mejor (if para cuando hay respuesta y un throw new Error para cuando falle) y como veremos, el nuevo error pasará al .catch(). Aprovechamos las funciones de flecha para simplificar la sintaxis del 2º promise y el catch:</p>
      
                  <pre><code class="language-js">
                    fetch(url)
                      .then((response) => {	
                        //console.log(response)
                        if(response.ok){								
                          return response.json()
                        } 
                        throw new Error('Hubo un error')
                      })
                      .then(data => console.log(data))	
                      .catch(error=> console.log(error))								
                  </code></pre>
      
                  <img class="my-2.5" src="./src/assets/img/37-2.png" alt="" />
      
                  <p>Como decíamos podemos usarlo sin función como acabamos de ver en el ejemplo anterior o también dentro de una función que mandaremos llamar. Funcionaría igual y este sería el código:</p>
                  <pre>
                    <code class="language-js">
                      const url = 'https://jsonplaceholder.typicode.com/comments'
      
                      const consultarAPI = () => {
                        fetch(url)
                          .then((response) => {	
                            //console.log(response)
                            if(response.ok){								
                              return response.json()
                            } 
                            throw new Error('Hubo un error')
                          })
                          .then(data => console.log(data))	
                          .catch(error=> console.log(error.message))
                      }
                      consultarAPI()
                    </code>
                  </pre>
      
                  <p>Fetch API con promises es una gran mejora pero Async Await lo hace aún más simple</p>						
                </div>
      <!-- Fin bloque desplegable interior -->
      
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-38').toggle();">	
                  <h3>38. Fetch API con Async / Await</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-38" class="hidden">
                  <p class="font-bold">Fetch con Async / Await <strong>sí requiere una función</strong>, que puede ser un arrow function o un function declaration. A continuación escribiremos código con ambas. En este caso ha de ser asíncrona (por eso requiere una función). Para el caso de función de flecha colocamos la palabra <span class="destacado">async</span> antes de los paréntesis, lo que convierte a la función en asíncrona y nos da acceso a la otra propiedad: <span class="destacado">await</span> que son los que reemplazan a los .then() del ejemplo anterior.</p>
                  
                  <p>El await (como antes los then) espera a que se realice la petición, ocurra una respuesta y vuelve a utilizar otro await para obtener los datos. Tengamos en cuenta que la conexión a una API externa dependerá del tipo de servidor (servidor gratis vs servidor de 1000$/mes) y la conexión que tengamos; y como decíamos leer los datos no va a ser lo mismo leer 2 registros que 500. Los await esperan que finalice de ejecutarse ese código para ir a la siguiente línea.</p>		
      
                  <p>La sintaxis es un poco diferente y se lee más como "de derecha a izquierda"</p>
      
                  <pre><code class="language-js">
                    const url = 'https://jsonplaceholder.typicode.com/comments'
                    /*
                    fetch(url)
                      .then((response) => {	
                        //console.log(response)
                        if(response.ok){								
                          return response.json()
                        } 
                        throw new Error('Hubo un error')
                      })
                      .then(data => console.log(data))	
                      .catch(error=> console.log(error.message))
                    */
                    const consultarAPI = async () => {
                      const response = await fetch(url)
                      const data = await response.json()
                      console.log(data)
                    }
                    consultarAPI()
                  </code></pre>
      
                  <p>Estos dos códigos hacen lo mismo, pero hay un detalle. Con Async / Await no hay forma de catchear un posible error. Por lo que normalmente cuando usamos Async / Await se usa junto a algo llamado Try Catch. En el caso de que cualquiera de las acciones indicadas en el Try falle, ejecuta lo que especifiquemos en el catch:</p>
      
                  <pre><code class="language-js">
                    const url = 'https://jsonplaceholder.typicode.com/comments'
                    const consultarAPI = async () => {
                      try {
                        const response = await fetch(url)
                        if(!response.ok){
                          throw new Error('Hubo un error')
                        }
                        const data = await response.json()
                        console.log(data)
                      } catch (error) {
                        console.log(error)
                      }
                    }
                    consultarAPI()
                  </code></pre>						
                </div>
      <!-- Fin bloque desplegable interior-->
      
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-39').toggle();">	
                  <h3>39. Medir performance y cómo manejar múltiples consultas</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-39" class="hidden">
                  <p>JS tiene una API para medir la performance de nuestro código. Más de una vez vamos a tener distintos códigos que hagan lo mismo y vamos a querer medir cual es la versión más rápida. Utilizamos para ello <span class="destacado">performance.now()</span>. Lo usamos al principio y al final de nuestro try y sacamos por consola la diferencia en ms. Veremos que en función de la url que usemos (que carga más o menos datos) ese rendimiento en ms varía.</p>
                  <pre>
                    <code class="language-js">
                      //Performance y múltiple Async Await
                      const url = 'https://jsonplaceholder.typicode.com/comments'
                      const url2 = 'https://jsonplaceholder.typicode.com/todos'
                      const url3 = 'https://jsonplaceholder.typicode.com/photos'
                      const consultarAPI = async () => {
                        try {
                          const inicio = performance.now()			
                          const response = await fetch(url3)
                          if(!response.ok){
                            throw new Error('Hubo un error')
                          }
                          const data = await response.json()
                          console.log(data)
                      
                          const fin = performance.now()			
                          console.log(`El resultado es: ${fin - inicio} ms`)
                        } catch (error) {
                          console.log(error)
                        }
                      }
                      consultarAPI()
                    </code>
                  </pre>
                  <p>Una aplicación real obtiene datos de muchos sitios distintos. Tal vez nuestra empresa tenga un rp, crm, e-commerce, sistemas de facturación... tal vez estamos creando algo que consume datos de diferentes lugares. Un error muy común es hacer lo siguiente, supongamos que consumimos los 3 "endpoints" de esta manera, vemos la consola (izquierda):</p>
                  <pre>
                    <code class="language-js">
                      //Performance y múltiple Async Await
                      const url = 'https://jsonplaceholder.typicode.com/comments'
                      const url2 = 'https://jsonplaceholder.typicode.com/todos'
                      const url3 = 'https://jsonplaceholder.typicode.com/photos'
                      const consultarAPI = async () => {
                        try {
                          const inicio = performance.now()	
      
                          const response = await fetch(url)				
                          const data = await response.json()
                          console.log(data)
                      
                          const response2 = await fetch(url2)				
                          const data2 = await response2.json()
                          console.log(data2)
                      
                          const response3 = await fetch(url3)				
                          const data3 = await response3.json()
                          console.log(data3)
                      
                          const fin = performance.now()			
                          console.log(`El resultado es: ${fin - inicio} ms`)
                        } catch (error) {
                          console.log(error)
                        }
                      }
                      consultarAPI()
                    </code>
                  </pre>
                  <p>usar así los awaits esperando a que cada llamada anterior se resuelva va a hacer que nuestras apps sean más lentas. <strong>¡OJO! va a a habver ocasiones en que realmente querramos llamarlas así secuencialmente porque el siguiente procesado necesite los datos anteriores</strong>. Pero veamos cómo hacerlo en caso de que queramos procesar a la vez todas las llamadas y no secuencialmente. Emplearemos <span class="destacado">Promise.all()</span>:</p>
      
                  <pre><code class="language-js">
                    const consultarAPI2 = async () =>{
                      try {
                        const inicio = performance.now()
                    
                        const [response, response2, response3] = await Promise.all([fetch(url),fetch(url2),fetch(url3)])
                        const [data, data2, data3] = await Promise.all([response.json(),response2.json(),response3.json()])			  
                        console.log(data)     
                        console.log(data2)    
                        console.log(data3)		
                    
                        const fin = performance.now()
                    
                        console.log(`El resultado de la SEGUNDA función es: ${fin - inicio} ms`)
                      } catch (error) {
                        console.log(error)
                      }
                    }
                    consultarAPI2()
                  </code></pre>
      
                  <p>Si vemos en la consola (derecha) el resultado de ejecutar las dos funciones <strong>(ver 39-performance.js)</strong> veremos que siempre en cada ejecución, la primera que termina (por tanto con mejor rendimiento, termina en menos ms) es la segunda función.</p>	
                  
                  <img class="my-2.5" src="./src/assets/img/39-1.png" alt="" />
      
                  
                </div>
      <!-- Fin bloque desplegable interior-->
      
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-40').toggle();">	
          <h3>40. DOM - Selectores</h3>			
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-40" class="hidden">
                  <p>Va a ser corto porque de hecho la forma de escribir código de DOM en JS es un poco diferente a como React lo maneja porque tiene algo llamado JSX que simplifica mucho. Pero siempre viene bien aprender o refrescar. Abrimos el DOM.html y colocamos el script:</p>
                  <pre>
                    <code class="language-html">
                      &lt;script src=&quot;js/40-DOM-selectores.js&quot;&gt;&lt;/script&gt;
                    </code>
                  </pre>
      
                  <p><strong>Selectores</strong>. Todas las interacciones que haces en el DOM con js requieren un selector. Es como en CSS seleccionas un elemento y empiezas a aplicar propiedades css para cambiar apariencia. En JS vas a aseleccionar algún elemento de tu página y vas a regresar operaciones por medio de js para agregar, modificar o eliminar atributos.</p>		
      
                  <p>queremos seleccionar este elemento del DOM.html:</p>
      
                  <pre><code class="language-html">
                    &lt;h1 class=&quot;text-4xl font-black heading&quot;&gt;JavaScript Intermedio - Manipulaci&oacute;n de DOM &lt;/h1&gt;
                  </code></pre>
      
                  <p>iniciamos con <span class="destacado">document</span>(podemos poner en consola document y vemos que es el documento entero.) De hecho podemos poner en consola document.title y vemos que saca el título de la página. pero para otro tipo de elementos de dentro del html hemos de utilizar <span class="destacado">querySelector()</span>. También comenta los que conocemos <strong>.getElementById</strong>, <strong>.getElementsByTagName</strong>, etc... pero hoy día se recomienda utilizar más la sintaxis con querySelector() porque tenemos acceso a selectores muy similares a los de css (.clase, #id, :last-of-type, :nth-child(),...), y sabiendo css los mismos selectores aplican para seleccionar elementos en js. Como hay selectores muy complejos, podremos seleccionar prácticamente cualquier elemento.</p>
      
                  <p>Si hacemos un console.log(heading), vemos que nos pone el elemento h1 como está con todo lo que contiene tanto el tag en sí como su contenido. Así seleccionado un elemento tenemos acceso a sus atributos, lo que conocemos como el DOM. El DOM podemos modificarlo y recorrerlo.</p>
      
                  <div class="flex">
                    <pre><code class="language-js">
                      const heading = document.querySelector('.heading')
                      console.log(heading)
                      console.log(heading.tagName)
                      console.log(heading.textContent)
                      console.log(heading.classList)
                    </code></pre>
      
                    <img class="my-2.5" src="./src/assets/img/40-1.png" alt="" />
                  </div>
      
                  <p>Veamos ahora el <span class="destacado">querySelectorAll()</span>. La principal diferencia es que trae <strong>TODOS</strong> los elementos que tengan correspondencia con ese selector, mientras que querySelector() solo trae uno (aunque haya más que correspondan con el selector indicado entre paréntesis, solo trae el primero que encuentra)</p> 
                  <pre><code class="language-html">
                    &lt;nav class=&quot;navegacion my-5 flex gap-5&quot;&gt;
                      &lt;a href=&quot;&num;&quot;&gt;Enlace 1&lt;/a&gt;
                      &lt;a href=&quot;&num;&quot;&gt;Enlace 2&lt;/a&gt;
                      &lt;a href=&quot;&num;&quot;&gt;Enlace 3&lt;/a&gt;
                      &lt;a href=&quot;&num;&quot;&gt;Enlace 4&lt;/a&gt;
                    &lt;/nav&gt;		
                  </code></pre>
      
                  <div class="flex">
                    <pre><code class="language-js">
                      const enlaces = document.querySelectorAll('.navegacion a')
                      console.log(enlaces)
                    </code></pre>
      
                    <img class="my-2.5" src="./src/assets/img/40-2.png" alt="" />
                  </div>
      
                  
                </div>
      <!-- Fin bloque desplegable interior-->
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-41').toggle();">	
                  <h3>41. Manipular elementos HTML con JS</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-41" class="hidden">
                  <p>Veamos algunos ejemplos</p>
                  <pre>
                    <code class="language-js">
                      const heading = document.querySelector('.heading')
                      const enlaces = document.querySelectorAll('.navegacion a')
                      //console.log(heading.textContent)
                      
                      heading.textContent = 'Un nuevo Heading'
                      heading.id = 'Un nuevo id'
                      heading.removeAttribute('id')
                      heading.removeAttribute('class')
                    </code>
                  </pre>
      
                  <p>Es muy comun que muchos formularios tengan ya un value por default:</p>		
      
                  <pre><code class="language-js">
                    const inputNombre = document.querySelector('#nombre')
      
                    //normalmente los atributos de los tags HTML se llaman igual los atributos de JS
                    inputNombre.value = 'Un nuevo valor'
                    //aunque no siempre, por ejemplo las clases o los atributos personalizados data-nombre="input"
                    console.log(inputNombre.classList)
                    inputNombre.dataset.nombre = "input"
                    
                    //Veamos como manipular colecciones. hemos de pasarle la posición o iterar sobre los elementos
                    console.log(enlaces)
                    enlaces.forEach( enlace => enlace.textContent = 'Nuevo Enlace')
                  </code></pre>
                </div>
      <!-- Fin bloque desplegable interior-->
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-42').toggle();">	
                  <h3>42. DOM eventos con click - <a href="https://developer.mozilla.org/es/docs/Web/API/Element" class="text-[#000000]" target="blank">Enlace MDN Element</a></h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-42" class="hidden">
                  <p>Una de las características ppales de JS es que podamos añadir interacción a nuestras aplicaciones/sitios web. Veamos algunos eventos que nos van a permitir eso.</p>
                  <pre>
                    <code class="language-js">
                    const heading = document.querySelector('.heading')
                    //vimos como podemos cambiar por ejemplo el contenido del tag por un nuevo título
                    heading.textContent = 'nuevo título'
                    </code>
                  </pre>
                  <p>Supongamos que quiero esperar a que por ejemplo alguien presione en el titulo para modificarlo. <strong>Una vez que seleccionas un elemento tienes acceso a registrarle un evento con el evento <span class="destacado">addEventListener()</span></strong>. Veamos el siguiente link https://developer.mozilla.org/es/docs/Web/API/Element, en la parte derecha podemos ver los eventos. Los hay de todo tipo, del mouse, de animaciones, eventos cuando copias algo con el teclado,... </p>	
                  
                  <p>esto es lo que se conoce como un callback, espera que ocurra el evento del primer argumento y cuando ocurre se dispara la función indicada en el segundo argumento.</p>
      
                  <pre><code class="language-js">
                    heading.addEventListener('click', () => {
                      heading.textContent = 'Al dar click'
                    })
                    heading.addEventListener('dblclick', () => {
                      heading.textContent = 'Al dar doble click'
                    })
                    heading.addEventListener('mouseenter', () => {
                      heading.textContent = 'Al entrar'
                    })
                    heading.addEventListener('mouseleave', () => {
                      heading.textContent = 'Al salir'
                    })
                  </code></pre>
      
                  <p>Para añadir addEventListener a los integrantes de un document.querySelectorAll utilizamos el forEach:</p> 
      
                  <pre><code class="language-js">
                    const enlaces = document.querySelectorAll('.navegacion a')
                    enlaces.forEach( enlace => {
                      enlace.addEventListener('click', () => {
                        console.log('diste click en un enlace')
                      })
                    })
                  </code></pre>	
      
                  <p>Vemos que al pulsar cada link la página nos da un salto. El elemento enlace tiene una acción por default que es intentar ir la url indicada en el href pero en nuestro caso no hay nada tenemos un #. Veamos. A la función que se dispara al realizar el evento le podemos pasar un parámetro que llamamos <strong>e, evento, evt, ...</strong> como queramos, y si hacemos un console log de ello vemos que aparece una gran cantida de información sobre el evento que se está llevando a cabo. Si scrolleamos un poco hacia abajo llegamos al "target" que nos da la información de qué es lo que ha disparado ese evento. Hacemos un console.log de e.target y nos da información de qué es a lo que hemos dado click:</p>
                  <pre><code class="language-js">
                    const enlaces = document.querySelectorAll('.navegacion a')
                    enlaces.forEach( enlace => {
                      enlace.addEventListener('click', (e) => {
                        console.log(e.target)
                        console.log('diste click en un enlace')
                        e.preventDefault()
                        e.target.textContent="diste click"
                      })
                    })
                  </code></pre>
                  <img class="my-2.5" src="./src/assets/img/42-1.png" alt="" />
      
                  <p>cuadno enviamos un formulario hay una acción por default, cuando haces click en un botón hay una acción por default, si presionas un heading o una imagen no hay una acción por default... pero los links es uno d elos elementos que sí tiene una acción por default. usamos <span class="destacado">e.preventDefault()</span> que básicamente le dice al link "ok, tú tines un comportamiento que es abrir una url. No lo hagas.</p>
      
                  <p>Por tanto nosotros mediante código podemos modificar las acciones a realizar, por ejemplo en un formulario, que en vez de enviarse haga validaciones. Importante:</p>
                  <ul class="mb-3.75">
                    <li><span class="destacado">e.preventDefault()</span> nos va a permitir <strong>prevenir la accion por defecto de algún elemento html que realiza algo</strong></li>
                    <li>ese <span class="destacado">e</span> reporta <strong>el evento que se está registrando</strong>, en nuestro ejemplo el click </li>
                    <li>el <span class="destacado">e.target</span> es <strong>lo que dispara ese evento</strong>, en nuestro ejemplo un enlace</li>
                  </ul>
                </div>
      <!-- Fin bloque desplegable interior-->
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-43').toggle();">	
                  <h3>43. DOM eventos en inputs</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-43" class="hidden">
                  <p>En nuestro DOM.html tenemos estos dos inputs:</p>
                  <pre>
                    <code class="language-html">
                      &lt;input type=&quot;text&quot; placeholder=&quot;Tu Nombre&quot; id=&quot;nombre&quot; class=&quot;p-2 rounded-lg text-sm&quot;&gt;
      
                      &lt;input type=&quot;password&quot; placeholder=&quot;Tu Password&quot; id=&quot;password&quot; class=&quot;p-2 rounded-lg text-sm&quot;&gt;
                    </code>
                  </pre>
      
                  <p>Queremos leer lo que el usuario va escribiendo en el input de nombre. registramos un addEventListener()</p>		
                  <pre>
                    <code class="language-js">
                      const inputNombre = document.querySelector('#nombre')
                      inputNombre.addEventListener('input', (e) => {
                        console.log('escribiendo')
                        console.log(e.target)
                        console.log(e.target.value)
                        console.log(e.target.value.length)
                      })		
                    </code>
                  </pre>
                  <p>Por defecto en un input de tipo password el contenido sale ofuscado. Queremos ver lo que escribimos durante poco tiempo y luego que se vuelva a ofuscar.</p>
                  <pre>
                    <code class="language-js">
                      const inputPassword = document.querySelector('#password')
                      inputPassword.addEventListener('input', functionPassword)
                      function functionPassword() {
                        inputPassword.type = "text"
                        setTimeout(() => {
                          inputPassword.type = "password"
                        }, 500)
                      }		
                    </code>
                  </pre>
                  
                </div>
      <!-- Fin bloque desplegable interior-->
      
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-44').toggle();">	
                  <h3>44. Eventos en Submit. 45. Validando formulario y mostrando alertas.</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-44" class="hidden">
                  <p>En nuestro formulario tenemos este input de tipo submit. El evento de submit se llama cuando alguien presiona sobre el formulario para enviarlo:</p>
                  <pre>
                    <code class="language-html">
                      &lt;input type=&quot;submit&quot; value=&quot;Iniciar Sesi&oacute;n&quot;
                      class=&quot;bg-cyan-500 hover:bg-cyan-600 text-sm uppercase p-2 font-black text-white cursor-pointer&quot;&gt;
                    </code>
                  </pre>
      
                  <p>Veamos un ejemplo de una validación sencilla:</p>
                  <pre>
                    <code class="language-js">
                      const formulario = document.querySelector('#formulario')
                      formulario.addEventListener('submit', e => {
                        e.preventDefault
                      
                        const nombre = document.querySelector('#nombre').value
                        const password = document.querySelector('#password').value
                      
                        if(nombre === '' || password === ''){
                          console.log('Todos los campos son obligatorios')
                        } else {
                          console.log('Todo bien, iniciando sesión')
                        }
                        // console.log('Enviando formulario')
                        // console.log(nombre)
                        // console.log(password)    
                      })
                    </code>
                  </pre>
      
                  <p>Creamos con JS un elemento html div al que vamos a añadir unas clases de tailwindcss para darle formato.</p>
      
                  <p>Hemos de seleccionar siempre un elemento de nuestro document en el que queremos renderizar lo que estamos creando. Como estamos creando un div de alerta de validación, tiene sentido que lo queramos mostrar en el formulario. Por tanto agregamos la alerta como un hijo del formulario <span class="destacado">formulario.appendChild(alerta)</span></p>
                  <pre>
                    <code class="language-js">
                      const formulario = document.querySelector('#formulario')
                      formulario.addEventListener('submit', e => {
                        e.preventDefault
                        const nombre = document.querySelector('#nombre').value
                        const password = document.querySelector('#password').value
                        
                        //Prevenir nuevas alertas
                        const alertaPrevia = document.querySelector('.alerta')
                        /*if (alertaPrevia){
                          alertaPrevia.remove();
                        }*/
                        alertaPrevia?.remove(); //comprobamos si existe con el optional chaining
      
                        const alerta = document.createElement('DIV')
                        //alerta.textContent = 'contenido de alerta'
                        //alerta.classList = 'clase-1 clase-2' //se pueden añadir así clases de estilo pero se recomienda hacerlo usando .add()
                        //alerta.classList.add('clase-1','clase-2','clase-3')
                        //añadamos clases de Tailwind css
                        alerta.classList.add('alerta','text-white','uppercase', 'text-sm', 'text-center', 'p-2', 'font-black')   
                    
                        if(nombre === '' || password === ''){
                          alerta.textContent = 'Todos los campos son obligatorios'
                          alerta.classList.add('bg-red-500')
                        } else {
                          alerta.textContent = 'Todo bien, iniciando sesión'
                          alerta.classList.add('bg-green-500')
                        }
                        //para eliminar la alerta pasados 2sg
                        setTimeout(() => {
                          alerta.remove()
                        }, 2000);
                        //console.log(alerta)
                        formulario.appendChild(alerta)
                      })
                    </code>
                  </pre>	
                </div>
      <!-- Fin bloque desplegable interior-->
                
              </div>			
            </div><!--Fin row-->
              
              
            
          </div>
          <!-- Fin div colapsable-->
      
      
        </div>
      </div>	
      <!-- SECCION 2 -->	


      <!-- SECCION 1 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
        <div class="row">
          <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion1').toggle();">	
            <h2>Sección 1: Introducción al Curso - Qué es React, Proyectos que Construiremos y más</h2>				
                    <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
          </div>
          
          <div id="seccion1"  class="hidden">			
            <div class="row">
              <div class="col-12 pl-1.25">	
                
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion1-1').toggle();">	
                  <h3>1. ¿Qué es React?</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                
                <div id="seccion1-1" class="hidden">	
                  
                  <p>Es una biblioteca de JS para construir interfaces de usuario</p>
                  <ul class="mb-3.75">
                    <li>Ayuda a crear UI interactivas de forma muy sencilla (tiene muchas funciones y eventos para disparar fcnes en base a las interacciones del usuario)</li>
                    <li>Se encarga de actualizar y renderizar de manera eficiente los componentes de tu aplicación</li>
                    <li>Esta basado en componentes: no son mas que fiunciones en JS utilizados para renderizar el diseño de tu aplicación o sitio web</li>
                    <li>Creado por Meta (antiguo Facebook). También la empresa Versell apoya su desarrollo.</li>
                  </ul>
    
                  <p class="font-bold">Ventajas de React</p>			
                  <ul class="mb-3.75">
                    <li>Excelente documentación con muchos ejemplos</li>
                    <li>Una gran comunidad y muchas librerias que puedes incorporar a tus proyectos</li>
                    <li>Tecnología con mucha demanda: La mayoría de vacantes solicitan React, tanto para fornt end como para full stack</li>
                  </ul>
    
                  <p class="font-bold">¿Qué necesito para aprender React?</p>
                  <ul class="mb-3.75">
                    <li>Dominar HTML y CSS</li>
                    <li>Conocer la sintaxis Moderna de Javascript (ES6(2015)EcmaScript6 y cada añao hay nuevas que añaden unas cuantas funciones más)</li>
                    <li>Tener instalado Node.js para crear nuestros proyectos</li>
                  </ul>
                  
                </div><!-- Fin seccion colapsable interior  -->
                
                
              </div>			
            </div><!--Fin row-->
              
            <div class="row">
              <div class="col-12 pl-1.25">	
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion1-2').toggle();">	
                  <h3>2. Proyectos 01 a 04 del Curso - Fundamentos de React y TypeScript</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>						
                
                <div id="seccion1-2" class="hidden">	
                  
                  <p class="font-bold">Proyecto carrito de compras GuitarLA</p>
                  <p>En este proyecto estaremos aprendiendo los fundamentos de React: <span class="destacado">Componentes, Eventos y State</span>, mientras creas un carrito de compras real con cantidades, precios, y más, tomaremos este mismo carrito para mostrarte como crear tus propios Hooks y como transformarlo a código de TypeScript y cuales son sus beneficios. Carrito de compra persistente sincronizando con localStorage (aprenderemos todas esas acciones agregar elementos, cambiarlos, cambiar cantidades, vaciar carrito...)</p>							
                  <img class="my-2.5" src="./src/assets/img/s1-01.jpg" width="" height="" alt=""/> 
    
                  <p class="font-bold">Calculadora de propinas y consumos. Un proyecto ideal para restaurantes donde se podrá generar una orden con consumos y la persona podrá elegir la propina que desea dejar.</p>							
                  <img class="my-2.5" src="./src/assets/img/s1-02.jpg" width="" height="" alt=""/> 
    
                  <p class="font-bold">Contador de Calorías y Ejercicios</p>	
                  <p> Una de las tareas que más vas a realizar en tu vida como Developer es procesar formularios; en este proyecto tendremos un formulario, leeremos sus datos, lo vamos a procesar y realizar algunas operaciones como validación y mucho más, además aprenderás que es <span class="destacado">useReducer</span> para manejar estados complejos en tus apps. Veremos cómo funciona este patrón, es un hook especial cuando tenemos un state un poco más complejo.</p>
                  <img class="my-2.5" src="./src/assets/img/s1-03.jpg" width="" height="" alt=""/> 
                  
                  
                  <p class="font-bold">Control de Gastos y Presupuestos:</p>	
                  <p>En este proyecto estaremos viendo que es <span class="destacado">Context API</span> para tener un estado global sin dependencias; Context API va a ayudarte a no pasar props por cada componente, completamos el curso con filtrar gastos por categoría, calendario de fechas de gastos, gráficas y mucho más! Por tanto también usaremos reducers, context Api para comenzar a trabajar con un estado global y un custom hook.</p>
                  <img class="my-2.5" src="./src/assets/img/s1-04.jpg" width="" height="" alt=""/> 
                  
                </div><!-- Fin seccion colapsable interior  -->
              </div>
            </div><!--Fin row-->
            
            
            
            
            <div class="row">
              <div class="col-12 pl-1.25">	
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion1-3').toggle();">	
                  <h3>3. Proyectos 05 a 08 del Curso - React Intermedio y API's</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>						
                
                <div id="seccion1-3" class="hidden">	
                  
                  <p class="font-bold">Administrador de pacientes de veterinaria</p>
                  <p>Introduce dos herramientas nuevas: Este proyecto añade dos herramientas nuevas: <span class="destacado">Zustand</span> para manejar un estado global de forma muy simple y <span class="destacado">React Hook Form</span>, una librería para para la parte de validación y procesamiento de nuestros formularios de manera bastante sencilla.</p>														
                  <img class="my-2.5" src="./src/assets/img/s1-05.jpg" width="" height="" alt=""/> 
                  
                  <p class="font-bold">Buscador de clima</p>
                  <p>Esta será nuestra primera aplicación que obtiene datos de una <span class="destacado">API externa</span>, como React Developer vas a trabajar en muchos proyectos que incluyen API's; estaremos viendo como validar y enviar peticiones hacia API, como leer las respuestas y como mostrar esa información. La parte de APIS es muy importante en el mundo de React.</p>							
                  <img class="my-2.5" src="./src/assets/img/s1-06.jpg" width="" height="" alt=""/> 
                  
                  <p class="font-bold">Cotizador de Criptomonedas</p>
                  <p>Este proyecto al igual que el anterior se conecta a una API para obtener el precio de una Criptomoneda en dólares, pesos mexicanos y otras monedas; Este proyecto incluye Zustand y Zod para validar las respuestas que obtenemos de nuestra API.</p>							
                  <!-- <img class="my-2.5" src="./src/assets/img/s1-07.jpg" width="" height="" alt=""/>  -->
    
                  <p>Proyecto 04: Migrar Carrito de Compras a useReducer: En este capítulo estaremos viendo como tomar el proyecto de carrito de compras y convertirlo hacia useReducer; cuando tomas un proyecto que conoces en una tecnología nueva es garantía que podrás entender mejor los conceptos.</p>
                  <p>Proyecto 05: Migrar Calculadora de Propinas hacia useReducer: Veamos como migrar nuestro otro proyecto hacia useReducer.</p>
    
    
                  <p>Proyecto 10: Buscador de Recetas: Este es nuestro primer proyecto que incluye múltiples páginas; lo estaremos realizando con React Router DOM la librería más popular para crear aplicaciones en React de múltiples página, este curso utiliza el Slice Pattern para tener múltiples Stores de Zustand!</p>
                  <p>Proyecto 11: Administrador de Productos: Este es nuestro primer proyecto Full Stack donde estaremos creando tanto frontend como backend utilizando el PERN (PostgreSQL, Node.js, Express y React) este proyecto utiliza una REST API que conectaremos con React, añadiremos temas más avanzados como Testing y Documentación de API's.</p>
                  <p>Proyecto 12: Administrador de Tareas y Proyectos: Este es el Proyecto más avanzado del curso, utiliza el MERN stack que es uno de los más populares hoy en día, este proyecto incluye un sistema robusto de autenticación y registro de usuarios con confirmación de cuentas y resetear el password en caso de olvidarlo; además incluye roles y los usuarios solo pueden realizar ciertas acciones. El curso incluye además una REST API bastante compleja y avanzada, El curso utiliza también React Query, Tailwindcss, React Router, Mongoose, Express, TypeScript y mucho más.</p>
                  <p>Proyecto 13: Quiosco de Comida: Finalizaremos este curso con una introducción a Next.js, utilizaremos la versión 14 con App Router, Server Actions, Prisma, Zod, Zustand, Tailwind, y mucho más, el proyecto incluye subida de archivos, CRUD Completo, paginador, buscador y más.</p>
    
                  
                </div><!-- Fin seccion colapsable interior  -->
    
              </div>
            </div><!--Fin row-->
            
            
            
            
            
            
            
            
            
            
            <!-- 
            <div class="row">
              <div class="col-12 pl-1.25">						
                
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccionX-X').toggle();">	
                  <h3>XXXXXXXXXXXXXXXXXXXXXX</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>						
                
                <div id="seccionX-X" class="hidden">	
                  
                  <p class="font-bold">XXXXXXXXXXXX</p>
                  <p>XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</p>							
                  <img class="my-2.5" src="./src/assets/img/XXXX.jpg" width="" height="" alt=""/> 
    
                  
                  
                </div>
    
              </div> 
            </div>
            -->
            
            
            
            
            
            
            
              
            <div class="row">
              <div class="col-12">	
    
                
    
              </div>
            </div>
              
            
            
          </div>
          <!-- Fin div colapsable-->
      
      
        </div>
      </div>	
      <!-- FIN SECCION 1 -->	
    
    
      <!-- SECCION 00 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
        <div class="row">
          <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion0').toggle();">
            <h2>Apuntes curso React</h2>
            <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
          </div>

          <div id="seccion0" class="hidden">
            <div class="row">
              <div class="col-12">

                <p>Aprende React con TypeScript paso a paso creando proyectos del mundo real.</p>
          
                <p>Aprende React con proyectos del mundo real; Incluso si tus bases de JavaScript no son muy fuertes el curso tiene una introducción con todo lo que debes saber.</p>
                <p>En este curso aprenderemos a crear proyectos reales abarcando todo el ecosistema de React: State, Hooks, crear tus propios hooks, hooks avanzados, estado global, componentes y eventos, consultar API's externas y crear tus propias API's.</p>
                <p>Todos los Proyectos incluyen TypeScript desde el inicio.</p>	

              </div>
            </div><!--Fin row-->
          </div>
          <!-- Fin div colapsable-->

        </div>
      </div>
      <!-- FIN SECCION 00 -->
               
    
    </div>
      
  </body>
</html>
