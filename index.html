<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Curso React</title>	
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">	
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">    
    
    <!-- <script src="https://unpkg.com/@tailwindcss/browser@4"></script> -->
  
    <script type="module" crossorigin src="https://andune55.github.io/manual-react/assets/index-BVWg7osX.js"></script>
    <link rel="stylesheet" crossorigin href="https://andune55.github.io/manual-react/assets/index-BQcgRXk-.css">
  </head>
  <body>
    <div id="root"></div>	
    <div>   
      
      <!-- SECCION 10 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
        
        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion10').toggle();">
          <h2>Sección 10: PROYECTO - Contador de Calorías, Consumo y Ejercicios con useReducer</h2>
          <span class="cambiaicono ico_chevron_up mr-2.5" title=""></span>
        </div>

        <div id="seccion10">
          
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-130').toggle();">
            <h3>130. El Proyecto que vamos a construir / 131. Creando el Proyecto / 132. Instalando Tailwindcss</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-130" class="hidden">            

            <p class="mb-3.25">Este proyecto es un contador de calorías para contar las calorías de lo que consumimos y las que quemamos haciendo actividades. Va a ser un poco más complejo pues va a tener <strong>formularios (una de las tareas que más vamos a realizar como Developer)</strong>; leeremos sus datos, lo vamos a procesar y realizar algunas operaciones como validación y mucho más. <strong>Trabajar con formularios en React es complicado. Existen distintas librerías que lo simplifican bastante, y es probable que en el grupo de trabajo se use una librería pero <span class="destacado">nosotros debemos saber trabajar con elementos de formulario, leer y colocar en el state lo que el usuario va metiendo y es la razón de este proyecto</span>.</strong>
              
            <p>También tendrá <strong>localStorage</strong>. Va a ser desarrollado con <strong>UseState</strong> pero también veremos el hook <strong>useReducer</strong> que es un hook especial para manejar states complejos en nuestras apps, como es el caso de este proyecto.</p>   
            
            <ul class="my-3.75">
              <li><span>Vamos al directorio donde queremos crearlo</span></li>
              <li><span><span class="destacado">npm create vite@latest</span> > <strong>calorie-tracker</strong> > <strong>react TypeScript + SWC</strong> > <span class="destacado">npm install</span></span></li>
              <li><span>arrancamos el servidor de desarrollo <span class="destacado">npm run dev</span> y hacemos limpieza: eliminamos carpeta src>assets, eliminamos src>App.css, borramos el contenido de index.css, en index.html cambiamos el title y eliminamos icono <code class="language-js">&lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt;</code> (borramos también el icono vite.svg de la carpeta public) y limpiamos el compo ppal App.tsx.</span></li>
              <li>instalamos tailwind: <a class="underline" href="https://tailwindcss.com/docs/installation/using-vite" target="_blank">https://tailwindcss.com/docs/installation/using-vite</a> 
                <ul class="my-3.75">
                  <li><span class="destacado">npm install tailwindcss @tailwindcss/vite</span></li>
                  <li>configurar el plugin: 
                    <pre><code class="language-js">
                      //vite.config.ts
                      import tailwindcss from '@tailwindcss/vite'
                      export default defineConfig({
                        plugins: [
                          tailwindcss(),
                        ],
                      })
                    </code></pre>
                  </li>
                  <li>importar tailwindcss en nuestra css principal: 
                    <pre><code class="language-js">
                      //src>index.css
                      @import "tailwindcss";
                    </code></pre>
                  </li>
                </ul>                   
              </li>
            </ul>
              
            <img class="mx-auto mt-1.25" src="https://andune55.github.io/manual-react/assets/s1-03-CV3P0oc-.jpg" alt="imagen contador calorias">            
          </div>
            
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-133').toggle();">
            <h3>133. Creando los Contenedores Principales</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-133" class="hidden">
            <p>Agregamos header donde irá nuestro título y el botón para restablecer app y content donde irá nuestro formulario:</p> 
            <p>Creamos nuestro primer componente <strong>Form.tsx</strong> y en nuestro compo ppal App.tsx lo importamos y llamamos a su tag en la sección que acabamos de crear.</p> 
            
            
            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">                
                <pre><code class="language-js">
                  //App.tsx
                  import Form from "./components/Form"
                  function App() {  
    
                    return (
                      &lt;&gt;
                  
                        &lt;header className=&quot;bg-lime-600&quot;&gt;
                          &lt;div className=&quot;flex justify-between max-w-4xl mx-auto&quot;&gt;
                            &lt;h1 className=&quot;text-center text-lg font-bold text-white uppercase&quot;&gt;
                              Contador de calorías 
                            &lt;/h1&gt;
                          &lt;/div&gt;
                        &lt;/header&gt;
                  
                        &lt;section className=&quot;bg-lime-500 py-20 px-5&quot;&gt;
                          &lt;div className=&quot;max-w-4xl mx-auto&quot;&gt;
                            &lt;Form /&lt;
                          &lt;/div&gt;
                        &lt;/section&gt;
                        
                      &lt;/&gt;
                    )
                  }
                  
                  export default App
                </code></pre> 
              </div>
              <div class="w-[50%] max-sm:w-[100%] max-sm:mt-1.25">
                <pre><code class="language-js">
                  //Form.tsx
                  export default function Form() {
                    return (
                      &lt;div&gt;Form&lt;/div&gt;
                    )
                  }
                </code></pre>
                <img class="my-2.5" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA8gAAADoCAMAAAAEyD2bAAAAA3NCSVQICAjb4U/gAAAAolBMVEX//////////+/1/////9b5+vvl////+b3/8dbV+f/s8fjl+b3p7vX/8Zzn6/LA8f/16L3V6O/l6L316HPd3+Sn6O/l3QDVzZzVzXOnzb1e3dbVzQBezb18zwBezXNszwDApZxYzwCnpXPApQCnpQB8sgBepZxepXNEsgBepQB8kABYkAAskABscAAUcABYSwAASwBEJAAAJAAsAAAUAAAAAAA8AMpOAAAANnRSTlMA//////////////////////////////////////////////////////////////////////8QiasuAAAACXBIWXMAAA50AAAOdAFrJLPWAAAAH3RFWHRTb2Z0d2FyZQBNYWNyb21lZGlhIEZpcmV3b3JrcyA4tWjSeAAAABZ0RVh0Q3JlYXRpb24gVGltZQAwMi8xMi8yNVx3gX8AAAbzSURBVHic7dtrc9vGAYZR0U3jOo7KpAzVlqnqJlGSyrnKKf//Xyuwi8uC0uRDSdvF63M0Q0EksWRm8nCBBX31CbB6V+/7DQDnEzIEEDIEuPoUWL2rTz/x48fP2n/MyBBAyBBAyBBAyBDg6s/A6gkZAlx9Aaze1T2wekKGAEKGAEKGAELeb559+b7fA5zpgw/5sHl+977fA5zrQw/5H3/46Jv3/R7gbB96yP80HZPgIiEfNr1dv7ntt67vh81y1Prdx93vcn9x00+DzXN606y43H3+ow6zefTo7n758PiCw/Fy90LT/vPQ40g39Rl1jP1wR71vHArW4QIhj13sxgQ2dfloO6TxOOT91O50dyns0e5tUOPL1EFPQ942Tz6MQzQht0NPI+3mkL9/MX1G7JevCytwfsh9Fn0Bh12ppXbaZ7odci0h3zdVlWjq9LctZR3mj4F29+6hfvCb6XX6YbY1xu1yrXk7vNTLu/sh6pLn9JKLoetIh7I9hlxCLx8u3Vap/aWQWY/zQ97O8+J2yrO/azyWfRRyt/GXYXvosUZ1unsN9iTk/p7r05AP7QTaPfGz05dcDF1H6m6bkPebjz6vzzk0h/OwEmeHXHtYbnZ1dKVshzYehbzfPPvbi/rUocd+jr55tPvTIXePlujbkOdn3ZcSb4aHx5dcDv1EyN0beP73+uTDxoVlVufskGt142YttTbShfyvj6du5of7aO7246lujaafKR/t3j10WJwjj0tZ3QPb+XS5jNi0173uN4d6mDAOuRy6jrRtz5H7X9/XD5dy4C9l1uXskJsj0WlzLrEP6jTk0s7wxxhy1/Xu0e7LNadxmFrtIuTmqKD8cT0+eXzJ5dDN6twYcvl6135anGsX0mEF3nLI/c1fT0Iu9w/TXzMj3zwZ8jw1NjPy6aH1IuSaY338d0Me39RuHHuxNGbVmjW5xKH1GNG02Zzkdon8aRny4jLSfI787Msndm8Gb8+RpzPoQTnFbrbbi0vXj99ZGWlf264hH8Z9mv+U5qwb/t+dHXIfzm7eLP/375tl50M7+Q2LSfO143nV+vndU7vv5/m+WbXena5a7zftifp8Abo5LW+GLiMNd9WQF1e5i62QWZPzLz8NF4GX15HrFd++tTJDtiFvpzPR6Qh5vxkPhE93b+baGnJ/xzz4aPwu13cv7+qnwHAm/cR15LpeXSMfV63HQ/NyBH4YJmrrXazIBb7ZtZ8PZcfZtr201DfUhDydz5agt4uZ8IndD9Ph7nRIPjy6WAob5+HnX79ols+mu28WQ89fLbmuIR/m726WBe/xeAHW4hLfta6npdMF4fFQu1mRbkKe1p3KxskXqp/YfdusUzUHv6dr2sPHyW66GlY25pDboYeQy7fGSsjbZtSb+jrmY1blQ//XTxBByBBAyBBAyBBAyBBAyBBAyBDg6hZYPSFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDACFDgPND/unY+/cF3gvwP7pAyG9eXeB9AGcQMgS4YMj9Mfav3e/Xxx+Ob149/PxwPP54+1t/A7xdlwv5l+NXt7cP3R+vS84P3WnzT8dy89XZrwH8rgstdr159e1/+vWu/vZ1Wfl6+Lm7+a3cmJLhLbvYjPy6/nr4sQu5n4IfpoaFDG+bkCHAxUJuD62FDO/WpRe7fr0VMrxzF7z89MvxeOzrFTK8a75rDQGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGEDAGu/gisnpAhgJAhgJAhgJAhgJAhgJAhwH8BA8DgF18rczIAAAAASUVORK5CYII=" alt="img 133">
              </div>      
            </div>


          </div>
           
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-134').toggle();">
            <h3>134. Agregando el Formulario de Entrada de datos</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-134" class="hidden">
            <p>Trabajar con formularios en React es complicado. Existen distintas librerías que lo simplifican bastante, y es probable que en el grupo de trabajo se use una librería <strong>pero nosotros debemos saber leer y colocar en el state lo que el usuario va metiendo y es la razón de este proyecto</strong>.</p> 
            
            <ul class="my-3.75">
              <li>Comenzamos a maquetar y darle contenido al componente <span class="file">Form.tsx</span>.</li>
              <li>Para las categorías del select iteramos desde un array de objetos que nos traemos de este <a href="https://gist.github.com/codigoconjuan/d84931241e93bebac46fccc28d096123" class="underline">Gist de categorias</a>. Creamos <strong>data>categories.ts</strong> y el type que van a tener lo vamos a reutilizar así que lo metemos en un archivo genérico de types <strong>types>index.ts</strong></li>
              <li>
                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre><code class="language-js">
                      //type>index.ts
                      export type Category = {
                        id: number,
                        name: string
                      }
                    </code></pre>
                    <pre class="mt-1.25"><code class="language-js">
                      //data>categories.ts
                      import type { Category } from "../types"

                      export const categories: Category[] = [
                          { id: 1, name: 'Comida'},
                          { id: 2, name: 'Ejercicio'}
                      ]                
                    </code></pre>

                    <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/134-klmm-c6f.png" alt="">
                  </div>
                  <div class="w-[50%] max-sm:w-[100%] max-sm:mt-1.25">
                    <pre><code class="language-js">
                      //App.tsx
                      import Form from &quot;./components/Form&quot;
                      function App() {  

                        return (
                          &lt;&gt;

                            &lt;header className=&quot;bg-lime-600&quot;&gt;
                              &lt;div className=&quot;flex justify-between max-w-4xl mx-auto&quot;&gt;
                                &lt;h1 className=&quot;text-center text-lg font-bold text-white uppercase&quot;&gt;
                                  Contador de calorías 
                                &lt;/h1&gt;
                              &lt;/div&gt;
                            &lt;/header&gt;

                            &lt;section className=&quot;bg-lime-500 py-20 px-5&quot;&gt;
                              &lt;div className=&quot;max-w-4xl mx-auto&quot;&gt;
                                &lt;Form /&gt;
                              &lt;/div&gt;
                            &lt;/section&gt;
                            
                          &lt;/&gt;
                        )
                      }

                      export default App
                    </code></pre>
                  </div>
                </div>
              </li>
              <li>
                <pre><code class="language-js">
                  //Form.tsx
                  import { categories } from &quot;../data/categories&quot;

                  export default function Form() {
                    return (    
                      &lt;form
                          className=&quot;space-y-5 bg-white shadow p-10 rounded-lg&quot;
                      &gt;
                  
                          &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                              &lt;label htmlFor=&quot;category&quot; className=&quot;font-bold&quot;&gt;Categoría:&lt;/label&gt;
                              &lt;select 
                                  id=&quot;category&quot;
                                  className=&quot;border border-slate-300 p-2 rounded-lg w-full bg-white&quot;
                              &gt;
                                  {categories.map(category =&gt; (
                                      &lt;option
                                          key={category.id}
                                          value={category.id}
                                      &gt;{category.name}&lt;/option&gt;
                                  ))}
                              &lt;/select&gt;
                          &lt;/div&gt;
                  
                          &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                              &lt;label htmlFor=&quot;name&quot; className=&quot;font-bold&quot;&gt;Actividad:&lt;/label&gt;
                              &lt;input 
                                  id=&quot;name&quot;
                                  type=&quot;text&quot; 
                                  className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                                  placeholder=&quot;Por ej: Comida, zumo de naranja, ensalada, Ejercicio, Pesas, Bicicleta&quot;
                                  /&gt;
                          &lt;/div&gt;
                  
                          &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                              &lt;label htmlFor=&quot;calories&quot; className=&quot;font-bold&quot;&gt;Calorías:&lt;/label&gt;
                              &lt;input 
                                  id=&quot;calories&quot;
                                  type=&quot;number&quot; 
                                  className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                                  placeholder=&quot;Calorías Por ej: 300, 500&quot;
                                  /&gt;
                          &lt;/div&gt;
                  
                          &lt;input 
                              type=&quot;submit&quot; 
                              className=&quot;bg-gray-800 hover:bg-gray-900 w-full p-2 font-bold uppercase text-white cursor-pointer&quot;
                              value=&quot;Guardar Comida o guardar Ejercicio&quot;
                          /&gt;
                      &lt;/form&gt;  
                    )
                  }                  
                </code></pre>
              </li>
            </ul>
            
          </div>
           
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-135').toggle();">
            <h3>135. Creando el State para las Actividades</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-135" class="hidden">
            <p>Vamos a ir almacenando en el state todo lo que el usuario elija/escriba en nuestro formulario. Al tener todo eso en nuestro state va a ser más fácil hacer validaciones.</p>
            <ul class="my-3.75">
              <li><strong>Importamos useState en nuestro componente Form.tsx.</strong></li>
              <li><strong>Definimos nuestro state.</strong> Como tenemos Categoría, actividad y calorías, normalmente crearíamos un state para cada uno:
                <pre class="border-5 border-red-700"><code class="language-js">
                  //Form.tsx
                  import { useState } from "react"

                  const[category, setCategory] = useState('') 
                  const[name, setName] = useState('')
                  const[calories, setCalories] = useState(0)
                </code></pre>
                  pero como están relacionados entre sí podemos tenerlos en un objeto. <strong>Hagamos un state más genérico que vamos a nombrar como activity</strong>. Inicia como arreglo y vamos a ir definiendo sus propiedades:
                  <pre class="border-5 border-emerald-600"><code class="language-js">
                    //Form.tsx
                    import { useState } from "react"

                    const[activity, setsetActivity] = useState({
                      category: '',
                      name: '',
                      calories: 0
                  }) 
                  </code></pre>
              </li>
              <li><strong>Vamos a conectar las propiedades de nuestro state array 'activity' con los inputs del formulario</strong>:
              
                <ul class="my-3.75">
                  <li>En el select de category, le añadimos como value<code class="language-js">value={activity.category}</code>
                    
                    <div class="flex max-sm:flex-col">
                      <div class="w-[30%] max-sm:w-[100%]">
                        <pre><code class="language-js">
                          //data>categories.ts
                          export const categories: Category[] = [
                            { id: 1, name: 'Comida'},
                            { id: 2, name: 'Ejercicio'}
                          ]
                        </code></pre>
                      </div>
                      <div class="w-[70%] max-sm:w-[100%] max-sm:mt-1.25">
                        <pre data-line="4"><code class="language-js">
                          //Form.tsx
                          &lt;select 
                              id=&quot;category&quot;
                              className=&quot;border border-slate-300 p-2 rounded-lg w-full bg-white&quot;
                              value={activity.category}
                          &gt;
                        </code></pre> 
                        <p>con lo que si en la propiedad category de nuestro state activity tenemos 1, el select por defecto marca Comida que es el de id1 (si fuera 2 que es el id de ejercicio, por defecto marca Ejercicio)</p>
                        <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/135-1-DV7npfDO.png" alt="">
                      </div>
                    </div> 
                  </li>         
                    
                  <li>El input de actividad (#name --> le hemos dado ese id porque coincidia con el nombre del nuevo state), le añadimos como value <code class="language-js">value={activity.name}</code></li>
                  <li>El input de calorias #calories, le añadimos como value <code class="language-js">value={activity.calories}</code></li>        
                </ul>
              </li>
            </ul>
                
            <pre><code class="language-js">
              //Form.tsx
              import { useState } from &quot;react&quot;
              import { categories } from &quot;../data/categories&quot;
              
              export default function Form() {
              
                  const[activity, setsetActivity] = useState({
                      category: 1,
                      name: &#39;&#39;,
                      calories: 0
                  }) 
              
                return (    
                  &lt;form
                      className=&quot;space-y-5 bg-white shadow p-10 rounded-lg&quot;
                  &gt;
              
                      &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                          &lt;label htmlFor=&quot;category&quot; className=&quot;font-bold&quot;&gt;Categoría:&lt;/label&gt;
                          &lt;select 
                              id=&quot;category&quot;
                              className=&quot;border border-slate-300 p-2 rounded-lg w-full bg-white&quot;
                              value={activity.category}
                          &gt;
                              {categories.map(category =&gt; (
                                  &lt;option
                                      key={category.id}
                                      value={category.id}
                                  &gt;{category.name}&lt;/option&gt;
                              ))}
                          &lt;/select&gt;
                      &lt;/div&gt;
              
                      &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                          &lt;label htmlFor=&quot;name&quot; className=&quot;font-bold&quot;&gt;Actividad:&lt;/label&gt;
                          &lt;input 
                              id=&quot;name&quot;
                              type=&quot;text&quot; 
                              className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                              placeholder=&quot;Por ej: Comida, zumo de naranja, ensalada, Ejercicio, Pesas, Bicicleta&quot;
                              value={activity.name}                
                          /&gt;
                      &lt;/div&gt;
              
                      &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                          &lt;label htmlFor=&quot;calories&quot; className=&quot;font-bold&quot;&gt;Calorías:&lt;/label&gt;
                          &lt;input 
                              id=&quot;calories&quot;
                              type=&quot;number&quot; 
                              className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                              placeholder=&quot;Calorías Por ej: 300, 500&quot;
                              value={activity.calories}
                              /&gt;
                      &lt;/div&gt;
              
                      &lt;input 
                          type=&quot;submit&quot; 
                          className=&quot;bg-gray-800 hover:bg-gray-900 w-full p-2 font-bold uppercase text-white cursor-pointer&quot;
                          value=&quot;Guardar Comida o guardar Ejercicio&quot;
                      /&gt;
                  &lt;/form&gt;  
                )
              }
            </code></pre>

            <p>Si abrimos React Developer tools, al pulsar el componente Form, vemos en hooks nuestro state activity</p>
            <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/135-2-DU2v0x-q.png" alt="">
            sin embargo si intentamos cambiar la opción del select categoría o escribir en algún input (actividad o calorías) no nos deja y da error en consola, porque necesitamos un <strong>onChange</strong>
            <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/135-3-B2Nhxe5p.png" alt="">
                          
          </div>
           
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-136').toggle();">
            <h3>136. Escribiendo en el State / 137. Inferir el type de un evento / 138. Creando el Type de Actividad y seteando los valores en el state</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-136" class="hidden">
            <p>Hemos definido nuestro state y lo hemos conectado con los campos de nuestro formulario (1 select y dos inputs) pero como vimos tenemos en la consola advertencias. Le estamos pasando un value pero <strong>también tenemos que especificarle un onChange (básicamente es como un addEventListener y escuchar por el evento change)</strong>, que se ejecutará cada vez que cambiemos de opción en el select o cada vez que intentemos escribir en los inputs. Podemos hacerlo en el mismo input o tener una función aparte que lo gestione y llamaremos <strong>handleChange</strong>. La llamamos desde cada campo de formulario y ya no tendremos errores:</p>
            <pre><code class="language-js">
              //Form.tsx
              const handleChange = () =>{
                console.log ('algo cambió')
              }
              return ( 
                ...
                onChange={handleChange} // en cada campo del formulario
            </code></pre>
            
            <p>Sin embargo vemos que de momento nada cambia en la vista, y es porque el value del select y los inputs es lo que está en el state y de momento no lo estamos actualizando. Hemos de ir escribiendo en el state para que se vayan actualizando esos values de nuestros campos de formulario ¿como lo hacemos?. <strong>Estamos usando la misma función para un select y dos inputs y hemos de leer lo que el usuario haya metido</strong>. Una técnica muy común es pasarle (e) y hacer un console.log(e.target) para, como vemos en la siguiente captura, identificar sobre qué estamos intentando escribir o hacer cambio: </p>     

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  //Form.tsx
                  const handleChange = (e) =>{
                    console.log (e.target)          
                  }
                  return ( 
                    ...
                    onChange={handleChange} // en cada campo del formulario
                </code></pre>  
                
                <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/136-1-DCb1kRK2.png" alt="">
              </div>
              <div class="w-[50%] max-sm:w-[100%] max-sm:mt-1.25">
                <pre><code class="language-js">
                  //Form.tsx
                  const handleChange = (e) =>{
                    console.log (e.target.id)
                  }
                  return ( 
                    ...
                    onChange={handleChange} // en cada campo del formulario
                </code></pre>  
                
                <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/136-2-DJF6UyTA.png" alt="">
              </div>
            </div>
            
            <p><span class="destacado">SI NOMBRAMOS LOS ID DE NUESTROS ELEMENTOS DE FORMULARIO CON EL MISMO NOMBRE QUE LAS PROPIEDADES DE NUESTRO STATE...</span> <br>es más sencillo, es como "ir mapeando los datos"</p>
            
            <div class="flex max-sm:flex-col">
              <div class="w-[25%] max-sm:w-[100%]">
                <pre class="verde" data-line="4-6"><code class="language-js">
                  //Form.tsx
                  export default function Form() {
                    
                    const[activity, setsetActivity] = useState({
                      category: 1,
                      name: '',
                      calories: 0
                    }) 
                    
                    const handleChange = (e) =>{
                        //console.log (e.target)
                        console.log (e.target.id)
                      }
                    </code></pre>
                  </div>
                  <div class="w-[25%] max-sm:w-[100%] max-sm:mt-1.25">
                    <pre class="verde" data-line="2"><code class="language-js">
                      //Form.tsx
                      &lt;select 
                      id=&quot;category&quot;
                      className=&quot;border border-slate-300 p-2 rounded-lg w-full bg-white&quot;
                      value={activity.category}
                      onChange={handleChange}
                      &gt;
                      {categories.map(category =&gt; (
                        &lt;option
                        key={category.id}
                        value={category.id}
                        &gt;{category.name}&lt;/option&gt;
                        ))}
                        &lt;/select&gt;
                      </code></pre>
                    </div>
                    
                    <div class="w-[25%] max-sm:w-[100%]">
                      <pre class="verde" data-line="2"><code class="language-js">
                  //Form.tsx
                  &lt;input 
                  id=&quot;name&quot;
                  type=&quot;text&quot; 
                  className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                  placeholder=&quot;Por ej: Comida, zumo de naranja, ensalada, Ejercicio, Pesas, Bicicleta&quot;
                  value={activity.name}  
                  onChange={handleChange}              
                  /&gt;
                </code></pre>
              </div>
              <div class="w-[25%] max-sm:w-[100%] max-sm:mt-1.25">
                <pre class="verde" data-line="2"><code class="language-js">
                  //Form.tsx
                  &lt;input 
                  id=&quot;calories&quot;
                  type=&quot;number&quot; 
                  className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                  placeholder=&quot;Calorías Por ej: 300, 500&quot;
                  value={activity.calories}
                  onChange={handleChange}
                  /&gt;
                </code></pre>
              </div>
            </div>
            
            <p><code class="language-js">e.target.id</code> ¿qué es lo que estoy intentando modificar?¿sobre qué intento actuar?</p>
            <p><code class="language-js">e.target.value</code> ¿qué es lo que estoy escribiendo/cambiando? </p>
            
            <p>La función de nuestro state, 'setActivity' es un objeto así que la llamamos, abrimos corchetes y, usamos el spread operator para que con cada cambio que hagamos en el state al modificar el value de CADA elemento de formulario, siempre mantenga el state que había antes de ese cambio (podemos ver en React Developer tools cómo se comporta el state si no hacemos esto, se cambia con cada intento de cambio en algún elemento del formulario) --> escribe correctamente y no pierde la referencia gracias a que tomamos una copia de lo que tenemos en nuestro state antes de escribir un nuevo state</p>
            
            <pre><code class="language-js">
              //Form.tsx
              const handleChange = (e) =>{        
                setActivity({
                  ...activity,
                  [e.target.id]: e.target.value
                })
              }
            </code></pre>
            
            <p>Podemos hacer así uso de nuestro state en otros lugares como por ejemplo en una validación, una vez que yo presione en guardar comida o guardar ejercicio, validamos eso que tenemos en el state antes de guardarlo.</p>
            
            <p class="esp-15-top esp-0-bottom"><span class="naranja">Inferir el Type de un evento</span></p>           
            
            <p>Si vemos, llevamos arrastrando esta advertencia de que <strong>el parámetro e/evt/event tiene un tipo any implícitamente</strong>.</p>
            
            <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/137-Ba3V1iOv.png" alt="">
            
            <p>Hemos de especificarle un tipo de dato para que no sea any. Si dejamos anys 'por ahí' vamos a tener más problemas que otra cosa y es como si no estuviéramos usando typescript. Veamos cómo identificar qué tipo de dato le vamos a pasar a este evento, con la ayuda del IS de VSC. Vamos al onChange del elemento select de formulario y en vez de llamar a la función handleChange, cambiamos momentáneamente por un <strong>e =></strong>, de ahí sacamos el tipo <strong>React.ChangeEvent&lt;HTMLSelectElement&gt;</strong> pero solo con ese no nos valdría porque vemos que nos da error en los onChange de los elementos input de nuestro formulario. Si hacemos lo mismo cambiando la llamada a la función por un <strong>e =></strong> sacamos el tipo <strong>React.ChangeEvent&lt;HTMLInputElement&gt;</strong></p>
            
            <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/137-2-CJTp4xwa.png" alt="">
            
            <p>Usando un pipe "|" en la definición del tipo de ese parámetro, vamos a indicar que nuestra función handleChange se puede utilizar tanto en un elemento select como en un elemento input. Podemos incluir 'ChangeEvent' en la importación de react y así reducimos la sintaxis del tipado de parámetro</p>
            
            <pre><code class="language-js">
              //Form.tsx
              import { useState, ChangeEvent } from "react"
              
              const handleChange = (e: ChangeEvent&lt;HTMLSelectElement&gt; | ChangeEvent&lt;HTMLInputElement&gt; ) =&gt;{        
                setActivity({
                  ...activity,
                  [e.target.id]: e.target.value
                })
              }
            </code></pre>
            
            <p>Vemos que ya no tenemos avisos de VSC y comprobando el hook de nuestro state activity en las React Developer tools vemos que con cada cambio se guarda adecuadamente lo que modificamos/escribimos. <strong>Sin embargo al cambiar vemos que, tanto la categoría como las calorías me las guarda en el state como string y quiero que sean de tipo número</strong>.</p>
            
            <p class="naranja">Creando el Type de Actividad y seteando los valores en el state</p>
            
            <p>En nuestro objeto state 'activity' vemos que las propiedades category y calories son números mientras que la propiedad name (nombre de la actividad) es un string. De hecho así es si recargamos nuestra app y miramos el state en nuestro compo Form en RDT(React Developer Tools). Pero si cambiamos a Ejercicio (la opción 2 del select que tiene un id de 2) o introducimos por ejemplo 300 calorías vemos que lo asigna todo como string</p>
            
            <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/137-3-C2Ix7A8N.png" alt="">

            <p>Vamos a agregar un type nuevo para el state de activity en nuestro fichero de types, lo importamos en nuestro componente Form.tsx y se lo asignamos vía generic a nuestro state:</p>

            <pre data-line="8,13"><code class="language-js">
              //types>index.ts
                export type Activity = {
                  category: number,
                  name: string,
                  calories: number
                }
              //Form.tsx
                import { useState, ChangeEvent } from "react"
                import { Activity } from "../types"
                import { categories } from "../data/categories"
                
                export default function Form() {
                
                    const[activity, setActivity] = useState&lt;Activity&gt;({
                        category: 1,
                        name: '',
                        calories: 0
                    }) 
            </code></pre>

            <p>Una vez hecho lo anterior VSC no nos marca errores, porque TS está funcionando bien en esta parte de nuestro compo, en nuestro código, pero no sabe qué es lo que vamos a agregar en ese formulario. <strong>Nosotros hemos de mantener esa integridad de nuestro state activity ¿Como podemos hacer para convertirlos a números antes de setearlos a nuestro state?</strong></p>
            <ul class="my-3.75">
              <li>Identifiquemos los que queremos que sean números. Creamos una variable de tipo array llamada 'isNumberField' que va a comprobar si donde estoy escribiendo es categoría o calorías: <code class="language-js">const isNumberField = ['category','calories'].includes(e.target.id)</code> --&gt; en caso de que esté escribiendo en category o calories me retorna true</li>
              <li>Teniendo en cuenta la comprobación que hacemos con esta nueva variable, añadimos un ternario a nuestra expresión anterior <code class="language-js">[e.target.id]: e.target.value</code> de manera que si es true convertimos a número con <span class="destacado">+</span> y si no lo dejamos como estaba, que setea string:
              <pre><code class="language-js">
                //Forms.tsx
                const handleChange = (e: ChangeEvent<HTMLSelectElement> | ChangeEvent<HTMLInputElement> ) =>{   
                  const isNumberField = ['category','calories'].includes(e.target.id)
                  setActivity({
                      ...activity,           
                      [e.target.id]: isNumberField ? +e.target.value : e.target.value
                  })
                }
              </code></pre>
              </li>
            </ul>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  //types>index.ts
                    export type Category = {
                      id: number,
                      name: string
                    }
                    export type Activity = {
                        category: number,
                        name: string,
                        calories: number
                    }
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%] max-sm:mt-1.25">
                <pre><code class="language-js">
                  //data>categories.ts
                  import type { Category } from "../types"

                  export const categories: Category[] = [
                      { id: 1, name: 'Comida'},
                      { id: 2, name: 'Ejercicio'}
                  ]  
                </code></pre>
              </div>
            </div>

            <pre><code class="language-js">
              import { useState, ChangeEvent } from &quot;react&quot;
              import { Activity } from &quot;../types&quot;
              import { categories } from &quot;../data/categories&quot;
              
              export default function Form() {
              
                  const[activity, setActivity] = useState&lt;Activity&gt;({
                      category: 1,
                      name: &#39;&#39;,
                      calories: 0
                  }) 
              
                  const handleChange = (e: ChangeEvent&lt;HTMLSelectElement&gt; | ChangeEvent&lt;HTMLInputElement&gt; ) =&gt;{   
                      const isNumberField = [&#39;category&#39;,&#39;calories&#39;].includes(e.target.id)
                      setActivity({
                          ...activity,           
                          [e.target.id]: isNumberField ? +e.target.value : e.target.value
                      })
                  }
              
                return (    
                  &lt;form
                      className=&quot;space-y-5 bg-white shadow p-10 rounded-lg&quot;
                  &gt;
              
                      &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                          &lt;label htmlFor=&quot;category&quot; className=&quot;font-bold&quot;&gt;Categoría:&lt;/label&gt;
                          &lt;select 
                              id=&quot;category&quot;
                              className=&quot;border border-slate-300 p-2 rounded-lg w-full bg-white&quot;
                              value={activity.category}
                              onChange={handleChange}
                          &gt;
                              {categories.map(category =&gt; (
                                  &lt;option
                                      key={category.id}
                                      value={category.id}
                                  &gt;{category.name}&lt;/option&gt;
                              ))}
                          &lt;/select&gt;
                      &lt;/div&gt;
              
                      &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                          &lt;label htmlFor=&quot;name&quot; className=&quot;font-bold&quot;&gt;Actividad:&lt;/label&gt;
                          &lt;input 
                              id=&quot;name&quot;
                              type=&quot;text&quot; 
                              className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                              placeholder=&quot;Por ej: Comida, zumo de naranja, ensalada, Ejercicio, Pesas, Bicicleta&quot;
                              value={activity.name}  
                              onChange={handleChange}              
                          /&gt;
                      &lt;/div&gt;
              
                      &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                          &lt;label htmlFor=&quot;calories&quot; className=&quot;font-bold&quot;&gt;Calorías:&lt;/label&gt;
                          &lt;input 
                              id=&quot;calories&quot;
                              type=&quot;number&quot; 
                              className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                              placeholder=&quot;Calorías Por ej: 300, 500&quot;
                              value={activity.calories}
                              onChange={handleChange}
                              /&gt;
                      &lt;/div&gt;
              
                      &lt;input 
                          type=&quot;submit&quot; 
                          className=&quot;bg-gray-800 hover:bg-gray-900 w-full p-2 font-bold uppercase text-white cursor-pointer&quot;
                          value=&quot;Guardar Comida o guardar Ejercicio&quot;
                      /&gt;
                  &lt;/form&gt;  
                )
              }    
            </code></pre>           
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-139').toggle();">
            <h3>139. Validando el Formulario</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-139" class="hidden">
            <p>Veamos como deshabilitar visualmente este formulario, este input de tipo submit</p>              
            <p>Creamos un arrow function, vamos debugeando lo siguiente con console.log y para ello la llamamos en el disabled del button submit:</p>
            <ul>
              <li><strong>name.trim() != ''</strong> el name(de actividad) al recortar espacio de inicio y fin es distinto de 0 <strong>true cuando está relleno</strong></li>
              <li>calories > 0 true cuando calorías es mayor que 0</li> 
              <li>Queremos que el botón esté deshabilitado si esta condición no se cumple, por tanto: <code class="language-js">disabled={!isValidActivity()}</code></li>
            </ul>
            <pre data-line="10"><code class="language-js">
              //Form.tsx
              const isValidActivity = () =>{
                const { name, calories } = activity
                return name.trim() != '' && calories > 0 // devuelve true cuando ambas se cumplen
              }
              ...
              &lt;input 
                  type=&quot;submit&quot; 
                  className=&quot;bg-gray-800 hover:bg-gray-900 w-full p-2 font-bold uppercase text-white cursor-pointer&quot;
                  value=&quot;Guardar Comida o guardar Ejercicio&quot;
                  disabled={!isValidActivity()}
              /&gt;
            </code></pre>

            <p>Con ello aseguramos tener deshabilitado el botón, no pasando esa validación hasta qeu no complete los dos campos qyue he especificado en mi función de validación 'isValidActivity' (si rellenáramos con espacios el campo name de actividad no vale por la comprobación que hace el trim()</p>
            <pre><code class="language-js">
              const str = "   foo  ";
              console.log(str.trim()); // 'foo'
            </code></pre>
            
            <p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim" class="underline" target="_blank">mdn web docs js referency</a> <span class="border-1 border-b-black bg-[#e6f4ea] px-1.5 py-0.5 italic leading-[24px]">El método trim() de valores tipo string elimina los espacios en blanco de ambos extremos de la cadena y devuelve una nueva cadena, sin modificar la cadena original. Para devolver una nueva cadena con espacios recortados solo en un extremo, usamos trimStart() o trimEnd()</span></p>
            
          </div>

           
<!-- Bloque desplegable interior-->
<div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-XX').toggle();">
  <h3>XXXXXXXXXXXXXXX</h3>
  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
</div>
<div id="seccion10-XX" class="hidden">
                
</div>
  
<!-- Bloque desplegable interior-->
<div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-XX').toggle();">
  <h3>XXXXXXXXXXXXXXX</h3>
  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
</div>
<div id="seccion10-XX" class="hidden">
                
</div>
  
<!-- Bloque desplegable interior-->
<div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-XX').toggle();">
  <h3>XXXXXXXXXXXXXXX</h3>
  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
</div>
<div id="seccion10-XX" class="hidden">
                
</div>
  
           
            
        </div>
        <!-- Fin div colapsable-->

        
      </div>
      <!-- FIN SECCION 10 -->
      
      <!-- SECCION 9-->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
      
        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer"
          onclick="$('#seccion9').toggle();">
          <h2>Sección 9: PROYECTO - Calculadora de propinas con TypeScript</h2>
          <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
        </div>
      
        <div id="seccion9" class="hidden">
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-104105').toggle();">
            <h3>104. El Proyecto que vamos a construir / 105. Creando el proyecto</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-104105" class="hidden">
      
            <div class="block md:flex">
              <img class="w-50 w-100-m mr-1.25" src="https://andune55.github.io/manual-react/assets/s1-02-BEtrmdfx.jpg" alt="Calculadora de proyectos">
              <div class="w-50 w-100-m">
                <p>Esta calculadora de propinas y consumos es un proyecto 100% TS, con nuestra carpeta de Data, algunos
                  Helpers, Hook personalizado, archivo de Types. Todos los proyectos de ahora en adelante.</p>
                <p>Vemos un botón de Guardar orden, para que el restaruante tenga un control de las ventas diarias (como aún
                  no hemos visto APIS simularemos que lo almacena en algún sitio.</p>
                <p>Este proyecto va a ser 100% TypeScript desde el inicio (no vamos a escribir js y después convertirlo sino
                  directamente ts), estaremos practicando mucho sobre el state, custom hook y demás.</p>
              </div>
            </div>
      
            <p class="mt-1.25 mb-0"><span class="naranja">Creamos proyecto nuevo:</span></p>
            <ul>
              <li>Tengo todos mis proyectos de React dentro de <strong>Curso React</strong> así que me ubico ahí y para
                crearlo</li>
              <li><span class="destacado">npm create vite@latest</span> crea el proyecto con la última versión de vite</li>
              <li>Lo nombro <strong>calculadora_propinas</strong></li>
              <li>Elijo framework <span class="destacado">React</span></li>
              <li>Elijo variante <span class="destacado">TypeScript + SWC</span> (puede que a futuro ya no salga "SWC" porque
                es el compilador que van a usar)</li>
              <li>Nos ubicamos en el nuevo directorio creado <strong>calculadora_propinas</strong> e instalamos las
                dependencias del proyecto con <span class="destacado">npm install</span></li>
              <li>Abrimos nuestro proyecto en Visual Studio Code (con botón derecho agrego la nueva carpeta en el área de
                trabajo)</li>
              <li>Arrancamos el servidor de desarrollo con <span class="destacado">npm run dev</span> --&gt; <a
                  href="http://localhost:5174/" target="blank">http://localhost:5174/</a> (<a href="http://localhost:5173/"
                  target="blank">http://localhost:5173/</a> la suelo usar para el manual)</li>
            </ul>
            <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/105-C58O_uYT.png" alt="" />
      
            <p><span class="destacado">Hagamos limpieza de algunos archivos</span>:</p>
            <ul>
              <li>Eliminamos el .svg: public&gt;<strong>vite.svg</strong></li>
              <li>Eliminamos la carpeta entera assets: src&gt;<strong>assets</strong></li>
              <li>Eliminamos la css: src&gt;<strong>App.css</strong></li>
              <li>Limpiamos src&gt;<strong>App.tsx</strong> dejandolo así:
                <script type="text/plain" class="language-js">
                          function App() {
      
                            return (
                              <>
                                <h1>Hola mundo</h1>
                              </>
                            )
                          }
                          
                          export default App
                        </script>
              </li>
              <li>Eliminamos todo el contenido de la css src&gt;<strong>index.css</strong></li>
              <li>Dejamos como está el src&gt;<strong>main.tsx</strong>. Importante la llamada que aquí se hace a nuestra css
                <strong>index.css</strong> porque <span class="destacado">vamos a instalar el framework TailwindCSS</span>
                <pre data-line="2"><code class="language-js">
                          import &lcub; StrictMode &rcub; from &apos;react&apos;
                          import &lcub; createRoot &rcub; from &apos;react-dom/client&apos;
                          import &apos;./index.css&apos;
                          import App from &apos;./App.tsx&apos;
                          
                          createRoot(document.getElementById(&apos;root&apos;)!).render(
                            &lt;StrictMode&gt;
                              &lt;App /&gt;
                            &lt;/StrictMode&gt;&comma;
                          )
                        </code></pre>
              </li>
            </ul>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-106107').toggle();">
            <h3>106. Introducción a TailwindCSS / 107. Instalando TailwindCSS y extensión para VSCode</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-106107" class="hidden">
            <p>Es un framework de CSS pero está basado en utilidades</p>
            <ul>
              <li><strong>Tailwind CSS es lo que se conoce como un framework de CSS, pero está basado en utilidades</strong>
              </li>
              <li><strong>A diferencia de Bootstrap, que es otro framework de CSS donde una clase contiene diferentes
                  propiedades de CSS</strong> (Por ejemplo, para crear un botón utilizas una clase llamada btn y si quieres
                cambiar el color utilizas btn danger; Esos van a tener muchas propiedades de CSS, solo da la apariencia de
                botón.) <strong>En el caso de Tailwind, cada clase es una propiedad de CSS que tiene un nombre
                  similar</strong>. <span class="destacado">Bootstrap descargas una css de 10000 líneas y usas las css vs
                  Tailwind modo JIT (Just In Time) solo las clases que utilices en tus js, tsx, ts, js se van a utilizar para
                  generar la css final, lo cual nos va a dar una css lo más ligera posible.</span></li>
              <li>Su ventaja principal es que escribes el código CSS en tus componentes sin hojas externas. ¿Que se deja de
                utilizar el componente? se elimina tambi´ne su código de css (a diferencia de lo que pasa en las hojas de
                estilos generales con miles de líneas y mal mantenidas).</li>
              <li>Otra ventaja es que tampoco es necesario por la herencia en CSS (especificidades, !important infinitos,
                pisado de código de otras partes del proyecto)</li>
              <li>Nos olvidamos del problema de cómo nombrar nuestras clases.</li>
              <li>La documentación es excelente: hay bastantes ejemplos muy gráficos muy visuales que van a permitirte saber
                qué clase es la que puedes utilizar.</li>
              <li>La extensión de Visual Studio Code también es excelente. El autocompletado es muy bueno y también te dice
                qué valor o cuánto se está aplicando en ciertas propiedades de CSS enfocadas a tamaño, por ejemplo el font
                size, etcétera.</li>
            </ul>
      
            <p class="mt-1.25 mb-0"><span class="naranja">Instalando TailwindCSS y extensión para VSCode: </span>
              Vamos al link de <strong><a href="https://tailwindcss.com/" target="blank"
                  class="text-[#000000]">https://tailwindcss.com/</a> > docs > installation > Framework guides:</strong>
              contiene guías específicas de framework para instalar TailwindCSS en un gran número distinto de entornos Vite /
              Next.js / Angular / Ruby on Rails / Parcel / Symfony / Astro / ... nosotros elegimos Vite. A partir de aquí los
              pasos varían con respecto a lo que indica en el vídeo porque la versión es más nueva, ver <a
                class="text-[#000000]" href="https://tailwindcss.com/docs/installation/using-vite"
                target="_blank">https://tailwindcss.com/docs/installation/using-vite</a>:
            </p>
      
            <ul>
              <li>Creación del proyecto y ubicarse en la carpeta ya lo hicimos</li>
              <li>Instalamos Tailwind CSS: instalamos las dependencias 'tailwindcss' y '@tailwindcss/vite' via npm:
                <pre><code class="language-js">
                          npm install tailwindcss @tailwindcss/vite
                        </code></pre>
              </li>
              <li><strong>Configurar el plugin de vite:</strong> añadimos el plugin '@tailwindcss/vite' a nuestra
                configuración de vite en <span class="file">vite.config.ts</span>
                <pre data-line="1,8"><code class="language-js">
                      import { defineConfig } from 'vite'
                      import tailwindcss from '@tailwindcss/vite'
                      import react from '@vitejs/plugin-react-swc'
                      
                      // https://vite.dev/config/
                      export default defineConfig({
                        plugins: [
                          react(),
                          tailwindcss()
                        ],
                      })
                    </code></pre>
              </li>
              <li><strong>Importar Tailwind CSS en nuestra css:</strong> <span class="file">src&gt;index.css</span> <code
                  class="language-css">@import "tailwindcss";</code></li>
              <li><strong>Comenzar a utilizar las utility classes de Tailwind CSS para dar estilo a nuestro contenido</strong>
                <script type="text/plain" class="language-html">
                      <h1 className="text-3xl font-bold underline">
                        Hello world!
                      </h1>
                    </script>
              </li>
            </ul>
      
            <p><span class="destacado">Instalamos la extensión Tailwind CSS IntelliSense en el Visual Studio Code</span>.</p>
            <p><strong>Le veo de momento un par de inconvenientes: no cubren todas las casuísticas de tamaños (por cuenta
                ajena si el diseño viene marcado desde agencia o Dpto con tamaños no contemplados en este FW estamos haciendo
                un pan con unas tortas. Además ¡OJO! hay nombres de clases que PARA NADA son descriptivos de lo que hacen como
                por ejemplo font-black que lo que hace es actuar sobre un font-weight!!!)</strong></p>
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-112').toggle();">
            <h3>108. Creando el Header / 109. Agregando los Productos / 110. Agregando los contenedores principales / 111.
              Extensiones par React / 112. Listano los productos del menú</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-112" class="hidden">
            <p class="mt-1.25 mb-0"><span class="naranja">Creamos el Header</span></p>
            <p>En el return de nuestro <span class="file">App.tsx</span> agregamos el header pero simplemente como tag html5
              semántico y practicamos algo de Tailwind CSS.</p>
            <script type="text/plain" class="language-html">
                    <header className="bg-teal-400 py-5">
                      <h1 className="text-center text-4l font-black">Calculadora de propinas y consumo</h1>
                    </header>
                  </script>
      
            <p class="mt-1.25 mb-0"><span class="naranja">Agregando los productos</span> - <a class="text-[#000000]"
                href="https://gist.github.com/codigoconjuan/7ff5b34a0a0773f8c48fd13b51a508aa" target="blank">Gist de
                Productos</a></p>
            <p>Aún no hemos visto como consumir una API, consultar una BBDD, todo eso lo veremos más adelante. Así que de
              momento vamos a trabajar como el proyecto anterior, <strong>con un archivo plano que tiene un arreglo de
                productos</strong>. Vamos a consumirlo y mostrarlo.</p>
      
            <p>Vamos a crear 2 archivos .ts (no .tsx que tienen código html y/o eventos de React:</p>
            <ul>
              <li>Creamos <strong>src&gt;db&gt;<span class="file">db.ts</span></strong>: metemos en su interior lo que
                copiamos en formato raw del <a class="text-[#000000]"
                  href="https://gist.github.com/codigoconjuan/7ff5b34a0a0773f8c48fd13b51a508aa" target="blank">Gist de
                  Productos</a>. Con el IS vemos que TS infiere cual es el tipo de dato de cada propiedad así que tenemos un
                array de objetos y eso está bien, pero <strong>está aún mejor crear un type personalizado "MenuItem" y
                  asignárselo para tener un mejor autocompletado y para que, en caso de que alguna de mis propiedades no
                  cumpla con lo tipado, nos lo marque como error</strong>.
                <pre data-line="0,2"><code class="language-js">
                      import type { MenuItem } from "../types" 
      
                      export const menuItems : MenuItem[] = [
                          {
                            "id": 1,
                            "name": "Pizza a la Leña Chica",
                            "price": 30
                          },                     
                    </code></pre>
              </li>
              <li>Creamos <strong>src&gt;types&gt;<span class="file">index.ts</span> en donde creamos este primer type
                  MenuItem</strong>
                <pre><code class="language-js">
                  //src>types>index.ts
                      export type MenuItem = {
                        id: number,
                        name: string,
                        price: number
                    }
                    </code></pre>
              </li>
              <li>En nuestra <span class="file">App.tsx</span> vamos a importar los datos y si hacemos un console.log ya vemos
                que tenemos disponibles esos datos.
                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre><code class="language-js">
                      //App.tsx
                        import { menuItems } from "./data/db"
      
                        function App() {
      
                        console.log(menuItems)
      
                        return (
                        </code></pre>
                  </div>
                  <div class="w-[50%] max-sm:w-[100%]">
                    <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/109-3hblSBV7.png" alt="" />
                  </div>
                </div>
              </li>
            </ul>
      
            <p class="mt-1.25 mb-0"><span class="naranja">Agregando los contenedores principales:</span> acabamos de crear
              nuestro primer type (MenuItem) y se lo hemos agregado a nuestros datos. Vamos a ver como mostrar la información
              en pantalla, como renderizar lo que ahora mismo vemos en consola <code
                class="language-js">console.log(menuItems)</code>para que se vea en nuestra interfaz.</p>
      
            <p>En el return de nuestro <span class="file">App.tsx</span> agregamos el main pero simplemente como tag html5
              semántico y seguimos practicando algo de Tailwind CSS <span class="destacado">revisar/empollar uso de Tailwind:
                <a class="text-[#ffffff]" href="https://certidevs.com/tutorial-tailwindcss-introduccion"
                  target="_blank">Tutorial certidevs</a></span> por ejemplo Mediaquerys en Tailwind: las clases como
              <strong>sm:, md:, lg:, xl:, y 2xl:</strong> permiten aplicar estilos específicos basados en el tamaño de la
              pantalla. ¿Como funciona? queremos 2 columnas a partir del tamaño md: ponemos <strong>md:grid-cols-2</strong>
            </p>
            <pre><code class="language-html">
                      &lt;main className=&quot;max-w-7xl mx-auto py-20 grid grid-cols-2&quot;&gt;
                        &lt;div&gt;
                          &lt;h2&gt;Menú&lt;/h2&gt;
                        
                        &lt;/div&gt;
                
                        &lt;div&gt;
                          &lt;h2&gt;Consumo&lt;/h2&gt;
                        
                        &lt;/div&gt;
                      &lt;/main&gt;
                    </code></pre>
      
            <p>Ya con nuestro div para el menú vamos a renderizar lo que ahora vemos en la consola <code
                class="language-js">console.log(menuItems)</code> que es como una pequeña base de datos</p>
      
            <ul>
              <li>Creamos <strong>components&gt;MenuItem.tsx</strong></li>
              <li>Antes de empezar a picar recomienda instalar estas dos <span class="naranja">extensiones para React en
                  VSCode: </span> <strong>ES7+ React/Redux/React-Native snippets</strong> y <strong>Simple React
                  Snippets</strong>. Con esto por ejemplo si escribimos en <span class="file">MenuItem.jsx</span>
                <strong>rfc</strong> vemos que nos autocompleta la estructura básica de nuestro componente, tanto con el
                export default como con el return: (con <strong>rafc</strong> la crearía como arrow function). El import react
                no es necesario así que lo eliminamos
                <pre class="error" data-line="0"><code class="language-js">
                      import React from 'react'
      
                      export default function MenuItem() {
                        return (
                          <div>MenuItem</div>
                        )
                      }
                    </code></pre>
              </li>
              <li> En nuestro <span class="file">App.tsx</span> renderizamos nuestro nuevo componente MenuItems una vez por
                cada elemento que tengamos en nuestro array que simula la base de datos:
                <pre><code class="language-js">
                      {menuItems.map(item =&gt; (
      
                        &lt;MenuItem 
                          key = {item.id} //siempre que iteramos, recordar añadir key único
                        /&gt;            
                      ))}
                    </code></pre>
                <p>En este punto si miramos la renderización nos aparece "menuItem" 12 veces (porque es lo que ahora mismo nos
                  renderiza el return del componente: &lt;div&gt;MenuItem&lt;/div&gt;</p>
              </li>
            </ul>
      
            <p class="mt-1.25 mb-0"><span class="naranja">Listando los productos del menú:</span> Veamos como pasarle los
              props y escribir el type para este componente, hacerlo dinámico para que imprima la información de nuestra
              pequeña BBDD.</p>
            <p>En el tag de llamada al componente del return de nuestro <span class="file">App.tsx</span> creamos un prop
              llamado item y le pasamos el objeto de item <code class="language-js">item={item}</code>. Nos da error porque el
              componente de momento no espera ninguna propiedad. Si, en nuestro <span class="file">MenuItem.tsx</span>
              aplicamos destructuring para que reciba ese item: <code
                class="language-ts">export default function MenuItem({item}) {</code> vamos a ver que es de tipo Any
              implícito, (mientras que ese item que pasamos como prop en App.tsx sí es de tipo item)<strong>, <span
                  class="destacado">osea se pierde la referencia entre nuestros componentes App.tsx y MenuItem.tsx</strong> y
              nosotros tenemos que especificarle qué tipo de dato va a ser</span>. Para ello vamos a crear en el <span
                class="file">MenuItem.tsx</span> un type nuevo <strong>MenuItemProps</strong>(que solo va a usarse en este
              compo por lo que no tenemos que crearlo en archivo común de types):</p>
      
            <pre><code class="language-js">
                    import type { MenuItem } from &quot;../types&quot;
      
                    export type MenuItemProps = {
                        item: MenuItem
                    }
                    
                    export default function MenuItem({item}: MenuItemProps) {
                      return (
                        &lt;&gt;
                            &lt;p&gt;{item.name}&lt;/p&gt;
                            &lt;p className=&quot;font-black&quot;&gt;{item.price}&lt;/p&gt;
                        &lt;/&gt;
                      )
                    }
                  </code></pre>
      
            <p>La idea es que al ir presionando en cada elemento se vaya colocando a la derecha. Para ello tenemos que
              agregarles un evento y por buenas prácticas no debemos hacerlo en el p así que convertimos el fragment
              &lt;&gt;&lt;/&gt; en un botón &lt;button&gt;&lt;/button&gt; que es donde vamos a tener un evento que veremos
              como registrarlo. Seguimos practicando algo de Tailwind CSS dándole estilos a nuestros contenedores <span
                class="destacado">revisar/empollar uso de Tailwind</span> Quedan de la siguiente manera: </p>
      
            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">                
                <pre><code class="language-js">
                  //App.tsx
                  import MenuItem from &quot;./components/MenuItem&quot;
                  import { menuItems } from &quot;./data/db&quot;
                  
                  function App() {
                  
                    return (
                      &lt;&gt;
                        
                        &lt;header className=&quot;bg-teal-400 py-5&quot;&gt;
                          &lt;h1 className=&quot;text-center text-4l font-black&quot;&gt;Calculadora de propinas y consumo&lt;/h1&gt;
                        &lt;/header&gt;
                  
                        &lt;main className=&quot;max-w-7xl mx-auto py-20 grid grid-cols-2&quot;&gt;
                          &lt;div className=&quot;p-5&quot;&gt;
                            &lt;h2 className=&quot;text-4xl font-black&quot;&gt;Menú&lt;/h2&gt;
                  
                            &lt;div className=&quot;space-y-2 mt-10&quot;&gt;
                              {menuItems.map(item =&gt; (
                                &lt;MenuItem
                                  key = {item.id} //siempre que iteramos, recordar añadir key único
                                  item = {item}
                                /&gt;
                              ))}
                            &lt;/div&gt;
                          
                          &lt;/div&gt;
                  
                          &lt;div&gt;
                            &lt;h2&gt;Consumo&lt;/h2&gt;
                          
                          &lt;/div&gt;
                        &lt;/main&gt;
                        
                      &lt;/&gt;
                    )
                  }
                  
                  export default App
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  //MenuItem.tsx
                  import type { MenuItem } from &quot;../types&quot;

                  export type MenuItemProps = {
                      item: MenuItem
                  }
                  
                  export default function MenuItem({item}: MenuItemProps) {
                    return (
                      &lt;button className=&quot;border-2 border-teal-400 hover:bg-teal-200 w-full p-3 flex justify-between&quot;&gt;
                          &lt;p&gt;{item.name}&lt;/p&gt;
                          &lt;p className=&quot;font-black&quot;&gt;{item.price}&lt;/p&gt;
                      &lt;/button&gt;
                    )
                  }                       
                </code></pre>
              </div>      
            </div>
      
            <p>A continuación vamos a crear un custom Hook para ir almacenando nuestra orden.</p>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-113').toggle();">
            <h3>113. Creando un Hook para la orden <span class="destacado">Generics en TS</span></h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-113" class="hidden">
            <p>Creamos nuestro <span class="file">useOrder.ts</span> <strong>hooks&gt;useOrder.ts</strong>
            <pre><code class="language-js">
                    export default function useOrder() {
      
                      return{
                          
                      }
                    }     
                  </code></pre>
            </p>
            <p>Definimos un state en el que vamos colocando los elementos que forman parte de nuestra orden. Iniciamos como un
              arreglo vacío. Si vemos, así lo hicimos en el anterior proyecto de las guitarras pero con el IS vemos que nos da
              que order es de tipo Never por lo que lo ideal es aplicarle un tipo de dato en específico.</p>
            <pre><code class="language-js">
                    import { useState } from "react"
      
                    export default function useOrder() {
                      const [order, setOrder] = useState([])
      
                      return{
                        
                      }
                    }
                  </code></pre>
            <p>En nuestro fichero de types vamos a crear un tipe nuevo <span class="type">OrderItem</span> para la orden y va
              a requerir lo mismo que el tipo <span class="type">MenuItem</span> pero además tiene que tener cantidad por lo
              que lo declaramos así <span class="file">types&gt;index.ts</span>:</p>
            <pre data-line="5-7"><code class="language-js">
                    export type MenuItem = {
                      id: number,
                      name: string,
                      price: number
                    }
                    export type OrderItem = MenuItem & {
                      quantity: number
                    }
                  </code></pre>
      
            <p>Lo importamos en nuestro hook <span class="file">useOrder.ts</span> <code
                class="language-ts">import { OrderItem } from "../types"</code>. ¿Cómo hacemos para asignar a ese state
              'order' nuestro type OrderITem y que tenga esos atributos definidos incluyendo quantity? <span
                class="destacado">Generics en TypeScript: es una característica que nos va a permitir escribir código más
                flexible y reutilizable</span>. Veamos estos 3 states para ver que, en los casos en que nuestros tipos son un
              poco más complejos (y no solo tenemos un valor inicial de state sencillo como puede ser un
              number/string/boolean..) viene bien especificarle con el generic nuestro type. Así todo lo que agreguemos a ese
              state order, React va a revisar que tenga la estructura del tipo definido. En el caso de los que tienen un valor
              inicial más sencillo que TS puede inferir bien, no es necesario el generic:</p>
            <pre><code class="language-js">
                    const [order, setOrder] = useState&lt;OrderItem[]&gt;([]) //Nuestro tipo (OrderItem) es más complejo y queremos especificarle que sea ese, sí requiere generic
                    const [total, setTotal] = useState&lt;number&gt;(0) //No sería necesario el generic es redundante porque con el valor inicial se infiere bien
                    const [auth, setAuth] = useState&lt;boolean&gt;(false) //No sería necesario el generic es redundante porque con el valor inicial se infiere bien
                  </code></pre>
      
            <p>Los generics por tanto son muy útiles cuando tenemos estructuras propias o más complejas porque TS no sabe qué
              queremos hacer y de esta manera le decimos "sí, esto va a ser un arreglo/objeto pero tiene que tener estas
              propiedades</p>
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-114').toggle();">
            <h3>114. Creando la función para Añadir articulos a la orden</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-114" class="hidden">
            <p>Creamos en nuestro hook un arrow function nueva para agregar items y la exportamos en el return. </p>
            <pre><code class="language-js">
                    export default function useOrder() {
                      const [order, setOrder] = useState<OrderItem[]>([])
                  
                      const addItem = () => {
                          console.log('Añadiendo item')
                      }
                  
                          return{
                              addItem
                          }
                  }
                  </code></pre>
      
            <p>La importamos en nuestra <span class="file">App.tsx</span>, vamos a ver como tener un estado global. Vemos a
              continuación como usando destructuring extraigo de nuestro custom hook useOrder la nueva función addItem, que a
              su vez hemos de pasar como prop a nuestro componente MenuItem.jsx (porque cada vez que presione uno de esos
              menús es una función con valores diferentes).</p>
            <pre><code class="language-js">
                    import useOrder from "./hooks/useOrder"
      
                    function App() {
                    
                        const { addItem } = useOrder() 
                  </code></pre>
            <p>Si nos colocamos en el destructuring encima de ese addItem vemos con el IS que es un arrow function () => void.
              Usamos esa información para <strong>completar el type exclusivo que definimos en nuestro componente <span
                  class="file">MenuItem.tsx</span></strong> y añadimos el segundo parámetro en la declaración de nuestra
              función de componente y el onClick con la llamada a la función, como callback porque tengo que pasarle qué es lo
              que quiero agregar.</p>
            <pre data-line="2,5,9"><code class="language-js">
                    type MenuItemProps = {
                      item: MenuItem,
                      addItem: () => void // muy común cuando pasamos una fcn vía props. VOid significa que no retorna nada. A veces sí tomará parámetro y a veces retornaraá un valor
                  }
                  
                  export default function MenuItem({item, addItem}: MenuItemProps) {
                    return (
                      &lt;button 
                        className=&quot;border-2 border-teal-400 hover:bg-teal-200 w-full p-3 flex justify-between&quot;
                        onClick = {() =&gt; addItem()}
                        &gt;
                  </code></pre>
      
            <p>En <span class="file">App.tsx</span> tenemos que pasarle esa función a nuestro componente vía props</p>
            <pre data-line="5"><code class="language-js">
                    &lt;div className=&quot;space-y-2 mt-10&quot;&gt;
                      {menuItems.map(item =&gt; (
                        &lt;MenuItem
                          key = {item.id} //siempre que iteramos, recordar añadir key único
                          item = {item}
                          addItem = {addItem}
                        /&gt;
                      ))}
                    &lt;/div&gt;
                  </code></pre>
      
            <p>Una vez que presionemos en ese botón queremos añadir ese elemento con el nombre, con el id y con el precio.</p>
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-115').toggle();">
            <h3>115. Agregando el signature a la función de agregar articulo con TypeScript</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-115" class="hidden">
            <p>Vamos a ver como escribir en el state de useOrder, ahora mismo solo estamos sacando un mensaje en consola al
              pulsar. Tenemos que pasarle un argumento desde la llamada del onClick en el componente hasta nuestro custom
              hook. Para ello en nuestro hook tenemos que decirle que la función addItem va a tomar un elemento, le ponemos
              como parámetro 'item' y vemos que se nos pone en color rojo, si vamos a la App.tsx vemos que también en rojo nos
              indica el IS "bueno tú le estás pasando un item que actualmente tiene el tipo de dato Any y tu firma, lo que tú
              has colocado, es una función que no toma nada y que no retorna nada (la firma nos dice que tiene muy pocos
              argumentos)": </p>
      
            <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/115-Cn1-Ht8i.png" alt="">
      
            <p>Vamos a nuestro componente <span class="file">MenuItem.tsx</span> y en el type <span
                class="type">MenuItemProps</span> también le añadimos el parámetro item al definir el tipo de la función, se
              pone inmediatamente en rojo y el IS nos indica que es un any y hemos de corregirlo, además en el arrow function
              del onclick nos marca en rojo también la llamada a la función porque, habiendo especificado que le pasamos algo
              como argumento aún no lo hemos indicado:</p>
      
            <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/115-2-DPelHrNF.png" alt="">
      
            <p><span class="destacado">Vayamos siguiendo los errores para corregirlos:</span> indicamos en nuestro type <span
                class="type">MenuItemProps</span> que el parámetro item que pasamos como argumento es de tipo <span
                class="type">MenuItem</span> y en la arrow function del onClick le especificamos el parámetro item.</p>
      
            <pre data-line="4,11"><code class="language-js">
                    import type { MenuItem } from &quot;../types&quot;
      
                    type MenuItemProps = {
                        item: MenuItem,
                        addItem: (item: MenuItem) =&gt; void
                    }
                    
                    export default function MenuItem({item, addItem}: MenuItemProps) {
                      return (
                        &lt;button 
                          className=&quot;border-2 border-teal-400 hover:bg-teal-200 w-full p-3 flex justify-between&quot;
                          onClick = {() =&gt; addItem(item)}
                          &gt;
                            &lt;p&gt;{item.name}&lt;/p&gt;
                            &lt;p className=&quot;font-black&quot;&gt;{item.price}&lt;/p&gt;
                        &lt;/button&gt;
                      )
                    }
                  </code></pre>
      
            <p><span class="destacado">Hemos de irle diciendo siempre <span class="type">qué tipo de dato vamos a tener
                  tanto</span> en nuestras funciones como en los parámetros que le vamos pasando</span>. En <span
                class="file">useOrder.ts</span> nos queda por corregir especificar el tipo de dato de item (<strong>Vemos que
                al declararlo como type <span class="type">MenuItem</span> al no estar importado en el fichero, el IS nos da
                la opción de corregirlo y automáticamente aparece en las importaciones de arriba</strong>). Ya en el console
              logo podemos indicarle {item}</p>
      
            <pre data-line="1,6"><code class="language-js">
                    import { useState } from &quot;react&quot;
                    import { MenuItem, OrderItem } from &quot;../types&quot;
                    
                    export default function useOrder() {
                        const [order, setOrder] = useState&lt;OrderItem[]&gt;([])
                    
                        const addItem = (item: MenuItem) =&gt; {
                            console.log({item})
                        }
                    
                            return{
                              addItem
                            }
                    }
                  </code></pre>
      
            <p><span class="destacado">Importante:</span> nuestra función del custom hook <span
                class="file">useOrder.ts</span> <code class="language-js">export default function useOrder() {</code>: </p>
            <pre><code class="language-js">
                    const addItem = (item: MenuItem) => {
                      console.log({item})
                    } 
                  </code></pre>
            <p>toma un item de tipo MenuItem, sin embargo cuando desde nuestra <span class="file">App.tsx</span> pasa como
              prop al componente <span class="file">MenuItem.tsx</span> se pierde esa referencia y nosotros tenemos que,
              digamos, recuperar o reasignar esa referencia para que TS sepa que tiene que hacer y sobre todo qué atributos de
              ese type es a los uqe va a tener acceso. Si probamos la App veremos que cada vez que presionamos un producto nos
              aparece en consola el item correspondiente con lo que la comunicación es correcta. A continuación vamos a
              empezar a escribir en nuestro state de nuestro hook de useOrder().</p>
      
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-116').toggle();">
            <h3>116. Añadiendo elementos al state de Orden</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-116" class="hidden">
            <p>Vamos a escribir en nuestro state de órdenes pero recordemos que <span class="file">useOrder.ts</span> este
              estate order <code class="language-js">const [order, setOrder] = useState&lt;OrderItem[]&gt;([])</code> lo
              definimos con un <strong>generic</strong> como un array de tipo <span class="type">OrderItem</span>, y ese tipo
              tenía una cantidad 'quantity'.</p>
      
            <pre><code class="language-js">
                    export type OrderItem = MenuItem & {
                      quantity: number
                  }
                  </code></pre>
      
            <p>Entonces lo que tenemos que hacer es castear o cambiar el valor pero tenemos que agregarle una cantidad así que
              veamos como hacerlo.</p>
      
            <p>Quitamos el console.log y llamamos a la función del state para, como es un arreglo, tomar una copia de lo
              previo y le pasamos el item, pero podemos ver que en seguida nos saca error. ¿por qué?</p>
      
            <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/116-CPXUa8tn.png" alt="">
      
            <p>Estamos intentando pasar como argumento un 'item' que es de tipo <span class="type">MenuItem</span> que tiene
              estos atributos:</p>
      
            <pre><code class="language-js">
                    export type MenuItem = {
                      id: number,
                      name: string,
                      price: number
                    }
                  </code></pre>
      
            <p>mientras que nuestro state de order es de tipo <span class="type">OrderItem</span> que, recordemos tiene los
              atributos de <span class="type">MenuItem</span> más la cantidad 'quantity'</p>
      
            <pre><code class="language-js">
                    export type MenuItem = {
                      id: number,
                      name: string,
                      price: number
                  }
                  export type OrderItem = MenuItem & {
                    quantity: number
                  }
                </code></pre>
      
            <p>Lo resolvemos creando una variable nueva <strong>newItem</strong> que va a ser un objeto y en el que incluyo
              una copia del item que paso + quantity inicializada a 1 para la primera vez que añado una orden (más adelante
              iremos ajustando esta cantidad según casuística). Le pasamos ese newItem a la función del state y ya no tenemos
              errores. Si nos ponemos encima de esta nueva variable vemos con el IS que tiene los atributos de <span
                class="type">OrderItem</span> más no es como tal un OrderItem, podríamos castearlo especificando el tipo:
              <code class="language-js">const newItem: OrderItem = {...item, quantity: 1}</code> aunque no es necesario y él
              no lo hace porque en la declaración de nuestro state ya especificamos con el generic que las órdenes van a tener
              ese tipo de dato.</p>
      
            <pre><code class="language-js">
                  import { useState } from &quot;react&quot;
                    import { MenuItem, OrderItem } from &quot;../types&quot;
                    
                    export default function useOrder() {
                      const [order, setOrder] = useState&lt;OrderItem[]&gt;([])
                      
                      const addItem = (item: MenuItem) =&gt; {
                        //console.log({item})
                        const newItem = {...item, quantity: 1}
                        setOrder([...order, newItem])
                      }
                      console.log(order)
                      
                      return{
                        addItem
                      }
                    }
                  </code></pre>
      
            <p>Añadimos un console.log de order para ver que si repetimos en alguna orden se añade varias veces.</p>
            <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/116-2-MhLHbLsT.png" alt="">
            <p>Lo ideal es que no se repita sino controlar eso con la cantidad. Por la inmutabilidad de React es un poco más
              complicado así que vemos como hacerlo a continuación</p>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-117').toggle();">
            <h3>117. Evitando duplicados</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-117" class="hidden">
            <p>Vamos a revisar si una orden existe en el arreglo:</p>
            <ul>
              <li><strong>¿No existe?:</strong> este código está bien:
                <pre><code class="language-js">
                        const newItem: OrderItem = {...item, quantity: 1}
                        setOrder([...order, newItem])
                      </code></pre>
              </li>
              <li><strong>¿Existe?:</strong> hemos de revisar cantidad</li>
            </ul>
      
            <p>Usamos el array method <strong>.find()</strong> para encontrar un elemento de un array en base a una condición
              y empleamos dentro del find un arrow function <strong>(recordar que el parámetro aquí usado (una variable
                temporal en la ejecución de este find) lo llamamos COMO QUERAMOS en este ejemplo 'orderItem' y hace referencia
                a cada uno de los objetos que AHORA MISMO HAY en nuestro state array order)</strong>. <span
                class="destacado">Ojo al escribir el código de la comprobación, cómo funciona el autocompletado de VSC para
                cada uno de los 2 objetos implicados (el que hace referencia a cada uno de los elementos del state order
                actual 'orderItem' y el que hace referencia al item que la pasamos al clickar).</span> Así es como queda
              nuestro código de momento con un console.log que nos avise si pulsamos en una orden que ya existe:</p>
      
            <pre><code class="language-js">
                    const addItem = (item: MenuItem) => {
                        
                      const itemExist = order.find(orderItem => orderItem.id === item.id) // buscamos en el state order el elemento cuyo id sea igual al id del item que estamos pasando
                      if (itemExist) {
                        console.log('El item ya existe') 
                      } else {
                          const newItem: OrderItem = {...item, quantity: 1}
                          setOrder([...order, newItem])
                      }
                      
                  }
                  </code></pre>
      
            <p>Si existe el elemento que intentamos agregar, hay que encontrar cual es, incrementar su cantidad pero siempre
              sin mutar el state. Para ello utilizamos el <strong>.map() y algunos spreads</strong></p>
      
            <pre><code class="language-js">
                    export default function useOrder() {
                      const [order, setOrder] = useState&lt;OrderItem[]&gt;([])
                  
                      const addItem = (item: MenuItem) =&gt; {
                          
                          const itemExist = order.find( orderItem =&gt; orderItem.id === item.id )
                          if (itemExist) { //El item ya existe         
                            const updatedOrder = order.map( orderItem =&gt; orderItem.id === item.id ? // identificamos el elemento duplicado, busca el elemento de la orden cuyo id sea igual al id del elemento que viene en item (click)
                              {...orderItem, quantity: orderItem.quantity + 1} : //toma una copia de lo que tenemos en nuestra orden e incrementa la cantidad en 1
                              orderItem)//contiene el resto de artículos de la orden que no cumplen el condicional del ternario (los no duplicados)
                              //gracias al .map() nos retorna un arreglo nuevo y podemos setear nuestra orden
                              setOrder(updatedOrder)
                          } else { // El item no existe
                              const newItem: OrderItem = {...item, quantity: 1}
                              setOrder([...order, newItem])
                          }
                          
                      }
                      console.log(order)
                  
                          return{
                            addItem
                          }
                    }
                  </code></pre>
      
            <p>Veamos cómo mostrar el state order en pantalla (ahora solo podemos verlo en consola o en React Developer tools)
            </p>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-118').toggle();">
            <h3>118. Mostrando el Consumo de la orden</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-118" class="hidden">
            <p>Estamos escribiendo en nuestro state de órdenes, ahora queremos ir mostrando a la derecha todo lo que yo pulso
              a la izquierda. Vamos así a comunicar distintos componentes con las interacciones del usuario para crear apps
              que sean más dinámicas. Vamos al <span class="file">App.tsx</span> y creamos un div con estas propiedades de
              estilo usando tailwindcss (dentro de él llamamos al nuevo componente que creamos a continuación): </p>
            <pre><code class="language-js">
                    import OrderContents from "./components/OrderContents"
      
                    &lt;div className=&quot;border border-dashed border-slate-300 p-5 rounded-lg space-y10&quot;&gt; 
                      &lt;OrderContents /&gt;
                    &lt;/div&gt;
                  </code></pre>
            <p>Creamos un componente nuevo <span class="file">OrderContents.tsx</span> en el cual creamos el componente con el
              snippet <strong>rfc</strong> le ponemos un título y en él iteraremos sobre nuestra orden:</p>
            <pre><code class="language-js">
                    export default function OrderContents() {
                      return (
                        &lt;div&gt;
                            &lt;h2 className=&quot;font-black text-4xl&quot;&gt;Consumo&lt;/h2&gt;
                    
                        &lt;/div&gt;
                      )
                    }
                  </code></pre>
            <p>y lo llamamos desde nuestra App.tsx</p>
            <p>A continuación exportamos "order" desde nuestro Hook <span class="file">useOrder.ts</span>:</p>
            <pre data-line="23"><code class="language-js">
                    //useOrder.ts
                    import { useState } from &quot;react&quot;
                    import { MenuItem, OrderItem } from &quot;../types&quot;
                    
                    export default function useOrder() {
                        const [order, setOrder] = useState&lt;OrderItem[]&gt;([])
                        const addItem = (item: MenuItem) =&gt; {
                            
                            const itemExist = order.find( orderItem =&gt; orderItem.id === item.id )
                            if (itemExist) { //El item ya existe         
                              const updatedOrder = order.map( orderItem =&gt; orderItem.id === item.id ? // identificamos el elemento duplicado, busca el elemento de la orden cuyo id sea igual al id del elemento que viene en item (click)
                                {...orderItem, quantity: orderItem.quantity + 1} : //toma una copia de lo que tenemos en nuestra orden e incrementa la cantidad en 1
                                orderItem)//contiene el resto de artículos de la orden que no cumplen el condicional del ternario (los no duplicados)
                                //gracias al .map() nos retorna un arreglo nuevo y podemos setear nuestra orden
                                setOrder(updatedOrder)
                            } else { // El item no existe
                                const newItem: OrderItem = {...item, quantity: 1}
                                setOrder([...order, newItem])
                            }
                            
                        }
                        console.log(order)    
                            return{
                              order,
                              addItem
                            }
                    }
                  </code></pre>
      
            <p><span class="destacado">Aún no hemos visto como tener un estado global (¿en al App.tsx?)</span> así que no lo
              podemos importar directamente en nuestro <strong>OrderContents.tsx</strong> porque es como tener una clase nueva
              entonces pierde la referencia??. En <span class="file">App.tsx</span>, que importamos nuestro Hook, en el
              destructuring de nuestro hook <strong>useOrder</strong> <span class="destacado">extraemos también la orden que
                vamos a pasar como prop al nuevo componente</span>:</p>
            <pre data-line="5"><code class="language-js">
                      //App.tsx
                      import useOrder from "./hooks/useOrder"
                      import OrderContents from "./components/OrderContents"
      
                      function App() {
      
                        const { order, addItem } = useOrder()
                    </code></pre>
      
            <p>Si somos limpios usando el mismo orden que usamos en el Hook para declarar y retornar las variables será más
              fácil tenerlo todo controlado; si vemos nuestro hook:</p>
            <pre data-line="2,3,8,9"><code class="language-js">
                    //useOrder.ts
                    export default function useOrder() {
                      const [order, setOrder] = useState&lt;OrderItem[]&gt;([])
                      const addItem = (item: MenuItem) =&gt; {      
      
                          ....
                  
                          return{
                            order,
                            addItem
                          }
                    }
                  </code></pre>
      
            <p>Al asignarle la prop me marca un error porque, esa propiedad que enviamos desde App.tsx hacia OrderContents.tsx
              hemos de tiparla, no tenemos ningún type asociado.</p>
      
            <pre class="error" data-line="2"><code class="language-js">
                    //App.tsx
                    &lt;OrderContents 
                    order = { order }
                  /&gt;
                  </code></pre>
      
            <p><strong>En nuestro nuevo componente OrderContents.tsx creamos un nuevo type específico y en su definición
                indicamos que la order es del tipo array OrderItem (hemos de importar ese tipo)</strong>.</p>
      
            <div class="flex">
              <div class="w-50">
                <pre><code class="language-js">
                        //OrderContents.tsx
                        export default function OrderContents() {
                          return (
                            &lt;div&gt;
                                &lt;h2 className=&quot;font-black text-4xl&quot;&gt;Consumo&lt;/h2&gt;
                        
                            &lt;/div&gt;
                          )
                        }
                      </code></pre>
              </div>
              <div class="w-50">
                <pre><code class="language-js">
                        //OrderContents.tsx
                        import { OrderItem } from &quot;../types&quot;
      
                        type OrderContentsProps = {
                            order: OrderItem[]
                        }
                        
                        export default function OrderContents({order}: OrderContentsProps) {
                          return (
                            &lt;div&gt;
                                &lt;h2 className=&quot;font-black text-4xl&quot;&gt;Consumo&lt;/h2&gt;
                        
                            &lt;/div&gt;
                          )
                        }
                      </code></pre>
              </div>
            </div>
      
            <p>Comentamos el console.log(order) de nuestro hook para comenzar a mostrarlo en nuestro componente. Añadimos este
              contenedor con esta comprobación:</p>
      
            <pre><code class="language-js">
                    //OrderContents.tsx
                    &lt;div className=&quot;space-y-3 mt-5&quot;&gt;
                      { order.length === 0 ? 
                          &lt;p className=&quot;text-center&quot;&gt;La orden está vacía&lt;/p&gt;
                          : 
                          //&lt;p className=&quot;text-center&quot;&gt;La orden tiene algo&lt;/p&gt;
                          ( order.map( item =&gt; (
                              &lt;div key={item.id}&gt;
                                  &lt;p&gt;{item.name}&lt;/p&gt;
                              &lt;/div&gt;
                              )
                          ))
                      }
                    &lt;/div&gt;
                  </code></pre>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-119').toggle();">
            <h3>119. Formateando el Consumo y mostrando cantidades</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-119" class="hidden">
      
            <p>Sigamos con nuestro html, vamos a mostrar nombre, precio, cantidad y un botón para eliminar los elementos.
              Añadimos el precio y en vez de poner a pelo el signo del $, crea carpeta y fichero <span
                class="file">helpers&gt;index.ts</span> donde mete la función '<strong>formatCurrency()</strong>':</p>
            <pre><code class="language-js">
                    //helpers>index.ts
                    export default function formatCurrency(quantity: number){
                      return new Intl.NumberFormat('en-US', {
                          style: 'currency', currency: 'USD'
                      }).format(quantity)
                  }
                  </code></pre>
            <pre><code class="language-js">
                    //OrderContents.tsx
                    (order.map( item =&gt; (
                      &lt;div 
                          className=&quot;flex justify-between items-center border-t border-gray-200 py-5 last-of-type:border-b&quot;
                          key={item.id}
                      &gt;
                          &lt;div&gt;
                              &lt;p className=&quot;text-lg&quot;&gt;
                                  {item.name} - {formatCurrency(item.price)}
                              &lt;/p&gt;
                              &lt;p className=&quot;font-black&quot;&gt;
                                  Cantidad: {item.quantity} - {formatCurrency(item.price * item.quantity)}
                              &lt;/p&gt;
                          &lt;/div&gt;
                          &lt;button className=&quot;bg-red-600 h-8 w-8 rounded-full text-white font-black&quot;&gt;X&lt;/button&gt;
                      &lt;/div&gt;
                      )
                    ))
                  </code></pre>
      
            <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/119-Ba37j4cw.png" alt="Imagen 119">
      
      
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-120').toggle();">
            <h3>120. Eliminando articulos de la orden</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-120" class="hidden">
            <p>Creamos función nueva para eliminar items de la orden y vemos todos los cambios necesarios en App.tsx, nuestro
              custom hook y el componente implicado.</p>
            <pre><code class="language-js">
                    //useOrder.ts 
                    // - creamos una nueva función para borrar items
                    // - le ponemos como parámetro id y lo tipamos como MenuItem con un lookup para id 
                    // - (lo podríamos poner como number pero si cambiáramos la BBDD a Mongo DB que son string, la liamos sin ese "seguimiento de tipados" del lookup)
                    // - en el console.log comprobamos la comunicación ¿OK? --&gt; seteamos ese state en base a nuestra condición. Accedemos a nuestro state 'order' y usamos el array method filter para crear un nuevo array con los elementos del order actual de los que se exluye el elemento cuyo id coincida con el que le pasamos como argumentoal pulsar el click.
                    // - la exportamos en el return para hacerla disponible en nuestros componentes
                      import formatCurrency from "../helpers"
                      import { MenuItem, OrderItem } from "../types"
                      export default function useOrder() {
                        const [order, setOrder] = useState&lt;OrderItem[]&gt;([])
                      ...
                      const removeItem = (id: MenuItem['id']) => { 
                        //console.log('Eliminando', id)
                        setOrder(order.filter(item => item.id != id))
                      
                      }
                      return{
                          order,
                          addItem,
                          removeItem
                      }
      
                    //App.tsx 
                    //- extraemos de nuestro hook con destructuring esta nueva función
                      const { order, addItem, removeItem } = useOrder()
      
                    //- en el tag de nuestro compocreamos un prop nuevo 'removeItem' que le pasa esa fcn el compo desde donde se va a utilizar "OrderContents.tsx"    
                      &lt;OrderContents 
                        order = { order }
                        removeItem = {removeItem}
                      &gt;
                      // saldrá en rojo hasta que en el componente donde se usa "OrderContents.tsx" hagamos lo siguiente: 
      
                    //OrderContents.tsx 
                    //- lo incluimos como parámetro (necesitamos incluirlo en el tipo personalizado type OrderContentsProps) 
                    //- recibe un parámetro que tipamos como lookup for 'id' del type MenuItem
                    //- añadimos la llamada a la función para borrar desde el onclick del botón y le pasamos como argumento el id del item.
                    
                      type OrderContentsProps = {
                        order: OrderItem[],
                        removeItem: (id: MenuItems['id']) => void
                      }
                      ...
                      export default function OrderContents({order,removeItem}: OrderContentsProps) {
                      ...
                      &lt;button 
                          className=&quot;bg-red-600 h-8 w-8 rounded-full text-white font-black&quot;
                          onClick={() =&gt; removeItem(item.id)}
                      &gt;X&lt;/button&gt;
                  </code></pre>
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-121').toggle();">
            <h3>121. Creando el Componente con los totales</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-121" class="hidden">
            <p>Vamos a crear un nuevo componente para los totales que irá justo debajo de la lista de contenidos de nuestra
              orden. A diferencia del proyecto anterior en donde también la fcn para totales la teníamos en nuestro custom
              hook, dado que en este caso solo se va a requerir su uso en el componente totales la vamos a especificar ahí.
            </p>
      
            <pre><code class="language-js">
                    //OrderTotals.tsx (nuevo componente para totales)
      
                    //App.tsx
                    //-importamos nuestro componente
                    //-Lo renderizmaos en el return() a continuación del componente &lt;MenuItem /&gt;
                      import OrderTotals from "./components/OrderTotals"
                      ...
                      &lt;OrderTotals /&gt;
      
                    //OrderTotals.tsx
                    //- div con las cantidades 
                    //- button para almacenar o reiniciar la orden (mas adelante veremos como conectar BBDD con servidor de node de momento simulamos que la almacenamos )
                      export default function OrderTotals() {
                        return (
                          &lt;&gt;
                      
                            &lt;div className=&quot;space-y-3&quot;&gt;
                              &lt;h2 className=&quot;font-black text-2xl&quot;&gt;Totales y propina:&lt;/h2&gt;
                              &lt;p&gt;Subtotal a pagar:
                                &lt;span className=&quot;font-bold&quot;&gt;$0&lt;/span&gt;
                              &lt;/p&gt;
      
                              &lt;p&gt;Propina:
                                &lt;span className=&quot;font-bold&quot;&gt;$0&lt;/span&gt;
                              &lt;/p&gt;
                      
                              &lt;p&gt;Total a pagar: 
                                &lt;span className=&quot;font-bold&quot;&gt;$0&lt;/span&gt;
                              &lt;/p&gt;
                            &lt;/div&gt;
                      
                            &lt;button&gt;&lt;/button&gt;
                      
                          &lt;/&gt;
                        )
                      }
      
                  </code></pre>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-122').toggle();">
            <h3>122. Calculando el Consumo y más TypeScript</h3>
            <span class="cambiaicono ico_chevron_up_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-122" class="hidden">
            <p><strong>Calculemos el subtotal a pagar en base al precio de los artículos y sus cantidades.</strong> Si
              agregamos varios elementos, vemos que el subtotal tiene que ser el resultado de sumar cada precio por la
              cantidad. Eso antes era más complejo hacerlo pero <strong>gracias a las "nuevos"(2015) array methods como
                <strong>useMemo() o reduce() </strong>es más sencillo simplifican el código, evitando tener que tener renders
                adicionales</strong>. Como ese cálculo viene desde <strong>order</strong> vamos a nuestro App.tsx</p>
            <pre><code class="language-js">
                    //App.tsx
                    //- en el tag de nuestro nuevo componente &lt;OrderTotals/&gt; le pasamos como propiedad la order para que esté conectado y sepa cuáles son los contenidos de nuestra orden (lo podemos hacer en el hook o en el componente, con react tenemos siempre distintas formas)
                      &lt;OrderTotals 
                      order = { order }/&gt;
                  </code></pre>
      
            <pre><code class="language-js">
                  //OrderTotals.tsx  
                  //- importamos useMemo y nuestra función formatCurrency() de helpers que los vamos a usar
                    import { useMemo } from "react"
                    import formatCurrency from "../helpers"
      
                  //- como esa prop 'order' va a ser de tipo array OrderItem, importamos ese type
                  //- nuestro componente va a recibir como parámetro esa prop así que creamos type personalizado para este componente
                    import {OrderItem} from &quot;../types&quot;
                    type OrderTotalsProps = {
                      order: OrderItem[]
                    }
      
                    export default function OrderTotals({order}: OrderTotalsProps) {
      
                    //- creamos función nueva 'subtotalAmount' para calcular el subtotal a pagar en base al precio de los artículos y sus cantidades:
                      const subtotalAmount = useMemo(() => order.reduce( (total, item) => total + (item.quantity * item.price), 0), [order])
      
                      //- usamos useMemo; va a ser siempre un callback y la dependencia es lo que hay tras la coma --&gt; useMemo(()=&gt; ,[]order).
                      // nos permite que el código se renderice o se ejecute cada vez que cambia la dependencia (en nuestro caso cada vez que cambia la orden).
                      //- usamos el array method .reduce() que es uno de los pocos que toma dos parámetros (acumulado temporal y el item sobre el  que iteramos): 
                        // total(temporal) es un acumulado, en cada iteración que se va dando va almacenando en memoria (en nuestro caso la suma del total temporal con (menuItems.quantity * item*price))
                        // item(elemento sobre el que estamos iterando) --&gt; tras la coma, 0 es el valor inicial de la iteracion
                  
                    //- usando en el return{} nuestra función formatCurrency() de helper, ya podemos ver el subtotal:
                      return (
                        &lt;&gt;
                          &lt;p&gt;Subtotal a pagar:
                            &lt;span className=&quot;font-bold&quot;&gt;{ formatCurrency(subtotalAmount) }&lt;/span&gt;
                          &lt;/p&gt;
      
                    
      
                    
                    
                    
      
                      
                      
      
                  </code></pre>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-123').toggle();">
            <h3>123. Primeros pasos con las propinas / 124. Añadiendo la cantidad seleccionada de Propina</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-123" class="hidden">
            <p>Vamos a tener un formulario en el que vamos a indicar cuánto queremos dejar de propina. Creamos componente
              nuevo <span class="file">TipPercentageForm.tsx</span> en el que usamos como const <a
                href="https://gist.github.com/codigoconjuan/93fd42da96258357fc9f78eb1d17a6b3" class="underline"
                target="_blank">Gist Arreglo con objetos (id, value, label) para iterarlo y mostrarlo en el formulario</a></p>
            <pre><code class="language-js">
                    //App.tsx
                    import TipPercentageForm from "./components/tipPercentageForm"
      
                    &lt;TipPercentageForm /&gt;
                  </code></pre>
            <pre><code class="language-js">
                    //TipPercentageForm.tsx
                    const tipOptions = [
                    {
                      id: &#39;tip-10&#39;,
                      value: .10,
                      label: &#39;10%&#39;
                    },
                    {
                      id: &#39;tip-20&#39;,
                      value: .20,
                      label: &#39;20%&#39;
                    },
                    {
                      id: &#39;tip-50&#39;,
                      value: .50,
                      label: &#39;50%&#39;
                    },
                  ]
      
                  export default function TipPercentageForm() {
                    return (
                      &lt;&gt;
                          &lt;h3 className=&quot;font-black text-2xl&quot;&gt;Propina:&lt;/h3&gt;
      
                          &lt;form&gt;
                              {tipOptions.map( tipOption =&gt; (
                                  &lt;div
                                      key={tipOption.id}
                                      className=&quot;flex gap-2&quot;
                                  &gt;
                                      &lt;label htmlFor={tipOption.id}&gt;{tipOption.label}&lt;/label&gt;
                                      &lt;input 
                                          id={tipOption.id} 
                                          type=&quot;radio&quot;
                                          name=&quot;tipOption&quot;
                                          value={tipOption.value}
                                      /&gt;
                                  &lt;/div&gt;
                              ))}  
                          &lt;/form&gt;
                      &lt;/&gt; 
                    )
                  }
                  </code></pre>
      
            <p class="naranja">Añadiendo la cantidad seleccionada de Propina</p>
      
            <p>vamos a colocar el state de propina en nuestro hook useOrder():</p>
            <pre><code class="language-js">
                    //useOrder.ts 
                    export default function useOrder() {
                        const [order, setOrder] = useState<OrderItem[]>([])
                        const [tip, setTip] = useState(0)
      
                        return{
                          order,
                          tip,
                          setTip,
                          addItem,
                          removeItem
                      }
      
                    //App.tsx
                    - extraigo ambos: tip y setTip para tenerlos disponibles Y
                    - pasarlos como propiedades del componente 
      
                      const { order, addItem, removeItem, tip, setTip } = useOrder()
      
                        &lt;TipPercentageForm 
                          setTip = {setTip}
                        /&gt;
                      
                    //TipPercentageForm.tsx
                    //- definimos type nuevo específico para la función setTip que estamos pasando ¿donde lo miramos? dejamos que VSC nos lo infiera
                    //y con el Intellisense de VSC lo copiamos 'setTip: React.Dispatch&lt;React.SetStateAction&lt;number&gt;&gt;' 
                    // significa funcion que dispara la accion de modificar el state de tipo number
                    
      
                        type TipPercentageFormProps = {
                          setTip: React.Dispatch&lt;React.SetStateAction&lt;number&gt;&gt;
                        }
                        
                        export default function TipPercentageForm({setTip}:TipPercentageFormProps) {
      
                    //También podríamos reducir un poco nuestro código del nuevo type para esta propor importando de react los dos types:
                        import type { Dispatch, SetStateAction } from "react"
      
                        type TipPercentageFormProps = {
                          setTip: Dispatch<SetStateAction<number>>
                      }
      
                    // - usamos setTip en nuestro input, en el onChange modificamos el value, sin embargo vemos que al escribir onChange={ e =&gt; setTip(e.target.value)}
                    // nos marca en rojo, TS escanea nuestro código y setTip es number y el value de un input es string. Lo podemos solucionar de dos manera:
                    //  * signo + antes de lo que lee como string, lo convierte a number  onChange={ e =&gt; setTip(+e.target.value)}
                    //  * añadirle el sufijo AsNumber onChange={ e =&gt; setTip(e.target.valueAsNumber)} PERO ESTO NO FUNCIONA CON LAS INPUT RADIO!!!
                      &lt;form&gt;
                        {tipOptions.map( tipOption =&gt; (
                            &lt;div
                                key={tipOption.id}
                                className=&quot;flex gap-2&quot;
                            &gt;
                                &lt;label htmlFor={tipOption.id}&gt;{tipOption.label}&lt;/label&gt;
                                &lt;input 
                                    id={tipOption.id} 
                                    type=&quot;radio&quot;
                                    name=&quot;tipOption&quot;
                                    value={tipOption.value}
                                    //onChange={ e =&gt; setTip(e.target.value)}
                                    onChange={ e =&gt; setTip(+e.target.value)}
                                /&gt;
                            &lt;/div&gt;
                        ))}  
                      &lt;/form&gt;
                  </code></pre>
            <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/124-q52RywGi.png" alt="imagen 124">
      
            <p>Veamos como pasar ese tip o el porcentaje hacia OrderTotals.tsx para hacer los dos últimos cálculos, propinas y
              total a pagar.</p>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-125').toggle();">
            <h3>125. Calculando el Total de la propina / 126. Calculando el Total a pagar</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-125" class="hidden">
            <pre><code class="language-js">
                    //App.tsx
                      &lt;OrderTotals 
                        order = {order}
                        tip = {tip}
                      &gt;
                  </code></pre>
            <pre><code class="language-js">
                    //OrderTotals.tsx
                    //- completamos el type de propiedades de ese componente con la nueva que pasamos, tip que es de tipo number
                    //- la extraemos
                    //- como tip solo tiene el % (0.1 para 10% y así...) creamos variable nueva para formatearlo: 'tipAmount' y usamos useMemo() porque esa propina puede cambiar:
                    //  * cuando cambiemos la propina marcada 'tip'
                    //  * cuadno cambie nuestra orden 'order'
                    // por tanto empleamos esas dos dependencias para que, tanto cuando cambiemos el radio de la propina como cuando añadamos o eliminemos de nuestra orden, todo se Actualicemos
                    // - creamos nueva variable para el total 'totalAmount' y también usamos useMemo()
                      import { useMemo } from "react"
                      import { OrderItem } from &quot;../types&quot;
                      import formatCurrency from &quot;../helpers&quot;
      
                      type OrderTotalsProps = {
                        order: OrderItem[]
                        tip: number
                      }
      
                      export default function OrderTotals({order, tip}: OrderTotalsProps) {
      
                        const subtotalAmount = useMemo(() =&gt; order.reduce( (total, item) =&gt; total + (item.quantity * item.price), 0), [order])
                        const tipAmount = useMemo(() =&gt; subtotalAmount * tip, [tip, order])
                        const totalAmount = useMemo(()=&gt; subtotalAmount + tipAmount, [tip, order])
      
                        return (
                          &lt;&gt;
      
                            &lt;div className=&quot;space-y-3&quot;&gt;
                              &lt;h2 className=&quot;font-black text-2xl&quot;&gt;Totales y propina:&lt;/h2&gt;
                              &lt;p&gt;Subtotal a pagar:
                                &lt;span className=&quot;font-bold&quot;&gt; {formatCurrency( subtotalAmount )}&lt;/span&gt;
                              &lt;/p&gt;
                              &lt;p&gt;Propina:
                                &lt;span className=&quot;font-bold&quot;&gt; {formatCurrency( tipAmount )}&lt;/span&gt;
                              &lt;/p&gt;
                              &lt;p&gt;Total a pagar: 
                                &lt;span className=&quot;font-bold&quot;&gt; {formatCurrency( totalAmount )}&lt;/span&gt;
                              &lt;/p&gt;
                            &lt;/div&gt;
                            &lt;button&gt;&lt;/button&gt;
      
                          &lt;/&gt;
                        )
                      }
                  </code></pre>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-127').toggle();">
            <h3>127. Diferencia entre useMemo y useCallback</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-127" class="hidden">
            <p>Existe otra funcíón que es exactamente igual que useMemo() pero su sintaxis es diferente: useCallback()
              <strong>simplemente es añadir los () en cada llamada que se haga a las distintas funciones. El código anterior
                de nuestro componente OrderTotals.tsx quedaría así: </strong></p>
      
            <pre><code class="language-js">
                    //OrderTotals.tsx
                      import { useMemo, useCallback } from "react"
      
                      export default function OrderTotals({order, tip}: OrderTotalsProps) {
      
                        const subtotalAmount = useCallback(() =&gt; order.reduce( (total, item) =&gt; total + (item.quantity * item.price), 0), [order])
                        const tipAmount = useCallback(() =&gt; subtotalAmount() * tip, [tip, order])
                        const totalAmount = useCallback(()=&gt; subtotalAmount() + tipAmount(), [tip, order])
                      
                        return (
                          &lt;&gt;
                      
                            &lt;div className=&quot;space-y-3&quot;&gt;
                              &lt;h2 className=&quot;font-black text-2xl&quot;&gt;Totales y propina:&lt;/h2&gt;
                              &lt;p&gt;Subtotal a pagar:
                                &lt;span className=&quot;font-bold&quot;&gt; {formatCurrency( subtotalAmount() )}&lt;/span&gt;
                              &lt;/p&gt;
                              &lt;p&gt;Propina:
                                &lt;span className=&quot;font-bold&quot;&gt; {formatCurrency( tipAmount() )}&lt;/span&gt;
                              &lt;/p&gt;
                              &lt;p&gt;Total a pagar: 
                                &lt;span className=&quot;font-bold&quot;&gt; {formatCurrency( totalAmount() )}&lt;/span&gt;
                              &lt;/p&gt;
                            &lt;/div&gt;
                            &lt;button&gt;&lt;/button&gt;
                      
                          &lt;/&gt;
                        )
                      }
                  </code></pre>
      
          </div>
      
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-128').toggle();">
            <h3>128. Reiniciando la Orden / 129. Deployment del Proyecto</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-128" class="hidden">
            <p>Vamos a trabajar con e botón del final de nuestro componente OrderTotals.tsx</p>
            <pre><code class="language-js">
                    // OrderTotals.tsx
                    // - le damos estilos y lo deshabilitamos si el total es 0. 
                    // - aprovehamos las clases de tailwind para formatear aspecto cuando esté deshabilitado
                    &lt;button 
                      className=&quot;w-full bg-black p-3 uppercase text-white font-bold mt-10 rounded-sm cursor-pointer disabled:opacity-10 disabled:cursor-auto&quot;
                      disabled={totalAmount === 0 }
                      &gt; 
                      Guardar Orden
                    &lt;/button&gt;
                  </code></pre>
      
            <p>Creamos función nueva de tipo arrow 'placeOrder' y recordar el orden de propagación: <br>
              <span class="destacado">hook</span> <strong>useOrder.ts</strong> -> <span class="destacado">compo ppal</span>
              <strong>App.tsx</strong> -> <span class="destacado">compo donde se utiliza</span>
              <strong>OrderTotal.tsx</strong>
            </p>
      
            <pre><code class="language-js">
                    //useOrder.ts
                        const placeOrder = () => {
                          console.log('guardando...')
                      }
                      return{
                          order,
                          tip,
                          setTip,
                          addItem,
                          removeItem,
                          placeOrder
                      }
      
                    //App.tsx
                      function App() {
      
                        const { order, tip, setTip, addItem, removeItem, placeOrder } = useOrder()
                      
                        return (
                          &lt;&gt;
                          &lt;OrderTotals 
                            order = {order}
                            tip = {tip}
                            placeOrder = {placeOrder}
                          /&gt;
      
                    //OrderTotals.tsx
                      type OrderTotalsProps = {
                        order: OrderItem[]
                        tip: number,
                        placeOrder: ()=>void
                      }
                      
                      export default function OrderTotals({order, tip, placeOrder}: OrderTotalsProps) {   
                        
                        &lt;button 
                          className=&quot;w-full bg-black p-3 uppercase text-white font-bold mt-10 rounded-sm cursor-pointer disabled:opacity-10 disabled:cursor-auto&quot;
                          disabled={totalAmount === 0 }
                          onClick={placeOrder}
                          &gt; 
                          Guardar Orden
                        &lt;/button&gt;
                  </code></pre>
      
            <p>Si probamos se restablece todo, pero el radio queda marcado ¿como conseguimos que no queda marcado? Hemos de
              pasarle al componente TipPercentageForm.tsx como propiedad desde App.tsx la propina tip para poder añadirle al
              input esta comprobación: <code class="language-js">checked={tipOption.value === tip}</code>. <strong>Cuando
                restablecemos la orden el state tip cambia porque tiene las dos dependencias mencionadas antes con lo cual
                deja de cumplirse la condición para que permanezca marcado</strong></p>
      
            <pre><code class="language-js">
                    //App.tsx
                    &lt;TipPercentageForm 
                      tip = {tip}
                      setTip = {setTip}
                      &gt;
      
                    //TipPercentageForm.tsx
                      type TipPercentageFormProps = {
                        tip: number,
                        setTip: Dispatch&lt;SetStateAction&lt;number&gt;&gt;
                      }
                      export default function TipPercentageForm({tip, setTip}:TipPercentageFormProps) {
                        return (
                          &lt;&gt;
                              &lt;h3 className=&quot;font-black text-2xl&quot;&gt;Propina:&lt;/h3&gt;
                      
                              &lt;form&gt;
                                  {tipOptions.map( tipOption =&gt; (
                                      &lt;div
                                          key={tipOption.id}
                                          className=&quot;flex gap-2&quot;
                                      &gt;
                                          &lt;label htmlFor={tipOption.id}&gt;{tipOption.label}&lt;/label&gt;
                                          &lt;input 
                                              id={tipOption.id} 
                                              type=&quot;radio&quot;
                                              name=&quot;tip&quot;
                                              value={tipOption.value}
                                              onChange={ e =&gt; setTip(+e.target.value)}
                                              checked={tipOption.value === tip}
                                          /&gt;
                                      &lt;/div&gt;
                                  ))}  
                              &lt;/form&gt;
                          &lt;/&gt; 
                        )
                      }    
                  </code></pre>
      
            <p>Cuando le damos a "Guardar Orden" (simulando ese envío a BBDD) y se restablece... si la orden está vacía,
              probablemente no tenga sentido cargar nada de esto:</p>
            <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/128-DSKXTlF6.png" alt="">
      
            <p>Vemos que en OrderContents.tsx. teníamos un ternario para mostrar "La orden está vacía" o en caso de que bo lo
              estuviera el/los elementos agregados:</p>
            <pre><code class="language-js">
                    //OrderContents.tsx
                      &lt;div className=&quot;space-y-3 mt-10&quot;&gt;
                        //{ order.length === 0 ? 
                          //&lt;p className=&quot;text-center&quot;&gt;La orden está vacía&lt;/p&gt;
                          //: 
                            {order.map( item =&gt; (
                              &lt;div 
                                  className=&quot;flex justify-between items-center border-t border-gray-200 py-5 last-of-type:border-b&quot;
                                  key={item.id}
                              &gt;
                                &lt;div&gt;
                                    &lt;p className=&quot;text-lg&quot;&gt;
                                        {item.name} - {formatCurrency(item.price)}
                                    &lt;/p&gt;
                                    &lt;p className=&quot;font-black&quot;&gt;
                                        Cantidad: {item.quantity} - {formatCurrency(item.price * item.quantity)}
                                    &lt;/p&gt;
                                &lt;/div&gt;
                                &lt;button 
                                    className=&quot;bg-red-600 h-8 w-8 rounded-full text-white font-black cursor-pointer&quot;
                                    onClick={() =&gt; removeItem(item.id)}
                                &gt;X&lt;/button&gt;
                              &lt;/div&gt;
                            )}
                          ///))}
                        //}
                        
                        &lt;/div&gt;
                  </code></pre>
      
            <p>Cambiemos el compo ppal App.tsx para meter aquí la comprobación, mejorando así el rendimiento porque en caso de
              que la orden esté vacía no se renderiza ninguno de los 3 componentes:</p>
            <pre><code class="language-js">
                    &lt;div className=&quot;border border-dashed border-slate-300 p-5 rounded-lg space-y10&quot;&gt;    
                      &lt;h2 className=&quot;font-black text-4xl&quot;&gt;Consumo&lt;/h2&gt;
                      {order.length &gt; 0  ? (
                        &lt;&gt;
                          &lt;OrderContents 
                            order = { order }
                            removeItem = {removeItem}
                          /&gt;            
                          &lt;TipPercentageForm 
                            tip = {tip}
                            setTip = {setTip}
                          /&gt;
                          &lt;OrderTotals 
                            order = {order}
                            tip = {tip}
                            placeOrder = {placeOrder}
                          /&gt;
                        &lt;/&gt;
                      ) : (
                        &lt;p className=&quot;text-center&quot;&gt;La orden está vacía&lt;/p&gt;
                      )}  
                    &lt;/div&gt;
                  </code></pre>
      
            <p>Hemos estado viendo performance (useMemo, useCallback) tips sobre cómo inferir el tipo de dato. Más adelante
              retomaremos este proyecto para ver cómo almacenarlo en una BBDD, y así poder incluirlo en nuestro portfolio.</p>
      
          </div>
      
      
        </div>
        <!-- Fin div colapsable-->
      
      
      </div>
      <!-- FIN SECCION 9 -->

     
      <!-- SECCION 8 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">

          <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion08').toggle();">
            <h2>Sección 8: PROYECTO - Carrito de Compras - Migrando a TypeScript paso a paso</h2>
            <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
          </div>

          <div id="seccion08" class="hidden">
        

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-91').toggle();">
                  <h3>91. ¿Qué es TypeScript y sus ventajas?</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-91" class="hidden">
                  <p class="font-bold">Typescript ¿qué es? y ventajas</p>
                  <ul>
                    <li>Es un lenguaje de programación de código abierto. Sí, es un lenguaje completo, desarrollado y mantenido por Microsoft. También se le conoce como un <strong>superconjunto tipado para JavaScript, lo que significa que cualquier código de JavaScript válido es también código de TypeScript válido</strong>.</li>                    
                    <li>La principal característica de TypeScript es que agrega un sistema de tipos estático a JavaScript, lo que permite detectar errores y proporcionar herramientas de desarrollo más sólidas.</li>
                  </ul>

                  <p class="font-bold">¿Cuáles son las ventajas de implementar TypeScript?</p>
                  <ul>
                    <li>El sistema de tipado de tipos de TypeScript permite al programador especificar los tipos de variable, parámetros de función, valores de retorno y más. Esto va a brindar la capacidad de realizar la comprobación de tipos durante la compilación (cuando estás escribiendo tu código) y detectar posibles errores antes de que el código sea ejecutado. --&gt; Entonces su principal ventaja es que no necesitas que el proyecto esté en producción para revisar que todo esté bien. Con TypeScript puedes tener la garantía de que tu código va a funcionar correctamente.</li>
                    <li>Mejora enormemente el autocompletado o Intellisense que vas a obtener con Visual Studio Code (Ver presentación 10.html del curso de Angular).
                    <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/91-DzMAaQSY.png" alt="" />
                    </li>
                  </ul>

                  <p class="font-bold">Typescript y Javascript / React</p>

                  <ul>
                    <li>Una vez que has escrito el código en TypeScript, este código siempre se compila a JavaScript. Como tal, el navegador no soporta TypeScript, por lo tanto se tiene que compilar siempre hacia código de JavaScript</li>
                    <li>React y Vite incluyen soporte a TypeScript también, lo que ayuda bastante en el desarrollo de proyectos. Una vez que esté listo tu proyecto, lo construyes con build, se va a compilar a código de JavaScript y entonces puede ser publicado en Internet.</li>
                    <li>Hoy en día, TypeScript se ha convertido en un estándar para crear aplicaciones React, Angular y View. Incluso se pide en vacantes de Junior Developer por lo que es el momento adecuado para comenzar a aprender TypeScript.</li>
                  </ul>
                  

                </div>
                <!-- Fin bloque desplegable interior-->

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-92').toggle();">
                  <h3>92. Creando el Proyecto con TypeScript</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-92" class="hidden">
                  <p>Vamos a crear un proyecto nuevo <span class="destacado">npm create vite@latest</span> lo nombramos <strong>guitarla-ts</strong> que sea <strong>react con el nuevo compilador</strong>. Vamos a la carpeta e instalamos las dependencias con <span class="destacado">npm install</span>. Lanzamos el servidor de desarrollo con <strong>npm run dev</strong>.</p>

                  <p>Vemos que básicamente la estructura del proyecto es como la que hemos visto hasta ahora con algunas diferencias:</p>
                  <ul>
                    <li>vemos que hay 3 ficheros de configuración de typescript con extensión .json: tsconfig.app.json,tsconfig.json y tsconfig.node.json. Normalmente no tocaremos nada en ellos.</li>
                    <li>Si abrimos la carpeta src veremos que la extensión ya no es .jsx sino tsx.</li>                
                  </ul>

                  <p>Aunque el resto de proyectos los haremos desde cero con typescript, ahora vamos a convertir el proyecto de carrito de compras de guitarras <strong>guitarla-useCart</strong> a typescript. Copiamos entre proyectos de ese a este nuevo <strong>guitarla-ts</strong>:</p>

                  <ul>
                    <li>borramos el archivo public/vite.svg</li>
                    <li>copiamos y pegamos la carpeta public/img</li>
                    <li>En la carpeta principal del proyecto, borro src del nuevo y copio src.</li>
                    <li>Cambiamos todos los .jsx --> .tsx y los .js --> .ts. veremos que nos empieza a marcar en rojo en muchos archivos. Si abrimos el componente Header.tsx por ejemplo vemos que los errores los resalta en los parámetros que toma este componente. Ahí es "donde entra typescript" en los parámetros, objetos que vamos creando vamos a ir definiendo el tipo de dato que le estamos pasando a nuestras funciones, componentes... Vamos a ir viéndolo paso a paso.</li>
                    <li>Error del main.tsx --> document.getElementById('root'). Veamos la explicación de esto. Si creamos una variable en ese mismo <span class="file">main.tsx</span>y le asignamos eso <code class="language-js">const div = document.getElementById('root')</code>, vemos en el Intellisense que TypeScript <span class="destacado">INFIERE</span> que el tipo de dato de ese elemento es un HTMLElement o null.<br>
                      
                      <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/92-DCYpb648.png" alt="" />

                      <p>Es decir, <span class="destacado">TypeScript nos marca eso como error porque estamos utilizando un parámetro que puede ser null. Para eliminar esa posibilidad, fijamos el tipo de dato de esta manera:</span> <code class="language-js">const div = document.getElementById('root') as HTMLElement</code> y entonces podríamos quitar ese error como se hacía hasta no hace mucho aunque no se considera buena práctica porque con <code class="language-js">as HTMLElement</code> le estamos diciendo a typeScript "confia en mí, este va a ser el tipo de dato":</p>

                      <pre class="verde" data-line="0"><code class="language-js">
                        ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
                          &lt;React.StrictMode&gt;
                            &lt;App /&gt;
                          &lt;/React.StrictMode&gt;&comma;
                        )
                      </code></pre>                      
                        <p><span class="verde">Otra manera es utilizar el <strong>operador de Assertionnot null = non null assertion operator "!"</strong> que es una manera de asegurarle a TypeScript que ese elemento no va a ser null:</span></p>
                        <pre class="verde" data-line="0"><code class="language-js">
                          ReactDOM.createRoot(document.getElementById('root')!).render(
                            &lt;React.StrictMode&gt;
                              &lt;App /&gt;
                            &lt;/React.StrictMode&gt;&comma;
                          )
                        </code></pre>
                    </li>                 
                  </ul>

                  <p>Vamos a ir viendo como solucionar el resto de errores que nos aparecen en los ficheros.</p>
                </div>
                <!-- Fin bloque desplegable interior-->
                

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-93').toggle();">
                  <h3>93. Introducción a TypeScript - Primitive Types</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-93" class="hidden">
                  <p>Vamos a comenzar a solucionar los errores que encuentra Typescript en el código. Vemos que en App.tsx, Guitar.tsx, Header.tsx, useCard.ts se van pintando en rojo algunos de estos archivos. No es que el código esté mal escrito (si arrancamos el servidor de desarrollo y probamos vemos que todo funciona bien) sino que más bien tneemos que darle más información a TypeScript. esa información normalmente se la pasamos con algo llamado <span class="destacado">Primitive Type</span>.</p>

                  <ul>
                    <li>Los Primitive Types son los tipos de datos que soporta TypeScript de forma nativa.</li>
                    <li>Estos son number, string, boolean, null y undefined. Cuando creamos un objeto, hemos de especificar qué tipo de dato (primitive type) es el que tiene cada propiedad de ese objeto. De igual manera si creamos una variable o si le pasamos parámetros a una función.</li>
                    <li>En el caso de arrays hay una sintaxis especial para crearlos</li>
                  </ul>

                  <p>Abrimos nuestro <span class="file">App.tsx</span> y tras importar state <code class="language-js">import { useCart } from './hooks/useCart'</code>, creamos un nuevo state para verificar si un usuario está autenticado, así es como lo hemos hecho hasta ahora poniendole como valor inicial que el usuario no está logado: <code class="language-js">const [auth, setAuth] = useState(false)</code>. Si nos ponemos encima de auth el intellisense nos muestra que TypeScript infiere que el tipo de auth va a ser boolean, pero si le cambiamos el valor inicial a '20' y volvemos a ponernos encima de auth el IS nos muestra que TS infiere que el valor es number. Si inmediatamente hago un <code class="language-js">setAuth(true)</code> nos lo marca como error y el IS nos indica algo como "no le puedes asignar un booleano porque tú dijiste que era un número". <span class="destacado">En este tipo de acciones es donde TypeScript nos va a proteger, el evitarnos que estemos asignando diferente tipo de dato nos va a permitir escribir un mejor código.</span></p>

                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/93-sQkytaUK.png" alt="" />
                  

                  <p>Explica que hay algunos casos de uso para especificar el tipo entre tags <span class="destacado">&lt;&gt;</span> por ejemplo: <code class="language-js">const [auth, setAuth] = useState&lt;number&gt;(20)</code> Pero que no lo hacemos así porque es dar información redundante.</p>

                  <p>Si abrimos nuestro <span class="file">data&gt;db.ts</span> y nos ponemos encima de db vemos como TypeScript infiere el tipo de dato para cada elemento id, name,... Poría decirse que va a escanear nuestro código y va a ser nuestro mejor asistente. De hecho si al segundo elemento de nuestro array le dijeramos que el id es "2" y volviéramos a consultar el IS, veríamos lo que aparece a la derecha de la siguiente captura, que <strong>TS nos especifica que puede ser un number o un string</strong>:</p>
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/93-2-DJxNuL_g.png" alt="" />

                  <p>Sin embargo estas guitarras y lo que tenemos en useCart.ts en nuestro carrito es básicamente lo mismo, vamos agregando nosotros las guitarras salvo con algunas excepciones y <span class="destacado">cuando trabajas con objetos, la recomendación es no dejar que TypeScript infiera ese tipo de dato sino que nosotros crearemos nuestros propios grupos de tipo de dato que se les conoce como Types e Interfaces.</span></p>

                </div>
                <!-- Fin bloque desplegable interior-->
                

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-94').toggle();">
                  <h3>94. Introducción a TypeScript - Types e Interfaces</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-94" class="hidden">
                  <p>Si nos colocamos en la variable db vemos un objeto que tiene diferentes propiedades. Cuando tenemos una estructura de este tipo lo mejor es crear lo que se conoce como un Type o Interface. Básicamente es lo mismo, pero veamos un poco más de información de este tema.</p>

                  <ul>
                    <li>Types e Interfaces son dos de las características que más vamos a utilizar en TypeScript.</li>                  
                    <li>Ambas pueden ser utilizadas incluso de forma intercambiable, hay muy pocas diferencias entre ambos y en la comunidad vas a encontrar ejemplos con ambos (La verdad es que la comunidad está dividida, unos dicen utilizar interfaces, otros types...) Cuál vas a utilizar en un proyecto? Bueno, el que ya estén utilizando.</li>
                    <li><strong>Es una forma de crear una estructura y definir qué tipo de dato tiene cada propiedad de un objeto o agrupar propiedades de un objeto</strong>.</li>                
                  </ul>

                  <p>Veamos algunos ejemplos. Creemos nuestro primer type para nuestras guitarras. <span class="file">db.ts</span>: la convención de nombrado es con la primera mayúscula.</p>

                  <pre data-line="0-6,7"><code class="language-js">
                    type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  export const db : Guitar[] = [
                      {
                          id: 1,
                          name: 'Lukather',
                          image: 'guitarra_01',
                          description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                          price: 299,
                      },
                  </code></pre>

                  <p>Definimos nuestra estructura Types, la aplicamos a nuestra información y si el tipo de dato no es el correcto nos va a marcar el error. si cambiáramos el tipo de id a string veríamos que nos saca un error y ahí es donde TS nos va a yudar mucho, no vamos a necesitar compilar el proyecto para ver si tiene errores, desde le momento en que estamos escribiendo TS ya nos va marcando si tenemos algún error.</p>

                  <p>La sintaxis para definir nuestra interface es similar usando la palabra interface y sin el "="</p>

                  <pre data-line="0,7"><code class="language-js">
                    interface Guitar {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  export const db : Guitar[] = [
                      {
                          id: 1,
                          name: 'Lukather',
                          image: 'guitarra_01',
                          description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                          price: 299,
                      },
                  </code></pre>

                  <p>La preferencia es types porque es mas corto de escribir pero ambos valen igual. <span class="destacado">Como hemos visto, a nuestra constante db le estamos añadiendo el type Guitar: <code class="language-js">export const db : Guitar[] = [</code> y de hecho si abrimos nuestro <span class="file">useCart.ts</span> vemos que ahí estamos seteando ese db <code class="language-js">const [data] = useState(db)</code>. Si nos ponemos encima de data el IS nos dice que tiene el type Guitar[] por tanto se propaga en nuestro código ese tipo de dato.</span></p>

                  <img class="my-2.5" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAZoAAABYCAMAAAD7j8FaAAAAA3NCSVQICAjb4U/gAAACW1BMVEUgICA0YTXBl1wxMR0hYcuMjBDm5gM1UGcfH0POcLMfgKuZmZkhK7ElkPHUxZ9iHx/OR2AfH1wfiYukY9YfZHnQ3KqGVdbQ3IvQo3lio51Go9U2cGSliXlEm8vBzMxEREQzWqgfH6g/ZodHsJukLB87wfGfYR++vgm43J1ElJBClcI6gnN0dBO9vb0lMS+Huaqx1NSrgB+lzaqGHx8fH4RTUxgvQlLQzXk7o6gztP9+rMxra2s/k4I2bInaY6EfUbMkKS1RUVGluapPwfH//wBio4spQTwspd/c3IszMzOnpwxMw6shft+HH2IzWh9iZHkro/82jNbaVYOluXnOcNZWeoMfOaHW1gZAjrg7eR87wdtWnMtKZmBLte62cLNAQBorHx95eRI8pbHc3J1hR8u2cMtHeqPc3KowW1K43Iu2OR/U1NS43KpDoY5Nu/f39wEhK5ApP0tElMtJt6HcuWLOcMshKzU/UR88fjVjYxbQ3J1Iqd4fWsUlMTcfObPPzwc7wf9Pwd9Pwf9WnLM+h664uWLQo0MfXpo6OhuSkg9RkcbMzMxWjKGzswqHuYuxsbFzczSavsx+fn4tetZPtMUxWG4oMTnv7wIpKR5Po6g3NzcnKzU7faFWnNbacNZYWBg/nNa4iWLe3gRKsOe4iR/U1Mk2OR8fLKFKnLNKvKXDwwhOi73acMusrAvczXknlPKcnA6rq6vacLOEhBFPtctTls62cNY+jHwmZstEwfFPpbHHx8dpaRWCstSlZB9MhbWlo51LSxlKnMsxMSEfH2I0pf9Ewf9Ewdve3gWvyrX8AAAACXBIWXMAAA50AAAOdAFrJLPWAAAAFnRFWHRDcmVhdGlvbiBUaW1lADAxLzMwLzI1vVYACQAAAB90RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgOLVo0ngAAAozSURBVHic7Z2LfxRXFcdvbUlSBaPbJHWNEbuxprQ0a8OCxiaSFkQgWBe1jdFEU4PZqEkDurZUGlKmNAYivmhIWrpJtWkRlC2VUtKHifGzPv4szzn3MTO7O/uY3c3uLPf3gZ2ZO68z97vnzJl7ZoExLc+oafFb5TZBy0GJu35abhO0HHTkE+W2QMtBbtAc2OoZHSh+j22YXKA58EoJ7CiRXvEwm5Nfrc93l62lsKNU8pSxSTq5mK/feOpqPWWsXUfyz549dbWeMtYuF/caT12tp4y1S6OpWGk0lSo3owGeulpPGWtV02L+uXNBV9t9YtLtrqO94xnWPvzB7OwfYfr27Ozb1nbPonGlnK+2Z602ucmKZu71Y5n23ne51wZDoBn9xb50Wz/84CNi7mMaTXYVhGa09yZjzc2p7RqNsyxXWxuLxQKM7boRi43A0kiAFnvWYrGzF9hILMZXS502DAPQTJ7AybFBWDKemqNmnLBHZn9nOcs495j2VqBzE+bHe5EVuhJoFNr4ZPwmzDRrNFzm1dbe2IWTC2dr4W8AQI2wWmASGOGrk7yme/AYec2rc0DntPKauVeBDjqTDc2+y9xhFBqkgJ/Ca0YfgObWdiA2TlONBqWutmeNu0RgrQcwrfXAH3bhr7tYAPDw9VY0kye6zYB2usUW0FJjG6IBR2l2QiNnxwELTjUalLpa9BYUeYkFDYYyhOaAZu4piGQmGoxvxmA6NOgyTmjaWyGgXd4nGjMEtJmlM1ev9BXnyiteFq8RaNBrAhY0jOKbA5pjg6dtXtOCtFK8pr11PCMa6S0Z0BCUvaTtxbv6ipYZI0Tk2nWjljzIgobHupER634tLeAwiKYbpoAGZ3jz5An0Gnsa0Aw3d0JzE2YtaMRNCLKE9tZMXvPsXosWitwFlSpL+A6YGVqASTSYoMUIyoWz1gwNcrLB7k9PYkY2eD+gYd2UmmF8++7rKWgge+7F3AsmrV3jIjVDDs2UmuHaroxe02aSuVqqrqg0VeSdNRXNQp9Cs1Q2szZYHkHD1ucFmZr1WzCgVY7SjaEtCTRTEzUHd5bRto1TRaJJq+sczTV0n/89eXu5zSm9vIOGXUUyV9jMmRqYTrRVvet4CA2lAvRQs7NtAu86135YbpNKKg+hYTPze+fF7ML2PqAzP1XNgc1LaNjvrQ81PLDVnFuq1ozNU2i2Xl+3Li4820Y5waY3y2VQSeUtNCktM9cxsE1MVeNzqPffeV6/iq4zf3A93UpPqxp+KfDhFKbTfU9WV2B7OrPKbV6uun0TZtbzbdWUE1QJGtDOc/P0sDNTbkOKpepBA66zfQofRfuqpNZWTWhAM9doFOect0dxmhbxbU/s/6Odxx3RHFl0805ozpI/1nruv0Nsy8u8LfSDHYUccgnLbhN/3uShwPbEX4Zsy0307noKmvC2JK9x8VM35o9EInHYLThta264O6nTL/3y83zGioYdKfDLsHCdcoIrnnGdDUTj2y8QZEGTuEv+tMGGRphWiNYP1uyd2FToUYqnlVgs9ow5GThP08ThWOyFodBr+Pbl9y2Zv0Cz+XnDMADNIZq8hW9hGu8/Tc3vZ0Xjj/L+ruuIRBBHYiwSARrBKF8bQUV5c5Q+I5HhVVpB8MSh8dSnEE3YMPqx4dKdBYU00sKHZyrHa1ZeGMLJbpjsBgYrsQG28pshtvI4X53ea452biOv2fwjoHPqovKar18EOsdzRePnLOo6pgHAMvNF+LL0mt/uoGbpNehUfox33ITn3nuMe43RxQ6dQiOr7d+mCL32DE4Shwfg8/wAIUEcgpgDmkPvXFQBbfO9t9kCGswyO5rQF38G+rhqUGh4BGv4Uj1vAwehFktAw1mBJgiUEvetSgLhLjOg3fN8v2lb1eiJf1G0ShxGQhY0DOIa0sqCBoKJscdEg0HGSEGTLImGBSmQ+WQEAwUxcgk01K7QYPSjwBZ6NwVNqJPQuPi9cCUr1CLQDPAPhQYdaiAbmrcgmFm85o7/HM/Ha/C8Y9PMFzc3pQjG0TQ0Llu9pq5jWWySxmvufcy0rXp0Hm4sjN9y8H5jQUO4RMBT4pd/x3u3gcMAGkAURq/BGUADzYdy8Jp4fWKMBzN+nzEDmI/u98Sq4Ver4DjTAheT4U+asOUliGOnOBqYZ9V3r6HIJTI0zMQEGkzQYpQJ7E6boUFOti18nDKyn6PXHO2k1Azi2zv/zooGYtPwZ+7eQSEK4xglYcu0iGQodkUp3MUfRWo+laHRY8/JvyOjUKex53PfwzTAMIhMUTI0L8t8rsk8UOPmkTNHmc816Uy7dVUBaMzRAJsKHQ3wvMwxtExoNmgMzaoCx9CqRtm9RqtM0mi0tLS0tLRuQTWVNi226tJ3Fv+W7gGmSAr9GA+eGIvbLofGV001NEYtS345CptZG/SvM6cf3nSSGALOJjmgKUZgkqWKArz38lNDIz9oUm1UjY5KiTEFBzTSBDsaJktMsqpnlzyHGBsvtUqJxg/dUPftVB8sBI0YC82OJvPgQVINXImjCQKXxIspK9U5ijWa56YAzWhUsZ9XgftxhH4LTsNUiO5KYzP/lnEvwe81Lqte5JVm6MxvjEXi9X6zfJMJDeLFyhqNei6rMVHxgoEqW2MzbBmMiOKPdFRxaBGifFE/Lw01kp3KBF5Q4qUjPvyNW+OYOLM0++LfbISt1TmKNZznqgDNtlDJl93zZUbV37DxMo3MO3iNCAM0zE+IyGvUaxqi0tzQOLxqqdew3NBI7whGRYVBHFW0f22VmuU3WpmgxnrINqx9c3NkSVWaQDPoIXw1be0XMVA2+4AnHtj0zKKMILorQIuKLwnrWOGXeF3LCQ3vLr/soiQ0KOgCVTtLj+YfWI974wtyUaFppP5I/EQiD/IvuCWgYX+KblMmqIooRyNdMD0aOgGttqGRzb5hjsVEU5SI5q4Aje9MkKgADWi6+FZO9xoeGLjHp6IRlWbVmXl5De4NszxK8j7zmWVr3m6iUSY05YUmKEtJdjSiWWY1Jho3+UuK3BWgRcWX4hp5jbi/OKcBWMpU18uvRXzflbdkQePgNbRDvN521w+qCjdVUC1eow6dl9eg11u8xifSStmciqY4eYCrAjRFMMYrv+E9JhoWFi/sfWX2IftpMODLS5L3UUx0IEOTlWbVu+pbmdFr9u+o65B9FK+v6zCzXOLBkwx+D8NV/C03ZULSvSYZjekY02IpaHpNXQdu/qJqVi83BKUNRapWuSlA80jWD/ccw7jf4jXUgPMfnf2IuY+qNPsi4nlAPBcEeZgQlWaFRiRbWeIC7PUn6E2/OCadZJonVzKrGqbV+/8pq9zTpgn82YO/phNVaPwRy9Hk64nTNP3Ufatya5lximYTjThHmQquOZ701599KPtGWVWUkO2gUhZFy/OWQk5oPvmH5HjmTqVE4/SGQRG0QaMByaq2MbRSSP8PZ1paWlpaWlpaWlpaWlpaWlpaWlpaWlpaWlpaRdT/AZyNV+vR2+89AAAAAElFTkSuQmCC" alt="" />

                  <p>Si nos ponemos encima de cart el IS nos dice tipo de dato any; en otros componentes como <span class="file">Guitar.jsx</span> vemos que si nos ponemos encima de addToCart el IS nos dice tipo de dato any implícito. <span class="destacado">any en TypeScript es veneno.</span> Veamos cómo solucionarlo.</p>

                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/93-4-7XTUwsHJ.png" alt="" />

                </div>
                <!-- Fin bloque desplegable interior-->
                

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-95').toggle();">
                  <h3>95. Asignar Types a tus Props - Inline Type</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-95" class="hidden">
                  <p>Si nos llenamos de Any es como si no estuviéramos utilizando TS. Hemos de facilitar más información a TS. Vamos a <span class="file">Guitar.tsx</span> donde tenemos <code class="language-js">export default function Guitar({guitar, addToCart}) {</code> ese guitar que es un objeto y el addToCart que es una función. ¿Cómo convertimos esos props hacia TS? hay dos opciones:</p>

                  <ul>
                    <li><strong>inline type</strong></li>
                    <li><strong>separate type</strong></li>
                  </ul>

                  <p class="font-bold">inline type</p> 
                  
                  <p>en nuestro <span class="file">Guitar.tsx</span> <span class="destacado">añadimos el type</span></p> 
                  <pre><code class="language-js">
                    type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  </code></pre>
                  <p><span class="destacado">y a continuación especificamos el tipado a esas dos props que toma como parámetro la función de nuestro componente (objeto "guitarra" y funcion "addToCart"). Para especificar el tipo de dato usamos la sintaxis con ":"</span></p>

                  <pre><code class="language-js">                    
                  export default function Guitar({guitar, addToCart} : {guitar : Guitar, addToCart: (item: Guitar) => void}) {
                  </code></pre>

                  <p><span class="destacado">El primer parámetro es un objeto de tipo Guitar</span> y en cuanto lo tipamos vemos que del parámetro ya nos desaparece el aviso/error (antes el IS nos lo marcaba como any y ya nos aparece que es de tipo Guitar); </p>
                      
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/95-1-Dec-uNg8.png" alt="" />

                  <p>Fijémonos que todas las propiedades que definimos en nuestro type </p>
                  <pre><code class="language-js">
                    type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }                      
                  </code></pre>

                  <p>si en el return() de nuestro componente Guitarra (la parte de la vista) sustituyéramos por ejemplo <code class="language-js">{name}</code> por <code class="language-js">{guitar.}</code> vemos como en el IS solo me aparecen disponibles esas opciones (los tipos de datos que yo definí en ese objeto es lo que puedo imprimir ahí), no tenemos que enviarlo a la consola, ya lo tenemos disponible en VSC y eso va hacer que escribamos código más rápidamente:</p>

                  <img class="my-2.5" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAPoAAACLCAMAAAB/THRrAAAAA3NCSVQICAjb4U/gAAACplBMVEUhISJKZmAEOV5mzP8fZMQvPEixhB/fzbuIiL58iR8fH2Bpp97JRELMzMwmHx+rq6t8OzbX7/8EYZ1ckL6ZmZmAgIA0RlY2OR8EOcAEtOV+fn7U1NSczcQfHzw3o9oZa4K+5voEkdVERERUgakEOafXtF6AZUWsTB9PT0//+fUbJhyc3P5Quf4/UR8ba/Foo/BMcZOelIjHx8d1OV4EOXNWeoN1dXX/7NsyHx8akP+cuaczMSc3Nze+kcBra2t9zfX317YfN0qAgGcyVnNFlMYcPsQcJqckJyqMo4RKnMs0hLubNx9zVjLX/+UfidpoZB+8amqlpaW3t7e+kV7f9v8fRmdHaYdyuPdKnLNnRh8Xfqdrrd4Zn9saPhxkntKc3Np1zfVXdICWxuVEY34oMDaeOV45T2IcJoJ83P51t+BFHx+9vb2+saL/7+VviIgEVYiAdFccVtt9lfg/WnLDkXjvzacfHzI0OV7xTExWjKEfOaFFe5dXMx8XkMTv4NCunpctetaPj49SfaPX//VlqtAbfv/f/+VQo/BWhK2+sdsoKCgkLiS+8/WWzepngGdsrObv//91vv+skWr//+X///8tOUNQHx8fM1eM3P5lYV4EVcY2jNYmZsuXf3/Pt9VflcXv89Vusu7X//8wP0tYiLOCstRdnssZn/HXup0fUbOQhISGfnOO1/pltOXv/+XP8//v0KxCMioyQlAfH6cZVhy2qp1FZYA3o/AfH4RShK1wtfI3Hx8kOV6c3PBzgGf/9urTSEZrjIz/4MA6UmtYh7KIiNA/nMtJbYxjnNaKPTiAgHNWnNb/89Vde4iHbUwZn//3/P9zgICM3PC+8/////UsKSAfH0UEOX3/+fAzMzPn+f/W9/+OfnNngHPHsaKmlIjvzrU/nNYv5h2wAAAACXBIWXMAAA50AAAOdAFrJLPWAAAAFnRFWHRDcmVhdGlvbiBUaW1lADAxLzMwLzI1vVYACQAAAB90RVh0U29mdHdhcmUATWFjcm9tZWRpYSBGaXJld29ya3MgOLVo0ngAAAjLSURBVHic7Z2Lf9NUFMcvBVSsNQqpsooP6tCagmJF1FnrA5WpA6SoUz+oQ8AHFRXnZL6QqiBu6kAKqExxoqjF92v7IIofQPko6sT5wcfH53/iOefeZGm3bGuWrXn9sE16k9zke8+5J7mnd5YxX56U4tGX11Xu9i/Ty9Om9zS8L6+pSadwNpzHV5MZDergcqgAPd9MypqqSRycn2nJdQ2D9A6g5BVS2Iz3iIObTR1cfoU5etZUzFcPtvqihk4X33+qdn/PKsqqzhvJ6oVPfKNeqGJ9PyHAwZd1vnmTcBn1eWHTl0tY69l8XS2zy1KgM14WVpbNB8Ple5ARusJmT/jcmD7crCx7FA7WXAZWFtYwRKf1lfv375+i21b+5fHPX8XYjBoqyCqn38jRexdHNxD09cvni76O1gYdfG6JQOd66IpjtXPZRMrBA6fgMizQlclxUHXHyDGMtYO94WM1mh5Lb9nIOkbG49AIsHly/Is5TNido1NfvzZ8A9U7A2pVWs9eiebGfTq+AXRxLlvYHfXAgnvPxavn6LNv2dgxsopp6ABfje/C6ifMgU3V2ALVbHKVWoVAB6vP+O4RKjn4Fy5b949grQ8eiQVv04LOZQ/xvrrwkiVw9atORHTkaZ/wuQE6tVc7tkyVvg9AX7/9vE+g+bAmqvdaQkSHf+j6c9nhm0Vf5+eyZOxl+lWgz8I17L7OT/D+lG9Hq1cXWV3ROMnzhVN0NyDcHoB9/t0HDwj0BxaQ23N0svrhm0do57KNuBOGhdVnx9XOzNEVndUV9vEd1cLqenS8r18Od7e85vAi1uHNDa2urotzlb2Pa+QYehQR4Q8TTGj52XGdw4/6GYPax3eMobsdR8eq3jjukIIIz8PcZzUqrmr1jv+mqOeyjeiGo2gRHq2OZgfPnvBUFbBSwIdd2inC4/sZHJ33HR06fxREg1OQU7S+jl2d+ro4l82ktzqavBQp3RGea4atjGsk9dkuTM9jytfg0WDxMYb79Sro6/Q0p9tPF1P1z3j2szkZDp/hucOPKbodFF2vUryev6yz88cjmg0fBftst7JIP4Id1JC78fyjvvrw28a8JWPp4ZAefWY2TP/ypmq6urHx5Wz+6kZLLms41JsjmPTL36PO0mD6ShF5wGFilj0XR8uNUqqss3q03Ciliq6637HNAKREy41Sqqy710bVKsc++9Nph75YcJZ4Q/9XUpebVEKxBWI9H05MNkaUVwjgK7ZfeVIhvAl09ZAhRbdIUaxu7K1rV2zHFYB/qydHCTJxSInqQWC2A1Bff3ftij95vdMufX/9Ylqr7MrlcsAx/jVaBCpy+mVl16R47pd5uBXewcgN8RzYuS6H2q0VB6AUViqfueC1nKjXenTTiiLdOWfuxFp/ffLo315ZzS8xvptMWNnVANsnBcY/QSiBCo4EDdNAu4gNdfCxAuFUq4vi788K1K1fXNn1yzysyIbos56+Zumny++584+ldy0fP4vQJ77HOSa+ehYQoB0bODIHqOwC7AoAUxl3i7UCdGwzdBD4j+9iQ/TF07YdfdpPSx/bSR/06BXChQMT16LLEgyhq1FMh47bCtHxze7oePUfkNO/tLoQHS0rRK7bB3rvVoc326PjRYPTX0QtgFeNHVg4Ogk7cx2PVr2hx7GV6kRT8WIsghL7ok97Z9ffyxEde/s/OwUnuHmdiPAQu9HxeSxXI7y6F5VjKUHjjWG3VowRHtrKvugB6Om7/r7wXwB/bKe567GKawCyFp3gcznT4I5GB/iHfzAN7nB0x8hHtwLduqqcJh/di/LRGVu0prZ2zaLuDbFMOsnXkunIcF/VsEigA/iWrcfcrIOPJdJiW9Re6I9YVRHhLTp5x5atuALwU3vsYjOri3legxeiT92x7SPxcU+wbTStyKGQhMtYJhQK2Qp90wGLpvQA+oa24G38w8KWtpODW8UWGdGTadluVt+kTngarAB9a/DxlpaFbObUtpbr4EMBehhinc36upUOj7T1wdraYD1jxegRiHU2s7qVYY7T7n2dPn9UjG47q6Ms+fJJQ1+zBt7A6cepWwg9lUixufYKc5YJI/y4tn2EDuDBPbw4mYbAjjEeIr0s2Qzdoi8c6b5eH2zZt3cvgNdbU6kzJJ7Y6oPr1rU4B9yqvs61YYMV1TlJ/sjNi/LRvSgf3YsaQILKrRpAgsqtGkCCyq3qJ0Elz01ksrgW4XkqylfBaA6Xcrmu2SIB+ug+ElRyYno6PT0TiwFnJBFjkgTj2AjlrWIJmw3oSlU/CSpZSqYjqUwMC2KZFOImMzJLYQikHRwsLUG1o9cElSxFObpEjp5MS5S9QPcXKVvnqp8ElWp1GZwdrE4tIPO8lePVT4JKtboMrFIiJVwf+rnTYxzrN0GlWj2WCIXmCquj2fGz01N2pSWoyOrY2d2g0hJUeH9jsvB6p6vEBBU4fCLhDnJ/5OZJ+ehelI/uRRkmqNwvwwSV++UnqIoTVFEpnAnhAyuOUyTMyoQkKRShYY3Dh+maDBJUyUwihekYJscwExVNp6cnZBjGStQM5bxg62SQoKL5M2oGSpJFvkKKpWMuyVMwwwRVUkWnVJQs8hVSCofpIZck6A0SVKrVMf2qs3rKJeNVkkGCKqmhYw5SszqmJV0jgwSV1tdhgJ7utnoTJa7cE+YwR9NWlKCy2f98aUjkzBlUlsifQeVF+ehelI/uRfno/SeoZKd/u9hDA05QuRTduwmqfbU9ElQwXqEEFSwlMWOKf7UcEd+vu3cGVTQNpJIESyCUcKSK00nwW2ZqADfPoKLxeiSdjOIAnTJShK7m5dw8g4rG65FErPvP+whdtbSbZ1B1W70AXW0JV2QmDRJUiBxLyE1FVmcyn1Lh+hlUcvef7ZOHY4iT1RlUCbfOoLLh37FaLoMElc3+enlIZJCg8pDVvSgf3YtKuuDZxKy8+6sA3pX4gRQvfMVmKN3v3dh6aTFz2X+vq9Slr8HLt7s3ZdFvyAz5y5e1Knff9fu4r770P5fKqHfR7lcdAAAAAElFTkSuQmCC" alt="" />
                  
                  <p>Para definir el tipo del segundo parámetro (función addToCart que toma una guitarra), nos vamos al fichero <span class="file">App.tsx</span> e inspeccionamos el aviso del IS al ponernos encima del prop addToCart que aún no hemos tipado --&gt; <strong>item(any) =&gt; void</strong>.</p>
                    
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/95-3-C9bkpcCv.png" alt="" />

                  <p>Copiamos ese código. "void" es algo muy común en java, se usa cuando una función no devuelve nada. El any vamos a quitarlo: cuando yo agrego un elemento con el onClick del botón, le paso una guitarra completa:</p> 

                  <script type="text/plain" class="language-js">
                    <button 
                      type="button"
                      className="btn btn-dark w-100"
                      onClick={() => addToCart(guitar)}
                  >Agregar al Carrito</button>
                  </script>

                  <p>así que cambiamos ese any por Guitar, le decimos así que el item que maneja esa función que agrega tiene que ser una guitarra de tipo Guitarra. <span class="destacado">Y en definitiva estamos tipando ese parámetro como una función que toma un objeto Guitarra y no retorna nada.</span></p>
                      
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/95-1-Dec-uNg8.png" alt="" />

                  <p>Ya desaparecen los errores/avisos. Estamos tipando fuertemente. Si por ejemplo me voy a la <span class="file">App.tsx</span> y le quitamos la propiedad addToCart de aquí:</p>

                  <script type="text/plain" class="language-js">
                    <div className="row mt-5">
                      {data.map((guitar) => (
                          <Guitar 
                            key={guitar.id}
                            guitar={guitar}
                            addToCart={addToCart}
                          />
                      ))}              
                  </div>
                  </script>

                  <p>vemos que nos marca un error. Por tanto nos va a indicar si le falta algo, si escribimos algo mal, si le pasamos un valor de forma incorrecta</p>
                    
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/95-4-B-sFk80-.png" alt="" />

                  <p>Vamos a ver la otra sintasis de <strong>separate type</strong> que él indica que le gusta más.</p>

                </div>
                <!-- Fin bloque desplegable interior-->
                

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-96').toggle();">
                  <h3>96. Asignar Types a tus Props - Type Separado</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-96" class="hidden">
                  <p class="font-bold">separate type</p> 
                  <p>Veamos esta otra sintaxis que es menos confusa: podríamos hacer salto de línea a lo que tenemos ahora mismo para que quedara un poco más ordenado:</p>

                  <pre><code class="language-js">
                    export default function Guitar({guitar, addToCart} : {
                      guitar : Guitar, 
                      addToCart: (item: Guitar) => void
                  }) {
                  </code></pre>

                  <p>Sin embargo es mejor tener un type (o una interface) y tenerlo separado para minimizar la posibilidad de cometer errores:</p>

                  <pre><code class="language-js">
                    type GuitarProps = {
                      guitar : Guitar, 
                      addToCart: (item: Guitar) => void
                  }                
                  export default function Guitar({guitar, addToCart} : GuitarProps) {
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
                

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-97').toggle();">
                  <h3>97. Creando un Archivo de Types ¿Donde y como hacerlo?</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-97" class="hidden">
                  <p>Vamos a crear un archivo que centralice los types que se van a compartir más de una vez. Si nos fijamos ahora mismo el type Guitar que hemos creado lo tenemos tanto en <span class="file">db.ts</span> como en <span class="file">Guitar.tsx</span>, si tuviéramos que modificarlo porque el proyecto por ejemplo crece, el mantenimiento se hace complicado. <span class="destacado">Cuando tenemos un type que se comparte en diferentes componentes o Hooks lo mejor es ponerlo en su propio archivo</span>, hay dos maneras de hacerlo.</p>

                  <p>Si en en src creamos un archivo nuevo <strong>types.d.ts</strong> y metemos ahí nuestro types, creado así con ese nombre no necesitaríamos importarlo. Sin embargo ¡¡el equipo de desarrollo de TS no recomienda hacerlo de esta forma!!!</p>

                  <p>Creamos carpeta y archivo <strong>types>types.ts</strong> (también se podría llamar index.ts). En el solo metemos el type Guitar al cual le ponemos delante la palabra export:</p>

                  <pre><code class="language-js">
                    export type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  </code></pre>

                  <p>importamos ese type en los ficheros donde se va a utilizar: <span class="file">db.ts</span> y <span class="file">Guitar.tsx</span> </p>
                  
                  <ul>
                    <li>si hemos nombrado el fichero como <strong>index.ts</strong> lo importaremos así: <code class="language-js">import type {Guitar} from '../types'</code></li>
                    <li>si hemos nombrado el fichero como <strong>types.ts</strong> lo importaremos así: <code class="language-js">import type {Guitar} from '../types/types'</code></li>                  
                  </ul>
                  
                  <p>Como vemos no metemos en ese archivo exclusivo de types el otro type GuitarProps, porque no se trata de un type que vayamos a utilizar en diferentes componentes o diferentes Hooks; en este caso es un type exclusivo del componente <span class="file">Guitar.tsx</span>. <span class="destacado">Habitualmente así es como vamos a definir nuestros types, en el componente donde se requieren y en el caso de que se vaya a compartir en mas sitios (otros componentes y/o Hooks) entonces se mueve al archivo específico de types.</span></p>

                  <p>Como vemos, ya están completamente tipados nuestro <span class="file">db.ts</span> y nuestro componente de guitarra<span class="file">Guitar.tsx</span>. Migremos a continuación nuestro Hook personalizado para solucionar esos Any que aparecen en nuestro cart.</p>
                </div>
                <!-- Fin bloque desplegable interior-->


                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-98').toggle();">
                  <h3>98. Añadiendo un Type para los elementos del Carrito / 99. Heredar y extender un Type</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-98" class="hidden">
                  <p>Si miramos nuestro custom Hook <span class="file">useCart.ts</span> vemos que tenemos dos states: data tiene el type Guitar pero cart tiene un tipo Any.</p>
                  <pre><code class="language-js">
                    const [data] = useState(db)
                    const [cart, setCart] = useState(initialCart)
                  </code></pre>
                  <p><span class="destacado">Algo muy común en TS es que cuando obtenemos datos externos, sea de localStorage o de una consulta con FetchAPI, a TS se le hace muy complicado inferir el tipo de dato.</span> ¿Como hacemos para indicar que este const initialCart va a ser de tipo Guitar (o un tipo de elemento en un carrito)?</p>
                  <pre><code class="language-js">
                    const initialCart = () => {
                      const localStorageCart = localStorage.getItem('cart')
                      return localStorageCart ? JSON.parse(localStorageCart) : []
                  }
                  </code></pre>

                  <p>Importamos nuestro type <code class="language-js">import type { Guitar } from '../types/types'</code> Le especificamos a ese initialCart que el tipo de dato va a ser Guitar[] (pero array, que es un carrito):</p>

                  <pre data-line="0"><code class="language-js">
                    const initialCart = () : Guitar[] => {
                      const localStorageCart = localStorage.getItem('cart')
                      return localStorageCart ? JSON.parse(localStorageCart) : []
                  }
                  </code></pre>

                  <p>sin embargo inmediatamente vemos en nuestro código que TS se queja: <strong>"oye, estas diciendo que esto es un tipo Guitar, pero hasta en 3 funciones de tu Hook se intenta utilizar una propiedad "quantity" que no existe en ese tipo Guitar"</strong>. Cuando intentamos agregar una guitarra al carrito, sí es un objeto Guitar pero tiene una propiedad adicional llamada "quantity" que se requiere para estar en el carrito</p>
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/98-DoGHG_f8.png" alt="" />
                  
                  <p>Podríamos resolverlo, añadiendo un nuevo type en nuestro archivo <span class="red">types.ts</span>:</p>
                  <pre><code class="language-js">
                    export type CartItem = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                      quantity: number
                    }
                  </code></pre>
                  <p>Importamos nuestro type <code class="language-js">import type { CartItem } from '../types/types'</code> Le especificamos a ese initialCart que el tipo de dato va a ser CartItem[] (pero array, que es un carrito):</p>
                  
                  <pre data-line="0"><code class="language-js">
                    const initialCart = () : CartItem[] => {
                      const localStorageCart = localStorage.getItem('cart')
                      return localStorageCart ? JSON.parse(localStorageCart) : []
                    }
                  </code></pre>
                  
                  <p>así ya nos desaparecen los errores con el quantity que teníamos en nuestras funciones (aunque aún quedan algunos errores en parámetros que los veremos). </p>
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/98-2-Cp4l6brd.png" alt="" />

                  <p>Este código funciona pero se puede mejorar porque los atributos id, name, image, description, price son exactamente iguales en los dos types Guitar y CartItem.</p>
                  
                  <pre data-line="1-5,8-12"><code class="language-js">
                    export type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  export type CartItem = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                      quantity: number
                  }
                  </code></pre>

                  <p>TypeScript nos permite heredar como si fuera de una clase a otra y podemos hacerlo heredando todos esos atributos dentro de cartItem</p>

                  <p class="naranja">Heredar y extender un Type</p>

                  <p>Ya hemos definido nuestro segundo tipo de dato. Teníamos <strong>Guitar</strong> pero como nuestro carrito de compras tiene una propiedad adicional "quantity" hemos creado un type llamado <strong>CartItem</strong>. Ambos comparten muchos atributos por lo que apliquemos herencia para simplicar el código, también para que si cambia alguno de ellos el mantenimiento sea más sencillo. Como es un poco diferente en types e interfaces veos ambos.</p>

                  <p class="font-bold">herencia en types</p>

                  <p><span class="destacado">Borramos los atributos duplicados del type que hereda y en su declaración tras el "=" añadimos el nombre del type del que queremos que herede seguido de "&"</span></p>

                  <pre data-line="7"><code class="language-js">
                    export type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  export type CartItem = Guitar & {
                      quantity: number
                  }
                  </code></pre>

                  <p><strong>Podríamos perfectamente generar una interface y heredar de nuestro type:</strong> <span class="destacado">el "=" se cambia por la palabra "extends", de manera similar a lenguages como Java o php y se elimina el "&"</span></p>
                  <pre data-line="7"><code class="language-js">
                    export type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  export interface CartItem extends Guitar {
                      quantity: number
                  }
                  </code></pre>

                  <p>Existe otra forma de hacerlo, con los <span class="destacado">utility types</span>, solo se puede hacer con la sintaxis de type</p>
                
                </div>
                <!-- Fin bloque desplegable interior-->


                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-100').toggle();">
                  <h3>100. Utility Types en TypeScript</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-100" class="hidden">
                  <p>Acabamos de ver como se aplica herencia utilizando types e interfaces pero eso hereda todo el tipo de dato y sus atributos completos. Si bien podríamos hacer algo como cambiarle el number por string al atributo id del type original (no lo tengo muy claro que haga lo que dice por lo que veo en el IS)</p>

                  <pre data-line="1,9"><code class="language-js">
                    export type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  export type CartItem = Guitar & {
                      quantity: number
                      id: string
                  }
                  </code></pre>

                  <p>Otras veces lo que vamos a querer es, manteniendo los mismos tipos de datos simplemente tener algunos atributos de un type y/o omitir otros. Para eso es muy útil lo que se conoce como <span class="destacado"><a class="text-[#ffffff]" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" target="_blank">Utility Types</a></span>. Hay unos cuantos, en cada nueva versión se agregan más, va a hacer que nuestro código sea más corto y son muy útiles cuando comenzamos a tener varios  types interdependientes que comparten atributos. Pone como ejemplo estos dos para explicar sintaxis y como se utilizan <strong>Pick&lt;Type&comma; Keys&gt;</strong> y <strong>Omit&lt;Type&comma; Keys&gt;</strong></p>

                  <p>En el siguiente ejemplo el Utility Type Pick selecciona del type Guitar los atributos id, name y price y los coloca en este nuevo type CartItem:</p>
                  <script type="text/plain" class="language-js">
                    export type CartItem = Pick<Guitar, 'id' | 'name' | 'price'>
                  </script>

                  <p>aquí le agregaríamos el atributo extra "quantity" que no existe en ese type Guitar:</p>
                  <script type="text/plain" class="language-js">
                    export type CartItem = Pick<Guitar, 'id' | 'name' | 'price'> & {
                      quantity: number
                    }
                  </script>

                  <p>Omit es para lo contrario, excluir los atributos que se especifiquen:</p>
                  <script type="text/plain" class="language-js">
                    export type CartItem = Omit<Guitar, 'id' | 'name' | 'price'> & {
                      quantity: number
                  }
                  </script>

                  <p>Veamos a continuación como especificar type a los parámetros que aún nos marca en nuestro código como aviso/error</p>
                </div>
                <!-- Fin bloque desplegable interior-->
                          

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-101').toggle();">
                  <h3>101. Agregando el Nuevo Type a nuestro código / 102. Creando un Type para el ID de la guitarra</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-101" class="hidden">
                  <p>Vamos a nuestro Hook <span class="file">useCart.ts</span>para "terminar de migrar a TS" nuestras funciones:</p>
                  
                  <p class="font-bold">function addToCart(item){}</p>
                  <p>Importamos nuestro type Guitar y le especificamos al parámetro de la fcn que es de tipo Guitar</p>
                  <pre data-line="0"><code class="language-js">
                    function addToCart(item : Guitar) {
                      const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                      if(itemExists >= 0 ) { // existe en el carrito
                          if(cart[itemExists].quantity >= MAX_ITEMS) return
                          const updatedCart = [...cart]
                          updatedCart[itemExists].quantity++
                          setCart(updatedCart)
                      } else {
                          item.quantity = 1
                          setCart([...cart, item])
                      }
                  }
                  </code></pre>
                  <p>Vemos que nos marca estos errores ¿por qué?</p>
                  <img class="my-2.5" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAABTCAMAAABHwSm5AAAAA3NCSVQICAjb4U/gAAACHFBMVEUcOR8fYhQeaPFaHx+4iR+aXh8fH0K2cMvJ1NQfWsXKQ0PFeZGUzqhoo9ofZHmVecBAQEC7WliGVda43Ko7wfGMo4QfH6doZKfOcNYrHx98iR/FyAB83PDcuWK43ItoZIQfH4Q3ZMQan9toZB/MzMGVNB+c3Nq4o0PwTEy1zqiHuaqMuad5MzOotQBozfA+JiYfOcUfHxg3o/BPwdsfgYkfidrxyBQfH2JGmZtPtMUXfKiavsw7eR/xnxx83P64o3mEHx/FYh/OR2Cc3P5QH6fUsoJoicQfLKHKQ5iUgR+7hsA7o6jc3KozWh9QHx8dfP8bn/9Quf6fxdSEnwqM3NrczXnFancfH1zc3Iscj/FmzP/bhh96Hx/aY6EaaIT/tRh8o4QfSKHacMtEkMXb1wAfhhAztP8bUh8fedtEkISlhqF8o8TUxZ+czfClzaoXj8WHNTUfXpofUtu5wP43Hx/Q3KqrgB8ro/+cucSc3PDQ3IuMzcTBzMwfH3dPwf+M3P4cj/9io52oHx96asD/yBS7hqEfHx/WQkKnmXhaWrbBl1x8iafc3J2CstSlhsDQo0NwcHA7wf8fNJFPwfHU1NQfhLHacNZPo6glkPEXn/GlZB/U1MmcuaeczcSM3PDFhrYvIyPx1xCkLB/MzMxiHx+lhrYfZMS43J3b1wqAwKhEwfGfYR/FhqF+rMxvzv7FhsAfiYtEwf8fYZ8hhLUM4gapAAAACXBIWXMAAA50AAAOdAFrJLPWAAAAH3RFWHRTb2Z0d2FyZQBNYWNyb21lZGlhIEZpcmV3b3JrcyA4tWjSeAAAABZ0RVh0Q3JlYXRpb24gVGltZQAwMS8zMS8yNQXqZ2wAAAXmSURBVHic7Zv9f9NEHMcBcYoPQ5iNUphGJ3NUNqRYy0TmJD6hYVud0lnrAz7OJ0QE6tR1zkl8poIwJnY6ndanaat/off93uVhSZomadr0IZ8fcsk3l8vdO9/7XnKv3BpJp2/0Bm80/smwesBdf8jTwrc+7f7aNXpDjQBIW/er+x4D6H+uiovrBmD37/cr+94CWHv3cOVMZVU3AI2qAIDfFfBbAQC/K+C3AgB6Azc29qpZxrlicZNlSaNj93hUp7rKxAPuvNU865wlgONlrmp0mQDgnzLvF9YA1jXl87cBILmxWDyMexTAkSL2BdXM1LIA5g6TxmLTEcD0r9t1ZqYWAiCNPqvuT7+eJk/96sskGcCZTTqzyUXNJNPuPvqdYj73KHH5ogoADCtprRm1znzoaAKZdYGPNI05dzot7ypB8POVtMbM1EIesCoGJDcqoU4BcGQlrTEztVAMMI4CJOxPnyliCoPAj9sVs6qWBWBXLQSg3JugtY6/XW1V/JHZt4C7cNY63wLtpQCA3nCdH7XwUQEAvSEA4EctfJRzAFEh7N3tE1M93hXmSq4BJEJV3JVPMYgMgM3C9u44WMVNzeW6C3gDwElhHX98do3/ALghAR5aVADl8VgISfzAtUI+oekbfEoAe2zxhMRto/nJZfzADUNC74iUwKtDUmEGjpTCoiQ33Zhq78F4AwCQaIPkh8anQoRBmE8t3jITiuaVTIk85pABFJ7HlvGpqR64QvWAwhMjamGFH3qwwLJqQACFD+Ch5UmDSFNUANguDQBmw3ZDLnMAkDAD6uvzRN//pd66AQHEqPdWAoA9orciAJI9ahUNGhEA7bGVACRIasMDuG03D2iGxcb2ABqsuCEWCmQAyX23XQ7mMAltBAA8dRL9SEjgUxoPwBgBYgDkyBd96w6rWzcCAPR5GAfAq9koIIT1ACBbHh4rifdfQhCcEYQ3NB7ABg8M/zAOsMJIPouXrLt2gLxGUMNXYRdvCtoQWCc1FADLMbBGqg2AJUna2fduCLZXLdndPvKPkKf79VRtAPQt7fx01zG3Wy9qYFu1AXCsr2+X+60XNbCtYD5AbwgA+FELHxUA0BtqBYD+LL15fv6ZX7wqkhsqO3dA9PCN8y/8TNLx/eXzSNUD6Di6nqWi2G083fm+/Cc3/V1+8wFnxaP4V+41tTMA+ukl9borAMDulyxXE3gEIN5FWl9abzitAGALJjwFIJ+2BiCt/elji6sdAyiJophTnnhEFPF49knm2LOi+NUlwBIhabwLzpJjZbVABQAL2WyWNHaSJYMb/s1elDJZ0GuGzFH6ASXPr8Ex+bCKvZeaemiGugYFIPVbdQKnAOK/XcI00k1amZM9AHdBnbdLAIPgyUEWxQNeZitmrAEs7NkCCfcYaTzZnczu2bLhz0PlPYBOQDAPIJ/e8FkdE8KJ3gfwk10GIN/cVI4BdGFT4zeRMkvksesAgEijO45209MygHG2qsUSAHdWbSgsKpn8ljbeHoBEGOcqYosnEiFuFQDLPuC4C3SeFCeGYUtkBAA9g5yXQ6MCoN8OAHjaKHB60vjJQXQIewBw1k2YMgOgXa1jkJsgODsxrAQ31tQIiwER+tQNAOx5AFtKBD0BPWCQ2m0CoKGw5h5AVJqgPo6K4E7nyRyOAhgaNB4Q76I7+hhw4fyDePpxOuX335VvAsAMfeQLJMloPEDKXKTp38unTACw+bVo70gZAJ7GgBIL6+jrOWwiptAnumlyn8YDID+OAmww1gFIqgDwn8sMhn/ubDb7osYD0ACjwIXlL9SaUJ9X59dwgo0EQSMAT0cBt6rmPUDROx+eqpxJVW3eA9yqijdBpuS+ZUftr8+boG1pvwVsz5Kt2uoKrHRJnb4FXMndXJmzQuzWxRcA7ubKnBVity7Bb3J+V8BvBQD8roDfsr1wslXl2e/yzSrPFkw0qwIARlPbA2jaFXCuVGnhZMur0sLJllcQA4ymAEC7A2jzN0HXCyebVO3k7aYKAPhdAb/V9gD+B2xQzokK8j5IAAAAAElFTkSuQmCC" alt="" />
                  
                  <p>Si miramos nuestro fichero de <span class="file">types.ts</span> vemos que el type Guitar no tiene ninguna propiedad quantity, sin embargo sí habíamos definido un nuevo type CartItem que heredaba del type Guitar al que le añadíamos esa propiedad:</p>          
                  <pre><code class="language-js">
                    export type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                    }
                    export type CartItem = Guitar & {
                      quantity: number
                    }
                  </code></pre>
                  
                  <p><span class="destacado">Vamos a castear: tomar un tipo de dato y convertirlo a otro:</span> <strong>creamos una nueva variable newItem de tipo CartItem que toma una copia de lo que le estamos pasando a esta función item (usamos el operador spread) y además tiene la nueva propiedad quantity</strong>:</p>
                  
                  <pre class="verde" data-line="8,9"><code class="language-js">
                    function addToCart(item : Guitar) {
                      const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                      if(itemExists >= 0 ) { // existe en el carrito
                        if(cart[itemExists].quantity >= MAX_ITEMS) return
                        const updatedCart = [...cart]
                        updatedCart[itemExists].quantity++
                        setCart(updatedCart)
                      } else {
                        const newItem : CartItem = {...item, quantity : 1}
                        setCart([...cart, newItem])
                      }
                    }
                  </code></pre>        
                  
                  <p class="naranja">Creando un Type para el ID de la guitarra</p>
        
                  <p>Si nos fijamos en nuestro archivo <span class="file">types.ts</span> vemos que el id de las guitarras es de tipo number con lo que podríamos solucionar fácilmente nuestro "problema" en las tres funciones que nos quedan por migrar de nuestro custom Hook <span class="file">useCart.ts</span> tipando como <strong>number</strong> los tres parámetros id de las funciones:</p>
                  <pre><code class="language-js">
                    function removeFromCart(id) { --> function removeFromCart(id : number) {
                      function decreaseQuantity(id) { --> function decreaseQuantity(id : number) {
                        function increaseQuantity(id) { --> function increaseQuantity(id : number) {
                        </code></pre>

                  <p>pero <strong>¿qué pasaría si a futuro migramos y digamos que ya dejamos de utilizar MySQL o PostgreSQL, que tienen los IDS como tipo number y nos vamos hacia MongoDB que utiliza strings?</strong> pues que tendríamos que tener cuidado de cambiar el tipo string en nuestro fichero de types y también en todos los lugares en donde en nuestro custom Hook usáramos esos ids. <strong>Normalmente queremos que los posibles cambios repercutan en los menores lugares posibles, buscamos un código sencillo con buen mantenimiento.</strong> Por ello podemos:</p>
                  
                  <ul>
                    <li>Crear un nuevo type empleando el <span class="destacado">Utility Type Pick</span>, de manera que si eso cambia a futuro solo tenemos que tocar el type Guitar: <code class="language-js">export type GuitarID = Pick&lt;Guitar &comma; &apos;id&apos;&gt;</code></li>
                    <li>Crear un nuevo type empleando algo que se conoce como <span class="destacado">Lookup:</span> <code class="language-js">export type GuitarID = Guitar['id']</code>. En vez de tenerlo en este archivo de types lo podemos utilizar tal cual en nuestro Hook:
                    <pre><code class="language-js">
                    function removeFromCart(id) { --> function removeFromCart(id : Guitar['id']) {
                    function decreaseQuantity(id) { --> function decreaseQuantity(id : Guitar['id']) {
                    function increaseQuantity(id) { --> function increaseQuantity(id : Guitar['id']) {
                    </code></pre></li>
                  </ul>
                  
                  <p>Este evento no es necesario porqeu se setea en automático así que lo quitamos (la e):</p>
                  
                  <img class="my-2.5" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMcAAABGCAMAAABPN3CJAAAAA3NCSVQICAjb4U/gAAABPlBMVEUfHxgfZHnFyAAfH2KlZB/Q3ItiHx8mZsvOR2CkY9YXfKjOY6GlzapWeoMfUbPoVkLQo0OkLB8aaISGVdYan9vczXkfhhCHuao/UR8fOaHFYh8fH0O4o0NhR8scOR8eaPFWnMtojqLQ3KpDVmD/yBQfH4TcuWK4iR+EHx9io51KZmA/nMsXj8U/nLPacMs7LCHaVYNAQEAfUtssNDhWjKHkWD4fObMteta4o3kfH6jc3IsfiYu43J2jVSsmHx/bhh//1wAcj/9wmrC2cMs2jNZihZcbn/Hc3J02QUi4uWK2OR/c3Krb1wBUNyJiH0OyVy02OR8fHx8fOcU/UYMdfP8/nNZWnLMbUh/Q3J3aY6G43KpWnNZNZXFZd4Ybn//wTExKnNb/1wofLKEtOaFKnLNKnMtynbNrkabacNa2cNZvNHTVAAAACXBIWXMAAA50AAAOdAFrJLPWAAAAH3RFWHRTb2Z0d2FyZQBNYWNyb21lZGlhIEZpcmV3b3JrcyA4tWjSeAAAABZ0RVh0Q3JlYXRpb24gVGltZQAwMS8zMS8yNQXqZ2wAAAQMSURBVGiB7ZoLVxJBFMehtchCQ1HRyBSNZw9KS1KSsKKszXQqsdgMe5F9/y/QvfPYx6zAghSznP2f487uMMve39x7Z/cuhshoKDRsAwakgEMtBRxqKeBQSwGHWrJzRAyjXul6Rmn5oPvXJnQ91r9RhKSfT1kH369ecn6qjZ9elk6wcSz86mTgwk+O6IkDSDpxJKO6njmrO8t2tHGHnfH7znGLnyUwB8fkw07OAI7uvrKpE4fWAIhy1tVvckiGauNvHOPisjccHBHKgTTp2wckUigZxjx2GIZRSB/C1gBPLJyw2MMOHHn3x4lh5y/rPKIYBxy+GoM2T1uwM4FtfpabybphLOxkMRjZ2Tyq1lOtVo2O23BydeIooaFGweKAfSSb5GFk+oMGmPaiAH8TgFOvpA/nLQxqtckR/jRGyls5Er5B0HgIpxhJZJJR7iveDQAZ2gp/cLNrNUA5xj1HuvTojwlqMhpsmU930B+TuIEuHElKBfEVpoWcIx+zgiV8MZeMYjzNvovaYg66SQIYsBVDF2k+7KZ2CfmSWidyYMlh5oXDnGy7Pyosl9wcWsMMesrBIiVL81rfynE7TVrebeaS4GB5vfqsBaIcDg/E7025MDz4Q3DUXf6AjcsfEgc3kE+4+DjB80P4QeZg/lj9vWvOTx/+qIPtyyZHJVJnfrA7Bo8KNEckDpKH2bVxiHRJZMBG0x8kvBKj6xXvtta2BFuMWX6sp2ria/vID0z4D8IfOOsRmv503UI8XA2gG9crGCFz4AoEuaw1+MpTZoETXtH1x5Y/6HGGiG6LA8/D9eoPnXBcr1rHFphHDoV0rvuHQup2P5eOiaocNCGKhGw3HxV7fr5STc3i9rW9/WbR02CFOfabzT3cehpscjz4V+b8HwUcaing8Kj0zhFs56rVb9fham+r1adwuDQ96Mv0zSGeJfL0wUOW9cD48Qpu526JMReQY/PrUY+X66bzciQAQnvt+tTkWJuhjckRohzk/UyPl+smzxyiYGXzn6eFRYYWfFTtKtSdIycH8we4acCR5ZVDe8IMxiqVltfMH6LSblehinl3cazdGRQBk2eOBo+jLGdycqDOqlCFuXJcDTywPMcV1ApbOVaJ8gjCXsHRrkJdkjmEPzZf3hwMAFcveZ63KjrzvY4o+NpUqC5/kGH7g/DcEIss80QyCg2sV+0qVFd+hIacH2XdeqOmIwJ/tYmNVbi6K9SdaSfHsNerfiXfP8iw7x/9Srqfh1S7n3uV6s9XimnkOHyugEMtjR5H/NT9ttE/svnjrJ8VfCN7XC26X2P7RgGHWrJzbLj/TcA3cqy7G66fFXwjR1z5eOEdxfwIOIav0bufx099vOyO4POuvxVwqKWAQy0FHGppVDj+AnK6jvC78EGTAAAAAElFTkSuQmCC" alt="" />

                  <p><strong>Los que vemos que TS infiere bien, como por ejemplo los states derivados isEmpty (retorna un boolean) y carTotal (devuelve un number), no hay que ser redundantes y no hacemos nada más.</strong> Si TS no lo puede inferir como era el caso con LocalStorage nosotros intervenimos, y de esa forma tenemos completamente tipado nuestro Hook.</p>

                  <p>En el siguiente vídeo vamos a typar los props del Header, algunas son funciones y tienen una sintaxis particular.</p>              
                </div>
              <!-- Fin bloque desplegable interior-->
              

              <!-- Bloque desplegable interior-->
              <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-103').toggle();">
                <h3>103. Typando los Props del Header y Building del proyecto</h3>
                <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
              </div>
                <div id="seccion8-103" class="hidden">
                  <p>Añadamos TS a nuestro <span class="file">Header.tsx</span> que tiene entre otras cosas nuestro cart y los states derivados. Vamos a crear el type no inline (que es mas complicado en cuanto a sintaxis) sino separado y además solo en este .tsx (no lo metemos en el fichero de definición de types) porque es exclusivo para Header:</p>

                  <pre data-line="0,2,3,7"><code class="language-js">
                    import type { CartItem, Guitar } from '../types/types'

                    type HeaderProps = {                      
                    }
                    export default function Header({
                      cart, removeFromCart, decreaseQuantity, 
                      increaseQuantity, clearCart, isEmpty, cartTotal
                  } : HeaderProps) {
                  </code></pre>

                  <p>Para el siguiente prop <strong>removeFromCart</strong>, que es una función miramos en App.tsx, en la parte de la vista donde el tag del componente Header que es donde se envía ese prop; el IS nos dice que es una función que envía un id de tipo number y no devuelve nada. Pues eso mismo es lo que vamos a especificar en la definición de nuestro type HeaderProps. Y hacemos lo mismo con las siguientes props funciones <strong>decreaseQuantity</strong> e <strong>increaseQuantity</strong></p>

                  <pre><code class="language-js">
                    type HeaderProps = {
                        cart: CartItem[] //el carrito cart es de tipo CartItem como arreglo
                        removeFromCart: (id: Guitar['id']) => void
                        decreaseQuantity: (id: Guitar['id']) => void
                        increaseQuantity: (id: Guitar['id']) => void
                        clearCart: () => void
                        isEmpty: boolean
                        cartTotal: number
                    }

                    export default function Header({
                      cart, removeFromCart, decreaseQuantity, 
                      increaseQuantity, clearCart, isEmpty, cartTotal
                  } : HeaderProps) {
                  </code></pre>

                  <p>Comenta que una vez que hemos agregado <code class="language-js">type HeaderProps = {}</code> que se le conoce como el <span class="destacado">function signature o firma</span> estamos mucho más protegidos por parte de TS para que no pasemos cosas indebidas a nuestros componentes etc. Vemos ese tipo de posibles errores desde el momento en que estamos escribiendo el código, sin necesidad de esperar a compilar.</p>

                  <p>Compilamos nuestro proyecto. Vemos en el <span class="file">package.json</span> en el bloque de scripts>build que se llama a "tsc && vite build". <strong>tsc es el TypeScript Compiler</strong>. <span class="destacado">npm run build</span> construye nuestro proyecto haciendo todas las transformaciones de typescript hacia javascript. <span class="destacado">Ya con el build listo podemos subirlo a Netlify o Vercel o Github</span>.</p>

                </div>
                <!-- Fin bloque desplegable interior-->
                

              
          </div>
          <!-- Fin div colapsable-->


      </div>
      <!-- FIN SECCION 8 -->  
       
   	
      <!-- SECCION 7 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
        <div class="row">
          <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion07').toggle();">
            <h2>Sección 7: PROYECTO - Carrito de Compras - Crear tus propios Hooks</h2>
            <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
          </div>

          <div id="seccion07" class="hidden">
            <div class="row">
              <div class="col-12">

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion85-90').toggle();">
                  <h3>85. Ventajas y Como crear tus propios Hooks / 86. Instalando dependencias / 87. Creando el Hook de useCart</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion85-90" class="hidden">
                  <p class="naranja">Ventajas y Como crear tus propios Hooks</p>
                  
                  <p class="font-bold">Crear nuestro propios Hooks</p>
                  <ul>
                    <li><strong>Existe una gran ventaja de crear tus propios hooks, y esta es la de incorporar state y otros hooks de React en tu propio código para poderlo reutilizar en otros proyectos:</strong> esta es una gran ventaja porque actualmente nuestro código reside en nuestros componentes y nuestros componentes tienen cierta presentación, lo que lo hace que nuestro código no sea muy reutilizable para otros proyectos. Sin embargo, con un hook personalizado podemos copiar y adaptar todo lo que requerimos.</li>
                    <li><strong>Otra gran ventaja es la de organizar tu código:</strong> de esta forma el hook se va a encargar de toda la lógica, mientras que tu componente solamente se encarga de mostrar la información, la vista, solamente se encarga de mostrar la presentación y el código HTML.</li>
                    <li><strong>Nuestro código personalizado tendrá todas las ventajasde React, como son tener su propio State, podremos agregar Effects, integrar otros hooks de React y el performance que esto incluye.</strong></li>
                    <li><strong>Va a ser reutilizable con otros proyectos</strong></li>
                    <li>va a ser fácil de escribir testing de escribir las pruebas para tu código.</li>
                  </ul>

                  <p class="font-bold">¿Cómo vamos a crear nuestros propios hooks?</p>
                  <ul>
                    <li>Los hooks son funciones de JavaScript, pero tienen algunas reglas como vimos anteriormente.</li>
                    <li><strong>Nuestros hooks deben seguir la convención de nombrado que utiliza React, que es <span class="destacado">use</span> seguido del nombre de nuestro hook, como vimos anteriormente con los hooks <strong>Usestate, useEffect, etcétera</strong></strong> de esta forma React escanea tu código en búsqueda de posibles problemas con las reglas de los hooks y se segura de que nuestro código personalizado cumpla los estándares de React.</li>
                    <li><span class="destacado">Importante!</span> un hook normalmente solo debe de tener lógica y no presentación, porque para la parte de presentación están los componentes.</li>
                  </ul>

                  <p class="naranja">Instalando dependencias y Creando el Hook de useCart</p>
                  <p>Vamos a convertir el proyecto que llevamos hasta ahora de guitarla para que use un <strong>custom hook</strong>. Descargamos la carpeta (guitarla-useCart), la agregamos al area de trabajo en VSC, boton derecho "abrir en terminal integrado" e instalamaos dependencias con <span class="destacado">npm install</span> que son en base al sistema operativo.</p>

                  <p>Vamos a estar moviendo todo el código de antes del return() del App.jsx que maneja bastante lógica a un custom Hoook, para dejar limpio nuestro componente y hacerlo más reutilizable</p>

                  <p><span class="destacado">Creamos carpeta hooks donde se colocan los custom hooks</span>. Dentro creamos nuestro archivo hook personalizado que llamamos <strong>useCart.js</strong> (recordar que no es .jsx porque eso tiene parte de vista es el template). Los hooks son funciones de js con lo cual podemos definirlo como función "normal" o función arrow function pero <span class="destacado">siempre el nombre tiene que tener la palabra use y así React "escanea" el código para posibles violaciones de las reglas de los hooks</span>:</p>
                  <span class="file">useCart.js</span><br>
                  <pre><code class="language-js">
                    function useCart(){
                      
                    }
                  </code></pre>
                  <pre><code class="language-js">
                    const useCart = () => {

                    }
                  </code></pre>

                  <p>aquí es donde vamos a tener toda la lógica, todo lo que está antes de los return() del App.js y Header.jsx. Todo eso vamos a exportarlo para poder importarlo en otros componentes o donde sea que vamos a utilizar nuestro custom hook, pudiendo exportarlo de todas las maneras que se hacen exports en js:</p>
                  <pre><code class="language-js">
                    const useCart = () => {

                    }
                    export default useCart
                  </code></pre>
                  <pre><code class="language-js">
                    const useCart = () => {
                      
                    }
                    export {
                      useCart//de esta forma cuando lo importemos tenemos que usar ese mismo nombre
                    }
                  </code></pre>
                  <pre><code class="language-js">
                    export const useCart = () => {
                      console.log('Desde useCart')  
                    }                 
                  </code></pre>

                  <p>Para usar el custom Hook en nuestra App.jsx hemos de importarlo <code class="language-js">import { useCart } from './hooks/useCart'</code>. Si quisiéramos llamarlo dentro de nuestro componente principal de aplicación App.jsx hay que llamar a la función de igual manera que hacíamos con los otros hooks: <code class="language-js">useCart()</code></p>
                </div>
                <!-- Fin bloque desplegable interior-->


                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion88').toggle();">
                  <h3>88. Definir Valores y extraerlos en el Hook</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion88" class="hidden">
                  <p>¿Como hacemos para que el comportamiento de nuestro custom hook sea mas similar digamos al useState en <code class="language-js">const[data] = useState(db)</code> devolviendo algo. Supongamos que creamos una variable <code class="language-js">const auth = true</code> ¿como hacemos para que esté disponible en nuestro App.jsx? <strong>tenemos que agregar un return a continuación, que puede ser un Array pero se recomienda que sea un objeto.</strong> <span class="destacado">La ventaja de que sea un objeto es, que el mismo nombre con el que nombremos nuestras variables, funciones o state va a ser el mismo nombre para usarlo en nuestro componente.</span> Si usáramos un arreglo los retorna por posición, pero como normalmente vamos a tener en nuestro hook personalizado diferentes funciones/variables/states personalizados, lo ideal es que podamos acceder a ellos por medio de su nombre específico.</p>
                  
                  <span class="file">useCart.js</span>
                  <pre><code class="language-js">
                    export const useCart = () => {

                      const auth = true
                      return {
                        auth //de esta forma esta variable estará disponible donde yo esté utilizando mi custom hook
                      }
                    }
                  </code></pre>

                  <p>Por tanto. Una vez creada mi variable llamada auth, y colocada en el return de mi custom hook, en mi componente accedo a ella de la siguiente manera:</p>

                  <span class="file">App.jsx</span>
                  <pre data-line="3"><code class="language-js">
                    import { useCart } from './hooks/useCart'

                    function App() {
                      const { auth } = useCart()
                      console.log(auth)
                  </code></pre>

                  <p>De hecho si hacemos la prueba en nuestro componente de extraer una nueva variable <strong>carrito</strong> que en mi custom hook sí he definido pero no he metido en el return, obtengo un <strong>Undefined</strong> porque no podemos acceder a ese valor. Hemos de meterla en el return, separada por coma del resto de variables/funciones. Es muy similar a un export de los módulos de ECMAScript.</p>

                  <span class="file">useCart.js</span>
                  <pre><code class="language-js">
                    export const useCart = () => {

                      const auth = true
                      const carrito = []
                      return {
                        auth,
                        carrito
                      }
                    }
                  </code></pre>
                  <span class="file">App.jsx</span>
                  <pre data-line="3"><code class="language-js">
                    import { useCart } from './hooks/useCart'

                    function App() {
                      const { auth, carrito } = useCart()
                      console.log(auth)
                  </code></pre>

                  <p>Por tanto si tenemos distintas variables/funciones/states en nuestro custom hook hemos de colocarlas separadas por "," en el return de nuestro custom hook y, en nuestro componente, vamos a acceder a todo ello en estas "{}" de aquí ¡con el mismo nombre que tienen! <code class="language-js">const { auth, carrito } = useCart()</code></p>

                  <p>Veamos como migrar la lógica de nuestro carrito para usar nuestro custom hook</p>
                  
                </div>
                <!-- Fin bloque desplegable interior-->


                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion89').toggle();">
                  <h3>89. Migrando el Código hacia useCart / 90. Finalizando el Hook y Consideraciones</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion89">
                  <ul>
                    <li>Tomamos toda la lógica de antes del return de nuestro componente principal App.jsx y nos la llevamos a nuestro custom kook useCart.js.</li>
                    <li>Como los Hooks useState,useEffect y useMemo ya no se usan en los componentes sino en nuestro hook personalizado useCart.js, quitamos el import de nuestros componentes y nos llevamos ahí la importación. También hacemos lo mismo con los datos:
                      <span class="file">useCart.js</span>
                      <pre><code class="language-js">
                        import { useState, useEffect, useMemo } from 'react'
                        import { db } from '../data/db'

                        //necesitamos exportar toda esa funcionalidad para hacerla disponible donde quiera que yo importe mi custom hook
                        return {
                          data,
                          cart,
                          addToCart,
                          removeFromCart,
                          decreaseQuantity,
                          increaseQuantity,
                          clearCart,
                          isEmpty,
                          cartTotal
                      }
                      </code></pre>
                      </li>
                      <li>
                      <p>
                        <span class="file">App.jsx</span> Esta sería la expresión total para usar nuestro custom Hook y las funciones que tiene disponibles:</p>
                        <pre><code class="language-js">
                          import { useCart } from './hooks/useCart'
                        
                          function App() {                      
                            const { data, cart, addToCart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart, isEmpty, cartTotal } = useCart()
                        </code></pre>
                        
                        <p>También quitamos del tag Guitar el prop <strong>setCart={setCart}</strong> porque esa función <code class="language-js">const [cart, setCart] = useState(initialCart)</code>ya no está disponible al haberlo migrado a nuestro custom hook junto al resto de la funcionalidad:</p>
                        <pre class="error" data-line="3"><code class="language-js">
                          &lt;Guitar 
                          key=&lcub;guitar.id&rcub;
                          guitar=&lcub;guitar&rcub;
                          setCart=&lcub;setCart&rcub;
                          addToCart=&lcub;addToCart&rcub;
                        /&gt;	
                        </code></pre>
                      <p>Como vemos nuestro Hook tiene todas estas funciones. Algunos Hooks tienen más funciones otros menos, por ejemplo useState nos devuelve dos valores (state y funcion) y useEffect no devuelve nada es más toma como parámetro un callback. Si probamos de nuevo nuestra app vemos como funciona todo correctamente.</p>
                      
                    </li>
                    <li><p>Movamos también la lógica que tenemos presente en el componente que tiene la vista del carrito Header.jsx: tanto el import de useMemo como este código nos lo llevamos a nuestro custom Hook <code class="language-js">import { useMemo } from 'react'</code></p>
                    <pre><code class="language-js">
                      // State Derivado
                      const isEmpty = useMemo( () => cart.length === 0, [cart])
                      const cartTotal = useMemo( () => cart.reduce( (total, item ) => total + (item.quantity * item.price), 0), [cart] )
                    </code></pre>
                    </li>
                    <p>Recordemos que también tenemos que hacer disponibles estas dos funciones, añadiéndolas a la "lista objeto" de exportación que aparece en el return de nuestro Hook</p>

                    <p>Si probamos, vemos que tenemos muchos errores. Podríamos pensar en importar en nuestro componente Header.jsx el custom Hook y crear una nueva variable para usar las dos funciones isEmpty y cartTotal del custom Hook useCart(). Pero en ese caso vemos que no nos agrega guitarras al carrito ni funciona ¿por qué? <span class="destacado">Porque los custom Hooks funcionan como instancias de una clase, de esa manera con una variable en cada componente haciendo lo siguiente, en cada componente estaríamos creando un carrito distinto:</span></p>
                    <span class="file">App.jsx</span><br>
                    <pre data-line="2"><code class="language-js">
                      import { useCart } from './hooks/useCart'
                      function App() {                    
                        const { data, cart, addToCart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart} = useCart()
                    </code></pre>
                    <span class="file">Header.jsx</span><br>
                    <pre data-line="2"><code class="language-js">
                      import { useCart } from './hooks/useCart'
                      function App() {                    
                        const { sEmpty, cartTotal } = useCart()
                    </code></pre>
                    <p>Los carritos no saben de la existencia uno del otro, no están conectados, no están sincronizados. Sí, toda esa lógica está solo en nuestro custom Hook useCart.js que es único, pero cada vez que instanciamos (ver los dos códigos anteriores) estamos creando un nuevo data y un nuevo cart:</p>

                    <span class="file">useCart.js</span>
                    <pre><code class="language-js">
                      const [data] = useState(db)
                      const [cart, setCart] = useState(initialCart)
                    </code></pre>

                    <p>No funcionaría porque es como si estuviéramos creando nuevos objetos que siempre van a ser diferentes. <span class="destacado">Por tanto solo podemos tener una instacia de nuestro carrito de compras.</span> Eliminamos ese código de Header.jsx y extraemos en App.jsx esas dos nuevas funciones carTotal y isEmpty que acabamos de añadir en nuestro custom Hook, las pasamos via props y las extraemos en el Header:</p>
                    
                    <span class="file">App.jsx</span>
                    <pre data-line="0,10-11"><code class="language-js">
                      const &lcub; data&comma; cart&comma; addToCart&comma; removeFromCart&comma; decreaseQuantity&comma; increaseQuantity&comma; clearCart&comma; isEmpty&comma; cartTotal &rcub; = useCart()

                      return (
                      &lt;&gt;
                        &lt;Header 
                        cart=&lcub;cart&rcub;
                        removeFromCart=&lcub;removeFromCart&rcub;
                        decreaseQuantity=&lcub;decreaseQuantity&rcub;
                        increaseQuantity=&lcub;increaseQuantity&rcub;
                        clearCart=&lcub;clearCart&rcub;
                        isEmpty=&lcub;isEmpty&rcub;
                        cartTotal=&lcub;cartTotal&rcub;
                        /&gt;
                    </code></pre>

                    <span class="file">Header.jsx</span>
                    <pre><code class="language-js">
                      export default function Header({cart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart, isEmpty, cartTotal}) {
                        return (
                    </code></pre>

                    <p>Y así finalmente no vamos a tener errores y va a estar sincronizado nuestro state con las funciones de nuestro custom Hook. Aquí comenta que para manejar múltiples instancias de un objeto se maneja con un administrador global del estado como puede ser Redux toolkit, sustance, context API que lo vamos a ver un poco mas adelante</p>

                    <p>Como vemos nuestros componentes quedan limpios sin lógica, <strong>aún habrá ciertos casos donde necesitemos poner código antes del return de nuestro componente como apps con múltiples páginas usando React Router DOM o quieres ejecutar algún query una vez cargues en cierto componente.</strong></p>
                  </li>
                  </ul>
                  

                </div>
                <!-- Fin bloque desplegable interior-->
                
              

              </div>
            </div><!--Fin row-->
          </div>
          <!-- Fin div colapsable-->

        </div>
      </div>
      <!-- FIN SECCION 7 -->
      
      
      <!-- SECCIÓN 6 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
        <div class="row">
          <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion6').toggle();">	
            <h2>Sección 6: PROYECTO: Carrito de Compras - Creando el Carrito, introducción a Hooks y más</h2>				
            <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
          </div>
          
          <div id="seccion6" class="hidden">
              
            <div class="row">
              <div class="col-12">	
                
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-52').toggle();">	
                  <h3>52. La estructura de archivos de React</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion6-52" class="hidden">
                  <p><strong>index.html:</strong> Archivo html sobre el cual se monta la app de React. </p>	
                  <p><strong>App.jsx:</strong> nuestro componente principal de aplicación. Es donde estaremos agregando nuestros componentes.</p>	
                  <p><strong>index.css:</strong> para código css que aplique en toda la app</p>	
                  <p><strong>main.jsx:</strong> donde importamos la hoja de estilo y el componente ppal para que se inyecten en ese index.html</p>	
      
                    
                  <p>React es una librería de JS por tanto todo el código de JS que se genera es inyectado en el div <code class="language-html">&lt;div id="root"&gt;&lt;/div&gt;</code>. Por tanto es un DOM virtual, es código html que fue generado Unicamente con js. En este index podemos meter las google fonts o librerías de animaciones de css. Es nuestro archivo principal pero usualmente no vamos a hacer cambios aquí (solo el title)</p>
                  <p><strong>package-lock.json:</strong> no tocamos se genera a partir del package.json y las dependencias indicadas ahí</p>
                  <p><strong>package.json:</strong> dependencias y qué versiones están instaladas y utiliza este proyecto. De hecho en la parte de scripts, vemos que el de dev manda ejecutar <span class="destacado">vite</span>.</p>
                  <pre><code class="language-js">
                    "scripts": {
                      "dev": "vite",
                      "build": "vite build",
                      "lint": "eslint .",
                      "preview": "vite preview"
                      },
                  </code></pre>	
                    
                  <p>Si vamos añadiendo dependencias se van colocando aquí en el bloque siguiente de dependencias de proyecto y en el siguiente dependencias de desarrollo.</p>
                  <p>Nos fijamos en los dos logos que aparecen en la página de inicio. carpeta public --> 'vite.svg' y carpeta src>assets --> 'react.svg'. Vemos en nuestro <strong>App.jsx</strong> como se llaman esos logos usando la sintaxis propia de react conocida como <span class="destacado">jsx</span>: que nos permite combinar código html con código js. <span class="destacado">Importante como se importa cada cosa en función de donde esté (solo / si en public vs ./ si en src)</span></p>
                  <pre><code class="language-js">
                    import reactLogo from './assets/react.svg'
                    import viteLogo from '/vite.svg'
                  </code></pre>
                  <pre><code class="language-html">
                    &lt;a href=&quot;https://vite.dev&quot; target=&quot;&lowbar;blank&quot;&gt;
                    &lt;img src=&lcub;viteLogo&rcub; className=&quot;logo&quot; alt=&quot;Vite logo&quot; /&gt;
                    &lt;/a&gt;
                    &lt;a href=&quot;https://react.dev&quot; target=&quot;&lowbar;blank&quot;&gt;
                    &lt;img src=&lcub;reactLogo&rcub; className=&quot;logo react&quot; alt=&quot;React logo&quot; /&gt;
                    &lt;/a&gt;							
                  </code></pre>
      
                  <p>Vemos como el componente principal se llama App.jsx y también tenemos una css que se llama igual que ese componente App.css</p>
                  <p>Eliminamos la css, los logos y sus importaciones y uso en App.js, también el import y la const del state (mas adelante veremos) y dejamos solo lo siguiente:</p>
                  <pre><code class="language-js">		
                    function App() &lcub;
                    
                      return (
                      &lt;&gt;
                        
                        &lt;h1&gt;GuitarLA&lt;/h1&gt;
                        
                      &lt;/&gt;
                      )
                    &rcub;
                    
                    export default App
                  </code></pre>
      
                  <p><strong>main.jsx:</strong> es el archivo principal de nuestra aplicación de React. Recordemos que en index.html todo se agrega en el div <code class="language-html">&lt;div id="root"&gt;&lt;/div&gt;</code>. Este main.jsx lee ese div y entonces monta toda nuestra aplicación de React en ese div. Si nos fijamos en el main.jsx vemos que importamos dos librerias React (librería ligera) y react-dom que es lo que nos permite la integración con nuestro html (hay otra react-native para crearr apps para android y iphone). También aquí se importa el archivo css <strong>index.css</strong> que nos permite agregar estilos globales a todo nuestro proyecto. Lo vaciamos (y así el h1 ya no sale centrado verticalmente)</p>
                  <pre><code class="language-js">
                    import &lcub; StrictMode &rcub; from &apos;react&apos;
                    import &lcub; createRoot &rcub; from &apos;react-dom/client&apos;
                    import &apos;./index.css&apos;
                    import App from &apos;./App.jsx&apos;
                    
                    createRoot(document.getElementById(&apos;root&apos;)).render(
                      &lt;StrictMode&gt;
                      &lt;App /&gt;
                      &lt;/StrictMode&gt;&comma;
                    )	
                  </code></pre>
                </div>
                <!-- Fin bloque desplegable interior-->
      
      <!-- Bloque desplegable interior-->
      <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-53').toggle();">	
        <h3>53. Copiando el código HTML estatico a React</h3>			
        <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
      </div>
      <div id="seccion6-53" class="hidden">
        <p></p>
        
      </div>
      <!-- Fin bloque desplegable interior-->
      
      
      <!-- Bloque desplegable interior-->
      <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-54').toggle();">	
        <h3>54. Como Escribir código CSS en React</h3>			
        <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
      </div>
      <div id="seccion6-54" class="hidden">
        <p></p>
        
      </div>
      <!-- Fin bloque desplegable interior-->
      
      
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-55').toggle();">	
                  <h3>55. ¿Qué son los Componentes en React?</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion6-55" class="hidden">
                  <p>Una vez copiado (estructurado) el código estático de guitarras que descargamos, sigue siendo estático. Este App.jsx ya es un componente:</p>
                  <ul>
                    <li>Es una función y su nombre empieza por mayúsculas (para evitar problemas en la compilación). Lo que esté entre las llaves es el contenido de ese componente pero podemos pasarlo a otros por medio de algo llamado props (lo veremos mas adelante)</li>
                    <li>Tiene un return que devuelve lo que se ve en pantalla</li>
                    <li>Lo que está antes del return se utiliza para algo</li>
                    <li>lo que está después tiene otro fin</li>
                    <li>Básicamente es tener HTML y JS en un solo archivo</li>
                    <li><strong>¿Qué son los coponentes en React?</strong> React utiliza componentes para la creación de aplicaciones y sitios web. Actualmente nuestro App.jsx tiene demasiado código; (tiene mas de 100 líneas, podemos pensar en dividirl en componentes)</li>
                    <li><strong>Un componente puede tener la extensión <span class="destacado">.jsx (si utilizamos js)</span> o <span class="destacado">.tsx (si utilizamos typescript)</span>.</strong> .js taambién es posible pero se recomiendan las dos primeras</li>
                    <li><strong>Un componente normalmente tiene dos propósitos:</strong> ser reutilizable y/o separar la funcionalidad. Si se cumplen ambas mejor.</li>
                    <li><strong>Siempre tiene que tener un <span class="destacado">return()</span> que es lo que se muestra en pantalla</strong></li>
                    <li></li>
                  </ul> 
      
                  <p>Creemos en una nueva carpeta que llamamos "components" nuestro primer componente: <strong>Header.jsx</strong>. Si en el return metemos un h1, vemos que en la app no se muestra nada porque nuestro componente principal App.jsx no sabe de la existencia de este nuevo componente Header.jsx. Hay que exportarlo e importarlo. podemos poner al final del archivo <strong>export default Header</strong> o mejor, colocarlo antes de la palabra function y lo tenemos en una sola línea <span class="destacado">export default function Header(){}</span>. Ahora ya podemos importarlo en cualquier otro componente:</p>
                  <pre><code class="language-js">
                    export default function Header(){
      
                      return(
                        <h1>Desde Header</h1>
                      )
                      
                    }							
                  </code></pre>
                    
                  <p>Lo importamos en nuestro componente ppal de Aplicación App.jsx usando al ppio la palbra import y con el autocompletado ya nos sale nuestro Header.</p>
                  <p>Aún tenemos que renderizarlo (como si fueran tags HTML). Importante:</p>
      
                  <pre><code class="language-html">
                    &lt;Header/&gt; &lt;!-- sintaxis de componente React --&gt;
                    &lt;header&gt; &lt;!-- tag HTML --&gt;							
                  </code></pre>
                  
                  <p>Si volvemos a nuestro primer componente y nos fijamos en lo que hay dentro del return() vemos que tenemos un tag de html h1. Esto de primeras parece un poco raro, veamos qué es el jsx</p>
                </div>
                <!-- Fin bloque desplegable interior-->
      
      
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-56').toggle();">	
                  <h3>56. ¿Qué es JSX? / 57. Renombrando class a className de nuestro proyecto / 58. Creando un Componente para cada Guitarra </h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion6-56" class="hidden">
      
                  <ul>
                    <li><span class="destacado">JSX</span> <strong>Javascript Syntax Extension:</strong> es una extensión del lenguage desarrollada también por META (Facebook) para React y es una sintaxis especial para poder agregar HTML y JS en un solo lugar. Al ppio parece un poco complicado pero se ven los beneficios conforme comenzamos a trabajar con ella.</li>
                    <li>Parece JS (los componentes son funciones) pero muestra código HTML. Básicamente <strong>es un lenguage de Templates/Vistas</strong> que muestra HTML pero tiene todas las funciones de Javascript (todo js puede usarse en los archivos .jsx)</li>
                    <li><strong>Una vez compilado son archivos JS con funciones y objetos</strong></li>
                  </ul>
      
                  <p>En la parte anterior del return() podemos colocar código js, probemos con una variable const = name. Para comunicar esto en nuestra vista (dentro del return) <span class="destacado">hay que hacerlo entre llaves {}</span>. <br><span class="rojo">Ojo!</span> si intentamos poner solo {name} sin ningún tag nos da error. También si pongo dos o mas tags html seguidos!!!! Veamos las reglas de JSX y evitar estos errores</p>
      
                  <ul>
                    <li>A diferencia de HTML, <strong>en JSX si un elemento HTML tiene tag de apertura ha de tener también el de cierre (los tag &lt;link&gt; &lt;img&gt;A o &lt;input&gt; habr&aacute; que cerrarlas con /&gt;)</strong></li>
                    <li><strong>Cada componente debe tener un return</strong></li>
                    <li><strong>En el return solo puede haber un elemento (un tag) en el nivel superior=máximo</strong> --&gt; podría tener un &lt;div&gt; padre englobando todo en el return pero al final cargaríamos nuestro código con divs innecesarios. Para evitar eso usamos los <span class="destacado">Fragment</span>. esta sintaxis que vemos en el ejemplo de nuestro componente principal de aplicación App.jsx es una de las 3 maneras de usar Fragment: <strong>&lt;&gt;</strong>
                      <ul>
                        <li><code class="language-js">import { Fragment } from "react"</code> <code class="language-html">&lt;Fragment&gt;&lt;/Fragment&gt;</code></li>
                        <li><code class="language-js">import React from "react"</code> <code class="language-html">&lt;React.Fragment&gt;&lt;/React.Fragment&gt;</code></li>
                        <li>Sin hacer ninguna importación simplemente usamos: <code class="language-html">&lt;&gt;&lt;/&gt;</code></li>
                      </ul>
                    
                    </li>
                  </ul>
      
                  <p>Veamos un resumen de lo que es un componente:</p>
      
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/56-DRk3POVL.jpg" alt="" />
                  <p>Si vemos la consola nos sale este mensaje de error y es porque en React "class" es una palabra reservada del lenguage js. Con objeto de no mezclar el uso de ese "class" (que es de estilos) con el uso de la palabra reservada de js cuando definamos states, variables..., se soluciona sustituyendolo por className:</p>
      
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/57-BKmSUcyc.jpg" alt="" />
      
                  <p><span class="destacado">Se recomienda usar tags HTML semantico pero en lugar de class usamos className</span> (eso conecta en automático con el archivo de css de nuestro proyecto). Esto es solo de cara a desarrollo, una vez que compila el proyecto se agregan clases normales. Nos llevamos todo el códiog del header al nuevo componente Header.</p>
      
                  <p>Creamos un nuevo componente <strong>Guitar.jsx</strong> con el contenido de la primera guitarra y borramos las otras del App.jsx. Lo llamamos desde nuestro App.jsx (la integración con VSCode es muy buena, no hace falta que tecleemos la línea de importar ese cpomponente, con solo escribirlo y enter en el autocompletado nos añade la línea.)</p>
      
                  <p>Veamos a continuación que son los React Hooks que nos van a permitir Integrar toda las funcionalidades de React con nuestra interfaz</p>
                  
                </div>
                <!-- Fin bloque desplegable interior-->
      
      
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-59').toggle();">	
                  <h3>59. Introducción a los React Hooks / 60. ¿Qué es el State en React? y useState / 61. Reglas de los Hooks / 62. ¿Qué es useEffect?</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion6-59" class="hidden">
                  <p>Los <span class="destacado">React Hooks</span> son la base de React. Nos van a permitir Integrar toda las funcionalidades de React con nuestra interfaz.</p>
                  <ul>
                    <li><strong>Los Hooks permiten usar las diferentes funciones de React en nuestros componentes. React tiene una serie de Hooks pero también podemos crear los nuestros.</strong></li>
                    <li><strong>Los Hooks están disponibles desde la versión 16.8 de React, previo a ello se tenían que crear Classes para crear y modificar el state, con los Hooks no es necesario.</strong></li>
                    <li><strong>Existen muchos y se dividen entre Básicos y adicionales</strong></li>
                    <li>Son los siguientes (como vemos, el nombre de todos empieza con la palabra <strong>use</strong>). Los básicos que están en casi todos los proyectos son los 3 de la izquierda. Los otros son más avanzados que se utilizan para librerías o casos más específicos.</li>
                    <li><img class="my-2.5" src="https://andune55.github.io/manual-react/assets/hooks-YO7Fs55Y.jpg" alt="" /></li>
                    
                    <li>También podemos crear nuesros propios Hooks así podremos separar nuestro código en funciones reutilizables y sacar todo el beneficio de lo que React ofrece.</li>
                  </ul>
      
                  <p>Comenzamos utilizando el más común de todos <span class="destacado">useState</span>. Tiene un <a href="https://gist.github.com/codigoconjuan/f333ee8422b0b8c4fde227e81e626cce" target="_blank">Gist con todas las guitarras</a> preparado para utilizarlo en nuestra App simulando una base de datos, pero primero hemos de ver el Hook más común de todos <strong>useState()</strong> y ello nos lleva a ver qué es el <span class="destacado">state en React</span> que es la pieza central de React.</p>
      
                  <p class="font-bold naranja">¿Qué es el State en React?</p>
                  <ul>
                    <li><strong>El Estado o State en React es una variable con información relevante en nuestra aplicación de React</strong>, algunas veces el state pertenece a un componente en específico y otras veces quieres que sea compartido a lo largo de diferentes componentes.</li>
                    <li><strong>Pensemos en el state como el resultado de alguna interacción en el sitio o aplicación web: el listado de clientes, la imagen a mostrar en una galería, si un usuario está autenticado o no,...</strong></li>
                    <li><strong>El state es creado con el Hook useState()</strong>. Veamos un ejemplo:</li>
                  </ul>
      
                  <p>Importamos el Hook <code class="language-js">import { useState } from "react"</code> y la forma en que vamos a definir nuestro state es así: <code class="language-js">const [customer, setCustomer] = useState({});</code> Creamos una variable const y colocamos entre corchetes [] (useState siempre va a devolver un Array (aquí estamos aplicando Array Destructuring)) y podemos ver que estamos nombrando nuestro state como <strong>customer</strong> y usamos <strong>setCustomer</strong> (este nombre, usar "set", es una convención) a continuación un = seguido de un objeto dentro de paréntesis <strong>({})</strong>, es lo que se conoce como el valor inicial. Veamos más ejemplos de state y cómo, el valor inicial será una u otra cosa en función de qué tipos de datos tengamos:</p>
                  <pre><code class="language-js">
                    const [customer, setCustomer] = useState({})
                    const [total, setTotal] = useState(0)
                    const [products, setProducts] = useState([])
                    const [modal, setModal] = useState(false)	
                  </code></pre>
      
                  <p class="font-bold">Anatomía de useState: state, función y valor inicial</p>
                  <p><code class="language-js">
                    const [customer, setCustomer] = useState({});</code></p>
                  <ul>
                    <li><strong>customer</strong> es el state, la variable que va a tener toda la información</li>
                    <li><strong>setCustomer</strong> es la función que modifica el state, es la fcn que siempre vamos a usar cuando queramos realizar cambios en nuestro state (en este ejemplo customer)</li>
                    <li><strong>useState</strong> es el Hook que nos da React</li>
                    <li>el objeto vacío <strong>({})</strong> es el valor inicial</li>	
                  </ul>
      
                  <p class="font-bold">React reacciona en base al state</p>
                  <ul>
                    <li>Cada vez que el state cambia, la aplicación de React va a renderizar y actualizarse con esos cambios, no es necesario hacer nada más (recargar página o actualizar el DOM) y nuestra interfaz siempre va a estar sincronizada con el state.</li>
                    <li>Para modificar el state, se utiliza la función que extraemos cuando declaramos el state en nuestro componente.</li>
                  </ul>
      
                  <p>Para implementar useState en nuestra App Guitarlab, cerramos todo y dejamos abierto únicamente el componente principal de App, <strong>App.jsx</strong>.</p>
                  <ul>
                    <li><code class="language-js">import { useState } from "react"</code></li>
                    <li><strong>El state hay que definirlo en nuestro componente, ni fuera de él ni dentro del return() sino justo antes del return</strong>. Hay ciertas reglas para los Hooks que estaremos viendo a continuación. </li>
                    <li>lo más básico que nos da react es esto: <code class="language-js">const [] = useState()</code> pero <strong>nosotros tenemos que definir nombre del state, nombre de la función y su valor inicial.</strong>. Supongamos que vamos a crear un state para revisar si un usuario está autenticado o no, si lo está le mostramos un componente y si no lo llevamos al panel de iniciar sesión. <code class="language-js">const [auth, setAuth] = useState(false)</code>. Si sacamos un console.log del state lo vemos (y de hecho 2 veces, uno desde el Componente ppal App.jsx y otro desde el InstallHook.jsx, no nos preocupemos, React forzó en nuevas versiones este doble render para garantizar que se hace buen uso de React). Pero en vez de por consola usemos React developer tools.</li>
                    <li><strong><a href="https://chromewebstore.google.com/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=es&pli=1" target="_blank">React developer tools: </a></strong> una vez instalado y reiniciado chrome, en web developer tools tenemos una pestaña nueva llamada components, en la que vamos a ver intuitivamente el árbol de componentes de nuestro proyecto de React (App, Header, Guitar). Si pulsamos en App, vemos en el apartado de Hooks el state y su valor.</li>
                  </ul>                    
      
                  <p class="naranja">Reglas de los Hooks</p>
      
                  <p>Vamos a crear más states. Va a ser muy normal que una App tengamos varios states o el uso de varios Hooks:</p>
                  <pre><code class="language-js">
                    const [auth, setAuth] = useState(false)
                    const [total, setTotal] = useState(0)	
                    const [cart, setCart] = useState([])
                  </code></pre>
      
                  <p class="font-bold">Reglas de los Hooks en React</p>
                  <ul>
                    <li><strong>Los Hooks se colocan en la parte superior de los componentes de React.</strong> ni dentro de bucles/interacciones, ni dentro de funciones.</li>
                    <li><strong>No se deben colocar dentro de condicionales ni después de un return:</strong> los Hooks no se pueden registrar en base a una condición porque esa condición puede cambiar en algún momento y entonces tendremos un error.</li>
                  </ul>
      
                  <p class="naranja">¿Qué es el Hook useEffect?</p>
                  <ul>
                  <li>Tras el useState, <strong>useEffect es el segundo Hook más común que vamos a usar, es muy versátil y lo usaremos mucho</strong>. </li>
                  <li><strong>useEffect siempre es un callback</strong> que, dependiendo como lo declares, va a realizar diferentes acciones.</li>
                  <li>Es el Hook más versátil, sustituto de lo que, en versiones previas de React donde había Clases y métodos del ciclo de vida, era conocido como <strong>componentDidMount()</strong> y <strong>componentDidUpdate()</strong></li>
                  </ul>
      
                  <p>Importamos el Hook <code class="language-js">import { useEffect } from "react"</code> y para usar este Hook, dentro del () vemos que tiene un calllback que se puede poner como function o como arrow function. Los corchetes del final es lo que se llama <strong>arreglo de dependencias</strong> que ahora veremos:</p>
                  <pre><code class="language-js">
                    useEffect( () => {
                      console.log('El componente está listo')
                    }, [])	
                  </code></pre>
      
                  <p class="font-bold">Usos de useEffect()</p>
                  <ul>
                    <li>Al ejecutarse automáticamente cuando el componente está listo, es un buen lugar para colocar código para consultar una API o para obtener datos del LocalStorage.</li>
                    <li>Debido a que le podemos pasar una dependencia (que usualmente va a ser un state) va a estar escuchando por los cambios que suceden en una variable, pudiendo actualizar el componente (o ejecutar ciertas funciones) cuando ese cambio ocurra (podemos estar sincronizando con LocalStorage por ejemplo).</li>
                    <li>Dependiendo del valor que pasemos en el array de dependencias (o si no pasamos nada) el Hook userEffect va a hacer algo diferente:
                      <ul>
                        <li>Si dejamos el arreglo de dependencias vacío (significa que no tiene dependencias) el código especificado en el Hook solo se ejecuta una vez, y lo hace cuando el componente esté listo. Si sacamos un console.log por consola veremos que solo sale 1 vez (sale 2 pero por loq ue decíamos de la comprobación del modo estricto en el main incluido por el equipo de React en versiones recientes)
                          <pre><code class="language-js">					
                            useEffect ( () => {
                              console.log('Componente listo')
                            }, [])					
                          </code></pre>
                        </li>
                        <li>Si le pasamos un state (o varios), cada vez que cambie cada uno de esos states se ejecuta el efecto (la función) que especifiquemos en el Hook useEffect. En este caso añadimos un setTimeout que nos cambia el state Auth pasados 3 segundos. Veremos que se ejecuta una vez cuando el componente está listo (vemos esas 2 del modo estricto del main.jsx) y pasados 3 sg al cambiar el state auth se vuelve a ejecutar:
                          <pre><code class="language-js">
                            useEffect ( () => {
                              console.log('Componente listo o escuchando por auth')
                            }, [auth])
                          
                            setTimeout(() => {
                              setAuth(true)
                            }, 3000); 
                          </code></pre>
                        </li>
                      </ul>
                      
                      <p>De esta forma, podemos tener funciones que se ejecuten cuando cambie algún state en nuestra aplicación, para eso es el useEffect(). Es muy útil.</p>
                      <p>¿podríamos hacer lo siguiente? meter un condicional para ejecutar un código solo en el caso de que el usuario esté autenticado? (comenta que hay gente que dice que no se puede usar eso dentro de un useEffect, pero él afirma que se utiliza muchas veces y que es correcto)</p>
                      <pre><code class="language-js">
                        const [auth, setAuth] = useState(false)
                      
                        useEffect ( () => {
                          if(auth){
                            console.log('Componente listo o escuchando por auth')
                          }
                        }, [auth])
                        
                        setTimeout(() => {
                          setAuth(true)
                        }, 3000);				
                      </code></pre>
      
                    </li>
                  </ul>
                </div>
                <!-- Fin bloque desplegable interior-->
      
      
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-63').toggle();">	
                  <h3>63. Añadiendo los Productos al State / 64. Iterando sobre los productos en React / 65. Props / 66. Mostrando la Información de cada Guitarra- 
                    <a class="text-[#000000]" href="https://gist.github.com/codigoconjuan/f333ee8422b0b8c4fde227e81e626cce" target="_blank">Gist Guitarras</a></h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion6-63" class="hidden">
                  <p>Veamos como incorporar este <a href="https://gist.github.com/codigoconjuan/f333ee8422b0b8c4fde227e81e626cce" target="_blank">listado de Gist que simula ser una pequeña base de datos de guitarras</a> para hacer nuestra interfaz dinámica y no mostrar una única guitarra. Sobre todo también hacer el componente <strong>Guitar</strong> más inteligente.</p>
      
                  <p>Creamos en src una carpeta para los datos y un .js con los datos de ese git copiados en raw: <strong>data/db.js</strong>. Es una pequeña base de datos con 12 guitarras cada una con un id, descripción y precio; las imágenes están mapeadas con nuestra carpeta de imágenes. Vamos a nuestro componente principal <strong>App.jsx</strong> e importamos esta base de datos ayudándonos del autocompletado: <code class="language-js">import { db } from "./data/db"</code>. Si hacemos un console.log(db) podemos ver esa bbdd local. Hagámoslo al estilo de React. Se puede hacer de dos formas:</p>
      
                  <ul>
                    <li>Como es un archivo local, podemos ponerle que el valor inicial del state data es lo que tengamos en db
                      <pre><code class="language-js">const [data, setData] = useState(db)</code></pre>. Vemos en la pestaña de componentes, en el compo App > hooks toda la información de nuestro state. Está bien porque es un archivo local, lo va a leer, importar montar y después montar nuestro componente.</li>
                    <li>Si trabajáramos con una API usualmente usaremos un useEffect, esto en caso de hacerlo sin dependencias (hay muchas dependencias enfocadas a consumir APIS que se integran bastante bien con React y que lo hacen con un rendimiento excelente aunque es más para grandes proyectos, pero no es nuestro caso). <span class="destacado">Con mi arreglo de dependencias vacío, una vez el componente esté listo especificamos setData(db), es decir seteo en mi state mi base de datos que tenemos en el archivo indicado en la importación.</span>
                    <pre><code class="language-js">
                      const [data, setData] = useState([])
                      useEffect( () => {
                        setData(db)
                      },[])			
                    </code></pre>
                    si miramos en la pestaña componentes del web developer vemos que se coloca la información de las guitarras dentro del state.
                    <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/63-db-productos-en-state-Bgv4--2h.jpg" alt="" /></li>
                  </ul>	
      
                  <p>Si esto lo haces desde una API esta forma es la más recomendada porque una API va a conectarse y traerse la información, no sabemos cuando, entonces quieres que se mande llamar una vez que el componente esté listo. Un poco más adelante cuando veamos cómo integrar APIS con React volveremos sobre esto.</p>
      
                  <p>Una vez tenemos en nuestro state la información de la BBDD de nuestras guitarras, veamos cómo iterar sobre él y comenzar a mostrar la información de nuestras guitarras.</p>
      
                  <p class="naranja">Iterando sobre los productos en React</p>
      
                  <p>¿Como sabemos cual es el valor inicial de nuestro state? En nuestro caso es un arreglo y tenemos dos elementos. Hay muchas formas de iterar un arreglo, un for, un forEach. <span class="destacado">Es importante mencionar que antes de nuestro return() podemos escribir lo que se conoce como statements o expresiones, sin embargo dentro del return solo podemos escribir expresiones</span></p>
      
                  <ul>
                    <li><strong>Statement</strong> Una app de js es una serie de statements. Cada statement es una instrucción para hacer algo. Algunos statements muy comunes son <strong>creación de variables</strong>, <strong>códigos condicionales con if</strong>, <strong>lanzar errores con throw new Error()</strong>, <strong>Iterar con While o For</strong></li>
                    <li><strong>Expressions</strong> Una expresión es algo que produce un valor. Algunos ejemplos de Expressions son <strong>ternarios</strong>, <strong>utilizar un Array method que genere un nuevo array</strong>, <strong>map() que genera un nuevo array a diferencia de forEach</strong></li>
                  </ul>
      
                  <p>Por tanto, tenemos un Array queremos iterar sobre él y como hemos visto un bucle For o un While no se puede usar en la parte del return() pero sí un .map(). Podríamos usar un for para iterar en la parte superior sobre data, pero queremos hacerlo en pantalla por lo que tenemos que hacerlo en el return() del componente, por tanto usamos para ello la expresión .map() que cada vez que lo utilicemos nos genera un array nuevo. El map() va a ejecutarse una vez por cada elemento en nuestro Array. Veamos el siguiente código y como aparece 12 veces el párrafo especificado. Sustituyamos ese párrafo por el componente que teníamos hecho:</p>
      
                  <pre><code class="language-js">
                    const [data, setData] = useState(db)
                  </code></pre>
                  <pre><code class="language-html">
                    &lcub;data.map(() =&gt; (
                      //&lt;p&gt;Desde Guitarra&lt;/p&gt;
                      &lt;Guitar/&gt;	
                    )
                    )&rcub;
                    
                  </code></pre>
      
                  <p>¿qué hemos hecho? accedemos a data que es parte de nuestro state, utilizamos el array method map() y al comenzar a iterar generamos un componente Guitar por cada elemento presente en el arreglo (12 elementos). Nos aparece 12 veces el mismo componente estático &lt;Guitar/&gt;. <strong>En el siguiente vídeo con el uso de props  haremos nuestro componente estático más inteligente, más dinámico.</strong></p>
      
                  <p class="naranja">¿Qué son los Props en React?</p>
      
                  <p><strong>Props en React:</strong> es una forma de compartir inofrmación entre componentes</p>
                  <ul>
                    <li><strong>Los componentes de React utilizan Props para comunicarse entre ellos</strong>. Puedes pasarle información de un componente padre al hijo por medio de estos props. </li>
                    <li><strong>Los props se parecen mucho a los atributos HTML, la sintaxis es muy similar, pero puedes pasarle arrays, objetos o funciones</strong></li>
                    <li><strong>Los Props de pasan del padre al hijo, nunca se pueden pasar del hijo al padre</strong>
                      <ul>
                        <li>Si tenemos un state que se va a pasar por diferentes componentes, lo mejor es colocarlo en el archivo principal</li>
                        <li>Cada Nivel de Componentes deberá tomar y pasar el Prop hacia otros componentes. Tecnologías como Redux, Zustand, Jotai o Context evitan tener que hacerlo de esta forma (aunque implementar estas tecnologías para algo tan simple no es recomendado. Algunas las estaremos viendo en este curso)</li>
                        <li></li>
                      </ul>
                    </li>
                  </ul>
      
                  <p>Supongamos que tenemos un componente llamdo &lt;Header/&gt;. La sintaxis de los Props es como sigue: la parte de la izquierda del "=" es como lo vamos a llamar y poder acceder en el componente hijo, es decir en Header. Lo del lado derecho entre llaves es la información necesaria para ese componente que le vamos a pasar (datos, state, funciones, objetos...).</p>
      
                  <pre><code class="language-js">
                    &lt;Header
                      nombreProp=&lcub; datos / state o Funciones &rcub;
                    /&gt;
                  </code></pre>
      
                  <p>Podemos tener múltiples Props, veamos un componente llamado Users:</p>
                  <pre><code class="language-js">
                    &lt;Users
                      users=&lcub; users &rcub;
                      setUsers=&lcub; setUsers &rcub;
                      title="Listado de Usuarios"
                    /&gt;
                  </code></pre>
      
                  <p>Implementemos Props en nuestro componente de guitarras &lt;Guitar /&gt;. Le añadimos este Props a nuestro componente:</p>
                  <pre><code class="language-js">
                    &lcub;data.map(() =&gt; (                    
                      &lt;Guitar
                        price = &lcub;100&rcub;
                      /&gt;
                    )
                    )&rcub;		
                  </code></pre>
      
                  <p>A nuestro componente Guitar.jsx hemos de añadirle como parámetro la palabra reservada <strong>props</strong>. Si hacemos un console log (antes del return()) de ese props veremos en la consola  ese {price: 100}; viene como un objeto porque le podemos pasar múltiples props. También lo podemos ver en la pestaña de components de React Developer Tools</p>
                  <pre><code class="language-js">
                    export default function Guitar(props){
                      console.log(props)
                      return(
                  </code></pre>
      
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/63-props1-CL0pgyo9.jpg" alt="" />
      
                  <p>Pasémosle más de un props:</p>
                  <pre><code class="language-js">
                    &lcub;data.map(() =&gt; (                    
                      &lt;Guitar
                        price = &lcub;100&rcub;
                        auth = true;
                      /&gt;
                    )
                    )&rcub;		
                  </code></pre>
                  <p>¿Cómo puedo acceder individualmente a estos valores <strong>price</strong> y <strong>auth</strong>? Como es un objeto:</p>
                  <pre><code class="language-js">
                    export default function Guitar(props){
                      console.log(props.price)
                      console.log(props.auth)
                      return(
                  </code></pre>
      
                  <p>Pero incluso mejor, podemos aplicar destructuring:</p>
                  <pre><code class="language-js">
                    export default function Guitar({price,auth}){
                      console.log(price)
                      console.log(auth)
                      return(
                  </code></pre>
      
                  <p class="naranja">Mostrando la Información de cada Guitarra</p>
      
                  <p>Tenemos el array db.js y cada uno tiene un objeto con la información de cada guitarra. Estamos utilizando un map() para iterar en él así que vamos a acceder a cada uno de esos objetos (en la función de flecha le ponemos el nombre que queramos por ejemplo <strong>guitar</strong>). Creamos el prop guitar y le pasamos como valor el objeto guitar (explica que no hay ningún inconveniente en tener mismo nombre de prop que del objeto que deseas pasarle al prop):</p>
      
                  <pre><code class="language-js">
                    const &lsqb;data&comma; setData&rsqb; = useState(db)
      
                    &lcub;data.map((guitar) =&gt; (                    
                      &lt;Guitar
                        guitar = &lcub;guitar&rcub; 
                        key = &lcub;guitar.id&rcub; // Cuando iteremos en una lista, React nos requiere que siempre utilicemos un prop especial llamado <strong>key</strong> y pasarle un valor único.                      
                      /&gt;
                    )
                    )&rcub; 
                  </code></pre>
                  <p>Si hacemos un console.log(props) veremos que tenemos un prop que va a tener el objeto de guitarra</p>
                  <pre><code class="language-js">
                    export default function Guitar(props){
                    console.log(props)
                  </code></pre>
      
                  <p>Si aplicamos destructuring quedaría así y en la consola ya vemos que aparece la información propia de cada guitarra:</p>
                  <pre><code class="language-js">
                    export default function Guitar({guitar}){
                    console.log(guitar)
                  </code></pre>
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/66-1-CgAxKnPm.jpg" alt="" />
      
                  <p>Para cada elemento html que teníamos en el código estático (nombre, imagen, precio...) que queremos que cargue de forma dinámica hacemos el reemplazo por ejemplo el nombre de la  guitarra que está en el h3, 'Lukather', lo cambiamos por <code class="language-js">{guitar.name}</code>. Si actualizamos el navegador vemos que cada guitarra ya muestra un nombre diferente, porqeu ya estamos leyendo la información de nuestra pequeña base de datos. <span class="destacado">Así vemos el beneficio de los props junto al state junto a emplear array methods para iterar en nuestro state --> crear componentes reutilizables optimizando el código a escribir</span></p>
      
                  <p>En vez de llamar cada dato así <code class="language-js">{guitar.name}</code>, creemos una variable cont nueva para hacer destructuring del objeto guitar que recibimos como propiedad del compoennte padre App.jsx y simplificar el código de la siguiente manera:</p>
                    
                  <pre><code class="language-js">
                    export default function Guitar({guitar}){
      
                      const { id, name, image, description, price } = guitar		
                  </code></pre>
      
                  <p>Hago unos leves cambios de nombre con respecto a lo explicado para rastrear mejor lo que estoy haciendo:</p>
      
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/66-2-lNg4kD6J.jpg" alt="" />
      
                  <p>En el siguiente video comenzamos con el carrito de la compra.</p>
                </div>
                <!-- Fin bloque desplegable interior-->
      
      
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-67').toggle();">	
                  <h3>67. Eventos en JSX / 68. Creando un State de Carrito / 69. Agregando Guitarras al Carrito / 70. Detectar si un elemento existe en el carrito / 71. Agregando guitarras al Carrito con Cantidad / 72. Incrementando cantidad si un articulo ya estaba agregado</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion6-67" class="hidden">
      
                  <p class="naranja">Eventos en JSX</p>
      
                  <p>Cuando presione en cada guitarra se tienen que ir listando en el carrito. En ese carrito tenemos que poder ajustar la cantidad y eliminar los que queramos. Si tienes exp en js eso se hace con un addEventListener</p>
      
                  <p class="font-bold">Sobre los eventos en React</p>
                  <ul>
                    <li>La forma en que React maneja los eventos es muy similar a como lo hace JavaScript de forma nativa con algunos cambios.</li>
                    <li><strong>Los eventos son camelCase</strong>, es decir en lugar de <strong>onclick</strong> <span class="destacado">onClick</span>, en lugar de <strong>onchange</strong>, <span class="destacado">onChange</span></li>
                    <li>A diferencia de JS y HTML en los que se coloca el nombre de la función en un string, <strong>en React (JSX) se utiliza la función entre llaves <span class="destacado">{}</span></strong></li>
                    <li>Ejemplo click en HTML: <code class="language-html">&lt;button onclick=&quot;getLatestOrders()&quot;&gt;Descargar pedidos&lt;/button&gt;</code></li>
                    <li>Ejemplo click en React(JSX): <code class="language-js">&lt;button onClick=&lcub;getLatestOrders()&rcub;&gt;Descargar pedidos&lt;/button&gt;</code><br>Esa función se recomienda que esté <strong>en el mismo componente antes del return()</strong> o <strong>en un Hook personalizado, otro archivo</strong></li>
                    <li>Ejemplo submit en HTML: agregarCliente() es la función que va a procesar un formulario de ajax o FetchAPI; también le colocamos un return false): 
                    <pre><code class="language-html">
                      &lt;form onsubmit=&quot;agregarCliente()&semi; return false&quot;&gt;
                        &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
                      &lt;/form&gt;
                    </code></pre>
                    </li>
                    <li>Ejemplo submit en React(JSX): como vemos hay una convención (similar a cuando en los states nombramos las funciones correspondientes del estate con la palabra<strong><span class="destacado">set</span>NombreState</strong>), y para eventos se recomienda usar la palabra <strong><span class="destacado">handle</span>NombreEvento</strong>
                      <pre><code class="language-html">
                        &lt;form onSubmit=&lcub;handleSubmit&rcub;&gt;
                        &lt;button type=&quot;submit&quot;&gt;A&ntilde;adir cliente&lt;/button&gt;
                      &lt;/form&gt;				
                      </code></pre>
                      </li>
                  </ul>
      
                  <p class="font-bold">Vamos a registrar un evento en nuestras guitarras</p>
                  <p>Como cuando yo presione en agregar al carrito quiero realizar una acción, <strong>vamos a agregarle/registrarle a nuestro botón el evento de onClick</strong>:</p>
      
                  <pre><code class="language-js">
                    const handleClick = () => {
                      console.log('Diste click')
                    }
                  </code></pre>
                  <pre><code class="language-html">
                    &lt;button 
                    type=&quot;button&quot;
                    className=&quot;btn btn-dark w-100&quot;
                    onClick={handleClick}
                  &gt;Agregar al Carrito&lt;/button&gt;		
                  </code></pre>
      
                  <p>Me gustaría poder identificar desde qué guitarra estoy haciendo click. ¿Cómo le pasamos un valor para identificar un parámetro o um argumento? Podríamos añadir paréntesis con el id dentro <code class="language-js">onClick={handleClick(id)}</code> ya que el id lo tenemos en la destructuración del prop "propguitar" <code class="language-js">const { id, name, image, description, price } = propguitar</code>. Hagamos que la función handleClick reciba ese argumento y lo vemos en consola. Vemos en la consola que salen TODOS los clicks porque esta expresión <code class="language-js">onClick={handleClick(id)}</code> está mandando llamar la función, no espera que ocurra el evento</p>
      
                  <p><strong>Cuadno tenemos argumentos, si tenemos funciones que toman parámetros, hay que colocar en la llamada un callback, por ejemplo un arrow function, <code class="language-js">onClick={() =>handleClick(id)}</code> y de esa forma ya no se manda llamar en automático sino que espera el evento.</strong></p>
      
                  <p>Mejor vamos a pasarle como argumento, en vez de solo el id, todo el objeto de guitarra: <code class="language-js">onClick={() => handleClick(guitar)}</code> y miramos la consola donde nos sale toda la información:</p>
                  
                  <div class="flex">
                    <div class="w-50 w-100-s">	
                      <p class="verde">Guitar.jsx</p>:
                      <pre><code class="language-js">
                        export default function Guitar({propguitar}){
      
                          const { id, name, image, description, price } = propguitar
                        
                          const handleClick = (algo) => {
                            console.log('Diste click', algo)
                          }
                        
                          return(
                            &lt;div className=&quot;col-md-6 col-lg-4 my-4 row align-items-center&quot;&gt;
                              &lt;div className=&quot;col-4&quot;&gt;
                                &lt;img className=&quot;img-fluid&quot; src=&lcub;&grave;/img/$&lcub;image&rcub;.jpg&grave;&rcub; alt=&quot;imagen guitarra&quot; /&gt;
                              &lt;/div&gt;
                              &lt;div className=&quot;col-8&quot;&gt;
                                &lt;h3 className=&quot;text-black fs-4 fw-bold text-uppercase&quot;&gt;&lcub;name&rcub;&lt;/h3&gt;
                                &lt;p&gt;&lcub;description&rcub;&lt;/p&gt;
                                &lt;p className=&quot;fw-black text-primary fs-3&quot;&gt;$&lcub;price&rcub;&lt;/p&gt;
                                &lt;button 
                                  type=&quot;button&quot;
                                  className=&quot;btn btn-dark w-100&quot;
                                  onClick=&lcub;() = &gt;handleClick(propguitar)&rcub;
                                &gt;Agregar al Carrito&lt;/button&gt;
                              &lt;/div&gt;
                            &lt;/div&gt;
                          )
                        }
                      </code></pre>	
                      <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/67-D_Nw8gJj.png" alt="" />
                    </div>
      
                    <div class="w-50 w-100-s">
                      <p class="verde">App.jsx:</p>
                      <pre><code class="language-js">
                        import &lcub; useState&comma; useEffect &rcub; from &quot;react&quot;
                        import Guitar from &quot;../components/Guitar&quot;
                        import Header from &quot;../components/Header&quot;
                        import &lcub; db &rcub; from &quot;./data/db&quot;
                        
                        function App() &lcub;
                        
                          //console.log(db)
                          const &lsqb;data&comma; setData&rsqb; = useState(db)
                        
                          // const &lsqb;data&comma; setData&rsqb; = useState(&lsqb;&rsqb;)
                          // useEffect( () =&gt; &lcub;
                          //     setData(db)
                          // &rcub;&comma;&lsqb;&rsqb;)
                        
                          return (
                            &lt;&gt;   
                            &lt;Header/&gt;
                          
                            &lt;main className=&quot;container-xl mt-5&quot;&gt;
                              &lt;h2 className=&quot;text-center&quot;&gt;Nuestra Colecci&oacute;n&lt;/h2&gt;
                        
                              &lt;div className=&quot;row mt-5&quot;&gt;
                                &lcub;data.map((guitar) =&gt; (                    
                                  &lt;Guitar
                                    propguitar = &lcub;guitar&rcub; 
                                    key = &lcub;guitar.id&rcub;                       
                                  /&gt;
                                )
                                )&rcub;         
                              &lt;/div&gt;
                            &lt;/main&gt;
                        
                            &lt;footer className=&quot;bg-gray-300 mt-5 py-5&quot;&gt;
                              &lt;div className=&quot;container-xl&quot;&gt;
                                &lt;p className=&quot;text-white text-center fs-4 mt-4 m-md-0&quot;&gt;GuitarLA - Todos los derechos Reservados&lt;/p&gt;
                              &lt;/div&gt;
                            &lt;/footer&gt;        
                            &lt;/&gt;
                          )
                        &rcub;
                        
                        export default App
                      </code></pre>
                    </div>
                  </div>
      
                  <p class="naranja">Creando un State de Carrito</p>
      
                  <p>Veamos como agregar nuestras guitarras. Hagamos un state nuevo de carrito. No es bueno tener 30 o 40 states (en esos casos quizás sean mejores otras opciones como sustain, J, Context API o como Redux Toolkit). Sin embargo, tampoco se recomienda tener un solo state muy grande, porque tener un state muy grande te va a llevar a tener que escribir una lógica muy grande cuando quieras actualizar o modificar ese state.</p>
      
                  <p>lo creamos en nuestro componente de App.jsx (no lo creamos en Guitar.jsx. cada guitarra es un componente distinto y si crearar ahí un state de carrito tendría 12 diferentes :D). Como va a ser un carrito de compras su valor inicial será un Array vacío <code class="language-js">const [cart, setCart] = useState([])</code> de manera que vamos a tener acceso a ciertos métodos de array para agregar elementos, eliminarlos, revisar si ya existe un elemento y evitar duplicados, si está vacío. <span class="destacado">Son muchos los beneficios de utilizar el tipo de dato adecuado a nuestro state inicial</span>. Si abrimos la pestaña componentes de React Developer Tools vemos que en el componente App tenemos nuestro state de guitarras, pero también este nuevo state de carrito que está vacío (con lo cual, se registró correctamente).</p>
      
                  <p>¿Cómo agregamos elementos a nuestro carrito? tenemos varias formas de hacerlo:</p>
      
                  <ul>
                    <li>la más simple: para agregar elementos a nuestro state "cart" vamos a tener que utilizar simepre la función "setCart". El evento de agregarlos se está presentando en el componente Guitar.jsx. Recordemos que podemos pasar vía props desde el componente padre App.jsx strings, objetos y <strong>funciones</strong>, así que pasamos nuestra función setCart del state cart <span class="verde">App.jsx:</span>
                      <pre><code class="language-js">
                        &lcub;data.map((guitar) =&gt; (                    
                          &lt;Guitar
                            key = &lcub;guitar.id&rcub; 
                            propguitar = &lcub;guitar&rcub; 
                            setCart = &lcub;setCart&rcub;                          
                          /&gt;
                        )
                        )&rcub;
                      </code></pre>
                      <span class="verde">Guitar.jsx:</span> <code class="language-js">export default function Guitar({propguitar, setCart}){</code>
                    <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/68-1-DeG11KP6.png" alt="" /></li>
                    <li>otra forma de hacerlo: tenemos en el botón nuestro <code class="language-js"> onClick={() => handleClick(propguitar)}</code> modificamos la función para pasarle la guitarra a nuestro state cart: <span class="destacado">esperamos que ocurra el click, cuando pinchas se le pasa la guitarra y seteamos al carrito</span>
                    <pre><code class="language-js">
                      const handleClick = (guitar) => {
                        setCart(guitar)
                      }			
                    </code></pre>
                    <p>cada vez que pinchamos se modifica el state agregando el objeto guitarra, pero si presiono otro reemplaza lo que hay, y en un carrito no queremos reemplazar sino agregar. Lo está escribiendo correctamente pero tenemos que mantener lo que ya teníamos en el carrito. En vez de un objeto quiero que me escriba un array pero nos seguirá pasando lo mismo, cada vez que pulsemos una guitarra reemplazará a la anterior en el state cart:</p>
                    <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/68-2-D7SDr9Wp.png" alt="" />
                    <p>¿Como hago para que los datos que agregué al carrito persistan? Tenemos que tener la referencia de nuestro state de carrito cart, así que lo pasamos desde nuestro componente padre App.jsx al componente Guitar.jsx: <span class="verde">App.jsx:</span></p>
                    <pre><code class="language-js">
                      &lcub;data.map((guitar) =&gt; (                    
                        &lt;Guitar
                          key = &lcub;guitar.id&rcub; 
                          propguitar = &lcub;guitar&rcub; 
                          cart = &lcub;cart&rcub;
                          setCart = &lcub;setCart&rcub;                          
                        /&gt;
                      )
                      )&rcub;
                    </code></pre>
                    <span class="verde">Guitar.jsx:</span> <code class="language-js">export default function Guitar({propguitar, cart, setCart}){</code>
                    <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/68-3-CCV3pvXO.png" alt="" />
                    </li>
                    <li>Otra manera: eliminemos la función 
                      <pre><code class="language-js">
                        const handleClick = (guitar) => {
                          setCart([...cart, guitar])
                        }			
                      </code></pre>
                      y llamarla directamente en el onClick: <code class="language-js">onClick={() => setCart([...cart, propguitar])}</code>. <span class="destacado">Algo importante es que ese <strong>setCart</strong> ya sabe lo que hay en el state. Desde que declaramos el state de cart esa función setCart siempre va a estar asociada con ese estate de carrito (sabe de su existencia, sabe qué hay, sabe que tiene que escribir en ese cart, nunca se va a mezclar con otras de otros states.) Por tanto no haría falta pasarle como propiedad el carrito (la función ya sabe lo que tiene).</span> En la nueva función de flecha nótese la convención de nombre <strong>prev</strong>Cart por tanto quedaría así <br><code class="language-js">onClick={() => setCart(prevCart =>[...prevCart, propguitar])}</code><br> No tenemos que pasar el state, la función setCart toma la copia del state actual</li>
                    </ul>
      
                  
                    <p class="naranja">Agregando Guitarras al Carrito</p>
      
                    <p>Con el enfoque actual, se hace un poco complicado porque tendríamos que añadir lógica en la llamada del onclick para revisar si un registro está duplicado o no etc... y no queremos lógica en nuestros templates. Para tener lógica usamos la parte de antes del return() o un Hook aparte. Cambiemos el enfoque y modifiquemos nuesto código:</p>
      
                    <p>En App.jsx antes del return creamos una nueva función intermedia que sea más descriptiva de loq ue se está haciendo y en donde con cierta lógica podamos evitar problemas ocmo elementos duplicados etc: <strong>function addToCart(){}</strong> y la pasamos como prop para que esté disponible para otros componentes de manera que se pueda agregar ese elemento al carrito. Al parámetro lo llamamos <strong>item</strong> también por convención para reutilización de lógica de carrito.</p>
      
                    <pre><code class="language-js">
                      function addToCart(item){
                        setCart(prevCart =>[...prevCart, item])
                      }
                    </code></pre>
      
                    <p class="naranja">Detectar si un elemento existe en el carrito</p>
      
                    <p>No queremos tener registros duplicados en un carrito de compras ¿como lo evitamos? antes de setear al carrito de compras hemos de verificar si ese elemento ya existe en el Array, si existe actualizaremos la cantidad y si no existe lo agregamos. Esto nos lleva a un tema que es muy importante en React <span class="destacado">¿Qué significa la inmutabilidad en React?</span> ¿qué significa que un state es inmutable? Si vemos la función que acabamos de crear. setCart(prevCart =>[...prevCart, item]) <strong>no estamos modificando el state, tomamos una copia del state y agregamos el nuevo elemento</strong>. Otros array methods que nos permiten añadir elementos a un array serían por ejemplo <strong>cart.push(item): sin embargo esto modifica el state original</strong>. Y nuestro state tiene que ser inmutable. Por eso siempre se utiliza la función asociada al state. Incluso si utilizáramos la función e hiciéramos algo como setCart(prevCart => cart.push(item) estaríamos modificando el state original. Para saber qué array methods de js mutan el state original y cuales no consultamos: <a href="https://doesitmutate.xyz/" class="text-[#000000]" target="blank">https://doesitmutate.xyz/</a>
                    </p>
      
                    <p>Para saber si ya existe un elemento en un array vamos a usar el método de arrays <span class="destacado">.findIndex()</span> que no provoca mutación; va a iterar sobre nuestro carrito de compras cart y va ir creando un objeto temporal que por ejemplo llamamos "guitar" (no lo llamamos item porque nuestra función ya tiene un parámetro que se llama así y provocaríamos confusión). En la parte derecha del arrow function añadimos la comprobación de si el elemento nuevo que estamos añadiendo es el mismo que ya existe en mi state. <strong>Si el elemento está presente en el array devuelve el índice que ocupa en el array y si no lo encuentra devuelve -1</strong>. En este punto nuestra función va así y hagamos un console.log() para entenderlo.</p>
      
                    <pre><code class="language-js">
                      function addToCart(item){
                        const itemExists = cart.findIndex(guitar => guitar.id === item.id) // ese "guitar" es el nombre que queramos poner
                        console.log(itemExists)
                    
                        setCart(prevCart =>[...prevCart, item])
                      }			
                    </code></pre>
      
                    <p>Como vemos haga lo que haga, de momento seguimos seteando elementos al state. Tendremos que meter una comprobación para antes de setear, si existe en el array actualizaremos la cantidad y si no existe lo agregamos.</p>
      
                    <p class="naranja">Agregando guitarras al Carrito con Cantidad</p>
      
                    <p>Agreguemos la cantidad de guitarras para poder reflejarlo en el carrito.</p>
                    <pre><code class="language-js">
                      function addToCart(item){
                        const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                        if(itemExists >= 0){//existe en cart
                          console.log('ya existe')            
                        } else{
                          //console.log('NO EXISTE, agregando...')
                          item.quantity = 1
                          setCart(prevCart =>[...prevCart, item])
                        }       
                      }	
                    </code></pre>
      
                    <p class="naranja">Incrementando cantidad si un artículo ya estaba</p>
                    <p>Cuando ya existe, hemos de tener cuidado en no romper ciertas reglas del state. Por ejemplo si en nuestra función añadiéramos esto cuando el elemento existe:
                    <code class="language-js">cart[itemExists].quantity++</code> <span class="rojo">¡estaríamos modificando directamente nuestro state!</span></p>
                    <pre><code class="language-js">
                      function addToCart(item){
                        const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                        if(itemExists >= 0){//existe en cart
                          console.log('ya existe')  
                          cart[itemExists].quantity++ //estaríamos modificando nuestro estate ¡Y EL STATE ES INMUTABLE!!         
                        } else{
                          //console.log('NO EXISTE, agregando...')
                          item.quantity = 1
                          setCart(prevCart =>[...prevCart, item])
                        }       
                      }
                    </code></pre>
      
                    <p>creamos una copia del carrito usando el spread operator, incrementamos la cantidad y seteamos:</p>
                    <pre><code class="language-js">
                      function addToCart(item){
                        const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                        if(itemExists >= 0){//existe en cart
                          const updatedCart = [...cart] //copia nueva de mi state, no modifica mi carrito       
                          updatedCart[itemExists].quantity++
                          setCart(updatedCart)
                        } else{//NO EXISTE en cart
                          item.quantity = 1
                          setCart(prevCart =>[...prevCart, item])
                        }       
                      }
                    </code></pre>
                  
                </div>
                <!-- Fin bloque desplegable interior-->
      
      
      
                
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-81').toggle();">	
                  <h3>73. Mostrando los Contenidos del carrito / 74. Detectando si el carrito está vacío / 75. State derivado / 76. Calculando el Total a pagar / 77. useMemo para mejorar el performance de nuestro código / 78. Eliminando artículos del carrito / 79/80. Creando una Función para Incrementar las cantidades y RETO 01 / 81. Función limpiar carrito</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion6-81" class="hidden">
                  <p>Vamos a empezar a hacer dinámica la sección del carrito de compra. Está en nuestro Header.jsx, vamos a hacer dinámica esta parte y sincronizarla con nuestro state. En nuestro componente App.jsx, al Header le vamos a pasar el carrito <strong>el prop se va a llamar cart y el valor también cart, para no tener que pensar en nombres diferentes es recomendable ponerl el mismo que tiene ese state</strong>.</p>
                  <pre><code class="language-js">
                    &lt;Header
                    cart = &lcub;cart&rcub;
                  /&gt;
                  </code></pre>

                  <pre><code class="language-js">
                    export default function Header({cart}){
                  </code></pre>

                  <p>la estructura del carrito es con una tabla. Iteramos en el tbody para que genere un tr por cada elemento en nuestro carrito:</p>
                  <pre><code class="language-js">
                    &lcub;cart.map( guitar =&gt;( 
                      &lt;tr&gt;
                        &lt;td&gt;
                          &lt;img className=&quot;img-fluid&quot; src=&quot;./public/img/guitarra&lowbar;02.jpg&quot; alt=&quot;imagen guitarra&quot; /&gt;
                        &lt;/td&gt;
                        &lt;td&gt;SRV&lt;/td&gt;
                        &lt;td className=&quot;fw-bold&quot;&gt;
                            $299
                        &lt;/td&gt;
                        &lt;td className=&quot;flex align-items-start gap-4&quot;&gt;
                          &lt;button
                            type=&quot;button&quot;
                            className=&quot;btn btn-dark&quot;
                          &gt;
                            -
                          &lt;/button&gt;
                            1
                          &lt;button
                            type=&quot;button&quot;
                            className=&quot;btn btn-dark&quot;
                          &gt;
                            &plus;
                          &lt;/button&gt;
                        &lt;/td&gt;
                        &lt;td&gt;
                          &lt;button
                            className=&quot;btn btn-danger&quot;
                            type=&quot;button&quot;
                          &gt;
                            X
                          &lt;/button&gt;
                        &lt;/td&gt;
                      &lt;/tr&gt;
                    ))&rcub;
                  </code></pre>

                  <p>Comenta sobre la posibilidad de que este tr lo hiciéramos componente y habla sobre el inconveniente de tener demasiados componentes pequeños, tener que andar enviando y manejando demasiados props (que se podría manejar con Redux toolkit o manejador de estado global pero aún no hemos visto ese tema ni conviene para un proyecto tan pequeño como este.) </p>

                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/73-CZKnIzDY.png" alt="" />

                  <p>no lo estoy pasando via props, pero el objeto <strong>guitar</strong> existe dentro de ese paréntesis y puedo acceder a sus propiedades. Si vemos en consola nos da un aviso de id único para Header. Tenemos que darle un key único al tr.</p>
                  
                  <pre><code class="language-js">
                    &lt;tbody&gt;
                    &lcub;cart.map( guitar =&gt;( 
                    &lt;tr key=&lcub;guitar.id&rcub;&gt;
                      &lt;td&gt;
                        &lt;img className=&quot;img-fluid&quot; src=&lcub;&grave;/img/$&lcub;guitar.image&rcub;.jpg&grave;&rcub; alt=&quot;imagen guitarra&quot; /&gt;
                      &lt;/td&gt;
                      &lt;td&gt;&lcub;guitar.name&rcub;&lt;/td&gt;
                      &lt;td className=&quot;fw-bold&quot;&gt;
                          $&lcub;guitar.price&rcub;
                      &lt;/td&gt;
                      &lt;td className=&quot;flex align-items-start gap-4&quot;&gt;
                        &lt;button
                          type=&quot;button&quot;
                          className=&quot;btn btn-dark&quot;
                        &gt;
                          -
                        &lt;/button&gt;
                          &lcub;guitar.quantity&rcub;
                        &lt;button
                          type=&quot;button&quot;
                          className=&quot;btn btn-dark&quot;
                        &gt;
                          &plus;
                        &lt;/button&gt;
                      &lt;/td&gt;
                      &lt;td&gt;
                        &lt;button
                          className=&quot;btn btn-danger&quot;
                          type=&quot;button&quot;
                        &gt;
                          X
                        &lt;/button&gt;
                      &lt;/td&gt;
                    &lt;/tr&gt;
                    ))&rcub;
                  &lt;/tbody&gt;
                  </code>
                  </pre>

                  <p class="naranja">Detectando si el carrito está vacío</p>
                  <p>¿Hemos de crear un state para eso? no es necesrio crear un state para cada cosa. Veamos un par de alternativas para hacer esto. Estamos pasando como prop desde App.jsx nuestro cart, y en el código del componente Header.jsx iteramos el tr sobre cart. <span class="destacado">En este punto podemos escribir un ternario</span>. <strong>Como vimos en la parte de statements y expresiones, no podemos tener un if pero sí un ternario</strong>:</p>
                  <pre><code class="language-js">
                    &lcub;cart.length === 0 ? (
                      &lt;p className=&quot;text-center&quot;&gt;El carrito esta vacio&lt;/p&gt;                                            
                      ):( 
                      //El resto de la tabla
                    )&rcub;
                  </code></pre>
                  <p>También podemos usar un state derivado en lugar de ese <code class="language-js">cart.length === 0</code></p>

                  <p class="naranja">State derivado</p>

                  <p>Algunas veces queremos derivar el state. Actualmente tenemos nuestro state de carrito <code class="language-js">const [cart, setCart] = useState([])</code>. En lugar de crear un state nuevo que estemos revisando y su valor dependa de que cart tenga algo, podemos crear una variable/funcion cuyo valor vaya a depender mucho de este otro state. Lo podemos tener ¿en el return del App.jsx? o en el Header.jsx donde lo usamos (opta por esta). La idea es mantener la lógica fuera del template:</p>

                  <pre><code class="language-js">
                    export default function Header({cart}){

                      //State derivado
                      const isEmpty = () => cart.length === 0

                      {isEmpty() ? (
                        &lt;p className=&quot;text-center&quot;&gt;El carrito esta vacio&lt;/p&gt;                                            
                      ):( 
                      //El resto de la tabla
                      )}        
                  </code></pre>

                  <p class="naranja">Calculando el Total a pagar</p>			
                  <p>Metemos el párrafo en la parte del ternario que renderiza la tabla. <strong>nos dará error porque necesitamos tener un único elemento en el nivel superior, metemos un fragment que englobe a la tabla+p</strong>. Para calcular el total a pagar vamos a utilizar un array method llamado <span class="destacado">reduce()</span>. Lo utilizamos para construir este state derivado de lo que tenemos en el carrito de compras:</p>

                  <pre><code class="language-js">
                    const isEmpty = () => cart.length === 0
                    const cartTotal = () => cart.reduce( (total, item) => total + (item.quantity * item.price), 0)
                  </code></pre>

                  <p>Es uno de los pocos array methods que toma dos parámetros, uno es el total ,es decir un acumulado, va a ir iterando sobre cada elemento que tenemos en el carrito; el segundo parámetro <strong>item</strong> es el elemento actual. En el arrow function siguiente al total acumulado le vamos sumando el resultado de multiplicar la cantidad de item * precio de item. el valor <strong>0</strong> es el valor inicial; el carrito inicia en 0 y a apartir de ahí sumamos.</p>

                  <p>Si no quisiéramos llamar estas funciones isEmpty() y carTotal() podríamos hacer uso de un Hook que se llama useMemo que también es bastante común</p>

                  <p class="naranja">useMemo para mejorar el performance de nuestro código</p>

                  <p>Si tenemos experiencia con Vue.js sabremos que hay algo que se llama compute properties y useMemo hace algo bastante similar:</p>
                  <ul>
                    <li>Simplifica los templates un poco</li>
                    <li>Es un Hook enfocado al performance porqeu evita que este código se ejecute (los 2 states derivados vistos) si alguna de las dependencias que vamos a deifnir en ese useMemo no ha cambiado.</li>
                  </ul>
                  <p><strong>Importamos esl Hook useMemo en nuestro componente Header.jsx:</strong> <code class="language-js">import { useMemo } from 'react'</code>. Vamos a usarlo en nuestro state derivado isEmpty. useMemo es una función que toma dos parámetros (un factory que es la función y el array de dependencias), los vemos explicados si nos colocamos en VSC encima de useMemo:</p>
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/77-useMemo-C33Si16k.png" alt="" />
                  <pre><code class="language-js">
                    const isEmpty = useMemo( () => cart.length === 0, [cart])
                  </code></pre>

                  <p>Este código no va a cambiar hasta que cambien ciertas partes de nuestro código. ¿Qué imporancia tiene esto? React siempre va ahacer un render completo de nuestra aplicación. Si presionamos en agregar al carrito, hace un render completo donde tengas el state. Eso puede suponer mucho coste en términos de rendimiento, hacer que nuestra aplicación sea más lenta...entonces <span class="destacado">useMemo es una forma de decirle: "no haghas render completo de mi aplicación hasta que no cambie algo que yo te voy a decir qué es; para eso es el arreglo de dependencias y en concreto este código anterior le dice "vuelve a ejecutar este código, a hacer el render cuando cart cambie, cada vez que añadamos, eliminemos, modificamos algo del carrito"</span>. Como isEmpty ya no es una función, eliminamos en nuestro template esto <code class="language-js"> isEmpty() </code>y en su lugar lo llamamos así <code class="language-js"> isEmpty</code></p>

                  <p>Hacemos lo mismo con el state derivado carTotal, porque queremos que el Total se calcule solo cuando el carrito cambie:</p>
                  <pre><code class="language-js">
                    const isEmpty = useMemo( () => cart.length === 0, [cart])
                  </code></pre>

                  <p>useMemo no es un Hook que vayamos a utilizar en todos sitios, es un Hook enfocado a performance pero por el hecho de que cachea esos resultados entre renders, <strong>a veces puede ser contraproducente cachear tanto. Hay que probar según el caso y vigilar nuestro state. Si no se actualiza como esperamos lo quitamos y/o valorar otras opciones apra trabajar con caché en nuestros componentes</strong>.</p>

                  <p class="naranja">Eliminando artículos del carrito</p>

                  <p>Lo primero que tenemos que hacer es crear una función. El carrito está en el componente <strong>App.jsx</strong> y el botón para eliminar está en el componente <strong>Header.jsx</strong>. Creemos la función en el componente principal y la pasaremos via <strong>props</strong>. Comprobemos de momento con un console.log() sin más que la comunicación entre nuestro botón eliminar del Header y la nueva función creada es correcta. <span class="destacado">Como ya hemos hecho antes, al pasar el prop lo nombramos igual que nuestra función así nos quitamos de tener que pensar en varios nombres (yo en un ejemplo anterior con el objeto guitar le puse al nombre del prop "propguitar" pero era mientras me acostumbraba  a todo esto para no perder la referencia de lo que estaba haciendo).</span></p>

                  <pre><code class="language-js">
                    //antes del return
                    function removeFromCart(){
                      console.log('Eliminando...')
                    }
                    
                    //en el return llamando a nuestro componente
                    &lt;Header
                    cart = &lcub;cart&rcub;
                    removeFromCart = &lcub;removeFromCart&rcub;
                  /&gt;      
                  </code></pre>

                  <p>Nos vamos ahora a nuestro componente Header.jsx y primero vamos a tomar esa función, aplicamos destructuring a esa función:</p>

                  <pre><code class="language-js">export default function Header({cart, removeFromCart}){</code></pre>

                  <p>la asociamos con el botón de eliminar. Vamos a esperar que el usuario presione en él por tanto colocamos en el un onClick y pasamos el nombre de la función: <code class="language-js"></code></p>

                  <pre><code class="language-html">
                    &lt;button
                      className=&quot;btn btn-danger&quot;
                      type=&quot;button&quot;
                      onClick=&lcub;removeFromCart&rcub;&gt;
                    X
                    &lt;/button&gt;
                  </code></pre>

                  <p>Si pulsamos ya vemos en la consola el mensaje que hemos puesto para verificar que hay comuniación. ¿Cçomo eliminamos elementos? Estamos almacenando todo en este arreglo de cart. <span class="destacado">Vamos a utilizar un array method que nos permita sacar elementos de ese arreglo y uno muy común que no muta nuestro state es .filter()</span> Nos va a permitir filtrar en base a una condición. Por ejemplo pensemos en los id. Para ello tenemos que pasarle un parámetro:</p>
                  <ul>
                    <li>le pasamos un parámetro a la función:
                      <pre><code class="language-js">
                        //antes del return
                        function removeFromCart(id){
                          console.log('Eliminando...', id)
                        }
                      </code></pre></li>
                    <li><span class="destacado">si le pasamos un parámetro en el onclick hay que ponerle un callback y le pasamos guitar.id, y de esa forma vamos a poder identificar qué elemento es el que estamos presionando para eliminarlo de nuestro carrito de compras.</span>
                      <pre><code class="language-html">
                        &lt;button
                          className=&quot;btn btn-danger&quot;
                          type=&quot;button&quot;
                          onClick=&lcub;() =&gt; removeFromCart(guitar.id)&rcub;
                        X
                        &lt;/button&gt;
                      </code></pre>          
                    </li>
                  </ul>

                  <p>podríamos crear una nueva variable con lo que nos retorna el filter() pero también podemos hacerlo en una sola función: si lo pasamos como callback aquí vamos a tener el valor previo de nuestro carrito. Le aplicamos el método filter() y le indicamos que nos filtre las guitarras cuo id sea diferente al que le pasamos; ello regresa el nuevo arreglo y lo setea en nuestra función.</p>

                  <pre><code class="language-js">
                    function removeFromCart(id){
                      //console.log('Eliminando...', id)      
                      setCart(prevCart => prevCart.filter(guitar => guitar.id !== id))
                  }
                  </code></pre>

                  <p>Si probamos a eliminar una guitarra vemos que se elimina del carrito y que además el total se actualiza. Recordemos que <strong>carTotal es un state derivado, tiene un useMemo y como dependencia el cart, también se vuelve a ejecutar y calcula el total a pagar de nuestro carrito de compra.</strong>. Si las eliminamos todas vemos que sale lo de que el carrito está vacío, porque también se ejecuta nuestro otro state derivado <strong>isEmpty</strong>.</p>

                  <p>Vemos lo sencillo que es con react mantener sincronizado nuestro state con nuestra interfaz, no hay que llamar a ninguna función para refrescar nuestra interfaz, automáticamente lo hace por nosotros.</p>

                  <p class="naranja">Creando una Función para Incrementar las cantidades y RETO 01</p>
                  <p>Creamos una nueva función intermedia desriptiva que nos sirva para manejar la lógica. toma un id porque requerimos identificar el elemento. Como está en el Header, la pasamos via prop usando el mismo nombre:</p>

                  <pre><code class="language-js">
                    function increaseQuantity(id)&lcub;
                    console.log(&apos;Incrementando...&apos;&comma; id)
                  &rcub;
                  
                  return (
                    &lt;&gt;   
                    &lt;Header
                      cart = &lcub;cart&rcub;
                      removeFromCart = &lcub;removeFromCart&rcub;
                      increaseQuantity = &lcub;increaseQuantity&rcub;
                    /&gt;
                  </code></pre>

                  <p>Extraemos la nueva prop en la declaración de la función de nuestro componente Header: <code class="language-js">export default function Header({cart, removeFromCart, increaseQuantity}){</code>. En el código del return donde está el botón "+" para incrementar le añadimos el onClick con su función de flecha que llama a ese prop pasándole como argumento el id de la guitarra que se pulsa:</p>

                  <pre><code class="language-js">
                    &lt;button
                    type=&quot;button&quot;
                    className=&quot;btn btn-dark&quot;
                    onClick=&lcub;() =&gt; increaseQuantity(guitar.id)&rcub;&gt;
                    &plus;
                  &lt;/button&gt;
                  </code></pre>

                  <p>Cada vez que agregábamos un elemento al carrito (ver en nuestro componente App.jsx la función addToCart) estábamos incrementando esta propiedad de cantidad "item.quantity". <strong>Actualicemos nuestra función teniendo esto en mente y que vamos a tener que actualizar esa propiedad de cantidad con cada agregado.</strong> Creamos una variable nueva "updatedCart" y usamos el .map() (recordemos que a diferencia de forEach(), nos va a devolver un array nuevo. Ambos sirven para iterar un arreglo pero .map() nos genera una copia nueva que va a estar en esta variable). Con cart.map( ) accedemos a cada elemento del carrito. También limitamos como número máximo 5 por guitarra. En este punto menciona el libro "Clean Code" y aconseja tanto seguir buenas prácticas ocmo tener preferencias personales; para este caso el es partidario de crear una constante con el valor máximo y es la que llamaremos en nuestra condición <strong>const MAX_ITEMS = 5</strong>:</p>

                  <pre><code class="language-js">
                    const &lsqb;data&comma; setData&rsqb; = useState(db)
                    const &lsqb;cart&comma; setCart&rsqb; = useState(&lsqb;&rsqb;)
                    const MAX&lowbar;ITEMS = 5
                    const MIN&lowbar;ITEMS = 1

                    function increaseQuantity(id){
                      //console.log('Incrementando...', id)
                      const updatedCart = cart.map ( item => {
                          if(item.id === id &amp;&amp; item.quantity &lt; MAX&lowbar;ITEMS){
                              return{
                                  ...item,//ponemos esto porque no queremos perder la referencia de loq ue ya tenemos en el cart
                                  quantity: item.quantity + 1 //si pusiéramos solo esto solo nos devolvería la cantidad
                              }
                          }
                          return item //para que mantenga el reto de elementos sobre los que no dimos click en aumentar cantidad
                      })
                      setCart(updatedCart) //esa variable la seteamos al carrito
                  }
                  </code></pre>

                  <p class="naranja">Reto 01: Decrementar cantidades</p>

                  <ul>
                    <li>Hacer funcional el botón de decrementar cantidades.</li>
                    <li>Crear la función, pasarla via props, identificar el elemento a actualizar y añadirlo al state, así como añadir un límite para nunca seleccionar menos de un elemento.</li>
                    <li>Seguir la convenciones de nombres de incrementar cantidad.</li>
                  </ul>

                  <pre><code class="language-js">
                    const &lsqb;data&comma; setData&rsqb; = useState(db)
                    const &lsqb;cart&comma; setCart&rsqb; = useState(&lsqb;&rsqb;)
                    const MAX&lowbar;ITEMS = 5
                    const MIN&lowbar;ITEMS = 1
                    
                    function decreaseQuantity(id){
                      //console.log('Decrementando...', id)
                      const updatedCart = cart.map( item => {
                          if(item.id === id && item.quantity > MIN_ITEMS){
                              return{
                                  ...item,//ponemos esto porque no queremos perder la referencia de lo que ya tenemos en el cart
                                  quantity: item.quantity -1 //si pusiéramos solo esto solo nos devolvería la cantidad
                              }
                          }
                          return item //cuando no se cumple la condición: mantiene el resto de elementos sobre los que no dimos click en decrementar cantidad
                      })
                      setCart(updatedCart)
                  }
                  </code></pre>

                  <p>Si presiono rápidamente en agregar cualquier guitarra podemos ver que nos pasamos del límite máximo de 5 que tenemos establecido por la variable <strong>const MAX_ITEMS = 5</strong>. <span class="destacado">Añadamos una nueva condición a la función addToCart() para que, en caso de que la posición actual de cart su cantidad sea mayor que el límite establecido no ejecute nada</span>. Vemos que en caso de que existiera ejecutábamos el código en el que <strong></strong>creábamos una nueva variables const updatedCart en la que hacíamos copia del cart actual con el spread operator y a continuación incrementábamos la cantidad del item y lo seteábamos en nuestro state de cart</strong>. No queremos que haga eso si en la posición actual del cart la cantidad supera el límite establecido. Añadimos <code class="language-js">if(cart[itemExists].quantity >= MAX_ITEMS) return</code>:</p>

                  <pre><code class="language-js">
                    function addToCart(item){
                      const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                      if(itemExists >= 0){//existe en cart
                          if(cart[itemExists].quantity >= MAX_ITEMS) return
                          const updatedCart = [...cart] //copia nueva de mi state, no modifica mi carrito       
                          updatedCart[itemExists].quantity++
                          setCart(updatedCart)
                      } else{//NO EXISTE en cart
                          item.quantity = 1
                          setCart(prevCart =>[...prevCart, item])
                      }       
                  }
                  </code></pre>

                  <p class="naranja">Agregando la función de Limpiar Carrito</p>

                  <p>Poríamos utilizar la función de nuestro state cart <strong>setCart()</strong> pero <span class="destacado">vamos a crear una función intermedia para borrar el carrito <span class="destacado">function clearCart(){}</span> en la que seteamos un arreglo vacío: setCart([])</span>. Esta es una de las grandes ventajas de los Hooks (por ejemplo para un usuario que se encontrara logado haríamos lo mismo seteando a false un supuesto state auth)</p>

                  <pre><code class="language-js">
                    function clearCart(){
                      setCart([]) //seteamos un arreglo vacío
                  }
                  </code></pre>
                  <p>como el botón donde vamos a llamar a esta función está en el componente Header.jsx, pasamos esa función vía props:</p>
                  <pre><code class="language-js">
                    &lt;Header
                    cart = &lcub;cart&rcub;
                    removeFromCart = &lcub;removeFromCart&rcub;
                    decreaseQuantity = &lcub;decreaseQuantity&rcub;
                    increaseQuantity = &lcub;increaseQuantity&rcub;
                    clearCart = &lcub;clearCart&rcub;           
                  /&gt;
                  </code></pre>
                
                </div>
                <!-- Fin bloque desplegable interior-->
            
      
      
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-82').toggle();">	
                  <h3>82. Carrito persistente con LocalStorage - Almacenando</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion6-82" class="hidden">
                  <p class="naranja">Carrito persistente con LocalStorage - Almacenando</p>
                  <p>Tener un carrito persistente es un buen truco para mantener los mismos elementos en el carrito aunque recarguemos navegador. ¿Cómo hacemos para tener sincronizado nuestro carrito de compras <code class="language-js">const [cart, setCart] = useState([])</code> con localStorage</p>
                  
                  <p>localStorage es una API muy sencilla que solo permite almacenar strings (ni objetos ni arrays). Como nuestro carrito es un array lo podemos convertir a string con <span class="destacado">JSON.stringify(cart)</span></p>

                  <pre><code class="language-js">
                  function saveLocalStorage(){
                    localStorage.setItem('cart', JSON.stringify(cart))
                  }
                  </code></pre>

                  <pre data-line="11"><code class="language-js">
                    function addToCart(item){
                      const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                      if(itemExists >= 0){//existe en cart
                          if(cart[itemExists].quantity >= MAX_ITEMS) return
                          const updatedCart = [...cart] //copia nueva de mi state, no modifica mi carrito       
                          updatedCart[itemExists].quantity++
                          setCart(updatedCart)
                      } else{//NO EXISTE en cart
                          item.quantity = 1
                          setCart(prevCart =>[...prevCart, item])
                      } 
                      saveLocalStorage()
                  }
                  </code></pre>

                  <p>Si vamos a las web developer tools, en la pestaña <strong>aplicación>storage</strong> podemos ver el Local Storage. Vemos que si añadimos un primer elemento al carrito agrega algo pero vacío, y ya la segunda vez sí agrega:</p>
                  
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/82-01-DYeZMwk4.png" alt="" />
                  
                  <p>El estado o state en React ¿es síncrono?¿o es asíncrono y por qué? Pos...es asíncrono, es decir, no se actualiza inmediatamente sino hasta algunos milisegundos después. ¿por qué es asíncrono? Si fuera síncrono (que todas las funciones se ejecuten en orden una tras otra) eso haría que no podríamos interaccionar con la pantalla hasta que no escriba ese estate, lo que nos dejaría sin respuesta en especial si es un state muy grande. <strong>Revisar:</strong> esa función saveLocalStorage() se manda llamar inmediatamente (mientras que el resto de nuestra función addToCart() es síncrona. Es decir cuadno la estamos llamando aún no ha sido escrito el cart por primera vez y es por eso que lo toma como un arreglo vacío</p>

                  <p>¿como lo solucionamos? usando el versátil <strong>Hook useEffect()</strong> (similar al watch en vue.js). Vimos su uso cuando el componente está listo pero también tiene el siguiente caso de uso (cuando cambie mi carrito ejecutar cierto código). Es muy útil para manejar los "efectos secundarios" de un cambio en nuestro state. <strong>Eliminamos la función que hemos creado y no obstante la usamos dentro del Hook que va a estar observando por nuestro state cart; cada vez que este cambie, ejecutará lo que le especificamos (lo que antes teníamos en la función).</strong>. React se va a encargar de actualizar el localStorage una vez que ese state haya completado su acción de actualizarse en base a las funciones que teNemos definidas para ese state en lo que llevamos hecho, no hemos de preocuparnos de crear una función. Abrimos chrome y limpiamos el local storage (boton derecho borrar) y podemos comprobar que si añadimos ahora elementos al carrito, ya desde la primera vez se actualiza el local storage.</p>

                  <pre><code class="language-js">
                    import { useState, useEffect } from "react" // importamos el Hook useEffect
                    //lo añadimos tras nuestras variables MIN_ITEMS, MAX_ITEMS
                    useEffect(() => {
                      localStorage.setItem('cart', JSON.stringify(cart))
                    }, [cart])
                  </code></pre>                               

                  <p class="naranja">Carrito persistente con LocalStorage - Recuperar los productos y mostrarlos</p>

                  <p>Si recargo me aparece el carrito vacío, veamos cómo hacemos que persista. Esto pasa porque el useEffect que empleo para el almacenamiento local cada vez que carrito cambie también se ejecuta por primera vez cuando el componente esta listo, es decir de manera similar a cuando no tiene ninguna dependencia. Debemos revisar si hay algo en localStorage ese va a ser nuestro valor inicial y si no colocamos un arreglo vacio. <strong>const inicialCart</strong> (en algunos ejemplos la nombran como inicialState pero no lo recomienda en caso de tener varios states)</p> 

                  <p>vamos a comprobar si hay algo en este elemento <strong>localStorageCart</strong>. (Si no hay nada devuelve un null) Si tiene algo lo convertimos de string a arreglo con JSON.parse()</p>

                    <pre data-line="5"><code class="language-js">
                      const initialCart = () => {
                        const localStorageCart = localStorage.getItem('cart') // lo primero es recuperar de localStorage
                        //a continuación comprobamos si hay algo en esa variable:
                        return localStorageCart ? JSON.parse(localStorageCart): []
                    }
                    const [data, setData] = useState(db)    
                    const [cart, setCart] = useState(initialCart)
                    </code></pre>
                  
                </div>
                <!-- Fin bloque desplegable interior-->
      
      
      <!-- Bloque desplegable interior-->
      <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-84').toggle();">	
        <h3>84. Últimos Ajustes y Deployment</h3>			
        <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
      </div>
      <div id="seccion6-84" class="hidden">
        <p>Veamos los últimos ajustes para realiszar el deployment de nuestro proyecto. Revismoas avisos en la terminal por si tenemos rutas a img mal puestas y también eliminamos funciones y/o variables que no se estén utilizando. En este caso como vemos, la función del state data "setData" no se está usando así que la podemos eliminar: <code class="language-js">const [data, setData] = useState(db) </code></p>

        <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/84-BJkjRQhC.png" alt="" />

        <p>¿Como podemos subir este proyecto? <span class="destacado">Este tipo de proyectos de React.js Vue.js Angular.js se tienen que construir</span>. Si abrimos el <strong>package.json</strong> vemos la línea de "build": "vite build". Todo loque tenemos está en desarrollo pero cuando construimos, este comando se va a encargar de realizar una serie de mejoras, de performance (subir versiones minificadas, más ligera...). Vamos a la terminal y escribimos <span class="destacado">npm run build</span> nos genera la carpeta <span class="destacado">dist</span>. En la consola nos da una serie de información "convertí 34 módulos" incluyendo nuestros componentes, nuestros archivos y también algunas d elas dependencias que imporamos en la parte superior, entonces Vite en automático se encarga de hacerlo. En esa carpeta dist genera nuestro index.html, la hoja de estilos y la js que contiene una versión de React. Pero si damos doble click a ese html eso no funciona, hay que subirlo a algún sitio. La mejor versión hoy día es Netlify. Si nos logamos de nuevas comenta que si la cuenta es muy nueva en Github va a haber errores (lo hacen para protegerse del spam) y presionamos en iniciar sesión con email.</p>

        <p>A continuación veamos cómo crear nuestros propios Hooks y por qué es bueno hacerlo. Lo haremos con uno que centralice todas las funciones de nuestro carrito de compra.</p>
        
      </div>
      <!-- Fin bloque desplegable interior-->
      

      <!-- BLOQUE CÓDIGO PROVISIONAL -->
      <div>
        <p class="rojo">App.jsx</p>
        <script type="text/plain" class="language-js h-300">
          import { useState, useEffect } from "react"
          import Guitar from "../components/Guitar"
          import Header from "../components/Header"
          import { db } from "./data/db"
          
          function App() {
              //console.log(db)
              // const [data, setData] = useState([])
              // useEffect( () => {
              //     setData(db)
              // },[])
          
              const initialCart = () => {
                  const localStorageCart = localStorage.getItem('cart') // lo primero es recuperar de localStorage
                  //a continuación comprobamos si hay algo en esa variable:
                  return localStorageCart ? JSON.parse(localStorageCart): []
              }
              const [data] = useState(db)    
              const [cart, setCart] = useState(initialCart)
              const MAX_ITEMS = 5
              const MIN_ITEMS = 1
          
              useEffect(() => {
                  localStorage.setItem('cart', JSON.stringify(cart))
              }, [cart])
              
          
              function addToCart(item){
                  const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                  if(itemExists >= 0){//existe en cart
                      if(cart[itemExists].quantity >= MAX_ITEMS) return
                      const updatedCart = [...cart] //copia nueva de mi state, no modifica mi carrito       
                      updatedCart[itemExists].quantity++
                      setCart(updatedCart)
                  } else{//NO EXISTE en cart
                      item.quantity = 1
                      setCart(prevCart =>[...prevCart, item])
                  }       
              }
          
              function removeFromCart(id){
                  //console.log('Eliminando...', id)      
                  setCart(prevCart => prevCart.filter(guitar => guitar.id !== id))
              }    
          
              function decreaseQuantity(id){
                  //console.log('Decrementando...', id)
                  const updatedCart = cart.map( item => {
                      if(item.id === id && item.quantity > MIN_ITEMS){
                          return{
                              ...item,//ponemos esto porque no queremos perder la referencia de lo que ya tenemos en el cart
                              quantity: item.quantity -1 //si pusiéramos solo esto solo nos devolvería la cantidad
                          }
                      }
                      return item //cuando no se cumple la condición: mantiene el resto de elementos sobre los que no dimos click en decrementar cantidad
                  })
                  setCart(updatedCart)
              }
          
              function increaseQuantity(id){
                  //console.log('Incrementando...', id)
                  const updatedCart = cart.map ( item => {
                      if(item.id === id && item.quantity < MAX_ITEMS){
                          return{
                              ...item,//ponemos esto porque no queremos perder la referencia de lo que ya tenemos en el cart
                              quantity: item.quantity + 1 //si pusiéramos solo esto solo nos devolvería la cantidad
                          }
                      }
                      return item //cuando no se cumple la condición: mantiene el resto de elementos sobre los que no dimos click en aumentar cantidad
                  })
                  setCart(updatedCart) //esa variable la seteamos al carrito
              }
          
              function clearCart(){
                  setCart([]) //seteamos un arreglo vacío
              }
          
              return (
                  <>   
                  <Header
                      cart = {cart}
                      removeFromCart = {removeFromCart}
                      decreaseQuantity = {decreaseQuantity}
                      increaseQuantity = {increaseQuantity}
                      clearCart = {clearCart}           
                  />
                
                  <main className="container-xl mt-5">
                      <h2 className="text-center">Nuestra Colección</h2>
          
                      <div className="row mt-5">
                          {data.map((guitar) => (                    
                              <Guitar
                                  key = {guitar.id} 
                                  propguitar = {guitar} 
                                  setCart = {setCart}    
                                  addToCart = {addToCart}                     
                              />
                          )
                          )}         
                      </div>
                  </main>
          
                  <footer className="bg-gray-300 mt-5 py-5">
                      <div className="container-xl">
                          <p className="text-white text-center fs-4 mt-4 m-md-0">GuitarLA - Todos los derechos Reservados</p>
                      </div>
                  </footer>        
                  </>
              )
          }
          
          export default App                         
        </script>
      </div>

      <div class="flex block-s">                 
        <div class="w-50 w-100-s">
          <p class="rojo">Guitar.jsx</p>
          <script type="text/plain" class="language-js">
            export default function Guitar({propguitar, addToCart}){

              //console.log(propguitar)
              const { id, name, image, description, price } = propguitar
          
              const handleClick = (guitar) => {
                  //setCart([...cart, guitar])
                  
              }
          
              return(
                  <div className="col-md-6 col-lg-4 my-4 row align-items-center">
                      <div className="col-4">
                          <img className="img-fluid" src={`/img/${image}.jpg`} alt="imagen guitarra" />
                      </div>
                      <div className="col-8">
                          <h3 className="text-black fs-4 fw-bold text-uppercase">{name}</h3>
                          <p>{description}</p>
                          <p className="fw-black text-primary fs-3">${price}</p>
                          <button 
                              type="button"
                              className="btn btn-dark w-100"
                              onClick={() => addToCart(propguitar)}
                          >Agregar al Carrito</button>
                      </div>
                  </div>
              )
          }       
          </script>
        </div>
        <div class="w-50 w-100-s">
          <p class="rojo">Header.jsx</p>
          <script type="text/plain" class="language-js">
            import { useMemo } from 'react'

            export default function Header({cart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart}){
            
                //State derivado
                const isEmpty = useMemo( () => cart.length === 0, [cart])
                const cartTotal = useMemo( () => cart.reduce( (total, item) => total + (item.quantity * item.price), 0), [cart])
                
                return(
            
                    <header className="py-5 header">
                        <div className="container-xl">
                            <div className="row justify-content-center justify-content-md-between">
                                <div className="col-8 col-md-3">
                                    <a href="index.html">
                                        <img className="img-fluid" src="/img/logo.svg" alt="imagen logo" />
                                    </a>
                                </div>
                                <nav className="col-md-6 a mt-5 d-flex align-items-start justify-content-end">
                                    <div className="carrito">
                                        <img className="img-fluid" src="/img/carrito.png" alt="imagen carrito" />
            
                                        <div id="carrito" className="bg-white p-3">
                                            
                                            {isEmpty ? (
                                                <p className="text-center">El carrito esta vacio</p>                                            
                                            ):(    
                                                <>                          
                                                <table className="w-100 table">
                                                    <thead>
                                                        <tr>
                                                            <th>Imagen</th>
                                                            <th>Nombre</th>
                                                            <th>Precio</th>
                                                            <th>Cantidad</th>
                                                            <th></th>
                                                        </tr>
                                                    </thead>
                                                
                                                    <tbody>
                                                        {cart.map( guitar =>( 
                                                        <tr key={guitar.id}>
                                                            <td>
                                                                <img className="img-fluid" src={`/img/${guitar.image}.jpg`} alt="imagen guitarra" />
                                                            </td>
                                                            <td>{guitar.name}</td>
                                                            <td className="fw-bold">
                                                                    ${guitar.price}
                                                            </td>
                                                            <td className="flex align-items-start gap-4">
                                                                <button
                                                                    type="button"
                                                                    className="btn btn-dark"
                                                                    onClick={() => decreaseQuantity(guitar.id)}>
                                                                    -
                                                                </button>
                                                                    {guitar.quantity}
                                                                <button
                                                                    type="button"
                                                                    className="btn btn-dark"
                                                                    onClick={() => increaseQuantity(guitar.id)}>
                                                                    +
                                                                </button>
                                                            </td>
                                                            <td>
                                                                <button
                                                                    className="btn btn-danger"
                                                                    type="button"
                                                                    onClick={() => removeFromCart(guitar.id)}>
                                                                    X
                                                                </button>
                                                            </td>
                                                        </tr>
                                                        ))}
                                                    </tbody>
                                                </table>
                                                <p className="text-end">Total pagar: <span className="fw-bold">${cartTotal}</span></p>
                                                </>
                                            )}
            
                                            
                                            <button 
                                                className="btn btn-dark w-100 mt-3 p-2"
                                                onClick={clearCart}
                                            >Vaciar Carrito</button>
                                        </div>
                                    </div>
                                </nav>
                            </div>
                        </div>
                    </header>
            
                )
            
            }       
          </script>
        </div>
      </div>
  <!-- FIN BLOQUE CÓDIGO PROVISIONAL -->
          
                
                  
              </div>			
            </div><!--Fin row-->
      
            
              
            
          </div>
          <!-- Fin div colapsable-->
      
      
        </div>
      </div>	
      <!-- FIN SECCIÓN 6 -->
    
  
      <!-- SECCION 3 y 4-->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
        <div class="row">
          <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion3').toggle();">	
            <h2>Sección 3 y 4: PROYECTO: Carrito de compras. Introducción / Herramientas / Creando el proyecto en Windows</h2>				
            <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
          </div>
          
          <div id="seccion3" class="hidden">
              
            <div class="row">
              <div class="col-12">	
                
                
                
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion3-46').toggle();">	
                  <h3>46. Introducción. El proyecto a construir GuitarLA</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion3-46" class="hidden">
                  <p class="font-bold">Proyecto carrito de compras GuitarLA</p>
      
                  <p>En este proyecto estaremos aprendiendo los fundamentos de React: <span class="destacado">Componentes, Eventos y State</span>, mientras creas un carrito de compras real con cantidades, precios, y más, tomaremos este mismo carrito para mostrarte como crear tus propios Hooks y como transformarlo a código de TypeScript y cuales son sus beneficios. Carrito de compra persistente sincronizando con localStorage (aprenderemos todas esas acciones agregar elementos, cambiarlos, cambiar cantidades, vaciar carrito...)</p>							
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/s1-01-D8LKf9H6.jpg" width="" height="" alt=""/> 
                  
                </div>
                <!-- Fin bloque desplegable interior-->
      
      
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion3-47').toggle();">	
                  <h3>47. Herramientas para crear aplicaciones en React.js</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion3-47" class="hidden">
                  <p class="font-bold">Tecnologías para crear aplicaciones en React</p>
                  <p>Permiten Crear una App En React en Minutos. Existen muchas formas de crear una app en React, incluso tu puedes crear tu propio ambiente de desarrollo con herramientas como Babel, Parcel, Webpack, Vite, etc</p>
      
                  <p>Pero también existe una gran cantidad de herramientas ya disponibles para crear aplicaciones en React en minutos sin conocer esta configuración</p>
                  
                  
                  <p class="font-bold">Ventajas de utilizar una herrmaienta ya existente: <strong>La mayoría de Herramientas ya existentes para crear aplicaciones en React son estables y siguen un enfoque muy claro: No tener que preocuparte por la configuración.</strong> Tú puedes crear tu propio ambiente de desarrollo pero tienes que asegurarte de que cada versión nueva de React, cada version de diferentes librerias sea compatible con tu proyecto y despues tienes que encontrar una forma de compilar código de css (sass etc) ...entonces vamos a gasta r más tiempo en solucionar este tipo de cosas que tirando código. Por eso se recomienda usar una herramienta ya existente</p>
      
                  <p>Cada una de estas herramientas ya existentes va desde básicas hasta avanzadas. Requieren tener instalado <span class="destacado">Node.js (NPM) o YARN</span>. Existen otros entornos hoy día como <strong>¿bum?</strong> Node.js con npm es bastante estable y es la que estaremos usando</p>
                  
                  <p>Opciones modernas para crear Apps en React. Los más populares hoy en día son<span class="destacado">Vite</span> y <span class="destacado">Next.js</span>. También Remix Run y Astro (que usaba en versiones anteriores del curso. Remix Run fue adquirido recientemente por shopify y están haciendo muchos cambios y no está listo)</p>
                  
                  <p class="font-bold">Recomendaciones del equipo de React</p>
      
                  <p>En su documentación recomiendan comenzar por Next.js o Remix para nuevos proyectos. Entonces ¿ya no se deben crear proyectos von Vite? Cuando creas proyectos con Vite tendrás que instalar dependencias para Routing, Consultas HTTP y más (herramientas como Next.js y Remix ya lo tienen incluido)</p>
      
                  <p><strong>Usualmente siempre hay que aprender primero la herramienta/lenguage de programación y después el framework por lo que esa recomendación es un poco rara, porque cuando estes creando un proyecto ya sea en Next.js o Remix tal vez estés escribiendo un código y no sabes si eso es React o si eso es Next. Y esa es la explicación de por qué los proyectos en este curso utilizan Vite y al final tendremos un proyecto con Next quedando más claro qué es React y qué es Next.js</strong></p>						
                </div>
                <!-- Fin bloque desplegable interior-->
      
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion4-48').toggle();">	
                  <h3>48. Instalando node y npm</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion4-48" class="hidden">
                  <p><a class="rojo" href="https://nodejs.org/es/" target="_blank">https://nodejs.org/es/</a> Requerimos node para crear nuestros proyectos pero también para instalar dependencias con npm</p>	
                
                  <p>Una vez instalado abrimos la terminal y comprobamos las versiones del entorno(node.js) <span class="destacado">node -v</span> y de las dependencias(npm) <span class="destacado">npm -v</span></p>
                  
                </div>
                <!-- Fin bloque desplegable interior-->
      
      
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion4-49').toggle();">	
                  <h3>49. Creando el primer proyecto</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion4-49" class="hidden">
                  <p>Abrimos terminal, vamos al escritorio (que es donde voy a crear los proyectos) y ponemos <span class="destacado">npm create vite@latest</span> (si es la primera vez nos pedirá instalar la dependencia de vite le decimos que "y"). A continuación nos pide nombre y lo llamamos <strong>guitarla</strong>. A continuación nos pide que elijamos framework (Vanilla, Vue, <strong>React</strong>, Preact, Lit, Svelte, Solid, Qwik, Others) y elegimos React. Nos pide elegir variante, normalmente y como él ha trabajado este curso es <strong>Typescript + SWC</strong>(SWC es un compilador nuevo de los de Vite basado en Ros, muy rápido)  pero al ser el primer proyecto elegiremos <strong>Javascript + SWC</strong>. Remix es una alternativa a Next.JS de los creadores de shopify pero este curso no incluye remix porque la compra fue hace poco y están modificando/agregando muchas cosas</p>
                
                <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/49-1-D8j_fj-g.png" alt="" />
      
                <p>ejecutamos los 3 comandos que nos indica para situarnos en la nueva carpeta del proyecto <span class="destacado">cd guitarla</span>, instalar las dependencias <span class="destacado">npm install</span>y arrancar el proyecto <span class="destacado">npm run dev</span></p>
      
                <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/49-2-DvNo3u2x.png" alt="" />
      
                <p>Cuando generamos un proyecto en React con Vite vemos que la estructura por defecto es muy simple:</p>					
                <ul>
                  <li><strong>carpeta "node_modules":</strong> las dependencias del proyecto. Va creciendo conforme instalamos más dependencias</li>
                  <li><strong>carpeta public:</strong> colocaremos por ej imagenes que seran accesibles para los visitantes de nuestro sitio web o app</li>
                  <li><strong>carpeta src:</strong> colocaremos todo nuestro código. Si revisamos la página de inicio de nuestro proyecto <strong>http://localhost:5173/</strong> nos dice: <strong>Edit src/App.jsx and save to test HMR</strong>. Así que abramos ese jsx, que es la página de inicio. 
                    <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/49-3-mXLELteO.png" alt="" /><br>
                    En esta carpeta <strong>src</strong> es donde vamos a pasar la mayor parte del tiempo escribiendo código (colocaremos nuestros customs hooks, librerías, componentes...).
                  </li>
                  <li>.gitignore: va a ignorar algunos archivos</li>
                  <li><strong>index.html:</strong> básicamente lo que hace es inyectar React en el div <code class="language-html">&lt;div id="root"&gt;&lt;/div&gt;</code>. Si abrimos el <strong>main.jsx</strong> vemos el siguiente código donde se busca ese div con id="root" donde monta toda la aplicación de React. En el index.html podemos poner algún bg-gray-200, agregar algunos tags mas de html que sean importantes para nuestro proyecto, pero no vamos a escribir código html ahí habitualmente.
                  <pre><code class="language-js">
                    createRoot(document.getElementById(&apos;root&apos;)).render(
                      &lt;StrictMode&gt;
                        &lt;App /&gt;
                      &lt;/StrictMode&gt;&comma;
                      )						
                  </code></pre>
                  </li>
                  <li><strong>package.json:</strong> ahí está el comando de "dev" que ejecutamos para arrancar y tiene algunos comandos para construir proyecto, previsualizarlo, y es donde se instalan las dependencias del proyecto y las de desarrollo. Al tener esas dependencias y sus versiones indicadas nos aseguramos que el equipo de trabajo sepa qué depndencias hay que tener para funcionar correctamente.</li>
                </ul>
                
                  
                </div>
                <!-- Fin bloque desplegable interior-->
      
                    
              </div>			
            </div><!--Fin row-->
      
          </div>
          <!-- Fin div colapsable-->
      
      
        </div>
      </div>	
      <!-- FIN SECCION 3 y 4-->	


      <!-- SECCION 2 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">	
        <div class="row">
          <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion2').toggle();">	
            <h2>Sección 2: Introducción a JavaScript para React</h2>				
            <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
          </div>
          
          <div id="seccion2" class="hidden">
      
            <div class="row">
              <div class="col-12 pl-1.25">	


                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-9').toggle();">
                  <h3>9. Variables creadas con let / 10. Variables creadas con const</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-9" class="hidden"> 

                  <p><span class="destacado">Los nombres de variables han de ser descriptivos y no pueden iniciar con * ni números ni caracteres especiales.</span></p>
                  <p>Podemos usar comillas dobles o simples para asignar valor string a una variable (pero no mezclar tipo de comillas, nos da error)</p>   
                  <p class="naranja">Variables creadas con let</p>               
                                
                  <ul>
                    <li>Pueden ser inicializadas con un valor o sin valor:
                      <pre><code class="language-js">
                        /*Podemos inicializarlas con un valor y después reasignarle otro valor. Con const no se puede hacer eso con otros lenguages no podríamos hacer esto pero Javascript es un lenguage de tipo dinámico donde el tipo de dato se asigna por su valor y no por la variable)*/
                        let cliente ="Juan"
                        cliente=30
                      </code></pre>                  
                      <pre><code class="language-js">
                        //Podemos inicializarlas sin valor y asignarlo después
                        let precio
                        precio = 200
                      </code></pre>
                    </li>
                  </ul>             
                  
                  <p>Si la inicializamos y no le asignamos valor y hacemos un console.log vemos que sale <span class="destacado">"Undefined"</span> <strong>es un tipo de dato en Javascript que nos indica que la variable fue inicializada pero nunca tuvo ningún valor</strong></p>
                  <p><strong>si hacemos un console.log de una variable "cantidad" que no hemos definido</strong> nos da el error <span class="destacado">"cantidad is not defined"</span></p>                   
                  <pre><code class="language-js">
                    var //(versiones anteriores, ya no se usan)
                    let
                    const

                    console.log('Hola Mundo')
                    console.log(2+2)
                    
                    let cliente = 30
                    cliente="Juan"                  
                    let calzado
                    
                    console.log(cliente)
                    console.log(calzado)
                    console.log(cantidad)                 
                  </code></pre>

                  <p class="naranja">variables creadas con const</p>
                  <ul>
                    <li>Tienen que ser inicializadas con un valor</li>
                    <li>No se pueden reasignar. si lo intentamos en la consola nos sale el error <span class="destacado">"Asignment to constant variable"</span></li>
                  </ul>
                  <p></p>
                    <pre><code class="language-js">
                      const cliente = 30 
                      cliente="Juan" 
                    </code></pre>
                    
                    <p>¿entonces let es mejor porque nos da mas flexibilidad de posibilidades? No.<br>
                    <span class="destacado">
                      Vamos a utilizar mas veces const que let. Lo normal es querer tener en nuestro código variables const
                      y let será una "excepción" cuando queramos inicializar sin valor y/o reasignar
                    </span></p>
                </div>
                <!-- Fin bloque desplegable interior-->
                
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-11').toggle();">
                  <h3>11. Tipos de Datos en JavaScript</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-11" class="hidden">
                  <pre><code class="language-js">
                    /* Tipos de dato

                    Javascript tiene pocos tipos de datos: string, number, 
                    
                    para saber el tipo de dato de una variable, operador typeof antes de la variable
                    console.log (typeof cliente)
                    
                    si nos ponemos encima de esta variable let alumno = "Juan" con el IntelliSense (IS) de Visual Studio si te pones encima de la variable te dice el tipo de dato --&gt; string 
                    (con let, con const no rula esto en Visual Studio code pero usamos el typeof)
                    El Undefined lo marca como any (que es específico de Typescript. Lo veremos y veremos por qué hay que evitarlo)
                    */
                    
                    //Undefined
                    let cliente
                    console.log (cliente)
                    console.log (typeof cliente)
                    
                    //Strings o cadenas de texto. Sirven para representar el nombre de un producto, categoría, reviews....
                    let alumno = "Juan"
                    const producto = 'Monitor 49 pulgadas'
                    console.log(alumno)
                    console.log(typeof alumno)
                    console.log(producto)
                    
                    //Numbers
                    const numero = 40
                    const numero2= 40.40
                    const numero3 = -100
                    console.log(numero)
                    console.log(numero2)
                    console.log(numero3)
                    console.log(typeof numero3)
                    
                    //BigInt
                    const numeroGrande = BigInt(1263472832934827342938427348274)
                    console.log(numeroGrande)
                    
                    //Boolean (true o false) --&gt; El usuario está bloqueado o no / autenticado o no / producto agotado o no....
                    const descuento = true;
                    console.log(typeof descuento)
                    
                    //Null
                    const descuento2 = null 
                    console.log(descuento2) //lo estoy asignando pero no existe no es nada. Es probable que queramos asignar null a una variable
                    
                    let precio
                    console.log(precio)     //--&gt; variable declarada pero no tiene valor
                    
                    //Symbol --&gt; son buenos para librerias. normlamente no los usaremos. Cada Symbol es distinto a otro no hay dos iguales. Son únicos, aunque los comparemos y tengamos el mismo valor, siem,pre son diferentes
                    const primerSymbol = Symbol(30)
                    const segundoSymbol = Symbol(30)
                    console.log(primerSymbol)
                    console.log(primerSymbol == segundoSymbol)
                    
                    //Objetos --&gt; veremos en su propio vídeo. La parte más importante en Javascript y una de las características que más vamos a trabajar sea con React, Node, Vue.js...
                    //Arrays o Arreglos también terminan siendo objetos                  
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-12').toggle();">
                  <h3>12. Objetos y Destructuring / 13. Manipulación de objetos</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-12" class="hidden">
                  <p>Los <span class="destacado">Objetos</span> son la parte más importante en Javascript y una de las características con las que más vamos a trabajar sea con React, Node, Vue.js...  Los Arrays=Arreglos también terminan siendo objetos</p>
                  <ul>
                    <li>Un objeto es una colección de propiedades; pueden tener múltiples propiedades SEPARADAS POR ","</li>
                    <li>Una propiedad es una asociación entre un nombre=clave(key) y un valor(value)</li>
                    <li>Sintaxis con llaves --&gt; <code class="language-js">let producto = {  }</code> / <code class="language-js">const producto = {}</code> /</li>
                  </ul>
                  <p>Por tanto siempre que veamos esta sintaxis estaremos viendo un objeto, una colección de propiedades (asociaciones key+value)</p>

                  <p class="mt-1.25 mb-0"><span class="naranja">Generar Objetos:</span> cada <span class="destacado">propiedad</span> de un objeto está formada por una asociación <span class="destacado">clave/valor</span> o pareja key/value. Las propiedades van separadas por comas.</p>
                  <pre><code class="language-js">
                    const producto = {
                        nombre : "Tablet",   // Esto es una propiedad. nombre es "key", "Tablet" es el "value". 
                        precio : 300,
                        disponible : false
                    }
                    console.log(producto); //veamos en la consola como se ven los objetos. dandole al triangulito expandimos y vemos las propiedades del mismo
                    console.log(typeof producto)
                    console.table(producto) //para objetos muy grandes y también para arrays podemos usar console-table para verlos formateados en la consola
                  </code></pre>

                  <p class="mt-1.25 mb-0"><span class="naranja">Acceder a Objetos:</span> Una de las características de los objetos es que podemos <span class="destacado">acceder a cada una de las propiedades de un objeto usando la sintaxis de "."</span> y vemos como nos aparece el autocompletado de VSCode y podemos elegir la propiedad (asociación key/value) que queramos. <strong>Si tratamos de acceder a una propiedad que no existe nos devuelve un Undefined</strong>.</p>
                  <pre><code class="language-js">                   
                    console.log(producto.nombre)
                    console.log(producto.precio)
                    console.log(producto.autenticado) // si tratamos de acceder a una propiedad que no existe nos devuelve Undefined
                  </code></pre>
                
                  <p class="mt-1.25 mb-0"><span class="naranja">Destructuring:</span> en versiones recientes de JS desde ECMAS6 agregaron "Destructuring" lo que nos permite en una sola línea de código extraer un valor y generar una variable. Está pensado para reducir código y usarlo siempre que podamos. Antes, en versiones anteriores de JS era muy común crear una variable y asignarle la propiedad de un objeto, por ejemplo:</p>
                  <pre><code class="language-js">                     
                    const nombre = producto.nombre
                    const precio = producto.precio
                    const disponible = producto.disponible
                    console.log(nombre)
                    console.log(precio)
                    console.log(disponible)                  

                    //Con "Destructuring" una sola línea de código extraemos un valor del objeto que hay tras el = y generamos variable.
                    const {} = //lo que hay detrás del igual es el objeto sobre el cual queremos aplicar destructuring, extraer un valor
                    const { nombre } = producto //nombre es la variable
                    console.log(nombre)
                  </code></pre>
                  
                  <pre><code class="language-js">
                    //La sintaxis del Destructuring
                    const { nombre, precio, disponible } = producto // aquí lo estamos haciendo en una sola línea, extrayendo el valor y generando las variables 
                    console.log(nombre)
                    console.log(precio)
                    console.log(disponible)
                  </code></pre> 

                  <p class="mt-1.25 mb-0"><span class="naranja">Object Literal Enhacement:</span> también pensado para reducir código. Sirve para colocar dentro de un objeto. ¿En qué casos es util? cuando tenemos una función que realiza ciertas operaciones y en lugar de devolver un monton de variables, devuelves un objeto con todo agrupado. Supongamos que tenemos las dos variables siguientes:</p>
                  <pre><code class="language-js">
                    const autenticado2 = true
                    const usuario = "Juan"

                    const nuevoObjeto = {
                        autenticado2 : autenticado2,
                        usuario: usuario
                    }

                    //si el key y el value se llaman igual puedo hacer esto
                    const nuevoObjeto = {
                        autenticado2 
                        usuario
                    }
                    console.log(nuevoObjeto)
                  </code></pre> 

                  <p class="mt-1.25 mb-0"><span class="naranja">Manipulación de objetos</span> El object de JS es muy grande y si abrimos la documentación de MDN vemos todos los métodos que podemos usar con el constructor de object <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object</a>
                </p>

                  <pre><code class="language-js">
                    //¿Como evitamos que se pueda manipular un objeto? Con TS es fácil, con JS usemos un par de métodos
                    Object.freeze(producto) //Evita que se manipule ninguna propiedad del objeto (ni ninguna existente, ni añadir una nueva ni eliminar ninguna)
                    Object.seal(producto) //Permite modificar las existentes en el objeto pero ni añadir ni eliminar ninguna propiedad

                    //Reescribir un valor
                    producto.disponible = true

                    //Si no existe la propiedad la va a añadir
                    producto.imagen = 'image.jpg'

                    //Eliminamos propiedad
                    delete producto.precio

                    console.log(producto)
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-14').toggle();">
                  <h3>14. Destructuring de 2 o más objetos</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-14" class="hidden">
                  <pre><code class="language-js">
                    // OBJETOS Destructuring de dos o más objetos:
                    const producto = {
                        nombre : "Tablet",   // Esto es una propiedad. nombre es "key" "Tablet" es el "value". las propiedades van separadas por comas
                        precio : 300,
                        disponible : false
                    }
                    
                    const cliente = {
                        nombre: "Juan",
                        premium: true,
                        direccion: {
                            calle: "Calle Nuevo Mexico"
                        }
                    }
                    
                    const { nombre } = producto
                    //const { nombre } = cliente //-->esto nos daba error. veamos a continuación como renombramos ese valor para evitar colisión de nombres
                    //const { nombre: nombreCliente, direccion: calle } = cliente
                    const { nombre: nombreCliente, direccion: { calle } } = cliente
                    
                    /*analizando la notación anterior:
                    
                        nombre: nombreCliente --> renombra la variable
                        direccion: { calle } --> entra a ese objeto y entra a calle
                    */
                    
                    
                    console.log(nombre)
                    console.log(nombreCliente)
                    console.log(calle)
                    
                    // Muchas veces instalaremos varias dependencias y cuando devuelven valores, resulta que las variables se llaman igual. Para evitar colisión de nombres 
                    // Viene bien saber como poder renombrarlas de esta manera.
                  </code></pre>
                

                </div>
                <!-- Fin bloque desplegable interior-->
              
                
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-15').toggle();">
                  <h3>15. Unir dos o más objetos</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-15" class="hidden">
                  <pre><code class="language-js">
                    // OBJETOS unir dos o mas objetos, técnicas y sintaxis que marca diferencia. Le dedica mucho tiempo a losobjetos porque es lo que más se utiliza en React:
                    const producto = {
                        nombre : "Tablet",   // Esto es una propiedad. nombre es "key" "Tablet" es el "value". las propiedades van separadas por comas
                        precio : 300,
                        disponible : false
                    }
                    
                    const cliente = {
                        nombre: "Juan",
                        premium: true    
                    }
                    
                    //supongamos que añadimos el objeto producto a un carrito
                    const carrito = {
                        cantidad: 1,
                        //si lo hacemos así nos agrega el objeto producto DENTRO de este objeto carrito, pero queremos unirlo
                        //producto 
                        // para que las key del objeto producto sean key de este objeto carrito (que el objeto carrito sea plano) Usamos para ello el "spread operator":
                        ...producto 
                    }
                    console.log(carrito)
                    
                    //este código tiene 2 objetos dentro (obtiene una copia)
                    const nuevoObjeto = {
                        producto: {...producto},
                        cliente: {...cliente},
                    }
                    console.log(nuevoObjeto)
                    
                    //podríamos obtener exactamente lo mismo que antes simplificando la sintaxis usando el 'object literal enhancement' diciendo:
                    // 'genérame un key de producto con el objeto producto y un key de cliente con el objeto cliente':
                    const nuevoObjeto2 = {
                        producto,
                        cliente
                    }
                    console.log(nuevoObjeto2)
                    
                    //si hago esto va a ser completamente diferente, un objeto plano pero ¡OJO! el key nombre del objeto producto no está!!!! porque el key nombre del objeto cliente reescribe el anterior
                    const nuevoObjeto3 = {
                        ...producto,
                        ...cliente
                    }
                    console.log(nuevoObjeto3)
                    
                    //lo anterior lo podemos hacer con menos código usando el Object.assign
                    const nuevoObjeto4 = Object.assign(producto, cliente)
                    console.log(nuevoObjeto4)
                    
                    //En react existe el término "inmutabilidad" es decir, no modificas directamente un objeto sino en base a ciertas funciones.
                    //Es importante entender las diferentes funciones que nos ofrece para poder cambiar algunos valores. Eso nos va a quedar más claro con los proyectos de React.
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-16').toggle();">
                  <h3>16. Template Strings y Concatenación</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-16" class="hidden">
                  <pre><code class="language-js">
                    //Template Strings y Concatenación

                    const producto = "Tablet de 12 pulgadas"
                    const precio = 400
                    const marca = "Orange"
                    
                    //como se hacía antes en js este tipo de concatenación (con + o ,)
                    console.log('El producto es: ' + producto) 
                    console.log(producto + "$" + precio + " Dolares, marca " + marca) 
                    
                    //hagamos este mismo código con los Template Strings como se hace ahora (con ``)
                    console.log(`El producto es ${producto}`)
                    console.log(`${producto} ${precio} Dolares, marca ${marca} `)
                    
                    //En React se utiliza básicamente así. Algo muy similar: "jsx" que nos permite mezclar html con js en React
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-17-19').toggle();">
                  <h3>17. Arrays / 18. Modificar Arrays / 19. Destructuring de Arrays</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-17-19" class="hidden">
                  <p>Los Arrays (Arreglos) junto con objetos es de lo que más se utiliza en nuestro código. Es un objeto similar a un listado que tiene métodos para realizar varias operaciones. Diferencias: </p>                
                  <ul>
                    <li>corchetes en vez de llaves</li>
                    <li>no tienen clave/valor sino solo valor</li>
                    <li>su llave va a ser el índice que se asigna automáticamente en base a su posición en el arreglo</li>
                  </ul>
                  <p>Los arreglos pueden mezclar tipos de datos en su interior pero se recomienda que un arreglo contenga estructura y que sea acorde para tener un mejor orden en el código</p>

                  <pre><code class="language-js">
                    const tecnologias = [20,30,40]

                    console.log(tecnologias)
                    console.table(tecnologias)
                    
                    console.log(tecnologias[1])                  
                  </code></pre>

                  <p class="mt-1.25 mb-0"><span class="naranja">Modificar Arrays</span></p>

                  <pre><code class="language-js">
                    const tecnologias = ['HTML','CSS','Javascript','React.js','Node.js']

                    tecnologias[5] = 'Nest.js'
                    tecnologias.push('Nest.js')
                    console.log(`tecnologias:`)
                    console.table(tecnologias)                  
                  </code></pre>

                  <p><strong>si vamos al navegador consola y desplegamos el [[prototype]] vemos todos los métodos disponibles para ese array</strong>. Cada tipo de datos tiene sus métodos. <span class="destacado">¡¡¡¡IMPORTANTE!!!!</span> En React siempre hemos de escribir nuestro código con funciones que no modifiquen directamente los valores de lo que se conoce como el "state". En esta página <a href="https://doesitmutate.xyz/" target="blank">https://doesitmutate.xyz/</a> podemos consultar si los métdos que nos aparecen en <strong>[[prototype]]</strong> de la consola del navegador modifican o no nuestro array. Como vemos si buscamos ahí por ejemplo el método "push()", sí modifica (mutates) nuestro arreglo por lo que no se recomienda utilizar push() con react. </p>

                  <p class="font-bold">Alternativa a push</p>
                  <pre><code class="language-js">
                    const nuevoArreglo = [...tecnologias, 'Nest.js'] // básicamente esos "..." copian tecnologías y a continuación indicamos optro valor más que es  'Nest.js'
                    //si lo quisiéramos al inicio --&gt; const nuevoArreglo = ['Nest.js', ...tecnologias]
                    console.log(`nuevoArreglo: alternativa a push() ${nuevoArreglo}`)                  
                  </code></pre>
                  
                  <p class="font-bold">método shift() elimina el primer elemento de un array. Modifica el array</p>
                  <pre><code class="language-js">
                    const tecnologias2 = ['HTML','CSS','Javascript','React.js','Node.js']
                    tecnologias2.shift();
                    console.table(`tecnologias2: usamos shift para eliminar primer valor ${tecnologias2}`)
                  </code></pre>  
                  
                    <p class="font-bold">alternativa a shift() --&gt; usamos filter() que no modifica nuestro arreglo</p>
                    <pre><code class="language-js">
                    console.log(`tecnologias3: alternativa a shift, uso de filter()`)
                    const tecnologias3 = tecnologias.filter(function(tech){
                        //console.log(tech)
                        if(tech!=='HTML'){ 
                            return tech 
                        }
                    })
                    console.table(tecnologias3)
                    </code></pre>
                    
                    <p class="font-bold">map() que itera sobre TODOS los elementos de nuestra colección</p>

                    <pre><code class="language-js">
                    //veamos como modificar un valor sin cambiar el array original, por ejemplo tecnologias[5] = 'Nest.js'. 
                    // Usamos map() que itera sobre TODOS los elementos de nuestra colección
                    console.log(`tecnologias4: uso de map()`)
                    const tecnologias4 = tecnologias.map(function(tech){
                        //console.log(tech)
                        //Queremos buscar el valor 'Node.js' para modificarlo por 'Nest.js' pero queremos mantener el resto
                        if(tech === 'Node.js'){
                            return 'Nest.js'
                        } else { // si no ponemos este else, vemos en consola que cuando no se cumple la condición devuelve undefined
                            return tech
                        }
                    })
                    console.table(tecnologias4)
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-19').toggle();">
                  <h3>19. destructuring arrays</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-19" class="hidden">
                  <pre><code class="language-js">
                    const tecnologias = ['HTML','CSS','Javascript','React.js','Node.js']

                    //variable con la posicion 3 del array
                    
                    const react = tecnologias[3]
                    console.log(react)
                    
                    // El destructuring de arrays los va a ir extrayendo en base a la posición
                    const [html, estilos, script] = tecnologias
                    console.log(html) //--> HTML
                    console.log(estilos) // --> CSS
                    //si quisiéramos sacar el valor de una única posición, por ej 'React.js' usando esta sintaxis de destructuring hemos de usar comas dejando los espacios
                    //(contar como en las tablas de colaboradores!!!! :D)
                    
                    const [ , , , reactjs] = tecnologias
                    console.log(reactjs)
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-20').toggle();">
                  <h3>20. Recorriendo arrays con for / 21. Recorriendo arrays con forEach, map y for ... of</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-20" class="hidden">
                  <pre><code class="language-js">
                    //recorriendo/iterar arrays

                    const tecnologias = ['HTML','CSS','Javascript','React.js','Node.js']
                    
                    // console.log(tecnologias[0])
                    // console.log(tecnologias[1])
                    // console.log(tecnologias[2])
                    // console.log(tecnologias[3])
                    // console.log(tecnologias[4])
                    
                    //igual que map() para iterar un array o filter() para sacar o mantener elementos de un arreglo existen métodos/funciones para iterar una array fácilmente
                        // for(let i = 0; i &lt; 5; i++) { 
                        //     //console.log(i) 
                        //     console.log(tecnologias[i]) 
                        // }
                    
                    /*si añadiéramos un nuevo valor al array sin modificar el bucle, por ejemplo al final vemos que no nos sale.
                    un arreglo va a crecer o ser mas pequeño en fcn de lo que el usuario haga en nuestra App. por ejemplo un carrito de compras, que se inicia con un arreglo vacío,
                    en función de lo que haga un usuario u otro se han podido añadir 3 elementos, 8, ninguno...
                    por tanto SIEMPRE TENEMOS QUE ESCRIBIR NUESTRO CÓDIGO DE FORMA DINÁMICA, QUE SE ADPATE A TODOS LOS ESCENARIOS*/
                    
                    //revisemos cuántos elementos hay en el arreglo para que el iterador se ejecute esa cantidad de veces
                    
                        // for(let i = 0; i &lt; tecnologias.length; i++) { 
                        //     //console.log(i) 
                        //     console.log(tecnologias[i]) 
                        // }
                    
                    //aunque un for (que se usa en C#, php, Java) no tiene nada de malo, js ha hecho 3 iteradores que son mas sencillos y claros de usar
                    
                    //forEach()  --&gt; MÉTODO QUE EJECUTA UNA FUNCIÓN INDICADA POR CADA ELEMENTO DEL ARREGLO
                    
                        // tecnologias.forEach(function(){
                        //     console.log('Desde la función')
                        // })
                    
                        //dentro de ese function podemos pasarle lo que queramos como parámetro, antes usamos 'tech' but podemos ponerle por ejemplo la letra 'a' y veremos que aparecen cada uno de esos valores
                        // tecnologias.forEach(function(a){
                        //     console.log(a)
                        // })
                    
                        //normalmente el nombre del parámetro ha de ser descriptivo de los valores que contenga el array, por ejemplo array de automóviles--&gt;parámetro 'automovil'. 
                        // Así que en este caso lo dejamos en 'tech'. Como vemos es mas sencillo que el bucle loop. Ya sabe cuantas veces ejecutarse porqeu ya sabe la extensión del
                        //array sobre el que se está ejecutando
                        // tecnologias.forEach(function(tech){
                        //     console.log(tech)
                        // })
                    
                    //map() --&gt; sirve para iterar pero su característica ppal es que CREA UN NUEVO ARREGLO, en base a las condiciones de la fcn. 
                    
                        // tecnologias.map(function(tech){
                        //     console.log(tech)
                        // })
                    
                        //Veamos esta característica diferencial con el siguiente código. El primer console.log (en el que intentamos return tech usandi forEach) nos dará un undefined
                        const arrayforEach = tecnologias.forEach(function(tech){
                            //return tech
                            console.log(tech)
                        })
                        const arrayMap = tecnologias.map(function(tech){
                            return tech
                        })
                    
                        console.log(arrayforEach)
                        console.log(arrayMap)
                    
                        // map() es el más utilizado con React. Por tanto DIFERENCIA:
                        /*
                        forEach() ejecuta una función dada tantas veces como valores  tiene un arreglo
                        map() genera un array nuevo en base a la condicion/fcn que le estás pasando
                        */
                    
                    // for ... of --&gt; EJECUTA UN BLOQUE DE CÓDIGO POR CADA ELEMENTO DE UN ARREGLO. Se parece mucho al for y tiene algo del forEach
                    
                    for(let tech of tecnologias){
                        console.log(tech)
                    }
                    // for(let i = 0; i &lt; tecnologias.length; i++) { 
                    //     console.log(tecnologias[i]) 
                    // }
                    
                    //tecnologias.forEach(function(){
                    //     console.log('Desde la función')
                    // })//recorriendo/iterar arrays
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-22').toggle();">
                  <h3>22. Funciones: Function declaration / Function Expression / Arrow Functions</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-22" class="hidden">
                  <p>Las funciones nos van a permitir escribir código reutilizable en js y en cualquier lenguage de programación. Vamos a separar el código en pequeñas funciones con su propósito. <strong>Ojo con los nombres (mismas restricciones que nombres de variables, no empezar por números, guiones...)</strong></p>
                  <p class="mt-1.25 mb-0"><span class="naranja">Funciones - Function declaration:</span> </p>
                  <pre><code class="language-js">
                    function sumar(){
                          console.log(1+1)
                      }
                    //Llamamos a la fcn, y además como son reutilizables, tantas veces como queramos. Se la puede llamar antes de declararla.
                      sumar()
                      sumar()
                    
                      function sumar(){
                          console.log(1+1)
                      }
                  </code></pre>

                  <p>Hemos de escribir funciones "inteligentes" que manejen <span class="destacado">parámetros:</span> es una variable especial que se utiliza en una función y cuyo valor se refiere a valores que vienen del exterior. <span class="destacado">En el ejemplo siguiente: numero1 y numero2 es un parámetro mientras que '10' es un argumento</span></p>
                  <pre><code class="language-js">
                    function sumar(numero1, numero2){   
                      console.log(numero1)
                      console.log(numero2)
                      console.log(numero1+numero2)
                    }
                    sumar(10, 20)
                    sumar(100, 131)
                  </code></pre>
                  <p>Hemos de saber qué tipo y cuantos argumentos mandarle a nuestra función (tanto conociendo la librería que importemos como haciedo uso del helper=Intellisense de Visual Studio) por ejemplo si a la fcn anterior le mandamos un único argumento numérico, como espera 2 números trata de sumar un número con NADA y devuelve 'NaN' (Not a Number). Para estos casos podríamos utilizar los <strong>parámetros por default</strong>, cuando un valor no está presente utilizar esos valores.</p> 
                    <pre><code class="language-js">
                      function sumar(numero1 = 0, numero2 = 0){
                        console.log(numero1+numero2)
                      }                   
                    </code></pre>
                  
                  <p class="mt-1.25 mb-0"><span class="naranja">Funciones - Function Expression:</span> Sintaxis similar, hacen lo mismo, but en este caso si intentamos llamar a la función antes de declararla nos devuelve error</p>

                  <pre><code class="language-js">
                    sumar(10, 20)
                    // sumar(300, 1)
                    // sumar(100)

                    const sumar = function (numero1 = 0, numero2 = 0){   
                      console.log(numero1+numero2)
                    }
                  </code></pre>
                  <pre><code class="language-js">
                  // En este caso podemos sí podemos llamar a la función antes de declararla. No están ni mucho menos deprecadas y se siguen utilizando mucho.
                  sumar(10, 20)
                  sumar(300, 1)
                  sumar(100)

                  function sumar(numero1 = 0, numero2 = 0){ 
                    console.log(numero1+numero2)
                  }
                  </code></pre>

                  <p class="mt-1.25 mb-0"><span class="naranja">Funciones - Arrow function:</span> Al igual que las function expressions si intentamos llamarla antes de declararla nos da error. La sintaxis es como las function expressions sin la palabra "function" y añadiendo "=>" entre el ")" y la "{"</p>

                  <pre><code class="language-js">
                    //const sumar = function(numero1 = 0, numero2 = 0) {

                    const sumar = (numero1 = 0, numero2 = 0) => {
                        console.log(numero1 + numero2)
                    }
                  
                    sumar(10, 20)
                    sumar(300, 1)
                    sumar(100)
                  </code></pre>

                  <p>Si nuestras funciones solo tienen una línea, podemos eliminar las llaves:</p>
                  <pre><code class="language-js">
                    const sumar = (numero1 = 0, numero2 = 0) => console.log(numero1 + numero2)
                  </code></pre>

                  <p><span class="destacado">Todas las fcnes que hemos visto devuelven valores</span>. A continuación veremos la otra característica que tienen las arrow functions y funciones que devuelven valores</p>
                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-25').toggle();">
                  <h3>25. Funciones que retornan valores</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-25" class="hidden">
                  <p>A continuación veremos la otra característica que tienen las arrow functions y funciones que devuelven valores</p>
                  <pre><code class="language-js">
                    // Funciones que devuelven valores. Veámoslo con los 3 tipos de funciones
                    const sumar = function (numero1 = 0, numero2 = 0){   
                        //console.log(numero1 + numero2)
                        return numero1 + numero2
                    }
                
                    function sumar(numero1 = 0, numero2 = 0){ 
                        //console.log(numero1+numero2)
                        return numero1 + numero2
                    }
                
                    //const sumar = (numero1 = 0, numero2 = 0) => console.log(numero1 + numero2)
                    const sumar = (numero1 = 0, numero2 = 0) => numero1 + numero2 //cuando solo tienen una línea no hace falta que usemos "return"
                
                    /* si tenemos múltiples líneas en la arrow function usamos return 
                    
                    const sumar = (numero1 = 0, numero2 = 0) => {
                        return numero1 + numero2
                    }                  
                    */              
                    const resultado = sumar(10, 20)
                    console.log(resultado)
                  </code></pre>
                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-26').toggle();">
                  <h3>26. Array Methods</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-26" class="hidden">
                <pre><code class="language-js">
                  //Array methods
                  const tecnologias = ['HTML','CSS','Javascript','React.js','Node.js']
                  const numeros = [10, 20, 30]
                  
                  //Filter
                      const nuevoArray = tecnologias.filter(function(tec) {
                          console.log(tec)
                      })
                  
                      // const nuevoArray2 = numeros.filter(function (nume) {
                      //     console.log(nume)
                      // })
                  
                      //también podríamos hacerlo así (sacando la función que va entre "()" fuera):
                  
                      // function ejemploFilter(nume) {
                      //     console.log(nume)
                      // }
                  
                      //esta sintaxis normalmente no se usa, no se crean funciones aparte
                      // const ejemploFilter = (nume) => console.log(nume)    
                      // const nuevoArray2 = numeros.filter(ejemploFilter)
                  
                      //Estos array methods se utilizan mucho y lo que hacen es iterar sobre cada uno de los elementos del array. 
                      //En base a ciertas condiciones podemos hacer algunas operaciones con ellos
                  
                      //IMPORTANTE --&gt; ventajas de uso de arrow function:
                      // (no usamos "function", como es una línea quitamos "{}", no usamos "return" porque se da por implícito que es return en base a la condición indicada
                  
                          // const nuevoArray2 = tecnologias.filter((tech) => tech === 'HTML' )
                          const nuevoArray2 = tecnologias.filter((tech) => tech !== 'HTML' )
                          console.log(nuevoArray2)
                  
                          //recuperando el ejemplo que vimos en 18.js, vemos que hacíamos lo miosmo sin arrow functions
                          const tecnologias2 = tecnologias.filter(function(tech){
                              //console.log(tech)
                              if(tech!=='HTML'){ 
                                  return tech 
                              }
                          })
                          console.log(tecnologias2)
                  
                      //Otra característica de los arrow functions es que si solo es un parámetro podemos eliminar los "()"
                      const nuevoArray3 = tecnologias.filter(tech => tech === 'HTML')
                      console.log(nuevoArray3)
                      //Filter también se puede usar para arrays de tipo numérico
                      const resultado = numeros.filter( num => num !== 10 )
                      console.log(resultado)
                  
                  //Includes --&gt; va a revisar si existe un elemento en un arreglo. En este caso como vemos la implementación es más sencilla, y en consola vemos que devuelve true
                  const resultado2 = tecnologias.includes('CSS')
                  console.log(resultado2)
                  
                      //Podemos ver todos los que hay tanto en la documentación https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array
                      //como en el prototype de la consola
                  
                      //Veamos más array methods. Algunos de ellos tienen un "callback" (una función de order superior=higher order function)
                  
                      //Some --&gt; devuelve si cumple la condición
                      const resultado3 = numeros.some( num => num > 15 ) //revisa si al menos uno de los valores del array numeros cumple la condición. Tengo dos de hecho. decuelve true
                      console.log(resultado3)
                  
                      /*usando este método reducimos código si por ejemplo quisiéamos mostrar un texto cuando se cumple condición, frente a por ejemplo el código a usar si tiramos del método filter
                              if(resultado.length>0){ 
                                  console.log('Si hay elementos')
                          
                              if(resultado3){ 
                                  console.log('Si hay elementos')
                              }
                      */
                  
                  //Find --&gt; devuelve el primer elemento que cumple una condición
                      const resultado4 = numeros.find( num => num > 15 )
                      console.log(resultado4)
                      
                  //Every --&gt; devuelve true o false si todos cumplen la condición
                      const resultado5 = numeros.every( num => num > 8 )
                      const resultado6 = numeros.every( num => num > 15 )
                      console.log(resultado5)
                      console.log(resultado6)
                  
                  //Reduce --&gt; devuelve un acumulado del total. Es de los mas complejos. Toma 2 parámetros.
                      //nos va a permitir hacer el cálculo en carritos de la compra de manera muy simple
                    const resultado7 = numeros.reduce( (total, numero) => { // total y numero(numero actual). El total va a servir como un acumulado
                          console.log('total iteracion: '+total) // solo con esta línea, en consola nos sale 0 y 2 undefined, porque tras el valor inicial no sabe que hacer la vez siguiente
                          console.log('numero iteracion: '+numero) // añadiendo esta línea ya aparecen los números del array alternados con un undefined
                  
                          //console.log(total) funciona como un acumulado. Hagamos por ejemplo que sume el primer valor del array a mi valor inicial 0, y a ese resultado le sume el siguiente valor....
                          //útil si construimos un carrito de compra, para mostrarle al usuario cual es el total a pagar de todos los elementos que tiene en el carrito
                          return total+numero // en 'total' va acumulando y 'numero' es el valor numérico actual del elemento del array numérico en cada iteración 
                    }, 0) //entre las llaves y el paréntesis ponemos un valor inicial de 0
                  
                    //También podríamos escribirla así: 
                    const resultado8 = numeros.reduce( (total, numero) => total + numero, 0 )
                  
                    console.log('resultado7: '+resultado7)     
                    console.log('resultado8: '+resultado8)  
                  
                </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-28-30').toggle();">
                  <h3>28. Condicionales en JavaScript / 29. Comparando con Comprador Estricto / 30. Logical Or y Logical And</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-28-30" class="hidden">
                <pre><code class="language-js">
                  //Condicionales
                  const disponible = 4000
                  const retirar = 200
                  
                  const auth = true
                  
                  if (auth){
                      //se cumple la condición
                      console.log('Acceso al sistema..')
                  } else {
                      //no se cumple la condición
                      console.log('No tienes permiso, inicia sesión')
                  }
                  
                  /*
                  &gt; mayor&comma; &lt; menor&comma; &gt;= mayor o igual&comma; &lt;= menor o igual&comma; == igual&comma; === igual estricto&comma; !==diferente a 
                  */
                  
                  if (disponible > retirar){
                      //se cumple la condición
                      console.log('Puedes sacar dinero')
                  } else {
                      //no se cumple la condición
                      console.log('No puedes sacar dinero')
                  }
                  
                  const numero1 = 20
                  const numero2 = 20
                  const numero3 = "20"
                  
                  console.log(typeof numero1,typeof numero2)
                  if (numero1 == numero2){
                      console.log('Son iguales')
                  } else {
                      console.log('No son iguales')
                  }
                  
                  console.log(typeof numero1,typeof numero3)
                  if (numero1 == numero3){
                      console.log('Son iguales')
                  } else {
                      console.log('No son iguales')
                  }
                  
                  //SIEMPRE VAMOS A QUERER UTILIZAR EL OPERADOR TRIPLE --> el operador estricto revisa tanto el valor como el tipo de dato. 
                  //Como vemos en ambos casos devuelve que sí se cumple porque el operador que no es estricto revisa el valor 20 y 20
                  console.log(typeof numero1,typeof numero3)
                  if (numero1 === numero3){
                      console.log('Son iguales')
                  } else {
                      console.log('No son iguales')
                  }
                  
                  //Logical Or '||' y Logical And '&&'
                  const saldo = 1000
                  const pagar = 500
                  const tarjeta = false
                  
                  // if( saldo > pagar){ //si mi saldo es mayor
                  //     console.log('Puedes pagar')
                  // } else if (tarjeta) { //si llevo mi tarjeta
                  //     console.log('Puedes pagar')
                  // } else {
                  //     console.log('No puedes pagar')
                  // }
                  /*se ejecuta la primera que se cumpla*/
                  
                  if( saldo > pagar || tarjeta){ //si se cumple una de las dos
                      console.log('Puedes pagar')
                  } else {
                      console.log('No, no puedes pagar')
                  }                
                </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                
              



      
      <!-- Bloque desplegable interior -->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-31').toggle();">	
                  <h3>31. Ternarios</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-31" class="hidden">
                  <p></p>
                  <pre>
                    <code class="language-js">
                      /*Ternarios --&gt; un if en una versión mas corta. En React se usa mucho porque en los templates no podemos escribir un if en la poarte que se muestra en pantalla
                      pero sí un ternario*/
                      
                      const auth = true
                      
                      const saldo = 1000
                      const pagar = 1200
                      const tarjeta = false
                      
                      // if (auth){
                      //     console.log('User autenticado..')
                      // } else {
                      //     console.log('No auntenticado, ir a Login')
                      // }
                      
                      //con un operador ternario vamos a poder tener todo lo anterior en una línea. Sintaxis algo compleja
                      
                      auth ? 
                        console.log('User autenticado..') : 
                        console.log('No auntenticado, ir a Login')
                      
                      //otra manera combinando operadores que vimos antes
                      
                      saldo > pagar ?
                        console.log('sí puedes pagar') :
                        console.log('no, no puedes pagar')
                      
                      //ternario anidado (al igual que los if se ejecuta la primera condición que se cumpla). 
                      saldo > pagar ?
                        console.log('sí puedes pagar') :
                        tarjeta ?
                          console.log('puedes pagar con tarjeta') :
                          console.log('no, no puedes pagar')
                      
                      //PERO MEJOR QUE TERNARIOS ANIDADOS ES HACER USO DE OPERADORES PARA MEJOR MANTENIMIENTO DE CÓDIGO
                      saldo > pagar || tarjeta ?
                        console.log('sí puedes pagar') :    
                        console.log('no, no puedes pagar')
                    </code>
                  </pre>						
                </div>
      <!-- Fin bloque desplegable interior -->
      
      <!-- Bloque desplegable interior -->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-32').toggle();">	
                  <h3>32. Optional chaining (?) y Nullish coolescing operator (??)</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-32" class="hidden">
                  <p>Son un par de características de las más nuevas que han añadido a js</p>
                  <p><strong class="text-[#609ad2]">Optional chaining (?) :</strong></p> 
                  <ul>
                    <li>permite llamar las propiedades de un objeto o llamar métodos sin tener que verificar si existen o no</li>
                    <li>además de ahorrarnos código, se usa mucho en respuestas rest API o repsuestas de BBDD en las uqe mkuchas veces no está todo relleno como esperamos</li>
                    
                  </ul>
                  <pre>
                    <code class="language-js">								
                      //Optional chaining (?) 
                        
                        const alumno = {
                          nombre: 'Juan',
                          clase: 'Programación 1',
                          aprobado: true,
                          examenes: {
                            examen1: 9
                          }
                        }
                        console.log(alumno)
                        console.log('Despues de ALUMNO')
      
                        //si hiciera esto me daría error porque esa propiedad examen1 no está definida, y el resto de mi js deja de funcionar (no saca lo de 'después de ALUMNO'):
                          //console.log(alumno.examenes.examen1)
                        
                        //para esto utilizamos el optional chaining, para ver si existe la propiedad examenes y entonces que nos imprima examen1 (evitamos usar ifs y más código)
                          console.log(alumno.examenes?.examen1)
                          console.log('Despues de ALUMNO')
                      </code>
                    </pre>
                    <p><strong class="text-[#609ad2]">Nullish coolescing operator (??):</strong> operador lógico que devuelve el valor del lado dcho cuando el valor izdo es nulo o undefined</p> 
                    <pre>
                      <code class="language-js">	
                      //Nullish coolescing operator (??) 
                        // por ejemplo se usa mucho cuadno se trabaja con un paginador desde la url. Cuando en la urlpage no tenemos esto: "?page=1"
                        const pagina = null ?? 1
                        // si tuviéramos este ejemplo "?page=10" 
                        // const pagina = 10 ?? 1 --&gt; este nos devolveria 10
                        console.log(pagina)
                      </code>
                    </pre>
                </div>
      <!-- Fin bloque desplegable interior -->
      
                
      <!-- Bloque desplegable interior -->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-34').toggle();">	
                  <h3>34-36. Introducción a ECMAScript Modules, más sobre módules y export default</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>					
                <div id="seccion2-34" class="hidden">						
                  <p>Se utilizan mucho en React y en el desarrollo web hoy en día ya que normalmente cuando instalas una dependencia/librería, esa dep. te permite importar ciertas funciones
                    el mismo React te permite importar sus funciones para que puedas utilizarlas en tu código
                    Supongamos que estamos creando un proyecto y vamos teniendo cada vez más y más funciones (pone el ejemplo de los tropecientos .js en nuestro html) --> eso se soluciona con los 
                    módulos de ECMAScript, que nos permiten separar nuestro código.</p>
        
                  <p>creamos un nuevo "funciones.js" donde metemos nuestras funciones y en nuestro html le indicamos al js que es de type module, y ello nos va a habilitar el poder importar.
                  dentro de nuestro .js de funciones le añadimos un "export" antes de cada función. En el .js donde queramos usar las funciones usamos un import</p>
                  
                  <pre>
                    <code class="language-js">
                      //ESTOS MODULOS ESTAN PRESENTES EN TODAS LAS TECNOLOGÍAS DE JS VUE, NODE, REACT... NOS PERMITEN SEPARAR NUESTRO CÓDIGO Y UN MEJOR MANTENIMIENTO
                      // export function sumar (n1, n2){
                        //     return n1 + n2
                        // }
                        // export function restar (n1, n2){
                        //     return n1 - n2
                        // }
                        // export default function multiplicar (n1, n2){
                        //     return n1 * n2
                        // }
                        // export function dividir (n1, n2){
                        //     return n1 / n2
                        // }
                        
                        export const sumar = ( n1, n2 ) => n1 + n2
                        export const restar = ( n1, n2 ) => n1 - n2 
                        
                        const multiplicar = ( n1, n2 ) => n1 * n2 
                        export default multiplicar
                        
                        export const dividir = ( n1, n2 ) => n1 / n2 
      
                        /* Ambos tipos de export requieren que al importarlos se llamen entre llaves y con el mismo nombre (salvo que usemos un alias)
                        Como vamos a importar muchas funciones, variables... de muchas librerias ¿como hacemos para evitar la colisión de nombres? utilizamo "alias" --> import {sumar as funcionSumar} 
      
                        Existe otro export que es el export default: solo puede haber uno por archivo. Lo importas sin llaves y nombras como queramos
      
                        export default function multiplicar (n1, n2){
                          return n1 * n2
                        }
                        */
                    </code>
                  </pre>   
                  
                  <pre>
                    <code class="language-js">
                  import agusmultiplica, { sumar, restar, dividir } from './funciones.js' // esta es la mejor manera de importar las funciones que nos ofrecen las dependencias/librerías
      
                  const resultadoSumar = sumar(25, 30)
                  const resultadoRestar = restar(25, 30)
                  const resultadoMultiplicar = agusmultiplica(25, 30)
                  const resultadoDividir = dividir(100, 10)
                  console.log(resultadoSumar + '\n' + resultadoRestar + '\n' + resultadoMultiplicar + '\n' + resultadoDividir);
                    </code>
                  </pre>   								
                </div>
      <!-- Fin bloque desplegable interior -->
      
      <!-- Bloque desplegable interior -->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-37').toggle();">	
                  <h3>37. Fetch API con Promises</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-37" class="hidden">
                  <p>Proporciona una interfaz para poder recuperar recursos y obtener datos a través de la red. Es la versión moderna de las dos tecnologías 
                    XMLHttpRequest(sintaxis muy difícil) y $.ajax. Usaremos esta herramienta {JSON Placeholder} 
                    <a class="text-[#cc3333]" href="https://jsonplaceholder.typicode.com" target="_blank">https://jsonplaceholder.typicode.com</a>. Podemos ver este ejemplo de uso en esa misma url:</p>
                  <pre>
                    <code class="language-js">
                      fetch('https://jsonplaceholder.typicode.com/todos/1')
                      .then(response => response.json())
                      .then(json => console.log(json))
                    </code>
                  </pre>
                  
                  <p>Vamos a trabajar con el json de 'Comments' <a href="https://jsonplaceholder.typicode.com/comments" class="blank">https://jsonplaceholder.typicode.com/comments</a>. Un json es muy parecido a un XML nos da unos datos con una estructura que podemos renderizar en nuestras aplicaciones.</p>
                  <p>También con FetchAPI es posible obtener datos de un archivo .txt</p>
                  <p>Para usarlo tenemos dos opciones, o ponerlo directamente en el código o meterlo en una función y mandarla llamar.<br>
                  fetch() utiliza promises, que fueron agregados en la versión de js moderno ECMAScript6. Podemos pensar en los promises como un objeto que va a estar disponible a futuro o no. Los promises cuentan con varios pasos y también con varios estados. Esos pasos se representan por una sintaxis que es <span class="destacado">.then()</span> siendo la lectura algo como "quiero obtener los datos de esta url, entonces tengo mi respuesta...voy a hacer..." El .then toma automáticamente un callback, una función que podemos nombrar como queramos <strong>then((response) => {})</strong></p>
                  <pre>
                    <code class="language-js">								
                      fetch(url)
                        .then((response) => {
                          console.log(response)
                        })
                    </code>
                  </pre>
                  <p>En la respuesta de la consola vemos en el Response que el ok es true y el status 200 --> la url existe (si no existiera tendríamos false y 404). Type cors lo veremos mas adelante, es complicado. Podremos ver como personalizar nuestros estados. Las APIS se comunican entre sí con estados numéricos, también los veremos en detalle.</p>
      
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/37-1-CsFJdISj.png" alt="" />
      
                  <p>Vemos qe no aparecen los datos por ningún sitio, pero si abrimos el prototype sí vemos los métodos <strong>json() y text()</strong>, que sirven apra decirle qué tipo de datos es el que estoy obteniendo (o un txt o un json). Como es un json le especificamos en el callback que retorne la respuesta como json <span class="destacado">return response.json()</span> lo cual nos dará acceso a otro promise con el que obtendremos los datos:</p>
      
                  <pre><code class="language-js">
                    fetch(url)
                      .then((response) => {									
                        return response.json()
                      })
                      .then(data => {
                        console.log(data)
                      })							
                  </code></pre>
                  
                  <p>Como vemos tenemos un .then() y otro .then() y así funcionan los promises, estamos llamando a esa url y no sabemos si vamos a poder obtener los datos o no. En este caso esta url que estamos usando es pública para aprender pero no podemos obtener los datos de por ejemplo instagram, youtubbe... solo haciendo un llamado a una url, en esos casos va a fallar la petición. Como no sabemos el tipo de respuesta que vamos a tener por eso tenemos estos pasos: </p>
                  <ul>
                    <li>trato de conectarme a un servidor</li>
                    <li>entonces, si tengo respuesta la quiero como json y estos comentarios son 500 (el tiempo de respuesta no va a ser igual si tengo 2 respuestas que si tengo 500)</li>
                    <li>una vez que finalice de ejecutarse el código del primer promise, tengo acceso a los datos con el segundo</li>
                  </ul>	
      
                  <p>Si la url fuera incorrecta, recordemos que el ok saldrá a false, response 200 y tendremos un segundo objeto vacío (del 2º promise). Podemos añadir un catch para intentar especificar algo en caso de error, sin embargo como veremos en la consola no se ejecuta el console log del catch ¿por qué? porque con el fetch() así especificado, el catch solo se ejecuta cuando hay problemas de red (podemos forzarlo quitando la wifi).</p>
      
                  <pre><code class="language-js">
                    const url = 'https://jsonplaceholder.typicode.com/urlerronea'
                    fetch(url)
                      .then((response) => {	
                        //console.log(response)								
                        return response.json()
                      })
                      .then((data) => {
                        console.log(data)
                      })	
                      .catch(error=>{
                        console.log(error)
                      })
                  </code></pre>
      
                  <p>Hagamos lo siguiente mejor (if para cuando hay respuesta y un throw new Error para cuando falle) y como veremos, el nuevo error pasará al .catch(). Aprovechamos las funciones de flecha para simplificar la sintaxis del 2º promise y el catch:</p>
      
                  <pre><code class="language-js">
                    fetch(url)
                      .then((response) => {	
                        //console.log(response)
                        if(response.ok){								
                          return response.json()
                        } 
                        throw new Error('Hubo un error')
                      })
                      .then(data => console.log(data))	
                      .catch(error=> console.log(error))								
                  </code></pre>
      
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/37-2-D0Wqwf9-.png" alt="" />
      
                  <p>Como decíamos podemos usarlo sin función como acabamos de ver en el ejemplo anterior o también dentro de una función que mandaremos llamar. Funcionaría igual y este sería el código:</p>
                  <pre>
                    <code class="language-js">
                      const url = 'https://jsonplaceholder.typicode.com/comments'
      
                      const consultarAPI = () => {
                        fetch(url)
                          .then((response) => {	
                            //console.log(response)
                            if(response.ok){								
                              return response.json()
                            } 
                            throw new Error('Hubo un error')
                          })
                          .then(data => console.log(data))	
                          .catch(error=> console.log(error.message))
                      }
                      consultarAPI()
                    </code>
                  </pre>
      
                  <p>Fetch API con promises es una gran mejora pero Async Await lo hace aún más simple</p>						
                </div>
      <!-- Fin bloque desplegable interior -->
      
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-38').toggle();">	
                  <h3>38. Fetch API con Async / Await</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-38" class="hidden">
                  <p class="font-bold">Fetch con Async / Await <strong>sí requiere una función</strong>, que puede ser un arrow function o un function declaration. A continuación escribiremos código con ambas. En este caso ha de ser asíncrona (por eso requiere una función). Para el caso de función de flecha colocamos la palabra <span class="destacado">async</span> antes de los paréntesis, lo que convierte a la función en asíncrona y nos da acceso a la otra propiedad: <span class="destacado">await</span> que son los que reemplazan a los .then() del ejemplo anterior.</p>
                  
                  <p>El await (como antes los then) espera a que se realice la petición, ocurra una respuesta y vuelve a utilizar otro await para obtener los datos. Tengamos en cuenta que la conexión a una API externa dependerá del tipo de servidor (servidor gratis vs servidor de 1000$/mes) y la conexión que tengamos; y como decíamos leer los datos no va a ser lo mismo leer 2 registros que 500. Los await esperan que finalice de ejecutarse ese código para ir a la siguiente línea.</p>		
      
                  <p>La sintaxis es un poco diferente y se lee más como "de derecha a izquierda"</p>
      
                  <pre><code class="language-js">
                    const url = 'https://jsonplaceholder.typicode.com/comments'
                    /*
                    fetch(url)
                      .then((response) => {	
                        //console.log(response)
                        if(response.ok){								
                          return response.json()
                        } 
                        throw new Error('Hubo un error')
                      })
                      .then(data => console.log(data))	
                      .catch(error=> console.log(error.message))
                    */
                    const consultarAPI = async () => {
                      const response = await fetch(url)
                      const data = await response.json()
                      console.log(data)
                    }
                    consultarAPI()
                  </code></pre>
      
                  <p>Estos dos códigos hacen lo mismo, pero hay un detalle. Con Async / Await no hay forma de catchear un posible error. Por lo que normalmente cuando usamos Async / Await se usa junto a algo llamado Try Catch. En el caso de que cualquiera de las acciones indicadas en el Try falle, ejecuta lo que especifiquemos en el catch:</p>
      
                  <pre><code class="language-js">
                    const url = 'https://jsonplaceholder.typicode.com/comments'
                    const consultarAPI = async () => {
                      try {
                        const response = await fetch(url)
                        if(!response.ok){
                          throw new Error('Hubo un error')
                        }
                        const data = await response.json()
                        console.log(data)
                      } catch (error) {
                        console.log(error)
                      }
                    }
                    consultarAPI()
                  </code></pre>						
                </div>
      <!-- Fin bloque desplegable interior-->
      
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-39').toggle();">	
                  <h3>39. Medir performance y cómo manejar múltiples consultas</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-39" class="hidden">
                  <p>JS tiene una API para medir la performance de nuestro código. Más de una vez vamos a tener distintos códigos que hagan lo mismo y vamos a querer medir cual es la versión más rápida. Utilizamos para ello <span class="destacado">performance.now()</span>. Lo usamos al principio y al final de nuestro try y sacamos por consola la diferencia en ms. Veremos que en función de la url que usemos (que carga más o menos datos) ese rendimiento en ms varía.</p>
                  <pre>
                    <code class="language-js">
                      //Performance y múltiple Async Await
                      const url = 'https://jsonplaceholder.typicode.com/comments'
                      const url2 = 'https://jsonplaceholder.typicode.com/todos'
                      const url3 = 'https://jsonplaceholder.typicode.com/photos'
                      const consultarAPI = async () => {
                        try {
                          const inicio = performance.now()			
                          const response = await fetch(url3)
                          if(!response.ok){
                            throw new Error('Hubo un error')
                          }
                          const data = await response.json()
                          console.log(data)
                      
                          const fin = performance.now()			
                          console.log(`El resultado es: ${fin - inicio} ms`)
                        } catch (error) {
                          console.log(error)
                        }
                      }
                      consultarAPI()
                    </code>
                  </pre>
                  <p>Una aplicación real obtiene datos de muchos sitios distintos. Tal vez nuestra empresa tenga un rp, crm, e-commerce, sistemas de facturación... tal vez estamos creando algo que consume datos de diferentes lugares. Un error muy común es hacer lo siguiente, supongamos que consumimos los 3 "endpoints" de esta manera, vemos la consola (izquierda):</p>
                  <pre>
                    <code class="language-js">
                      //Performance y múltiple Async Await
                      const url = 'https://jsonplaceholder.typicode.com/comments'
                      const url2 = 'https://jsonplaceholder.typicode.com/todos'
                      const url3 = 'https://jsonplaceholder.typicode.com/photos'
                      const consultarAPI = async () => {
                        try {
                          const inicio = performance.now()	
      
                          const response = await fetch(url)				
                          const data = await response.json()
                          console.log(data)
                      
                          const response2 = await fetch(url2)				
                          const data2 = await response2.json()
                          console.log(data2)
                      
                          const response3 = await fetch(url3)				
                          const data3 = await response3.json()
                          console.log(data3)
                      
                          const fin = performance.now()			
                          console.log(`El resultado es: ${fin - inicio} ms`)
                        } catch (error) {
                          console.log(error)
                        }
                      }
                      consultarAPI()
                    </code>
                  </pre>
                  <p>usar así los awaits esperando a que cada llamada anterior se resuelva va a hacer que nuestras apps sean más lentas. <strong>¡OJO! va a a habver ocasiones en que realmente querramos llamarlas así secuencialmente porque el siguiente procesado necesite los datos anteriores</strong>. Pero veamos cómo hacerlo en caso de que queramos procesar a la vez todas las llamadas y no secuencialmente. Emplearemos <span class="destacado">Promise.all()</span>:</p>
      
                  <pre><code class="language-js">
                    const consultarAPI2 = async () =>{
                      try {
                        const inicio = performance.now()
                    
                        const [response, response2, response3] = await Promise.all([fetch(url),fetch(url2),fetch(url3)])
                        const [data, data2, data3] = await Promise.all([response.json(),response2.json(),response3.json()])			  
                        console.log(data)     
                        console.log(data2)    
                        console.log(data3)		
                    
                        const fin = performance.now()
                    
                        console.log(`El resultado de la SEGUNDA función es: ${fin - inicio} ms`)
                      } catch (error) {
                        console.log(error)
                      }
                    }
                    consultarAPI2()
                  </code></pre>
      
                  <p>Si vemos en la consola (derecha) el resultado de ejecutar las dos funciones <strong>(ver 39-performance.js)</strong> veremos que siempre en cada ejecución, la primera que termina (por tanto con mejor rendimiento, termina en menos ms) es la segunda función.</p>	
                  
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/39-1-wlgkvzzm.png" alt="" />
      
                  
                </div>
      <!-- Fin bloque desplegable interior-->
      
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-40').toggle();">	
          <h3>40. DOM - Selectores</h3>			
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-40" class="hidden">
                  <p>Va a ser corto porque de hecho la forma de escribir código de DOM en JS es un poco diferente a como React lo maneja porque tiene algo llamado JSX que simplifica mucho. Pero siempre viene bien aprender o refrescar. Abrimos el DOM.html y colocamos el script:</p>
                  <pre>
                    <code class="language-html">
                      &lt;script src=&quot;js/40-DOM-selectores.js&quot;&gt;&lt;/script&gt;
                    </code>
                  </pre>
      
                  <p><strong>Selectores</strong>. Todas las interacciones que haces en el DOM con js requieren un selector. Es como en CSS seleccionas un elemento y empiezas a aplicar propiedades css para cambiar apariencia. En JS vas a aseleccionar algún elemento de tu página y vas a regresar operaciones por medio de js para agregar, modificar o eliminar atributos.</p>		
      
                  <p>queremos seleccionar este elemento del DOM.html:</p>
      
                  <pre><code class="language-html">
                    &lt;h1 class=&quot;text-4xl font-black heading&quot;&gt;JavaScript Intermedio - Manipulaci&oacute;n de DOM &lt;/h1&gt;
                  </code></pre>
      
                  <p>iniciamos con <span class="destacado">document</span>(podemos poner en consola document y vemos que es el documento entero.) De hecho podemos poner en consola document.title y vemos que saca el título de la página. pero para otro tipo de elementos de dentro del html hemos de utilizar <span class="destacado">querySelector()</span>. También comenta los que conocemos <strong>.getElementById</strong>, <strong>.getElementsByTagName</strong>, etc... pero hoy día se recomienda utilizar más la sintaxis con querySelector() porque tenemos acceso a selectores muy similares a los de css (.clase, #id, :last-of-type, :nth-child(),...), y sabiendo css los mismos selectores aplican para seleccionar elementos en js. Como hay selectores muy complejos, podremos seleccionar prácticamente cualquier elemento.</p>
      
                  <p>Si hacemos un console.log(heading), vemos que nos pone el elemento h1 como está con todo lo que contiene tanto el tag en sí como su contenido. Así seleccionado un elemento tenemos acceso a sus atributos, lo que conocemos como el DOM. El DOM podemos modificarlo y recorrerlo.</p>
      
                  <div class="flex">
                    <pre><code class="language-js">
                      const heading = document.querySelector('.heading')
                      console.log(heading)
                      console.log(heading.tagName)
                      console.log(heading.textContent)
                      console.log(heading.classList)
                    </code></pre>
      
                    <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/40-1-CqvY10l_.png" alt="" />
                  </div>
      
                  <p>Veamos ahora el <span class="destacado">querySelectorAll()</span>. La principal diferencia es que trae <strong>TODOS</strong> los elementos que tengan correspondencia con ese selector, mientras que querySelector() solo trae uno (aunque haya más que correspondan con el selector indicado entre paréntesis, solo trae el primero que encuentra)</p> 
                  <pre><code class="language-html">
                    &lt;nav class=&quot;navegacion my-5 flex gap-5&quot;&gt;
                      &lt;a href=&quot;&num;&quot;&gt;Enlace 1&lt;/a&gt;
                      &lt;a href=&quot;&num;&quot;&gt;Enlace 2&lt;/a&gt;
                      &lt;a href=&quot;&num;&quot;&gt;Enlace 3&lt;/a&gt;
                      &lt;a href=&quot;&num;&quot;&gt;Enlace 4&lt;/a&gt;
                    &lt;/nav&gt;		
                  </code></pre>
      
                  <div class="flex">
                    <pre><code class="language-js">
                      const enlaces = document.querySelectorAll('.navegacion a')
                      console.log(enlaces)
                    </code></pre>
      
                    <img class="my-2.5" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAXYAAAByCAMAAABwZgr1AAAAA3NCSVQICAjb4U/gAAACKFBMVEUhISG+/74yre4LV9BmZmb/soudAEtuHx+OXcW+u27//76+cR/frdMfH24yV9Ctra3///+OAIu92/+aRh+9iotuu74IY8KrfHKOAEvmvZ0ykuW9imidAIvb29ursv8fRm7i/76Pj4+disVuH264rdMrKyv//+Ifcb6R5e5hrd7imEO9XUthV9D/35q9LEsIQqD/ytmdveZuu//M//+a3/+OLKhaWlqdj6yRdND/5d645d4Lkt4sYIP/u26diuLW5f1fQqBDHx+dj53/26jT17dDRpq4//+aRkOdLKgwY8KRktmOAGjf///MxM//w7VucW6Pj52lzf3n5+fmimgfH0P//8VuH0NDH269LGhhyuUydN6/rpSa376RrdlAieDl7/7/4cKfn5///+bf4cKdj4+rAEvQ26i+cUO4ktC+nZ1hktCPrNAfRpphdNNDcb64/+4fRkOrtdq+rKwwhLVumJrQrI+aRm4LdN7m//+Pnb7//8yrAItuRkO+35rQXWi+//8LV9OrAGgzMzPTpYPZ2dnT4+xAJIi+5v/i/+L//+6amG6Rz97M0/KioqKsj4+X3f2snb6Pj6xhyv9AhdRhV9nm26isvb63hKBucb4wouMyV9n/5r5Ef9usj52sj6zQXUvM4/2+/+K+nY+dnb4IQqmRdNNhre5fQqm+vZ3/0ayR5f86leyQob69sqiyfmxDmOKamOILkuXQsous0f+riqjm/+KRkt5hktMnbDXTAAAACXBIWXMAAA50AAAOdAFrJLPWAAAAH3RFWHRTb2Z0d2FyZQBNYWNyb21lZGlhIEZpcmV3b3JrcyA4tWjSeAAAABZ0RVh0Q3JlYXRpb24gVGltZQAwMS8xNi8yNeL9DLUAAAnISURBVHic7Z2LfxtHEcevUWwHSU7XCS1ympiqJhI9LCNLdrGBixtMkkLDK66bEh4BUVNDQnmGCBWw+VBwAzRt3JYCoVVaKGDzMCY8/j1mZvdOe9JJe7EUFjvz+/ij0z50kr47N7M7Ot85gmVBju0PcGeKsVsRY7cixn77lF452a5pm9hTF0+3VhZOBJVefnv7ja3zs1Ln43ROJ9aEKCYSW34FPKdCOpG4fLoytkfM7F+LeiH029O6t9aqNm/bgj3tf4Yo7N5jk6LwtFZROLvsNyncKR1rqqT3ch0o5g6W9A6Ooxe3LTfYD1C/QX9xuM/85qtr8HBSLPnAivDll7ZEEbgsbVW+dkik/xOJPZJxbOwtKl4+LZbojST2M0qyNQVfzt3UujdsN1StlHx8kjajRN175/cnRdjcc6cmt/tBm/WU2pOE/osbsDG+5sr0GnxXgHVl+rI6HBE7jAMiqLz8/nMf/fq/37Un6E0WObN/hWyVGGMddh2Dzcx+OFJWNuBAwA7FD0zjRnVIJ1YCA4fOfgsaOB1OuLMimbvEfsQhPUSF3Kmf5dGCPccZXCYTczbBfPFRGbZLDdjBKWGD1lQ4exfh1xyOer6wmMkMlcNE+jKZzD5hrpuHumMiGFrAjtQ//NMX4NGIPb2FJra0Vhl78JyGvTL27rc2AOlbPz9UfPAPRf1AwME4SbYpscPLK2MbMHxyf1iFBw90KMIAQFl2wBfpop0oxyaxb8EwaNjF84T9WXqeHP3BiedOTXqAFozbBbeSKqHBAj1pt8m/k4H7DKRhSxcDddIPBYD8DguLI2LukWqYMAzD/DFhrJufqor6iNAGE6l/7C+fQu9uok7eBbB/emxj5txptNg9zdgBGWBfQkcPfJA2Ov+Ejx1fAwY+owaNsNMeXj6pBkl2uDINg9CEXe5OCUx/5XM6drEXqH9RPi0A9M+OvoGEvTyCRpbQ/NhkAJO+fu6gdPTS8RBb7O3mgx5K1KEPLHi+yYoBZW58xFiXe+KAWPjRAaH5OKD+k29+5vOzMZxMGgkmttLoGKKdzCEhAqsUgkgFRcIurbgDdt/Mw+BldQi8Hxl87GeOOnvVU29TpL5z4n4knCohaLBf9X39iKo8d+E4bpXjwR4eHTR5EQ4C5JDBgqNwzh0uG+sWnimLvqlq8FaCnMzs7I//PBvHyQjyEgDtyrTmSbBAIW6L0GnYERfYv0ZJhuLKmHIy5KvhGEoHwxPEaoqYlbEtfz/Bxp8q4euENpO5+6gKqMKFgOpsoh8BPwPYC8cvVqUJK0tGqMlf4RZtWk1afM7KDz3eiKLyEAHs9cyInCYpAeKFRXT37uByc13uYCMmA/a5fsTeiM0UUt9RwscOtAMtrWmTNyF9CPHEujD2tGySPehIWSMnQv7Hj6zo0cGtBK5bdsB2tGwdu9qdxI6vlMdFYwJ5t//F0Y0fDyJqyhl8W54iKpRSypY98DhYRQhdqvO9ioSc0oxdtsz1Zx4AS9axQ6R89K/o7jXsfp2OHcZr6B/7hO65KKT+7YMvxZnJWJPvlSLUs1VqaKbu6tN6LzTpdCMWWqnWxVVyIGKm35iVnp+Vs/bZG8Z5+28TVlTEIBvZgh+qd8mBtmvUlNMw8ORAK3UZIcJyI9ZXLs1Tlc6r5VKsVer/nzgnY0WM3YoYuxUxditi7FbE2K0oAvuZh55tFPoymUcP/O8+zp2iKOxBUgzXliOiPlVt7cTqStHYnb0qQTM/VM6Ng7knBxorldx4JsMj0Z3aYHeOyhRNfepf4/8Ei9exo5oz4qxbUxvsijpgf88xdDQh1dVvPaxtKxq772PEPPDta4qpUb//sG5NkdifD577IVV3Mn1T1YVFxt6VIrAfOaIV+uTvzk0hdeg+xt6VeLlkRYzdihi7FTF2K2LsVsTYrYixWxFjtyJTvl3MZ0Zau7C6lCHfjmkvxt57GfLtc4+8QvlHzrf3VoZ8u0yGCc6391iGfLuPPSTOt3ctQ749Cjvn27uXId8e5WQ43969DPl2/D8vTLhzvr234uWSFTF2K2LsVsTYrYixWxFjtyLGbkWM3YpM+fY6Zxtvh0zntx8ucyLgNsiQbxeYC9jH+fZey5hvF3P9xzjf3msZ8+258RbL5nx71zLl2yOoc769e5ny7XV5eS/Ot/dWhnw7Xi+N8+29Fy+XrIixWxFjtyLGbkWM3YoYuxUxditi7FZkyLdHXYaa1b1M57cj+ebLerO6ljnfTvkXzrf3VqZ8e59EzPn23sqYb49I/XK+vWsZz2+nC1eF2jnf3r2M57eDb+fryfRchnz7XH+rb+d8e/fi5ZIVMXYrYuxWxNitiLFbEWO3IsZuRYzdigzYcWnULt1OCQK88Vqrag/f2/ZOTywRw9qjuaI6YH/12x9h7J0UE3udco4/fDtt8O6lQ1/uz+CNDBaeuY9uZxDKDH/83i8x9o6Kh13d/rE+VZ07XIY/uhektPbFfXQ/Th177Y8bX2DsHRULO/6ehBevqo/Q3RxD2PGmmk2/+r36a8HYOyse9ifkFdwldvxZG0G3w157+L2g39+OT7trFNPJSLASu0+ZKn3sTb/6sbV3lgE7XU9mqopeBiaSDWtHc4cthlTGvg1tY7mEzqX5vsmsW9M2sOMvTnwLrO7EyQErYuxWxNitiLFbEWO3oh2B3Rtctv0ReizT9WRqV7PXYIo+nM1OCHEpS5uQaq/rM/hLN9u8T+XN7CdXg93p8pySSI5qXBuFwgm56AphT5U6fJ2dItP57YrqMNEGqNc/tBruHRM7gP/Kamt/kPeNp9tjjzifexdjb5x72oy98ubN2ut/ymbxGZo+HgDZC6qwjoVr5UvQef171eFfPgkt4vqT0sBD2FMXg+SBl39qEkjnDjrOphC4Adv2HAd6SGuHKrR2bMljA3XY4TKd395i7e8r165OiOu/qwJcGAPVQRWktUMjPhm+VqZBKuMYtGAP7NjLe5uAPbUJYEsCNlBA3m4+cDJk/15e9t/N1h6c3x7GnkUHLauIIlRTyS9I7FCqvVil8vAEHQEt2DV5+dx37xp949SkEC7yR8gujnw+cDKEvXBcHiG7GHvj/PZmaw+qOmAX6xPrN1V5Yv2C2lN77MK9pxm7TGeGrN0Hv3uxa+e3t8WOfqV2FZzMa6uNAm6xx4vfKssxeW1VtotOvl0kP0FOJjlQIj8zuFw4KzmHscttKvzvPDtTpvultscOc0GaTQ5jSPULKn5euiAbIPJSnMWm9r5dIOnkAIVUCJn3AFz0MiUwb9xgCwRYrELiULkrQ2pIIexxJQk3vaadk7kjZcSuL5fiCSaTdFSEsLdfLt2R2hHJgd0nxm5F/wXvLHTAFwSHqQAAAABJRU5ErkJggg==" alt="" />
                  </div>
      
                  
                </div>
      <!-- Fin bloque desplegable interior-->
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-41').toggle();">	
                  <h3>41. Manipular elementos HTML con JS</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-41" class="hidden">
                  <p>Veamos algunos ejemplos</p>
                  <pre>
                    <code class="language-js">
                      const heading = document.querySelector('.heading')
                      const enlaces = document.querySelectorAll('.navegacion a')
                      //console.log(heading.textContent)
                      
                      heading.textContent = 'Un nuevo Heading'
                      heading.id = 'Un nuevo id'
                      heading.removeAttribute('id')
                      heading.removeAttribute('class')
                    </code>
                  </pre>
      
                  <p>Es muy comun que muchos formularios tengan ya un value por default:</p>		
      
                  <pre><code class="language-js">
                    const inputNombre = document.querySelector('#nombre')
      
                    //normalmente los atributos de los tags HTML se llaman igual los atributos de JS
                    inputNombre.value = 'Un nuevo valor'
                    //aunque no siempre, por ejemplo las clases o los atributos personalizados data-nombre="input"
                    console.log(inputNombre.classList)
                    inputNombre.dataset.nombre = "input"
                    
                    //Veamos como manipular colecciones. hemos de pasarle la posición o iterar sobre los elementos
                    console.log(enlaces)
                    enlaces.forEach( enlace => enlace.textContent = 'Nuevo Enlace')
                  </code></pre>
                </div>
      <!-- Fin bloque desplegable interior-->
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-42').toggle();">	
                  <h3>42. DOM eventos con click - <a href="https://developer.mozilla.org/es/docs/Web/API/Element" class="text-[#000000]" target="blank">Enlace MDN Element</a></h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-42" class="hidden">
                  <p>Una de las características ppales de JS es que podamos añadir interacción a nuestras aplicaciones/sitios web. Veamos algunos eventos que nos van a permitir eso.</p>
                  <pre>
                    <code class="language-js">
                    const heading = document.querySelector('.heading')
                    //vimos como podemos cambiar por ejemplo el contenido del tag por un nuevo título
                    heading.textContent = 'nuevo título'
                    </code>
                  </pre>
                  <p>Supongamos que quiero esperar a que por ejemplo alguien presione en el titulo para modificarlo. <strong>Una vez que seleccionas un elemento tienes acceso a registrarle un evento con el evento <span class="destacado">addEventListener()</span></strong>. Veamos el siguiente link https://developer.mozilla.org/es/docs/Web/API/Element, en la parte derecha podemos ver los eventos. Los hay de todo tipo, del mouse, de animaciones, eventos cuando copias algo con el teclado,... </p>	
                  
                  <p>esto es lo que se conoce como un callback, espera que ocurra el evento del primer argumento y cuando ocurre se dispara la función indicada en el segundo argumento.</p>
      
                  <pre><code class="language-js">
                    heading.addEventListener('click', () => {
                      heading.textContent = 'Al dar click'
                    })
                    heading.addEventListener('dblclick', () => {
                      heading.textContent = 'Al dar doble click'
                    })
                    heading.addEventListener('mouseenter', () => {
                      heading.textContent = 'Al entrar'
                    })
                    heading.addEventListener('mouseleave', () => {
                      heading.textContent = 'Al salir'
                    })
                  </code></pre>
      
                  <p>Para añadir addEventListener a los integrantes de un document.querySelectorAll utilizamos el forEach:</p> 
      
                  <pre><code class="language-js">
                    const enlaces = document.querySelectorAll('.navegacion a')
                    enlaces.forEach( enlace => {
                      enlace.addEventListener('click', () => {
                        console.log('diste click en un enlace')
                      })
                    })
                  </code></pre>	
      
                  <p>Vemos que al pulsar cada link la página nos da un salto. El elemento enlace tiene una acción por default que es intentar ir la url indicada en el href pero en nuestro caso no hay nada tenemos un #. Veamos. A la función que se dispara al realizar el evento le podemos pasar un parámetro que llamamos <strong>e, evento, evt, ...</strong> como queramos, y si hacemos un console log de ello vemos que aparece una gran cantida de información sobre el evento que se está llevando a cabo. Si scrolleamos un poco hacia abajo llegamos al "target" que nos da la información de qué es lo que ha disparado ese evento. Hacemos un console.log de e.target y nos da información de qué es a lo que hemos dado click:</p>
                  <pre><code class="language-js">
                    const enlaces = document.querySelectorAll('.navegacion a')
                    enlaces.forEach( enlace => {
                      enlace.addEventListener('click', (e) => {
                        console.log(e.target)
                        console.log('diste click en un enlace')
                        e.preventDefault()
                        e.target.textContent="diste click"
                      })
                    })
                  </code></pre>
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/42-1-BZW0CDp8.png" alt="" />
      
                  <p>cuadno enviamos un formulario hay una acción por default, cuando haces click en un botón hay una acción por default, si presionas un heading o una imagen no hay una acción por default... pero los links es uno d elos elementos que sí tiene una acción por default. usamos <span class="destacado">e.preventDefault()</span> que básicamente le dice al link "ok, tú tines un comportamiento que es abrir una url. No lo hagas.</p>
      
                  <p>Por tanto nosotros mediante código podemos modificar las acciones a realizar, por ejemplo en un formulario, que en vez de enviarse haga validaciones. Importante:</p>
                  <ul>
                    <li><span class="destacado">e.preventDefault()</span> nos va a permitir <strong>prevenir la accion por defecto de algún elemento html que realiza algo</strong></li>
                    <li>ese <span class="destacado">e</span> reporta <strong>el evento que se está registrando</strong>, en nuestro ejemplo el click </li>
                    <li>el <span class="destacado">e.target</span> es <strong>lo que dispara ese evento</strong>, en nuestro ejemplo un enlace</li>
                  </ul>
                </div>
      <!-- Fin bloque desplegable interior-->
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-43').toggle();">	
                  <h3>43. DOM eventos en inputs</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-43" class="hidden">
                  <p>En nuestro DOM.html tenemos estos dos inputs:</p>
                  <pre>
                    <code class="language-html">
                      &lt;input type=&quot;text&quot; placeholder=&quot;Tu Nombre&quot; id=&quot;nombre&quot; class=&quot;p-2 rounded-lg text-sm&quot;&gt;
      
                      &lt;input type=&quot;password&quot; placeholder=&quot;Tu Password&quot; id=&quot;password&quot; class=&quot;p-2 rounded-lg text-sm&quot;&gt;
                    </code>
                  </pre>
      
                  <p>Queremos leer lo que el usuario va escribiendo en el input de nombre. registramos un addEventListener()</p>		
                  <pre>
                    <code class="language-js">
                      const inputNombre = document.querySelector('#nombre')
                      inputNombre.addEventListener('input', (e) => {
                        console.log('escribiendo')
                        console.log(e.target)
                        console.log(e.target.value)
                        console.log(e.target.value.length)
                      })		
                    </code>
                  </pre>
                  <p>Por defecto en un input de tipo password el contenido sale ofuscado. Queremos ver lo que escribimos durante poco tiempo y luego que se vuelva a ofuscar.</p>
                  <pre>
                    <code class="language-js">
                      const inputPassword = document.querySelector('#password')
                      inputPassword.addEventListener('input', functionPassword)
                      function functionPassword() {
                        inputPassword.type = "text"
                        setTimeout(() => {
                          inputPassword.type = "password"
                        }, 500)
                      }		
                    </code>
                  </pre>
                  
                </div>
      <!-- Fin bloque desplegable interior-->
      
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-43').toggle();">	
                  <h3>44. Eventos en Submit. 45. Validando formulario y mostrando alertas.</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-43" class="hidden">
                  <p>En nuestro formulario tenemos este input de tipo submit. El evento de submit se llama cuando alguien presiona sobre el formulario para enviarlo:</p>
                  <pre>
                    <code class="language-html">
                      &lt;input type=&quot;submit&quot; value=&quot;Iniciar Sesi&oacute;n&quot;
                      class=&quot;bg-cyan-500 hover:bg-cyan-600 text-sm uppercase p-2 font-black text-white cursor-pointer&quot;&gt;
                    </code>
                  </pre>
      
                  <p>Veamos un ejemplo de una validación sencilla:</p>
                  <pre>
                    <code class="language-js">
                      const formulario = document.querySelector('#formulario')
                      formulario.addEventListener('submit', e => {
                        e.preventDefault
                      
                        const nombre = document.querySelector('#nombre').value
                        const password = document.querySelector('#password').value
                      
                        if(nombre === '' || password === ''){
                          console.log('Todos los campos son obligatorios')
                        } else {
                          console.log('Todo bien, iniciando sesión')
                        }
                        // console.log('Enviando formulario')
                        // console.log(nombre)
                        // console.log(password)    
                      })
                    </code>
                  </pre>
      
                  <p>Creamos con JS un elemento html div al que vamos a añadir unas clases de tailwindcss para darle formato.</p>
      
                  <p>Hemos de seleccionar siempre un elemento de nuestro document en el que queremos renderizar lo que estamos creando. Como estamos creando un div de alerta de validación, tiene sentido que lo queramos mostrar en el formulario. Por tanto agregamos la alerta como un hijo del formulario <span class="destacado">formulario.appendChild(alerta)</span></p>
                  <pre>
                    <code class="language-js">
                      const formulario = document.querySelector('#formulario')
                      formulario.addEventListener('submit', e => {
                        e.preventDefault
                        const nombre = document.querySelector('#nombre').value
                        const password = document.querySelector('#password').value
                        
                        //Prevenir nuevas alertas
                        const alertaPrevia = document.querySelector('.alerta')
                        /*if (alertaPrevia){
                          alertaPrevia.remove();
                        }*/
                        alertaPrevia?.remove(); //comprobamos si existe con el optional chaining
      
                        const alerta = document.createElement('DIV')
                        //alerta.textContent = 'contenido de alerta'
                        //alerta.classList = 'clase-1 clase-2' //se pueden añadir así clases de estilo pero se recomienda hacerlo usando .add()
                        //alerta.classList.add('clase-1','clase-2','clase-3')
                        //añadamos clases de Tailwind css
                        alerta.classList.add('alerta','text-white','uppercase', 'text-sm', 'text-center', 'p-2', 'font-black')   
                    
                        if(nombre === '' || password === ''){
                          alerta.textContent = 'Todos los campos son obligatorios'
                          alerta.classList.add('bg-red-500')
                        } else {
                          alerta.textContent = 'Todo bien, iniciando sesión'
                          alerta.classList.add('bg-green-500')
                        }
                        //para eliminar la alerta pasados 2sg
                        setTimeout(() => {
                          alerta.remove()
                        }, 2000);
                        //console.log(alerta)
                        formulario.appendChild(alerta)
                      })
                    </code>
                  </pre>	
                </div>
      <!-- Fin bloque desplegable interior-->
                
              </div>			
            </div><!--Fin row-->
              
              
            
          </div>
          <!-- Fin div colapsable-->
      
      
        </div>
      </div>	
      <!-- SECCION 2 -->	


      <!-- SECCION 1 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
        <div class="row">
          <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion1').toggle();">	
            <h2>Sección 1: Introducción al Curso - Qué es React, Proyectos que Construiremos y más</h2>				
                    <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
          </div>
          
          <div id="seccion1"  class="hidden">			
            <div class="row">
              <div class="col-12 pl-1.25">	
                
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion1-1').toggle();">	
                  <h3>1. ¿Qué es React?</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                
                <div id="seccion1-1" class="hidden">	
                  
                  <p>Es una biblioteca de JS para construir interfaces de usuario</p>
                  <ul>
                    <li>Ayuda a crear UI interactivas de forma muy sencilla (tiene muchas funciones y eventos para disparar fcnes en base a las interacciones del usuario)</li>
                    <li>Se encarga de actualizar y renderizar de manera eficiente los componentes de tu aplicación</li>
                    <li>Esta basado en componentes: no son mas que fiunciones en JS utilizados para renderizar el diseño de tu aplicación o sitio web</li>
                    <li>Creado por Meta (antiguo Facebook). También la empresa Versell apoya su desarrollo.</li>
                  </ul>
    
                  <p class="font-bold">Ventajas de React</p>			
                  <ul>
                    <li>Excelente documentación con muchos ejemplos</li>
                    <li>Una gran comunidad y muchas librerias que puedes incorporar a tus proyectos</li>
                    <li>Tecnología con mucha demanda: La mayoría de vacantes solicitan React, tanto para fornt end como para full stack</li>
                  </ul>
    
                  <p class="font-bold">¿Qué necesito para aprender React?</p>
                  <ul>
                    <li>Dominar HTML y CSS</li>
                    <li>Conocer la sintaxis Moderna de Javascript (ES6(2015)EcmaScript6 y cada añao hay nuevas que añaden unas cuantas funciones más)</li>
                    <li>Tener instalado Node.js para crear nuestros proyectos</li>
                  </ul>
                  
                </div><!-- Fin seccion colapsable interior  -->
                
                
              </div>			
            </div><!--Fin row-->
              
            <div class="row">
              <div class="col-12 pl-1.25">	
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion1-2').toggle();">	
                  <h3>2. Proyectos 01 a 04 del Curso - Fundamentos de React y TypeScript</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>						
                
                <div id="seccion1-2" class="hidden">	
                  
                  <p class="font-bold">Proyecto carrito de compras GuitarLA</p>
                  <p>En este proyecto estaremos aprendiendo los fundamentos de React: <span class="destacado">Componentes, Eventos y State</span>, mientras creas un carrito de compras real con cantidades, precios, y más, tomaremos este mismo carrito para mostrarte como crear tus propios Hooks y como transformarlo a código de TypeScript y cuales son sus beneficios. Carrito de compra persistente sincronizando con localStorage (aprenderemos todas esas acciones agregar elementos, cambiarlos, cambiar cantidades, vaciar carrito...)</p>							
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/s1-01-D8LKf9H6.jpg" width="" height="" alt=""/> 
    
                  <p class="font-bold">Calculadora de propinas y consumos. Un proyecto ideal para restaurantes donde se podrá generar una orden con consumos y la persona podrá elegir la propina que desea dejar.</p>							
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/s1-02-BEtrmdfx.jpg" width="" height="" alt=""/> 
    
                  <p class="font-bold">Contador de Calorías y Ejercicios</p>	
                  <p> Una de las tareas que más vas a realizar en tu vida como Developer es procesar formularios; en este proyecto tendremos un formulario, leeremos sus datos, lo vamos a procesar y realizar algunas operaciones como validación y mucho más, además aprenderás que es <span class="destacado">useReducer</span> para manejar estados complejos en tus apps. Veremos cómo funciona este patrón, es un hook especial cuando tenemos un state un poco más complejo.</p>
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/s1-03-CV3P0oc-.jpg" width="" height="" alt=""/> 
                  
                  
                  <p class="font-bold">Control de Gastos y Presupuestos:</p>	
                  <p>En este proyecto estaremos viendo que es <span class="destacado">Context API</span> para tener un estado global sin dependencias; Context API va a ayudarte a no pasar props por cada componente, completamos el curso con filtrar gastos por categoría, calendario de fechas de gastos, gráficas y mucho más! Por tanto también usaremos reducers, context Api para comenzar a trabajar con un estado global y un custom hook.</p>
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/s1-04-CmOvAHLD.jpg" width="" height="" alt=""/> 
                  
                </div><!-- Fin seccion colapsable interior  -->
              </div>
            </div><!--Fin row-->
            
            
            
            
            <div class="row">
              <div class="col-12 pl-1.25">	
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion1-3').toggle();">	
                  <h3>3. Proyectos 05 a 08 del Curso - React Intermedio y API's</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>						
                
                <div id="seccion1-3" class="hidden">	
                  
                  <p class="font-bold">Administrador de pacientes de veterinaria</p>
                  <p>Introduce dos herramientas nuevas: Este proyecto añade dos herramientas nuevas: <span class="destacado">Zustand</span> para manejar un estado global de forma muy simple y <span class="destacado">React Hook Form</span>, una librería para para la parte de validación y procesamiento de nuestros formularios de manera bastante sencilla.</p>														
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/s1-05-6r9L6GA7.jpg" width="" height="" alt=""/> 
                  
                  <p class="font-bold">Buscador de clima</p>
                  <p>Esta será nuestra primera aplicación que obtiene datos de una <span class="destacado">API externa</span>, como React Developer vas a trabajar en muchos proyectos que incluyen API's; estaremos viendo como validar y enviar peticiones hacia API, como leer las respuestas y como mostrar esa información. La parte de APIS es muy importante en el mundo de React.</p>							
                  <img class="my-2.5" src="https://andune55.github.io/manual-react/assets/s1-06-DCP4YZTs.jpg" width="" height="" alt=""/> 
                  
                  <p class="font-bold">Cotizador de Criptomonedas</p>
                  <p>Este proyecto al igual que el anterior se conecta a una API para obtener el precio de una Criptomoneda en dólares, pesos mexicanos y otras monedas; Este proyecto incluye Zustand y Zod para validar las respuestas que obtenemos de nuestra API.</p>							
                  <!-- <img class="my-2.5" src="./src/assets/img/s1-07.jpg" width="" height="" alt=""/>  -->
    
                  <p>Proyecto 04: Migrar Carrito de Compras a useReducer: En este capítulo estaremos viendo como tomar el proyecto de carrito de compras y convertirlo hacia useReducer; cuando tomas un proyecto que conoces en una tecnología nueva es garantía que podrás entender mejor los conceptos.</p>
                  <p>Proyecto 05: Migrar Calculadora de Propinas hacia useReducer: Veamos como migrar nuestro otro proyecto hacia useReducer.</p>
    
    
                  <p>Proyecto 10: Buscador de Recetas: Este es nuestro primer proyecto que incluye múltiples páginas; lo estaremos realizando con React Router DOM la librería más popular para crear aplicaciones en React de múltiples página, este curso utiliza el Slice Pattern para tener múltiples Stores de Zustand!</p>
                  <p>Proyecto 11: Administrador de Productos: Este es nuestro primer proyecto Full Stack donde estaremos creando tanto frontend como backend utilizando el PERN (PostgreSQL, Node.js, Express y React) este proyecto utiliza una REST API que conectaremos con React, añadiremos temas más avanzados como Testing y Documentación de API's.</p>
                  <p>Proyecto 12: Administrador de Tareas y Proyectos: Este es el Proyecto más avanzado del curso, utiliza el MERN stack que es uno de los más populares hoy en día, este proyecto incluye un sistema robusto de autenticación y registro de usuarios con confirmación de cuentas y resetear el password en caso de olvidarlo; además incluye roles y los usuarios solo pueden realizar ciertas acciones. El curso incluye además una REST API bastante compleja y avanzada, El curso utiliza también React Query, Tailwindcss, React Router, Mongoose, Express, TypeScript y mucho más.</p>
                  <p>Proyecto 13: Quiosco de Comida: Finalizaremos este curso con una introducción a Next.js, utilizaremos la versión 14 con App Router, Server Actions, Prisma, Zod, Zustand, Tailwind, y mucho más, el proyecto incluye subida de archivos, CRUD Completo, paginador, buscador y más.</p>
    
                  
                </div><!-- Fin seccion colapsable interior  -->
    
              </div>
            </div><!--Fin row-->
            
            
            
            
            
            
            
            
            
            
            <!-- 
            <div class="row">
              <div class="col-12 pl-1.25">						
                
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccionX-X').toggle();">	
                  <h3>XXXXXXXXXXXXXXXXXXXXXX</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>						
                
                <div id="seccionX-X" class="hidden">	
                  
                  <p class="font-bold">XXXXXXXXXXXX</p>
                  <p>XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</p>							
                  <img class="my-2.5" src="./src/assets/img/XXXX.jpg" width="" height="" alt=""/> 
    
                  
                  
                </div>
    
              </div> 
            </div>
            -->
            
            
            
            
            
            
            
              
            <div class="row">
              <div class="col-12">	
    
                
    
              </div>
            </div>
              
            
            
          </div>
          <!-- Fin div colapsable-->
      
      
        </div>
      </div>	
      <!-- FIN SECCION 1 -->	
    
    
        <!-- SECCION 00 -->
        <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
          <div class="row">
            <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion0').toggle();">
              <h2>Apuntes curso React</h2>
              <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
            </div>

            <div id="seccion0" class="hidden">
              <div class="row">
                <div class="col-12">

                  <p>Aprende React con TypeScript paso a paso creando proyectos del mundo real.</p>
            
                  <p>Aprende React con proyectos del mundo real; Incluso si tus bases de JavaScript no son muy fuertes el curso tiene una introducción con todo lo que debes saber.</p>
                  <p>En este curso aprenderemos a crear proyectos reales abarcando todo el ecosistema de React: State, Hooks, crear tus propios hooks, hooks avanzados, estado global, componentes y eventos, consultar API's externas y crear tus propias API's.</p>
                  <p>Todos los Proyectos incluyen TypeScript desde el inicio.</p>	

                </div>
              </div><!--Fin row-->
            </div>
            <!-- Fin div colapsable-->

          </div>
        </div>
        <!-- FIN SECCION 00 -->
          
      
      
    
    </div>
      
     



  </body>
</html>
