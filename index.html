<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Curso React</title>	
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">	
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap" rel="stylesheet">    
    
    <!-- <script src="https://unpkg.com/@tailwindcss/browser@4"></script> -->
    <link rel="stylesheet" href="./src/assets/prism.css">
    <link rel="stylesheet" href="./src/index.css">
  
    <script type="module" src="./src/assets/prism.js"></script>
    <script type="module" src="./src/assets/jquery-2.1.4.min.js"></script>
    <script type="module" src="./src/assets/desplegar.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="./src/main.jsx"></script>	
    <div>   
      

    <!-- SECCION 13 -->
    <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 my-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">

      <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between" onclick="$('#seccion13').toggle();">
        <h2>Sección 13: PROYECTO - Control de Gastos y Presupuestos con Context API para estado global</h2>
        <span class="cambiaicono ico_chevron_up mr-2.5" title=""></span>
      </div>

      <div id="seccion13">

        <a class="underline text-rose-600 font-bold" href="https://github.com/and....55/control-gastos-contextapi/" target="blank">https://github.com/and....55/control-gastos-contextapi/</a>
        <p> Planificador de gastos. Proyecto con un un state más complejo pero nos apoyamos en <span class="destacado">useReducer</span> y <span class="destacado">contextAPI</span>. También <span class="destacado">localStorage</span>, <span class="destacado">validación de formulario</span>, <span class="destacado">modal que utiliza Headless UI</span></p>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-188').toggle();">
          <h3>188. El Proyecto que vamos a construir</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-188" class="hidden">
          <p>Vamos a hacer un <span class="destacado">planificador de gastos</span>. <strong>Va a ser el proyecto más complejo hasta ahora pero pone en práctica todo lo que hemos aprendido.</strong> <strong>Su backend (también hecho con typescrpt) lo hace en el curso que tiene de node.js</strong>. Podemos definir un presupuesto, por ejemplo para el mes, tendremos <span class="destacado">validación de formulario</span> para que no nos deje escribir letras ni negativos... Podremos filtrar los gastos por categorías, al pulsar el "+" inferior aparece una <span class="destacado">ventana modal que utiliza Headless UI: un framework de React de los colaboradores de Tailwindcss</span>. Vamos registrando gastos y vemos como se va actualizando la información con lo gastado, disponible... además tenemos un filtro de los gastos ya registrados. También podemos quitar gastos ya añadidos arrastrando a la izquierda o actualizarlos arrastrando a la derecha (en ese caso aparece el modal panel con el formulario completo con los datos de la actividad registrada que vamos a modificar). <span class="destacado">Son gastos persistentes, van a esta en LocalStorage</span> y, digamos que ya pasó la semana, reseteamos la app y definimos otro presupuesto para volver a calcular los gastos de la semana</p>

          <p>Este proyecto <span class="destacado">tiene un state más complejo pero nos apoyamos en useReducer y <strong>contextAPI</strong></span></p>

          <img class="mx-auto" src="./src/assets/img/188-planificador-gastos.jpg" alt="img" loading="lazy">

        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-189').toggle();">
          <h3>189. Creando el Proyecto y Copiando Materiales / 190. Instalando TailwindCSS</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-189" class="hidden">
          <p>Proyecto nuevo. Usamos useReducer pero tambien estaremos agregando <span class="destacado">contextAPI para tener un estado global en nuestras aplicaciones y no tener que pasar todo via props</span>. Lo veremos a continuación el cómo se agrega a nuestro proyecto.</p>

          <ul class="list-disc my-2.5">
            <li>npm create vite@latest</li>
            <li>control-gastos-contextapi</li>
            <li>TS + SWC</li>
            <li>npm install</li>
            <li>limpiamos (borramos src, borramos app.css ya que usaremos tailwindcss (estandar en apps de React (Next.js y otros frameworks ya lo incluyen)) limpiamos app.tsx, limpiamos index.css...)</li>
            <li>Descomprimos "Materiales+Control.zip" y todos esos iconos necesarios que están ahí los colocamos en la carpeta public de nuestro proyecto.</li>
            <li>instalamos tailwind: <a class="underline" href="https://tailwindcss.com/docs/installation/using-vite" target="_blank">https://tailwindcss.com/docs/installation/using-vite</a> 
              <ul class="mb-3.75">
                <li><span class="destacado">npm install tailwindcss @tailwindcss/vite</span></li>
                <li>configurar el plugin: 
                  <div class="code-toolbar"><pre class="language-js" tabindex="0"><code class="language-js"><span class="token comment">//vite.config.ts</span>
<span class="token keyword module keyword-import">import</span> <span class="token imports">tailwindcss</span> <span class="token keyword module keyword-from">from</span> <span class="token string">'@tailwindcss/vite'</span>
<span class="token keyword module keyword-export">export</span> <span class="token keyword module keyword-default">default</span> <span class="token function">defineConfig</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
<span class="token literal-property property">plugins</span><span class="token operator">:</span> <span class="token punctuation">[</span>
  <span class="token function">tailwindcss</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><div class="toolbar"><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" data-copy-state="copy"><span>Copy</span></button></div></div></div>
                </li>
                <li>importar tailwindcss en nuestra css principal: 
                  <div class="code-toolbar"><pre class="language-js" tabindex="0"><code class="language-js"><span class="token comment">//src&gt;index.css</span>
@<span class="token keyword module keyword-import">import</span> <span class="token string">"tailwindcss"</span><span class="token punctuation">;</span></code></pre><div class="toolbar"><div class="toolbar-item"><button class="copy-to-clipboard-button" type="button" data-copy-state="copy"><span>Copy</span></button></div></div></div>
                </li>
              </ul>                   
            </li>
            <li>Tenemos que instalar @heroicons <span class="destacado">npm install @heroicons/react</span> y @headlessui <span class="destacado">npm install @headlessui/react</span> en el vídeo 202. También <span class="destacado">npm install uuid</span> en el vídeo 210. <span class="destacado">npm i react-swipeable-list</span> para lista swipeable del vídeo 215. --&gt; 
              <br><span class="rojo">OJO me daba este error y blancazo interfaz:</span><br> 16:44:03 [vite] (client) error while updating dependencies:<br>
              Error: Build failed with 1 error:<br>
              node_modules/react-swipeable-list/dist/react-swipeable-list.esm.js:2:22: ERROR: Could not resolve "prop-types"
              <br><span class="verde">Solucionado con</span> <br>
              As of React 15.5.0, PropTypes have been removed from the core React package as a separate dependency. To fix this, add prop-types into your code:

              If you're loading via script tags:<br>

              &lt;script src=&quot;https://unpkg.com/prop-types/prop-types.min.js&quot;&gt;&lt;/script&gt;
              Or via NPM:<br>

              <span class="destacado">npm install --save prop-types</span><br>
              En el vídeo 224 instala <span class="destacado">npm i react-circular-progressbar</span>
            
            
            </li>
          </ul>
        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-191').toggle();">
          <h3>191. Creando los Primeros Componentes</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-191" class="hidden">
          <p>Vamos a empezar a trabajar con la interfaz.</p>

          <p>De momento nuestra App.tsx queda así:</p>

          <div class="flex max-sm:flex-col">
            <div class="w-[50%] max-sm:w-[100%]">
              <pre><code class="language-ts">
                //App.tsx
                &lt;header className=&quot;bg-blue-600 py-8 max-h-72&quot;&gt;
                  &lt;h1 className=&quot;uppercase text-center font-black text-4xl text-white&quot;&gt;Planificador de gastos&lt;/h1&gt;
                &lt;/header&gt;
          
                &lt;div className=&quot;max-w-3xl mx-auto bg-white shadow-lg rounded-lg mt-10 p-10&quot;&gt;
                  &lt;p&gt;Formulario aquí&lt;/p&gt;
                &lt;/div&gt;
              </code></pre>
            </div>
            <div class="w-[50%] max-sm:w-[100%] ml-2">
              <img src="./src/assets/img/192.png" alt="img" loading="lazy">
            </div>
          </div>

          <p><strong>En el minuto 2 cuenta como le ha convencido tailwindcss empezó como frontend y hacía guías de estilo, adaptando bootstrap a loq ue pedían... muy bueno ESCUCHARLO</strong></p>

          <p>Hacemos nuestra carpeta components y creamos el primero <strong>BudgetForm.tsx:</strong> que va a contener el formulario para que el usuario defina su presupuesto (y comenzar a agregar gastos y controlarlo). Agregamos el tag de este nuevo componente en nuestro compo ppal App.tsx</p>
          

        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-192').toggle();">
          <h3>192. Creando el Formulario para Definir el presupuesto / 193. Validando el presupuesto / 194. Creando el Reducer para Presupuestos</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-192" class="hidden">
          <p>Solo va a tener <strong>un campo para introducir la cantidad del presupuesto y un submit</strong>. Ese input va a tener el id="budget" y name="budget". Si recordamos en el ejemplo anterior cuando leíamos el state utilizábamos e.target.id pero si le ponemos un name podemos leer con e.target.name, que es otra forma de hacerlo (ninguna de las 2 sería necesaria, con e.target.value lo sacaríamos)</p>

          <p>Requerimos un state local para validar ese formulario y en caso de que pase la validación ya escribimos en nuestro reducer, por lo que importamos useState y lo definimos con valor inicial de 0. Lo usamos en el value de nuestro input numérico y así inicia en 0 nuestro formulario.</p>

          <p>Escribimos en nuestro state: <strong>creamos la nueva variable handleChange</strong> como arrow function y <strong>el tipo del parámetro e lo sacamos infiriendo</strong> de la siguiente manera: poniendo en el input un <code class="language-js">onChange={e =>}</code> y poniéndonos encima de la e (nos lo dice el IS no tenemos que memorizar nada). Utilizamos la función del state para setear en el state el value de nuestro campo, <strong>Ojo! el state lo iniciamos como número, si le ponemos simplemente 'e.target.value' da un error al indicarnos que es un string y no se puede, para pasarlo a número podemos usar cualquiera de las dos formas vistas, con el '+' o con el 'valueAsNumber'(en este caso sí podemos usarlo, solo daba problemas con radios)</strong></p>

          <div class="flex max-sm:flex-col">
            <div class="w-[50%] max-sm:w-[100%]">
              <pre data-line="5,7-10,22,23"><code class="language-js">
                //BudgetForm.tsx                  
                import { useState, ChangeEvent } from "react"

                export default function BudgetForm() {

                    const [budget, setBudget] = useState(0)

                    const handleChange = (e: ChangeEvent&lt;HTMLInputElement&gt;) =>{
                        //setBudget(+e.target.value)
                        setBudget(+e.target.valueAsNumber)
                    }
                    return (
                        &lt;form className=&quot;space-y-5&quot;&gt;
                            &lt;div className=&quot;flex flex-col space-y-5&quot;&gt;
                                &lt;label htmlFor=&quot;budget&quot; className=&quot;text-4xl text-blue-600 font-bold text-center&quot;&gt;
                                    Definir Presupuesto
                                &lt;/label&gt;
                                &lt;input
                                    type=&quot;number&quot;
                                    className=&quot;w-full bg-white border border-gray-200 p-2&quot;
                                    placeholder=&quot;Define tu presupuesto&quot;
                                    name=&quot;budget&quot;
                                    value={budget}
                                    onChange={handleChange}
                                /&gt;
                            &lt;/div&gt;
                            &lt;input 
                                type=&quot;submit&quot;
                                value=&quot;Definir Presupuesto&quot;
                                className=&quot;bg-blue-600 hover:bg-blue-700 cursor-pointer w-full p-2 text-white font-black uppercase&quot;
                                /&gt;
                        &lt;/form&gt;
                    )
                }
              </code></pre>
            </div>
            <div class="w-[50%] max-sm:w-[100%] ml-2">
              <img src="./src/assets/img/192-2.png" alt="img" loading="lazy">
            </div>
          </div>

          <p class="naranja">Validando el Presupuesto</p>

          <p>Como vemos puede ser que esté a 0 o incluso borremos la cantidad(string vacío) y el botón sigue activo, no queremos eso, vamos a validar que sean números y mayores a 0. creamos la función 'isValid' y usamos useMemo() usando como dependencia nuestro state local budget para que, <strong>solo cuando el usuario escriba se ejecute esa función</strong>. Si miramos con un <code class="language-js">console.log(isNaN(budget))</code> <strong>vemos que nos devuelve true cuando no es número. Podemos usar esa información para controlar el disabled del botón submit</strong></p>

          <p>Si los formularios son más complicados utilizaremos librerías para validación de formularios.</p>

          <pre data-line="12-14,35"><code class="language-js">
            //BudgetForm.tsx
            import { useState, ChangeEvent, useMemo } from "react"

            export default function BudgetForm() {

                const [budget, setBudget] = useState(0)

                const handleChange = (e: ChangeEvent&lt;HTMLInputElement&gt;) =&gt;{
                    //setBudget(+e.target.value)
                    setBudget(e.target.valueAsNumber)
                }

                const isValid = useMemo(() =&gt;{
                    return isNaN(budget) || budget &lt;= 0
                }, [budget])

                return (
                    &lt;form className=&quot;space-y-5&quot;&gt;
                        &lt;div className=&quot;flex flex-col space-y-5&quot;&gt;
                            &lt;label htmlFor=&quot;budget&quot; className=&quot;text-4xl text-blue-600 font-bold text-center&quot;&gt;
                                Definir Presupuesto
                            &lt;/label&gt;
                            &lt;input
                                type=&quot;number&quot;
                                className=&quot;w-full bg-white border border-gray-200 p-2&quot;
                                placeholder=&quot;Define tu presupuesto&quot;
                                name=&quot;budget&quot;
                                value={budget}
                                onChange={handleChange }
                            /&gt;
                        &lt;/div&gt;
                        &lt;input 
                            type=&quot;submit&quot;
                            value=&quot;Definir Presupuesto&quot;
                            className=&quot;bg-blue-600 hover:bg-blue-700 cursor-pointer w-full p-2 text-white font-black uppercase disabled:opacity-40&quot;
                            disabled={isValid}
                            /&gt;
                    &lt;/form&gt;
                )
            }
          </code></pre>

          <p>Supongamos que introducimos un valor de presupuesto válido. Lo queremos tener en el reducer para ir controlando todo mi state, así que vamos a crear el reducer de esta aplicación</p>
          
          <p class="naranja">Creando el Reducer para Presupuestos</p>

          <p>Creamos <span class="file">reducers&gt;budget-reducer.ts</span> donde lo vamos a controlar todo presupuesto, gastos, editarlos, eliminarlos, reiniciar la aplicación y también vamos a filtrar por categoría porque son todo elementos que pertenecen a estos gastos y presupuesto.</p>

          <p>el primer type va a ser lo que tenemos en nuestro state local del compo BudgetForm.tsx <code class="language-js">const [budget, setBudget] = useState(0)</code>. El form va a tener un onSubmit y es cuando lo vamos a escribir.</p>

          <pre><code class="language-js">
            //budget-reducer.ts
            export type BudgetActions = 
            { type: 'add-budget', payload: {budget: number} }
        
            export type BudgetState = {
                budget: number
            }
            
            export const initialState: BudgetState = {
                budget: 0
            }
            
            export const budgetReducer = (
                    state: BudgetState=initialState,
                    action: BudgetActions
                ) =>{
            
                if(action.type === "add-budget"){
            
                    return{
                        ...state,
                        budget: action.payload.budget
                    }
                }
            
                return state
            }
          </code></pre>

          <p>Hasta ahora lo que hemos hecho para escribir aquí es: ir a la App.tsx (que es donde nace nuestra aplicación) e importar useReducer, el state inicial, el reducer que acabamos de crear y extraemos tanto state como dispatch y pasamos ya sea state o funciones de tipo dispatch a nuestros componentes. Eso está bien pero podemos evitar estar pasando esos props de state y dispatch a los componentes utilizando contextApi o algún manejador de estados globales</p>

        </div>         
          
        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-195').toggle();">
          <h3>195. Introducción a ContextAPI</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-195" class="hidden">
          <p>Si el proyecto comienza a ser más complejo, tener un estado global nos va a ahorrar muchas líneas de código. Context API ya viene incluído en React y nos permite manejar un estado global sin instalar dependencias (porque hay varias opciones que sí requieren ser instaladas)</p>

          <ul class="list-disc my-2.5">
            <li><strong>Nos va a permitir tener un estado global en tu aplicación. Esto quiere decir que solo se tiene una instancia del State que se puede acceder desde cualquier componente sin pasarlo por diferentes componentes vía props.</strong> Si colocamos un state en un custom hook o en un reducer, lo que hemos hecho es tenerlo en el App.tsx y de ahí pasamos todo vía props. Si comenzamos a instanciar ese reducer o ese custom hook, veremos que se crean múltiples instancias de ese state por lo tanto las funciones no se pueden comunicar correctamente, solo se comunican con el state que fue instanciado ya sea via custom hook o custom reducer. Esto es lo que se soluciona con <strong>Context API: solo tendremos una instancia de nuestra aplicación</strong></li>
            <li><strong>El hook para utilizarlo es useContext</strong></li>
            <li><strong>Muchas librerías utilizan Context API</strong> muchas veces instalamos algo y ya solo es importarlo para que funcione correctamente. Una forma de poder hacerlo es con Context API porque ya viene incluido con React a diferencia de otras opciones como Redux Toolkit o Zustand</li>
          </ul>

          <p>Veamos un ejemplo. Actualmente tenemos nuestra aplicación de esta forma, y si tenemos un state de productos tenemos que pasarlo de App a tienda y de Tienda a productos. Con useContext lo podemos pasar directamente de App a Productos o simplemente llamarlo directamente en productos y va a funcionar sin problema. <strong>Por tanto lo principal es que nos va a evitar estar pasando via props ya sea state o dispatch porque podemos instanciarlo directamente.</strong></p>

          <img src="./src/assets/img/195.png" alt="img" loading="lazy">

          <p>Alternativas a Context API</p>

          <ul class="list-disc my-2.5">
            <li>Algo muy bueno de Context API es que no requiere dependencias pero su boilerplate para configurarlo (su configuración) puede ser algo complejo, de hecho vamos a crear nuestro context y también un custom hook para poder acceder a ese context</li>
            <li>Otras alternativas son Zustand o Redux Toolkit, que también los veremos a continuación en el curso</li>
          </ul>

        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-196').toggle();">
          <h3>196. Definiendo el Context</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-196" class="hidden">
          <p>Vamos a crear nuestro context y el nombrado es como si fuera una clase (el reducer con minúsculas y guion, recordemos <span class="file">reducers&gt;budget-reducer.ts</span>) <span class="file">context&gt;BudgetContext.tsx</span> </p>

          <ul class="list-disc my-2.5">
            <li><strong>Creamos nuestro provider (de donde vienen los datos)</strong> y los datos van a venir de nuestro reducer pero tenemos que agregarlo para tener de esa forma acceso al estado y a las funciones que modifican nuestro state. arrow function porque retorna algo. 
              <ul class="list-disc my-2.5">
                <li class="my-2.5">Para acceder al state y las acciones de nuestro reducer, hemos de instanciar aquí nuestro reducer (aquí podríamos usar useState y useEffect pero lo estamos haciendo con un reducer) para lo cual importamos useReducer, budgetReducer y el initialState. Y a continuación instanciamos: <code class="language-ts">const[state, dispatch] = useReducer(budgetReducer, initialState)</code></li>
                <li class="my-2.5">En el return() le vamos a pasar el state y el dispatch. <strong>Siempre que utilicemos nuestro provider, vamos a tener acceso a nuestro reducer y a las funciones de ese reducer, en este caso al dispatch.</strong> Pero para ello <strong>tenemos que crear el context </strong>porque esto que llevamos escrito
                  <pre><code class="language-ts">
                    import { useReducer, createContext } from 'react';
                    import { budgetReducer, initialState } from "../reducers/budget-reducer"
                    
                    export const BudgetProvider = () => {
                    
                        const[state, dispatch] = useReducer(budgetReducer, initialState)
                    
                        return(
                            
                        )
                    
                    }
                  </code></pre>
                  es solamente la sintaxis para poder acceder a la información y poder utilizar la sintaxis de React.</li>
                  <li>Creamos nuestro context con una función especial que se llama <span class="destacado">createContext</span> <code class="language-ts">import { useReducer, createContext } from 'react';</code> <code class="language-ts">export const BudgetContext = createContext()</code> como vemos nos da error porque se espera un argumento que es su valor por default. Lo primero que tenemos que decirle es qué va a manejar este provider, que en este caso maneja state y dispatch por lo tanto creamos un type (como hacíamos para tipar las propiedades en los compos) que llamamos BudgetContextProps. Vamos a manejar el state y ahí es donde se conectan tanto el context (la acción de tener el estado global) como el provider (los datos que va a tener ese context). Ponemos 'state:'' y 'dispatch:' porque es lo que va a manejar este provider. Con este type, este context sabe qué es lo que tiene que tener registrado, y al tener esos props tenemos el autocompletado y va a estar sincronizado tanto el context (qué tiene que manejar) como el provider (qué datos tiene que manejar). Para completar esos tipos inferimos de <code class="language-ts">const[state, dispatch] = useReducer(budgetReducer, initialState)</code>
                  <pre><code class="language-ts">
                    type BudgetContextProps = {
                      state:  BudgetState
                      dispatch: Dispatch&lt;BudgetActions&gt;
                  }
                </code></pre>
                  así es como le hacemos saber estos props a nuestro createContext(), que nuestro provider va a manejar tanto state como dispatch con esas acciones de este reducer. Le aplicamos ese tipo con un generic a nuestro context <code class="language-ts">export const BudgetContext = createContext<BudgetContextProps>()</code> y de esa forma nuestro context va a saber que tenemos state y dispatch, de donde vienen y el provider tiene el acceso ya a la información. Sin embargo vemos que sigue marcando rojo porque espera un argumento. <strong>Escribir context es un poco complicado con Typescript como vemos pero tenemos dos opciones que podemos usar:</strong>
                    <ul class="list-disc my-2.5">
                      <li><code class="language-ts">export const BudgetContext = createContext&lt;BudgetContextProps&gt;({} as BudgetContextProps)</code> Crear un objeto vacío y ponerle un as para "castearlo" como BudgetContextProps --&gt; le decimos a TS "confía en mí, se lo que hago y te voy a pasar correctamente state y dispatch"</li>
                      <li><code class="language-ts">export const BudgetContext = createContext&lt;BudgetContextProps&gt;(null!)</code> esta es otra forma aceptada por la comunidad y lo importante es que desaparece el error y podamos continuar</li>
                    </ul>
                    
                    <pre><code class="language-ts">
                      //BudgetContext.tsx
                      import { useReducer, createContext, Dispatch } from &#39;react&#39;;
                      import { BudgetState, BudgetActions, budgetReducer, initialState } from &quot;../reducers/budget-reducer&quot;
                      
                      type BudgetContextProps = {
                          state:  BudgetState
                          dispatch: Dispatch&lt;BudgetActions&gt;
                      }
                      
                      export const BudgetContext = createContext&lt;BudgetContextProps&gt;({} as BudgetContextProps)
                      
                      export const BudgetProvider = () =&gt; {
                      
                          const[state, dispatch] = useReducer(budgetReducer, initialState)
                      
                          return(
                      
                          )
                      
                      }
                    </code></pre>
                  
                </li> 
              </ul>            
            </li>
            
          </ul>

          <p><strong>Tenemos nuestros BudgetContext y BudgetProvider. Actualmente lo que los conecta, lo que le dice a este context que este provider va a manejar este state y dispatch es el type &lt;BudgetContextProps&gt;, pero son dos funciones independientes, como tal no están conectadas</strong>, solo le estamos diciendo a nuestro context que el provider va a tener un state y un dispatch, (porque los types al final solo son para darle información pero no hacen nada en tu código solo dan información de como se relacionan ciertos datos o qué esperar de ciertos datos). <strong>Por lo tanto en el return del BudgetProvider lo que hacemos es colocar este BudgetContext con sintaxis de componente y pasaremos state y dispatch y de esa forma cuando instanciemos o utilicemos nuestro context vamos a tener acceso a state y dispatch.</strong></p>

          <pre><code class="language-ts">
            &lt;BudgetContext.Provider&gt;
            
            &lt;/BudgetContext.Provider&gt;
          </code></pre>

          <p>Como decimos, es como sintaxis de componente lo que va a hacer es rodear toda nuestra aplicación de React y dentro va  aser muy simple tener acceso al state y al dispatch ¿Cómo vamos a poder utilizar este código en los otros componentes? ahí es donde entra algo llamado <span class="destacado">children</span> <code class="language-ts">export const BudgetProvider = ({children}) => {</code> <strong>¿Qué es children?</strong> Veámoslo con un ejemplo fácil: supongamos que estamos en el App.tsx y tenemos un párrafo y diferentes componentes, esos componentes serían hijos de ese párrafo y <strong>children es un prop especial que existe en React que hace referencia a los hijos de un componente.</strong> Como no sabemos (o puede ser que a futuro no sepamos) como se llaman esos componentes, existe ese prop especial que va a hacer referencia a todos los hijos de un componente</p>

            <pre><code class="language-ts">
              &lt;p&gt;
                &lt;BudgetForm /&gt;
                &lt;BudgetForm /&gt;
                &lt;BudgetForm /&gt;
              &lt;/p&gt;
            </code></pre>
          
          <p>y eso es lo que le pasamos en el return: Vemos que hasta ahora nos saldrían dos errores:</p>

          <ul class="list-disc my-2.5">
            <li>1º - el children está marcado como any</li>
            <li>2º - el provider no está retornando nada, nos dice que hace falta la propiedad value. Es un prop especial que existe en provider</li>
          </ul>

          <img src="./src/assets/img/196.png" alt="img" loading="lazy">

          <p><strong>ese prop value siempre es un objeto y aunque es un objeto retornamos otro objeto y le pasamos el state y el dispatch</strong>. De esta forma ya están conectados porque este context 'BudgetContext' espera estos props (tanto state como dispatch) y ya se los estamos pasando con ese prop value característico de provider.</p>

          <p>children es un poco más complejo porque pueden ser párrafos, formularios, componentes... Vamos a crear un type para  BudgetProvider con el cual ya tipamos ese {children} que extraemos como parámetro en el provider:</p>
          <pre><code class="language-ts">
            type BudgetProviderProps = {
              children : ReactNode
            }
          </code></pre>

          <p>Esto como tal no hace nada aún porque lo hemos creado como archivo independiente pero no lo hemos colocado en nuestro código de React, por lo que nuestra App de React no sabe aún que existe este archivo.</p>

          <pre><code class="language-ts">
            //BudgetContext.tsx
            import { useReducer, createContext, Dispatch, ReactNode } from &#39;react&#39;;
            import { BudgetState, BudgetActions, budgetReducer, initialState } from &quot;../reducers/budget-reducer&quot;
            
            type BudgetContextProps = {
                state:  BudgetState
                dispatch: Dispatch&lt;BudgetActions&gt;
            }
            type BudgetProviderProps = {
                children : ReactNode
            }
            
            export const BudgetContext = createContext&lt;BudgetContextProps&gt;(null!)
            
            export const BudgetProvider = ({children}: BudgetProviderProps) =&gt; {
            
                const[state, dispatch] = useReducer(budgetReducer, initialState)
            
                return(
                    &lt;BudgetContext.Provider
                        value={{
                            state,
                            dispatch
                        }}
                    &gt;
                        {children}
                    &lt;/BudgetContext.Provider&gt;
                )
            
            }
          </code></pre>

        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-197').toggle();">
          <h3>197. Agregando el Context a nuestra aplicación</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-197" class="hidden">
          <p>Actualmente ya tenemos el Boilerplate de nuestro context. tenemos dos partes,  provider(de donde vienen los datos y en este caso también las funciones) y context: que nos sirve para generar ese "componente" del return que es donde se están conectando ambos, tanto provider como context:</p>

          <pre><code class="language-ts">
            //BudgetContext.tsx
            return(
              &lt;BudgetContext.Provider
                  value={{
                      state,
                      dispatch
                  }}
              &gt;
                  {children}
              &lt;/BudgetContext.Provider&gt;
            )
          </code></pre>

          <p>Sin embargo este código no está conectado con nuestra app de React, es un archivo que está aparte ¿donde lo vamos a colocar para conectarlo y utilizarlo en nuestros componentes? Vamos hacia el <span class="file">main.tsx</span>. <span class="destacado">Context va a colocarse y envolver=rodear nuestra Aplicación para que podamos accder a las funciones, al state, a los datos que tengamos en este provider (en este ejemplo en nuestro provider estamos manejando el state y las funciones con useReducer, pero podríamos tener useEffect, variables, funciones, state, muchas otras cosas...)</span></p>

          <ul class="list-disc my-2.5">
            <li>Importamos BudgetProvider (recordemos, <strong>lo que contiene los datos</strong>, mientras que el context solo lo genera)</li>
            <li>Escribimos el tag <strong>&lt;BudgetProvider&gt;&lt;/BudgetProvider&gt;</strong> y llevamos el tag <strong>&lt;App/&gt;</strong> dentro de él <strong>para que estén disponibles en la app de forma global el state y el dispatch (con sus acciones) del reducer</strong></li>
          </ul>
          <pre data-line="5,9,11"><code class="language-ts">
            //main.tsx
            import { StrictMode } from 'react'
            import { createRoot } from 'react-dom/client'
            import './index.css'
            import App from './App.tsx'
            import { BudgetProvider } from './context/BudgetContext.tsx'
            
            createRoot(document.getElementById('root')!).render(
              &lt;StrictMode&gt;
                &lt;BudgetProvider&gt;
                &lt;App /&gt;
                &lt;/BudgetProvider&gt;
              &lt;/StrictMode&gt;,
            )
          </code></pre>

          <p>Si recargamos la app y abrimos en RDT componentes, vemos que ahora (antes en rojo) tenemos el BudgetProvider y Context.Provider. EN BudgetProvider vemos que viene el Reducer y el Budget mientras que en el Context.Provider viene el value con el dispatch y el state</p>

          <img src="./src/assets/img/197.png" alt="img" loading="lazy">

          <p>De esta forma ya hemos conectado y tenemos acceso a esa información.</p>

          <p>¿Como podemos acceder al dispatch y al state (que es lo que estamos retornando en el prop value del tag <strong>&lt;BudgetContext.Provider&gt;&lt;/BudgetContext.Provider&gt;</strong> en el return de nuestro context)? Recordamos que se utiliza el Hook useContext(). Algo importante es que createContext aquí: <code class="language-ts">export const BudgetContext = createContext&lt;BudgetContextProps&gt;(null!)</code> genera el context y aquí con <strong>useReducer</strong>le estamos "pasando el reducer" <code class="language-ts">const[state, dispatch] = useReducer(budgetReducer, initialState)</code> pero para poder utilizar este context, acceder y utilizar a lo que le estamos retornando en ese prop value <code class="language-ts">value={{state,dispatch}}</code> vamos a utilizar en <span class="file">App.tsx</span> useContext(), creando una nueva variable <strong>context</strong> en la que usamos este hook pasándole BudgetContext: <code class="language-ts">const context = useContext(BudgetContext)</code>. Si hacemos un console.log(context) vemos como aparece state y dispatch</p>

          <div class="flex max-sm:flex-col">
            <div class="w-[50%] max-sm:w-[100%]">
              <pre data-line="3,7"><code class="language-ts">
                //App.tsx
                import { useContext } from 'react';
                import BudgetForm from './components/BudgetForm';
                import { BudgetContext } from './context/BudgetContext';    
                
                function App() {
                
                  const context = useContext(BudgetContext)
                  console.log(context)
                
                  return (
                    &lt;&gt;
                    &lt;header className=&quot;bg-blue-600 py-8 max-h-72&quot;&gt;
                      &lt;h1 className=&quot;uppercase text-center font-black text-4xl text-white&quot;&gt;Planificador de gastos&lt;/h1&gt;
                    &lt;/header&gt;
                
                    &lt;div className=&quot;max-w-3xl mx-auto bg-white shadow-lg rounded-lg mt-10 p-10&quot;&gt;
                      
                      &lt;BudgetForm /&gt;
                      
                    &lt;/div&gt;
                    &lt;/&gt;
                  )
                }
                
                export default App
              </code></pre>
            </div>
            <div class="w-[50%] max-sm:w-[100%] ml-2">
              <img src="./src/assets/img/197-2.png" alt="img" loading="lazy">
            </div>
          </div>

          <p>Pone un ejemplo para que queda un poco más claro cual es el uso de ese value... crea en BudgetContext.tsx una const auth = true y la pasa como objeto en ese objeto prop 'value'. Si vemos el console.log que tenemos vemos que aparece!</p>

          <div class="flex max-sm:flex-col">
            <div class="w-[50%] max-sm:w-[100%] mr-2">
              <img src="./src/assets/img/197-3.png" alt="img" loading="lazy">              
            </div>
            <div class="w-[50%] max-sm:w-[100%]">
              <p>Podemos agregar más variables, funciones, state.... y en este value vamos colocando lo que vamos a poder consumir en nuestros componentes utilizando useContext() como acabamos de ver en el ejemplo de App.tsx <code class="language-ts">const context = useContext(BudgetContext)</code>. 
            </div>
          </div>

          <p>Pero utilizar en nuestra App.tsx useContext() para acceder a los contenidos de ese provider, (creando una variable nueva que llamamos 'context' a la que le asignamos el hook useContext() al que le pasamos nuestro context <code class="language-ts">const context = useContext(BudgetContext)</code>) no es la mejor forma. <span class="destacado">Es mejor usar un custom hook para ello</span>, veámoslo a continuación.</p>

        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-198').toggle();">
          <h3>198. Creando un Hook para fácilmente acceder al Context y al Reducer</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-198" class="hidden">
          <p>Ya hemos creado nuestro context y también tenemos nuestro provider:</p>

          <pre data-line="4-7,12, 20-23"><code class="language-ts">
            //BudgetContext.tsx
            import { useReducer, createContext, Dispatch, ReactNode } from &#39;react&#39;;
            import { BudgetState, BudgetActions, budgetReducer, initialState } from &quot;../reducers/budget-reducer&quot;
            
            type BudgetContextProps = {
                state:  BudgetState
                dispatch: Dispatch&lt;BudgetActions&gt;
            }
            type BudgetProviderProps = {
                children : ReactNode
            }
            
            export const BudgetContext = createContext&lt;BudgetContextProps&gt;(null!)
            
            export const BudgetProvider = ({children}: BudgetProviderProps) =&gt; {
            
                const[state, dispatch] = useReducer(budgetReducer, initialState)
              
                return(
                    &lt;BudgetContext.Provider
                        value={{
                            state,
                            dispatch
                        }}
                    &gt;
                        {children}
                    &lt;/BudgetContext.Provider&gt;
                )
            
            }
          </code></pre>
            
            
          <p><strong>Creemos nuestro custom hook que haga exactamente lo que acabamos de ver en el App.tsx del punto anterior.</strong></p>
          
          <p>Creamos <span class="file">hooks&gt;useBudget.ts</span> donde importamos el hook useContext y el context que queremos utilizar con él. A continuación creamos la variable useBudget que va a ser un arrow function y no vamos a retornar un objeto porque, como vemos en nuestro console.log anterior de App.tsx retorna el context completo (que tiene state y dispatch). Dentro del arrow function creamos la variable <span class="destacado">export const = useBudget () =&gt; {}</span> que es un arrow function en el que creamos la variable 'context' (que es la que habíamos creado antes en nuestra App.tsx) y en la que usamos el Hook de React useContext() para pasarle nuestro context personalizado. <strong>Mirar nuestro context en el 1er code de este desplegable para no perdernos</strong>:</p>
          
          <pre><code class="language-ts">
            //hooks&gt;useBudget.ts
            import { useContext } from "react"
            import { BudgetContext } from "../context/BudgetContext"
            
            export const useBudget = () => {
                const context = useContext(BudgetContext)
                return context
            }
          </code></pre>

          <p>Limpiamos así nuestro compo ppal App.tsx, para usar nuestro custom hook <strong>useBudget.tsx</strong>. Probamos a usar nuestro custom hook con este destructuring que extrae esos 2 objetos de nuestro context 'BudgetContext' (que es el que le estamos pasando al useContext() de mi custom hook) <code class="language-ts">const{ state, dispatch } = useBudget()</code>Vemos con el console.log(state) que nos muestra el budget: 0. Si abrimos nuestro reducer y en el initialState detras de budget:0 ponemos auth:true vemos en la consola que también nos lo muestra, porque <strong>va a estar conectado todo el tiempo con ese state y también podremos añadir más acciones, que se muestran/pueden usar por medio del dispatch</strong>:</p>
          <div class="flex max-sm:flex-col">
            <div class="w-[50%] max-sm:w-[100%]">
              <pre data-line="2,6,7"><code class="language-ts">
                //App.tsx
                import BudgetForm from './components/BudgetForm';
                import { useBudget } from './hooks/useBudget';    
                
                function App() {
                
                  const{ state, dispatch } = useBudget()
                  console.log(state)
                
                  return (
                    &lt;&gt;
                    &lt;header className=&quot;bg-blue-600 py-8 max-h-72&quot;&gt;
                      &lt;h1 className=&quot;uppercase text-center font-black text-4xl text-white&quot;&gt;Planificador de gastos&lt;/h1&gt;
                    &lt;/header&gt;
                
                    &lt;div className=&quot;max-w-3xl mx-auto bg-white shadow-lg rounded-lg mt-10 p-10&quot;&gt;
                      
                      &lt;BudgetForm /&gt;
                      
                    &lt;/div&gt;
                    &lt;/&gt;
                  )
                }
                
                export default App    
              </code></pre>
            </div>
            <div class="w-[50%] max-sm:w-[100%]">
              <img src="./src/assets/img/198-1.png" alt="img" loading="lazy">

              <pre data-line="4"><code class="language-ts">
                //budget-reducer.ts
                ...
                export const initialState: BudgetState = {
                  budget: 0,
                  auth: true
                }
                ...
              </code></pre>

              <img src="./src/assets/img/198-2.png" alt="img" loading="lazy">
            </div>
          </div>

          <p>Una buena práctica cuando creamos nuestros hooks y tienen un context es colocar un if que maneje la casuística de que no tengamos context lanzando un error con un mensjae en inglés a poder ser, que recuerde qué context(el que importamos <strong>BudgetContext</strong>) utiliza nuestra variable arrow function que lo maneja / o qué provider (<strong>BudgetProvider</strong>) --&gt; eso le dice a los usuarios: tienes que rodear tu app con este provider para poder hacer uso de mi custom hook. Y así es como se crean las librerías (los paquetes npm) que utilizan context API (si por ejemplo probamos en el main.tsx a quitar el tag del provider que envuelve el tag de nuestra app vemos que lanza ese error en consola). Así garantizas que el usuario haya tenido ese provider y entonces en ese provider comenzar a agregar los datos de la aplicación. <span class="destacado">Esta es su forma favorita de que todo esté controlado tener un reducer, un context y utilizar typescript.</span></p>

          <pre><code class="language-ts">
            //useBudget.ts
            import { useContext } from "react"
            import { BudgetContext } from "../context/BudgetContext"
            
            export const useBudget = () => {
                const context = useContext(BudgetContext)
                if(!context){
                    throw new Error('useBudget must be used within a BudgetContext')
                    //throw new Error('useBudget must be used within a BudgetProvider')
                }
                return context
            }
          </code></pre>

          <p>Dejemos bien limpio nuestro compo ppal App.tsx y a continuación usaremos nuestro custom hook <strong>useBudget.ts</strong> para definir nuestro presupuesto.</p>

          <pre><code class="language-ts">
            //App.tsx
            import BudgetForm from './components/BudgetForm';

            function App() {
            
              return (
                &lt;&gt;
                &lt;header className=&quot;bg-blue-600 py-8 max-h-72&quot;&gt;
                  &lt;h1 className=&quot;uppercase text-center font-black text-4xl text-white&quot;&gt;Planificador de gastos&lt;/h1&gt;
                &lt;/header&gt;
            
                &lt;div className=&quot;max-w-3xl mx-auto bg-white shadow-lg rounded-lg mt-10 p-10&quot;&gt;
                  
                  &lt;BudgetForm /&gt;
                  
                &lt;/div&gt;
                &lt;/&gt;
              )
            }
            
            export default App
            
          </code></pre>


          

        </div>


        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-199').toggle();">
          <h3>199. Llamando las acciones del reducer desde el Hook por medio del Context <span class="destacado">BudgetContext.tsx</span></h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-199" class="hidden">
          <p>Vamos a usar nuestro custom hook para definir nuestro presupuesto y escribir en nuestro reducer lo que el usuario ponga en el input. Hasta ahora ¿cómo lo hemos hecho? hemos estado usando nuestro reducer en el app.tsx, extraíamos state y dispatch, pasamos por ejemplo dispatch como prop al compo BudgetForm.tsx, lo agregamos a la firma de nuestro type... pero <span class="destacado">gracias a que ya tenemos configurado context API</span> no tenemos que hacerlo así. Vamos a usar nuestro custom hook <span class="file">useBudget.tsx</span> directamente en el componente. Y podemos tener múltiples instancias de ese custom hook, pero al final solo vamos a tener una instancia del state y de las funciones de tipo dispatch. Abrimos nuestro componente <span class="file">BudgetForm.tsx</span> y definimos un handleSubmit (recordar usar el IS para inferir el type del 'e', no tenemos que memorizar), ponemos un console.log() para ver que funciona y lo probamos. Es ahí donde vamos a usar el dispatch pero <strong>Ya no tenemos que hacerlo en el app.tsx ni usar useReducer, de aquí en adelante usamos nuestro hook useBudget.ts (donde tenemos habilitado context API y por tanto tenemos nuestro estado global) que lo importamos</strong>. Extraemos el dispatch de nuestro custom Hook con destructuring (<span class="destacado">ojo! llaves { } y no corchetes [ ]. useReducer nos retornaba state y dispatch ¡en un arreglo!. En este caso es un custom hook, tiene que ser con llaves porque retorna un objeto</span>) y directamente lo usamos en nuestro handleSubmit!!!</p>

          <pre data-line="1,6,8-12,15"><code class="language-ts">
            //BudgetForm.tsx
            import { useBudget } from "../hooks/useBudget"

            export default function BudgetForm() {

              const [budget, setBudget] = useState(0)
              const { dispatch } = useBudget() //ojo! llaves{} y no corchetes[]. useReducer nos retornaba state y dispatch ¡en un arreglo!. En este caso es un custom hook, tiene que ser con llaves
              ...
              const handleSubmit = (e:FormEvent<HTMLFormElement>) => {
                e.preventDefault();
                //console.log('Añadir o definir presupuesto')
                dispatch({type: 'add-budget', payload: {budget}})
              }   

              return (
                &lt;form className=&quot;space-y-5&quot; onSubmit={handleSubmit}&gt;
                ...
          </code></pre>

          <p>Si probamos, en RDT en componentes y pulsamos en BudgetProvider, vemos que el budget es 0 (es como tenemos definido el initialState en nuestro budget-reducer.ts) pero si ahora ponemos una cantidad en el formulario y le damos al botón "Definir presupuesto" vemos que estamos escribiendo en nuestro state de presupuesto. Entonces como vemos va a ser una gran ventaja haber incorporado context API para tener un estado global en nuestras apps. Sí fue bastante código pero <span class="destacado">recapitulemos</span>:</p>

          <ul class="list-disc my-2.5">
            <li>hemos definido este context: <span class="file">BudgetContext.tsx</span> en el cual creamos el context <strong>BudgetContext</strong> usando la función de React createContext() y también nuestro provider <strong>BudgetProvider</strong>. Para decirle que este provider va a tener state y dispatch creamos el type BudgetContextProps. La forma en que utilizamos o conectamos el context con este provider es con el return &lt;BudgetContext.Provider&gt;&lt;/BudgetContext.Provider&gt; </li>
            <li>Como estamos utilizando useReducer nos da acceso a BudgetReducer y vamos a poder definir y mandar llamar las acciones, como acabamos de hacer en nuestro componente BudgetForm.tsx utilizando dispatch</li>
            <li>La forma en que conectamos nuestro archivo de context BudgetContext.tsx creado a parte con nuestra aplicación, es en nuestro archivo <span class="file">main.tsx</span> en donde "envolvemos" nuestra aplicación con nuestro provider
              <pre><code class="language-ts">
                //main.tsx
                &lt;BudgetProvider&gt;
                  &lt;App /&gt;
                &lt;/BudgetProvider&gt;
              </code></pre>
            </li>
            <li>Para no estar escribiendo useContext() pasándole el context, hemos creado un custom Hook llamado <span class="file">useBudget.ts</span> donde importamos useContext() y el context en cuestión (BudgetContext), lo montamos, nos aseguramos de que tengamos un provider (si no lanzamos el error) y lo vamos a utilizar directamente en nuestros componentes, como hemos hecho en <span class="file">BudgetForm.tsx</span> importándolo <code class="language-ts">import { useBudget } from "../hooks/useBudget"</code> lo cual me da acceso a todas las funciones que tenga ese provider (en nuestro último ejemplo fue dispatch) tal cual se define en el prop value del tag del provider que escribimos en el return del correspondiente fichero.</li>
          </ul>

          <p>Este context ya no va a tener nada más de código, vamos a estar escribiendo todo lo demás en el reducer. Este es un Boilerplate que va a estar prácticamente en todos los proyectos así que guardemos el código, no hace falta memorizarlo, y cuando vayamos a usarlo lo copiamos, pegamos y lo vamos adaptando. En base a esa repetición e ir creando nuestros proyectos todo esto se irá haciendo má sencillo.</p>

          <pre><code class="language-ts">
            //BudgetContext.tsx
            import { useReducer, createContext, Dispatch, ReactNode } from &#39;react&#39;;
            import { BudgetState, BudgetActions, budgetReducer, initialState } from &quot;../reducers/budget-reducer&quot;
            
            type BudgetContextProps = {
                state:  BudgetState
                dispatch: Dispatch&lt;BudgetActions&gt;
            }
            type BudgetProviderProps = {
                children : ReactNode
            }
            
            export const BudgetContext = createContext&lt;BudgetContextProps&gt;(null!)
            
            export const BudgetProvider = ({children}: BudgetProviderProps) =&gt; {
            
                const[state, dispatch] = useReducer(budgetReducer, initialState)
              
                return(
                    &lt;BudgetContext.Provider
                        value={{
                            state,
                            dispatch
                        }}
                    &gt;
                        {children}
                    &lt;/BudgetContext.Provider&gt;
                )
            
            }
          </code></pre>


        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-200').toggle();">
          <h3>200. Mostrando de forma condicional un componente si el presupuesto es válido</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-200" class="hidden">
          <p>Una vez que defino un presupuesto ya quiero ocultar este componente BudgetForm.tsx y comenzar a mostrar otros. Para continuar trabajando en esa dirección, tenemos que:</p>

          <ul class="list-disc my-2.5">
            <li><strong>Creamos un nuevo componente</strong> <span class="file">components&gt;BudgetTracker.tsx</span> que nos servirá para mostrar qué cantidad hemos definido como presupuesto, cuanto hemos gastado y cuanto nos queda.</li>
            <li><strong>Leemos el state de nuestro context</strong>. Vamos a nuestro compo ppal <span class="file">App.tsx</span> donde vamos a importar nuestro custom hook y leer nuestro state. Ponemos un console.log(state.budget) y si recargamos y definimos un nuevo presupuesto vemos que aparece en la consola ese presupuesto.</li>
            <li><strong>Escribimos algo para validar ese presupuesto</strong>. Importamos useMemo() y, pasándole como dependencia el valor de state.budget vamos a comprobar si state.budget>0 (que es su valor inicial) y de esa forma comprobaremos si ya ha sido modificado por el usuario <code class="language-ts">const isValidObject = useMemo(()=> state.budget>0, [state.budget])</code>. Y a continuación en la parte del return de nuestro App.tsx donde simplemente escribíamos el tag del compo BudgetForm.tsx, vamos a completarlo utilizando nuestra nueva función para validar si ya tenemos presupuesto válido o no ¿no? renderiza el compo BudgetForm.tsx ¿si? renderiza nuestro nuevo compo BudgetTracker.tsx <code class="language-ts"> {isValidObject? &lt;BudgetTracker /&gt; : &lt;BudgetForm /&gt;}</code></li>    
          </ul>
            

          <pre data-line="1,2,4,7,19"><code class="language-ts">
            //App.tsx
            import { useMemo } from 'react';
            import { useBudget } from './hooks/useBudget';
            import BudgetForm from './components/BudgetForm';
            import BudgetTracker from './components/BudgetTracker';
            
            function App() {
              const {state} = useBudget()
              const isValidObject = useMemo(()=> state.budget>0, [state.budget])
            
              return (
                &lt;&gt;
                &lt;header className=&quot;bg-blue-600 py-8 max-h-72&quot;&gt;
                  &lt;h1 className=&quot;uppercase text-center font-black text-4xl text-white&quot;&gt;
                    Planificador de gastos
                  &lt;/h1&gt;
                &lt;/header&gt;
            
                &lt;div className=&quot;max-w-3xl mx-auto bg-white shadow-lg rounded-lg mt-10 p-10&quot;&gt;      
                  {isValidObject? &lt;BudgetTracker /&gt; : &lt;BudgetForm /&gt;}    
                &lt;/div&gt;
                &lt;/&gt;
              )
            }
            
            export default App
          </code></pre>

          

        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-201').toggle();">
          <h3>201. Creando el Componente con las cantidades y la gráfica</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-201" class="hidden">

          <p>Trabajamos con nuestro nuevo componente <span class="file">BudgetTracker.tsx</span>:</p>
          <ul class="list-disc my-2.5">
            <li>Añadimos clases de tailwindcss, el gráfico estático que tenemos en public (más adelante lo haremos dinámico), el botón de reset</li>
            <li>Creamos un compo nuevo para las cantidades: <span class="file">AmountDisplay.tsx</span> y lo renderizamos 3 veces en nuestro compo BudgetTracker.tsx con sus correspondientes props de label y amount. <strong>Esas props las extraemos con destructuring y tipamos con su type de props en ese compo nuevo específico para cantidades AmountDisplay.tsx.</strong> Como queremos formatearlo como dinero creamos <span class="file">helpers&gt;index.ts</span>
            <pre data-line="0"><code class="language-ts">
              //helpers&gt;index.ts
              export function formatCurrency(amount: number){
                return new Intl.NumberFormat('es-ES', { style: 'currency', currency: 'EUR' }).format(amount)
            }
            </code></pre>    

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <img class="mx-auto" src="./src/assets/img/201.png" alt="img" loading="lazy">
                <pre data-line="2-5,7"><code class="language-js">
                  //AmountDisplay.tsx
                  import { formatCurrency } from "../helpers"
                  type AmountDisplayProps = {
                      label: string
                      amount: number
                  }
                  
                  export default function AmountDisplay({label, amount} : AmountDisplayProps) {
                    return (
                      &lt;p className=&quot;text-2xl text-blue-600 font-bold&quot;&gt;
                          {label}: {&#39;&#39;}
                          &lt;span className=&quot;text-black&quot;&gt;{formatCurrency(amount)}&lt;/span&gt;
                      &lt;/p&gt;
                    )
                  }
                </code></pre>                
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="17,18,21,22,25,26"><code class="language-js">
                  //BudgetTracker.tsx
                  import AmountDisplay from './AmountDisplay';
                  export default function BudgetTracker() {
                    return (
                      &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-5&quot;&gt;
                          &lt;div className=&quot;flex justify-center&quot;&gt;
                              &lt;img src=&quot;./grafico.jpg&quot; alt=&quot;Gráfica de gastos&quot; /&gt;
                          &lt;/div&gt;
                  
                          &lt;div className=&quot;flex flex-col justify-center items-center gap-8&quot;&gt;
                              &lt;button
                                  type=&quot;button&quot;
                                  className=&#39;bg-pink-600 w-full p-2 text-white uppercase font-bold rounded-lg&#39;&gt;
                                      Resetear App
                              &lt;/button&gt;
                  
                              &lt;AmountDisplay
                                  label=&quot;Presupuesto&quot;
                                  amount={300}
                              /&gt;
                              &lt;AmountDisplay
                                  label=&quot;Disponible&quot;
                                  amount={200}
                              /&gt;
                              &lt;AmountDisplay
                                  label=&quot;Presupuesto&quot;
                                  amount={100}
                              /&gt;
                          &lt;/div&gt;
                      
                      &lt;/div&gt;
                    )
                  }
                </code></pre>
              </div>              
            </div>

        </li>
        </ul>

          <p>Hasta aquí la parte superior de nuestro compo ppal App.tsx. Vamos a añadirle un div nuevo que va a tener una ventana modal en la cual vamos a poder mostrar el formulario para registrar gastos.</p>

        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-202').toggle();">
          <h3>202. Instalando Headless UI para tener una ventana modal - <a class="text-white underline" href="https://gist.github.com/codigoconjuan/92e8a52abc8bd9ea5b81e5ad664d8ef0" target="blank">ExpenseModal.tsx</a></h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-202" class="hidden">
          <p>Vamos a crear una ventan modal para mostrar el formulario con el que vamos a agregar los gastos.</p>

          <ul class="list-disc my-2.5">
            <li>Creamos nuevo componente <span class="file">ExpenseModal.tsx</span> y su contenido va a ser lo que copiemos del link del gist que tenemos en este apartado.</li>
            <li>Tenemos que instalar @heroicons <span class="destacado">npm install @heroicons/react</span> y @headlessui <span class="destacado">npm install @headlessui/react</span> para que funcionen las importaciones correspondientes de lo que acabamos de copiar.</li>
            <li>En nuestro <span class="file">App.tsx</span> tras el segundo div renderizamos nuestra modal con el tag correspondiente a este nuevo componente <code class="language-ts">&lt;ExpenseModal/&gt;</code> y veremos que nos aparece este signo de '+' en la parte inferior de nuestra interfaz:
            <img src="./src/assets/img/202.png" alt="img" loading="lazy">
            y al pulsarlo debe mostrar el modal (cambiando a true el false que hay en la línea 16 del código del componente modal: <code class="language-ts">&lt;Transition appear show={false} as={Fragment}&gt;&lt;/Transition&gt;</code>), lo haremos con un dispatch, pero si lo cambiamos un momento a mano veremos que se muestra correctamente el modal.
            </li>
            <li>Creamos un tag main <code class="language-ts">&lt;main&gt;&lt;/main&gt;</code> y movemos dentro el tag <code class="language-ts">&lt;ExpenseModal/&gt;</code>. (el modal está flotado, es decir no le van a afectar las clases de estilo del main, pero en él vamos a tener los gastos y el filtrado por categorías) </li>
            <li>Si ahora mismo recargamos la pantalla vemos que ese '+' aparece cuando todavía no hemos definido el presupuesto así que vamos a controlar que eso no pase (es decir que solo aparezca el + una vez hayamos introducido un presupuesto) usando nuestro <code class="language-ts">const isValidObject = useMemo(()=> state.budget>0, [state.budget])</code> y lo utilizamos con && (es como un ternario pero solo se evalúa la condición del true):
            <pre><code class="language-ts">
              {isValidObject &amp;&amp; (
                &lt;main className=&#39;max-w-3xl mx-auto py-10&#39;&gt;
                  
                  &lt;ExpenseModal/&gt;
                &lt;/main&gt;
              )}
            </code></pre>
            </li>
            <li>El siguiente paso va a ser el dispatch para mostrar y ocultar el modal</li>
          </ul>
        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-204').toggle();">
          <h3>203. Mostrando el Modal cuando agregamos un nuevo gasto / 204. Agregando una acción para cerrar el modal</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-204" class="hidden">
          <p class="naranja">Mostrando el Modal cuando agregamos un nuevo gasto</p>

          <p>Vamos a nuestro reducer <span class="file">budget-reducer.ts</span>, que es donde estamos manejando todo el código de nuestro state. Vamos a añadir una acción nueva 'show-modal' que no toma ningún payload porque solo cambia de false a true.</p>

          <pre data-line="3,7,12,26-31"><code class="language-ts">
            //budget-reducer.ts
            export type BudgetActions = 
            { type: 'add-budget', payload: {budget: number} } |
            { type: 'show-modal' } 

            export type BudgetState = {
                budget: number
                modal: boolean
            }

            export const initialState: BudgetState = {
                budget: 0,
                modal: false
            }

            export const budgetReducer = (
                    state: BudgetState=initialState,
                    action: BudgetActions
                ) =&gt;{

                if(action.type === &quot;add-budget&quot;){
                    return{
                        ...state,
                        budget: action.payload.budget
                    }
                }
                if(action.type === &quot;show-modal&quot;){
                    return{
                        ...state,
                        modal: true
                    }
                }

                return state
            }
          </code></pre>

          <p>Vamos a nuestro compo <span class="file">ExpanseModal.tsx</span> y, <strong>recordando que todo nuestro state se maneja por medio del custom Hook:</strong></p>

          <ul class="list-disc my-2.5">
            <li><strong>Importamos nuestro custom Hook</strong><svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
            </svg> <code class="language-ts">import { useBudget } from '../hooks/useBudget'</code></li>
            <li><strong>Extraemos state y dispatch</strong> <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
            </svg> <code class="language-ts">const { state, dispatch } = useBudget()</code>.<br>
              <span class="destacado">state</span> porque el modal se muestra en base al <code class="language-ts">show="{false}"</code> y queremos ya comenzar a controlarlo y hacerlo dinámico<br>
              <span class="destacado">dispatch</span> porque, es el botón '+' que está en la parte superior el que controla que se muestre:
              <div class="flex max-sm:flex-col">
                <div class="w-[40%] max-sm:w-[100%]">
                  <pre class="rojo" data-line="1-3,7"><code class="language-js">
                    //ExpanseModal.tsx               
                    &lt;button
                      type=&quot;button&quot;
                    &gt;
                      &lt;PlusCircleIcon className=&#39;w-16 h-16 text-blue-600 rounded-full&#39; /&gt;
                    &lt;/button&gt;    
                    ...
                    &lt;Transition appear show={false} as={Fragment}&gt;&lt;/Transition&gt;
                  </code></pre>
                </div>
                <div class="w-[60%] max-sm:w-[100%]">
                  <pre class="verde" data-line="3,8"><code class="language-js">
                    //ExpanseModal.tsx
                    &lt;button
                      type=&quot;button&quot;
                      onClick={() =&gt; dispatch({type:&#39;show-modal&#39;})}
                    &gt;
                      &lt;PlusCircleIcon className=&#39;w-16 h-16 text-blue-600 rounded-full&#39; /&gt;
                    &lt;/button&gt;  
                    ...
                    &lt;Transition appear show={state.modal} as={Fragment}&gt;&lt;/Transition&gt; 
                  </code></pre>
                </div>
              </div>
            
            </li>
          </ul>

          <p class="naranja">Agregando una acción para cerrar el modal</p>
          <p>Si vemos el código del compo modal, vemos que aquí es donde se gestiona cerrarlo: <code class="language-ts">&lt;Dialog as=&quot;div&quot; className=&quot;relative z-10&quot; onClose={() =&gt; {}}&gt;</code></p>

          <ul class="list-disc my-2.5">
            <li>Añadimos una acción nueva 'close-modal' en nuestro reducer. No toma ningún payload porque solo cambia de true a false y añadimos el correspondiente:
              <pre data-line="4,6-11"><code class="language-js">
                //budget-reducer.ts
                export type BudgetActions = 
                { type: 'add-budget', payload: {budget: number} } |
                { type: 'show-modal' } |
                { type: 'close-modal' } 
                ...
                if(action.type === "close-modal"){
                  return{
                      ...state,
                      modal: false
                  }
                }
              </code></pre>
            </li>
            <li>Vamos a nuestro compo modal ExpenseModal.tsx y hacemos la modificación necesaria en la línea que controla el cerrado del modal:
              <div class="flex max-sm:flex-col">
                <div class="w-[40%] max-sm:w-[100%]">
                  <pre class="rojo" data-line="1"><code class="language-js">
                    //ExpenseModal.tsx
                    &lt;Dialog as=&quot;div&quot; className=&quot;relative z-10&quot; onClose={() =&gt; {}}&gt;           
                  </code></pre>
                </div>
                <div class="w-[60%] max-sm:w-[100%]">
                  <pre class="verde" data-line="1"><code class="language-js">
                    //ExpenseModal.tsx
                    &lt;Dialog as=&quot;div&quot; className=&quot;relative z-10&quot; onClose={() =&gt; dispatch({type : &#39;close-modal&#39;})}&gt;
                  </code></pre>
                </div>
              </div>
            </li>
            <li>Vamos a crear un componente nuevo <span class="file">ExpenseForm.tsx</span> que va a tener el formulario para registrar gastos. Lo vamos a llamar desde el componente modal, justo entre los tags <code class="language-ts">&lt;Dialog.Panel&gt;...&lt;/Dialog.Panel&gt;</code>:
              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre data-line="3"><code class="language-js">
                    //ExpenseModal.tsx
                    ..
                    &lt;Dialog.Panel className=&quot;w-full max-w-3xl transform overflow-hidden rounded-2xl bg-white p-6 text-left align-middle shadow-xl transition-all&quot;&gt;
                      &lt;ExpenseForm /&gt;
                    &lt;/Dialog.Panel&gt;
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%] ml-2">
                  <img src="./src/assets/img/204.png" alt="img" loading="lazy">
                </div>
              </div>    
              En él vamos a tener un formulario un poco más complejo con categoría a la que pertenece un gasto, la cantidad, la fecha en la que se hizo y le nombre del gasto.
            </li>
          </ul>


        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-205').toggle();">
          <h3>205. Creando el Formulario de Gastos - <a class="underline text-white" href="https://gist.github.com/codigoconjuan/75ba8738a387410b9fff81d96ffbc67d" target="_blank">Categorias para Admin de Gastos</a> / 206. Agregando un calendario definir la fecha de gasto</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-205" class="hidden">
          <p>Comenzamos a trabajar con el formulario que sirve de entrada para procesar cada uno de los de gastos <span class="file">ExpenseForm-tsx</span>.</p>
          <ul class="list-disc my-3">
            <li>Nombre gasto. El name del input lo ponemos para poder escribir en el state. La función que modifica state y value la vemos un poco más adelante.</li>
            <li>Cantidad</li>
            <li>Creamos <span class="file">data&gt;categories.ts</span> Categorías que cogemos del gist <a class="underline text-black" href="https://gist.github.com/codigoconjuan/75ba8738a387410b9fff81d96ffbc67d" target="_blank">Categorias para Admin de Gastos</a> que es un arreglo que tiene objetos con id, nombre e icono.</li>
            <li>También vamos a tener cuándo se realiza ese gasto, pero eso va a ser una dependencia para que sera más sencillo.</li>
            <li>boton de submit</li>
            <li>Tenemos que definir el state y conectarlo pero antes hagamos la dependencia para seleccionar de un date picker</li>
          </ul>

          <p class="naranja">Agregando calendario para definir la fecha de gasto - <a class="underline text-black" href="https://www.npmjs.com/" target="_blank">https://www.npmjs.com/</a></p>

          <p>Buscamos react-date-picker y elegimos este que vemos que soporta TS <a class="underline" href="https://www.npmjs.com/package/react-date-picker" target="_blank">https://www.npmjs.com/package/react-date-picker</a>. En esa misma página hay instrucciones sobre cómo utilizarlo. Instalamos con <span class="destacado">npm install react-date-picker</span>. Vamos a ExpenseForm.tsx e importamos DatePicker, las dos hojas de estilo. A continuación creamos los 2 types que están en la documentación de la dependencia (<strong>estos mejor, los llevamos al fichero de types que vamos a crear, ver siguiente punto</strong>) y con esto ya podemos comenzar a utilizarlo, marcar una fecha, la cual aparecerá ahí una vez empecemos a escribir en el state:</p>
          <pre><code class="language-ts">
            //ExpenseForm.tsx
            import DatePicker from 'react-date-picker'
            import 'react-date-picker/dist/DatePicker.css';
            import 'react-calendar/dist/Calendar.css';
            type ValuePiece = Date | null
            type Value = ValuePiece | [ValuePiece, ValuePiece]
          </code></pre>

          <p>Si vemos en la app ya nos aparece este calendario personlizado (que podríamos haber usado un input type="date" pero quería mostrarnos como hacerlo con una dependencia).</p>

          <img src="./src/assets/img/206.png" alt="img" loading="lazy">

        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-207').toggle();">
          <h3>207. Definiendo el Type para los gastos y definir el state</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-207" class="hidden">
          <p>Vamos a ver una forma un poco más avanzada de escribir en el state porque como vemos en nuestro formulario de gasto tenemos nombre de gasto, cantidad que es de tipo número, categoría y la fecha que es de tipo date.</p>

          <p><span class="destacado">Creamos un fichero para types</span>: <span class="file">types/index.ts</span> (en este punto vuelve a recordar que se puede usar interfaces en lugar de types pero que es preferencia personal porque es más sencillo)</p>

          <ul class="list-disc my-3">
            <li class="my-2"><strong>Creamos type para gasto una vez que se almacena (por tanto tiene id):</strong> <code class="language-ts">export type Expense = {}</code> que va a tener un id: string (vemos que nuestro formulario no lo tiene): vamos a hacer un enfoque un poco diferente, <strong>en el proyecto anterior generábamos el id cuando cargaba el componente, en este proyecto generamos id cuando se guarde este gasto</strong>. el date va a ser la fecha que tenemos de la dependencia instalada 'react-calendar', de hecho si nos fijamos en el 'cómo se usa' de su url <a class="underline mx-auto" href="https://www.npmjs.com/package/react-date-picker" target="_blank">https://www.npmjs.com/package/react-date-picker</a> vemos que definen el type 'value' y al crear una fecha le ponen con un generic el type: <code class="language-ts">&lt;value&gt;</code>. Con lo cual, el código de 'tipado' de esta dependencia mejor nos lo llevamos a nuestro fichero de type que tenerlo en el compo del form de gasto ExpenseForm.tsx (<strong>hemos de ponerle, eso sí, un export al type value</strong>)
              <img class="mx-auto" src="./src/assets/img/207.png" alt="img" loading="lazy">
            </li>
            <li class="my-2"><strong>Creamos type para gasto temporal (que no va a tener id)</strong> y salvo el id va a ser igual por lo que utilizamos un utility type llamado Omit: <code class="language-ts">export type DraftExpense = Omit&lt;Expense, &#39;id&#39;&gt;</code></li>
            <li class="my-2"><strong>Creamos type para las categorías</strong>, podemos inferir lo que contiene abriendo nuestros datos <span class="file">data/categories</span> y mirando el IS:
              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%] mr-2">
                  <img class="mx-auto" src="./src/assets/img/207-2.png" alt="img" loading="lazy">
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre data-line="1,3"><code class="language-ts">
                    //data/categories.ts
                    import type { Category } from "../types";
              
                    export const categories: Category[] = [
                    ...
                  </code></pre>
                </div>
              </div> 
              
              <pre><code class="language-js">
                //types/index.ts   
                export type Expense = {
                    id: string
                    expenseName: string
                    amount: number
                    category: string
                    date: Value
                }
                export type DraftExpense = Omit&lt;Expense, &#39;id&#39;&gt;

                type ValuePiece = Date | null;
                export type Value = ValuePiece | [ValuePiece, ValuePiece];

                export type Category = {
                  id: string
                  name: string
                  icon: string
                }
              </code></pre>
            </li>
          </ul>
        
          
          <p><span class="destacado">Definimos nuestro state local 'expense' con useState()</span> en ExpenseForm.tsx (vamos a manejar un estado local, no se requiere en el reducer por tanto lo voy a hacer en este archivo) para lo que <strong>importamos useState y también el type DraftExpense</strong> que acabamos de crear para tipar con un generic el estado que vamos a crear.</p>

          <pre data-line="1,2,6,11"><code class="language-css">
            //ExpenseForm.tsx
            import { useState } from "react";
            import type { DraftExpense } from "../types";
            ...
            export default function ExpenseForm() {

              const [expense, setExpense] = useState&lt;DraftExpense&gt;({
                amount: 0,
                expenseName: '',
                category: '',
                date: new Date()
              })
              ...
          </code></pre>

          <p><span class="destacado">Vamos a comenzar a asignar cada elemento del state expense ya en su correspondiente campo de formulario:</span>

            <pre><code class="language-js">
              //Input Nombre gasto    
                --&gt; value={expense.expenseName}
              //Input Cantidad        
                --&gt; value={expense.amount}
              //Select de Categoría   
                --&gt; value={expense.category}
              //Dependencia DatePicker 
                &lt;DatePicker
                  className=&quot;bg-slate-100 p-2 border-0&quot;
                  value={expense.date}
                /&gt;
            </code></pre>
            
            <p>Eso nos va a permitir conectar ese state con cada uno de los campos, sin embargo si buscamos el componente ExpenseForm en nuestra pestaña componentes de RWTD (Headless UI agrega un montón de componentes) vemos que si escribimos algo en Nombre de Gasto, no se está guardando en nuestro state, porque <strong>tenemos que utilizar un onChange</strong>. Va a ser un onChange un poco diferente/complejo porque tanto nombre de gasto como categorías son strings, la cantidad es un number y fecha gasto es un type value... por lo que vamos a tener dos funciones diferentes para poder escribir en el state</p>

        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-208').toggle();">
          <h3>208. Escribiendo el gasto en el State <span class="destacado">2 funciones handle, e.target-conexión name-destructuring</span></h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-208" class="hidden">

          <p>Nuestro state local para este formulario de gastos:</p>
          <pre><code class="language-js">
            //ExpenseForm.ts
              const [expense, setExpense] = useState&lt;DraftExpense&gt;({
                amount: 0,
                expenseName: '',
                category: '',
                date: new Date()
              })
          </code></pre>
          <p>Si vemos en la pestaña componentes de RDT y buscamos el ExpenseForm, vemos en el state que amount aparece un 0 en azul (string), hemos de conservar esa cantidad amount como número así que vamos a escribir un código para convertirlo a número. Nombre y categoría son strings, están bien y la fecha es una librería, una dependencia que hemos instalado, que si recordamos el type, los creadores de la librería definieron como Value (ya importado en nuestro fichero de types/index.ts). <strong>Entonces no podemos gestionarlo todo con la misma función por la disparidad de tipos, creamos dos funciones handleChange:</strong></p>
          <ul class="list-disc my-3">
            <li class="my-2"><strong>Función <code class="language-ts">const handleChangeDate = () => {}</code> para el campo fecha:</strong> cuando seleccionamos una fecha en el picker, la fecha nueva, el value, se pasa en automático así que le pasamos como parámetro value (del tipo Value que es el que definieron los de la librería y nosotros incluímos en nuestro fichero de types, así que lo importamos). Si hacemos un console.log(value) vemos que nos saca en consola la fecha que seleccionamos cada vez en el picker. Seteamos el state haciendo copia del mismo y estableciendo a continuación que el valor de date es el value (la fecha que acabamos de seleccionar del picker):
            <pre data-line="14"><code class="language-js">
              //ExpenseForm.tsx
              import type { DraftExpense, Value } from "../types";
              ...
              const handleChangeDate = (value:Value) =>{
                //console.log(value)
                setExpense({
                  ...expense,
                  date: value
                })
              }
              ... //En el onChange del campo fecha la llamamos:
              &lt;DatePicker
                className=&quot;bg-slate-100 p-2 border-0&quot;
                //value={expense.date}
                onChange={handleChangeDate}
              /&gt;
            </code></pre>
            </li>
            <li class="my-2"><strong>Función <code class="language-ts">const handleChange = () => {}</code> para los campos gasto, cantidad y categoría:</strong> escribimos código para, identificar si estamos escribiendo en amount y si es así comnvertirlo a número (+value ó Number[value]).
            <pre data-line="11"><code class="language-js">
              //ExpenseForm.tsx
              const handleChange = (e: ChangeEvent&lt;HTMLInputElement&gt; | ChangeEvent&lt;HTMLSelectElement&gt;) => {
                const { name, value } = e.target //extraemos name y value de cada campo de formulario
                const isAmountField = ['amount'].includes(name) //true si estamos escribiendo en amount y false si escribimos en gasto o seleccionamos categoría
                //console.log(isAmountField)
                setExpense({
                  ...expense,
                  [name] : isAmountField ? +value : value
                })
              }
              ... // en el onChange de los campos Nombre gasto, cantidad y categoría la llamamos:
              onChange={handleChange}
            </code></pre>
            </li>
          </ul>

          <p>Así ya estamos escribiendo en nuestro state y conservando los tipos de datos que hemos definido en el type de DrafExpense (una copia temporal que no tiene un id aún). Vamos a continuación a trabajar con el form. Una vez que presionemos el submit, necesitamos que todos los campos tenga algo relleno/seleccionado, veamos una forma de validarlo y, en vez de deshabilitar el input mostraremos una alerta.</p>.
        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-209').toggle();">
          <h3>209. Mostrando una alerta si la validación falla en el formulario <span class="destacado">error: compo, state y tag</span></h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-209" class="hidden">
          <p><strong>Función <code class="language-ts">const handleSubmit = () => {}</code> para trabajar con el submit del formulario.</strong><br>
            (Recordar, para sacar el type del parámetro 'e' que le pasamos a esta función, poner en el onSubmit del form: <code class="language-ts">onSubmit={e=>}</code> para que VSC lo infiera y lo podamos copiar del IS.</p>

          <p><span class="destacado">Para validar utilizamos Object.values(), método para objetos que lo que hace es convertir un objeto a arreglo</span> De momento  probamos con estos 2 console.log siguientes. Si probamos a enviar el formulario sin rellenar tal cual, veríamos que en la consola el console.log de error y a continuación el de 'todo bien' porque entra en el if pero al no haber nada que lo detenga, el código se seguiría ejecutando así que pongamos un return para que esto no pase:</p>

          <div class="flex max-sm:flex-col">
            <div class="w-[50%] max-sm:w-[100%]">
              <pre data-line="8,13"><code class="language-ts">
                //ExpenseForm.ts
                ...
                const handleSubmit = (e: FormEvent&lt;HTMLFormElement&gt;) => {
                  e.preventDefault()
              
                  //validar
                  if(Object.values(expense).includes('')){
                    console.log('error...')
                    return
                  }
                  console.log('todo bien')  
                }
              
                return (
                  &lt;form className=&quot;space-y-5&quot; onSubmit={handleSubmit}&gt;
                  ...
              </code></pre>
            </div>
            <div class="w-[50%] max-sm:w-[100%]">   
              <img src="./src/assets/img/209-1.png" alt="img" loading="lazy">
            </div>
          </div>

          <p>Creamos un state local para error que iniciamos como string vacío: <code class="language-ts">const [error, setError] = useState('')</code> y creamos un componente nuevo para error llamado <span class="file">ErrorMessage.tsx</span>. Vamos a hacer que pueda recibir errores de forma dinámica (de antemano no sabemos el mensaje que vamos a enviarle) usando como parámetro {children} (recordar su uso en el context y también su tipado: podríamos tiparlo de cualquiera de estas dos maneras: <strong>ReactNode</strong> nos va a permitir renderizar componentes dentro de otros componentes o <strong>PropsWithChildren</strong>). Usamos todo esto para, si nuestro state de error cambia (lo hemos inicializado como string vacío) entonces pintamos el componente de error con lo que tenga mi state: <code class="language-ts">{error &amp;&amp; &lt;ErrorMessage&gt;{error}&lt;/ErrorMessage&gt;}</code></p>

          <div class="flex max-sm:flex-col">
            <div class="w-[50%] max-sm:w-[100%]">
              <pre><code class="language-js">
                //ErrorMessage.tsx
                import { ReactNode } from "react"

                type ErrorMessageProps = {
                    children: ReactNode
                }
                export default function ErrorMessage({children} : ErrorMessageProps) {
                  return (
                    &lt;p className=&quot;bg-red-600 p-2 text-white font-bold text-sm text-center&quot;&gt;
                        {children}
                    &lt;/p&gt;
                  )
                }
              </code></pre>
            </div>
            <div class="w-[50%] max-sm:w-[100%]">
              <pre><code class="language-js">
                ////ErrorMessage.tsx
                import { PropsWithChildren } from &quot;react&quot;

                export default function ErrorMessage({children} : PropsWithChildren) {
                  return (
                    &lt;p className=&quot;bg-red-600 p-2 text-white font-bold text-sm text-center&quot;&gt;
                        {children}
                    &lt;/p&gt;
                  )
                }        
              </code></pre>
            </div>
          </div>

          <p>A continuación vemos un resumen de todo lo que entra en juego:</p>

          <ul class="list-disc my-3">
            <li class="my-1.25">El compo nuevo para error.</li>
            <li class="my-1.25">El state para error que inicializamos con string vacío.</li>
            <li class="my-1.25">La función que maneja el submit conteniendo la validación:
              <ul class="list-disc my-3">
                <li class="my-1.25">si no pasa la validación se setea el error en cuestión.</li>
                <li class="my-1.25">si pasa la validación aplicaremos un dispatch para comenzar a setear los gastos</li>
              </ul>
              </li>
            <li class="my-1.25">La llamada a la función en el submit del formulario.</li>
            <li class="my-1.25">La renderización del componente error con el contenido el state error en caso de que haya cambiado dicho state</li>
          </ul>

          <pre data-line="1,3,5,12,15,20"><code class="language-js">
            //ExpenseForm.tsx
            import ErrorMessage from "./ErrorMessage";
            ...
            const [error, setError] = useState('')
            ...
            const handleSubmit = (e: FormEvent&lt;HTMLFormElement&gt;) =&gt; {
              e.preventDefault()  
              //validar
              if(Object.values(expense).includes(&#39;&#39;)){
                setError(&#39;Todos los campos son obligatorios&#39;)
              }
              console.log(&#39;todo bien&#39;)  //
            }
          
            return (
              &lt;form className=&quot;space-y-5&quot; onSubmit={handleSubmit}&gt;
                &lt;legend
                  className=&quot;uppercase text-center text-2xl font-black border-b-4 border-blue-500 py-2&quot;
                &gt;Nuevo gasto&lt;/legend&gt;
          
                {error &amp;&amp; &lt;ErrorMessage&gt;{error}&lt;/ErrorMessage&gt;}
          
          </code></pre>
        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-210').toggle();">
          <h3>210. Definiendo la acción para nuevos gastos</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-210" class="hidden">
          <p>Veamos como agregar la acción que va a agregar los nuevos gastos. Vamos a nuestro budget-reducer.ts y agregamos la acción: <code class="language-ts">{ type: 'add-expense', payload: {expense: DraftExpense} } </code> de tipo DraftExpense porque no va a tener id, el id lo vamos a generar en el reducer. Veamos nuestros cambios en el budget-reducer.ts</p>

          <pre data-line="1,7,12,18,26-32"><code class="language-ts">
            //budget-reducer.ts
            import { DraftExpense, Expense } from "../types"

            export type BudgetActions = 
                { type: 'add-budget', payload: {budget: number} } |
                { type: 'show-modal' } |
                { type: 'close-modal' } |
                { type: 'add-expense', payload: {expense: DraftExpense} } 
            
            export type BudgetState = {
                budget: number
                modal: boolean
                expenses: Expense[]
            }
            
            export const initialState: BudgetState = {
                budget: 0,
                modal: false,
                expenses: []
            }
            
            export const budgetReducer = (
                    state: BudgetState=initialState,
                    action: BudgetActions
                ) =>{
                ...
                if(action.type === "add-expense"){

                  return{
                      ...state,
                      expenses: [...state.expenses, action.payload.expense]
                  }
                }
          
              return state
          }
          </code></pre>

          <p>Ya tenemos todo esto en un state global, ya no necesitamos pasarlo via props. Nos vamos al ExpenseForm.ts:</p>

          <ul class="list-disc my-3">
            <li class="my-1.25">Importamos useBudget y lo instanciamos después del state de error, extrayendo el dispatch. En nuestro handleSubmit cuando pasa la validación llamamos al dispatch en concreto a la acción que acabamos de crear para añadir gasto de tipo 'add-expense' y en el payload pasamos el gasto 'expense': 
              <pre data-line="1,11">
              <code class="language-ts">
                //ExpenseForm.ts
                const { dispatch } = useBudget()
                --
                const handleSubmit = (e: FormEvent&lt;HTMLFormElement&gt;) => {
                  e.preventDefault()
              
                  //validar
                  if(Object.values(expense).includes('')){
                    setError('Todos los campos son obligatorios')
                  }
                  //Agregar un nuevo gasto
                  dispatch({type: 'add-expense', payload: {expense}})
                }
              </code>
              </pre>

              Si vemos en la pestaña componentes de nuestro RDT el componente Budget Provider, vemos que en el reducer ya tenemos el nuevo state que acabamos de crear "expenses" y si en la app añadimos un gasto vemos que se añade, aunque si lo expandimos vemos que no hay ningún id único 
              <img src="./src/assets/img/210-01.png" alt="img" loading="lazy">      
              </li>
            <li class="my-1.25">En un ejemplo anterior cada vez que se montaba el componente generábamos un nuevo id. <strong>En este caso vamos a simular como si fuera una base de datos</strong>. En una bbdd nosotros no le decimos cual es el id; una vez que se genera se le asigna, por lo tanto vamos a volver al budget-reducer.tsx. Instalamos en nuestro proyecto <span class="destacado">npm install uuid</span> En nuestro budget-reducer.tsx importamos la dependencia (él, aunque parece que no lo necesitamos, instala las definiciones de types para uuid <strong>npm install --save-dev @types/uuid</strong>). Vamos a crear una función que va a tomar el payload de nuestro último action y le va a añadir un id, pero muy importante: <strong>lo va a convertir a type Expense, en lugar de que sea un DraftExpnse que no tiene id. Esta función 'createExpense' va a tomar desde el payload lo que está en el formulario, una vez que llega aquí mandamos llamar a esa función, le añade un id y lo devuelve hacia el reducer de nuevo</strong>. En lugar de generar el id en el formulario, no lo vamos a generar hasta que no haya pasado su validación. Podemos probar la app 
            
            <pre><code class="language-ts">
              //budget-reducer.tsx
              ...
              const createExpense = (draftExpense: DraftExpense ) : Expense => {
                return {
                    ...draftExpense,
                    id: uuidv4()
                }
              }
              
              export const budgetReducer = (
                    state: BudgetState=initialState,
                    action: BudgetActions
                ) =>{
                ...
                if(action.type === "add-expense"){
                  const expense = createExpense(action.payload.expense)
                  return{
                      ...state,
                      expenses: [...state.expenses, expense]
                  }
                } 
                return state
              }

            </code></pre>
            </li>
          </ul>

          <p>Una vez agregado un gasto correctamente querremos que se reinicie el formulario y se cierre el modal. Veamos como hacerlo</p>

        </div>

        <!-- Bloque desplegable interior -->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-211').toggle();">
          <h3>211. Reiniciar el Formulario y Ocultar el Modal si se agrega un gasto</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-211" class="hidden">
          <p>Ya estamos escribiendo en el arreglo de los gastos (el state 'expenses' que definimos en nuestro reducer y que podemos ver en la pestaña componentes de RDT pulsando el componente BudgetProvider dentro de los hooks)</p>

          <img src="./src/assets/img/211.png" alt="img" loading="lazy">

          <p>Una vez rellenado el gasto deberíamos o resetear el formulario o cerrar el modal para que el usuario pueda interactuar enla aplicación.</p>

          <p>En nuestro <span class="file">ExpenseForm.tsx</span> una vez que disparamos el dispatch para 'Agregar nuevo gasto' podemos reiniciar el state local con su función 'setExpense' pasándole los valores iniciales que teníamos. Eso lo podemos hacer porque tenemos conectado el value de los campos de formulario con nuestro state local. (<strong>en cada campo llamamos el id y el name del mismo como cada una de las propiedades de nuestro state local :)</strong>)</p>

          <pre data-line="11-17"><code class="language-ts">
            //ExpenseForm.tsx
            const handleSubmit = (e: FormEvent&lt;HTMLFormElement&gt;) => {
              e.preventDefault()
          
              //validar
              if(Object.values(expense).includes('')){
                setError('Todos los campos son obligatorios')
              }
              //Agregar un nuevo gasto
              dispatch({type: 'add-expense', payload: {expense}})
          
              //reiniciar el state
              setExpense({
                amount: 0,        //&lt;input type=&quot;number&quot; id=&quot;amount&quot; name=&quot;amount&quot; value={expense.amount} onChange={handleChange}/&gt;
                expenseName: '',  //&lt;input type=&quot;text&quot; id=&quot;expenseName&quot; name=&quot;expenseName&quot; value={expense.expenseName} onChange={handleChange} /&gt;
                category: '',     //&lt;select id=&quot;category&quot; name=&quot;category&quot; value={expense.category} onChange={handleChange}&gt;
                date: new Date()
              })
            }
          </code></pre>

          <p>Si quisiéramos cerrar el modal después de agregar el gasto, lo hacemos en nuestro reducer (gran ventaja de reducer tener algo de lógica y poder escribir en múltiples states al mismo tiempo, a diferencia de usar useState donde tendríamos que estar manejando para esto mismo distintos setStates):</p>
          <pre data-line="7"><code class="language-ts">
            //budget-reducer.ts
            ...
            if(action.type === "add-expense"){
              const expenseconId = createExpense(action.payload.expense)
              return{
                  ...state,
                  expenses: [...state.expenses, expenseconId],
                  modal: false
              }
            }
          </code></pre>

        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-212').toggle();">
          <h3>212. Creando el Componente para mostrar los gastos / 213. Mostrando los gastos / 214. Mostrando los iconos de la categoría del gasto</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-212" class="hidden">
          <p>Vamos a trabajar con <span class="file">App.tsx</span> y con <span class="file">budget-reducer.tsx</span> más que nada para extraer información</p>

          <p>En App.tsx tenemos la  comprobación de que si el presupuesto(budget) es válido el usuario pueda generar gastos; ahí es donde vamos a mostrar el listado de gastos. </p>

          <ul class="list-disc my-3">
            <li class="my-1.25"><strong>Creamos nuestro componente nuevo <span class="file">ExpenseList.tsx</span> para ese listado de gastos:</strong>  y lo renderizamos en App.tsx dentro de esa misma condición porque solo cuando tengamos un presupuesto válido es cuando queremos poder agregar nuevos gastos y listarlos:</li>

            <li class="my-1.25"><strong>Importamos nuestro useBudget.tsx en el nuevo componente:</strong> anteriormente pasábamos el state a utilizar como prop en este nuevo tag desde App.tsx al nuevo componentes ExpenseList.tsx pero ahora como tenemos contextAPI recordemos, disponemos de un state global.</li>

            <li><strong>Extraemos el state como nueva variable:</strong> <code class="language-ts">const { state } = useBudget()</code></li>
            <li><strong>Creamos una nueva variable 'isEmpty' usando useMemo que, teniendo el state como dependencia va a devolver true cuando no haya gastos:</strong> <code class="language-ts">const isEmpty = useMemo(() => state.expenses.length === 0, [state.expenses])</code> Queremos que en nuestra app, cuando aún no hay gastos se muestre el mensaje "No hay gastos" y si los hay, iterar sobre ellos para mostrarlos</li>
            <li class="my-1.25">Creamos un nuevo componente ExpenseDetail.tsx para usar en ExpenseList.tsx cuando iteramos sobre state.expenses y le pasamos como props key por iterar y expense (<strong>notar como con el autocompletado y la notación de punto tenemos accesos a las propiedades del type de gasto</strong>). Ese prop hemos de extraerlo y tiparlo en el nuevo componente ExpenseDetail.tsx como venimos haciendo hasta ahora con los props entre compos.
              <div class="flex max-sm:flex-col">            
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre data-line="0"><code class="language-js">
                    //ExpenseList.tsx
                    import { useMemo } from "react"
                    import { useBudget } from "../hooks/useBudget"
                    import ExpenseDetail from "./ExpenseDetail"
    
                    export default function ExpenseList() {
    
                        const { state } = useBudget()
                        const isEmpty = useMemo(() => state.expenses.length === 0, [state.expenses])
    
                        return (
                            &lt;div className=&quot;mt-10&quot;&gt;
                                {isEmpty ? &lt;p className=&quot;text-gray-600 text-2xl font-bold&quot;&gt;No hay gastos&lt;/p&gt; : (
                                    &lt;&gt;
                                        &lt;p className=&quot;text-gray-600 text-2xl font-bold my-5&quot;&gt;Listado de gastos.&lt;/p&gt;
                                        {state.expenses.map( expense =&gt; (
                                            &lt;ExpenseDetail
                                                key = {expense.id}
                                                expense = {expense}
                                            /&gt;
                                        ))}
                                    &lt;/&gt;
                                )}
                            &lt;/div&gt;
                        )
                    }
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre data-line="0"><code class="language-ts">
                    //App.tsx
                    {isValidObject && (
                      &lt;main className=&#39;max-w-3xl mx-auto py-10&#39;&gt;
                        &lt;ExpenseList/&gt;
                        &lt;ExpenseModal/&gt;
                      &lt;/main&gt;
                     )}
                  </code></pre>
                  <pre data-line="0"><code class="language-js">
                    //ExpenseDetail.tsx
                    import { Expense } from '../types/index';
    
                    type ExpenseDetailsProps = {
                        expense : Expense
                    }
                    
                    export default function ExpenseDetail({expense} : ExpenseDetailsProps) {
                        return (
                        &lt;div&gt;
                            
                        &lt;/div&gt;
                        )
                    }
                  </code></pre>
                </div>
               
              </div>
            </li>
            <li class="my-1.25">
              <p><strong>Construimos y damos estilos a las distintas etiquetas de la interfaz del componente <span class="file">ExpenseDetail.tsx</span>.</strong> Ojo! al intentar llamar a {expense.date} nos da este error porque, recordemos, tenía un type 'Value' de los creadores de la libreria, así que lo convertimos a string con un .toString(). Si lo vemos ahora, vemos que la fecha sale en el formato de la librería usada:</p>
              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <img src="./src/assets/img/213-1.png" alt="img" loading="lazy">
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <img src="./src/assets/img/213-2.png" alt="img" loading="lazy">
                </div>
              </div>            
            
              <p>Para que nos salga en formato español (hay muchas librerías y opciones para hacerlo porque trabajar con fechas es complicado). Nosotros vamos a utilizar las funciones Intl, como la que tenemos en nuestro helper y ahí es donde vamos a crear nuestra función para formatear la fecha, una función que toma un parámetro de tipo string y debe devolver un string. En la función creamos el objeto(usando el parámetro que recibe), le pasamos una configuración y retornamos la fecha formateada:</p>          

              <pre data-line="0"><code class="language-ts">
                //helpers/index.ts
                export function formatDate(dateStr : string) : string {
                  const dateObj = new Date(dateStr) //convertimos a objeto de tipo fecha
                  const options : Intl.DateTimeFormatOptions = {
                      weekday: 'long',
                      year: 'numeric',
                      month: 'long',
                      day: 'numeric'
                  }
                  return new Intl.DateTimeFormat('es-ES', options).format(dateObj)
                }
              </code></pre>

              <p>En nuestro componente ExpenseDetail.tsx llamamos a esa función para que formate la fecha (con la admiración le decimos a TS que ese valor va a estar ahí): <code class="language-ts">&lt;p className=&quot;text-slate-600 text-sm&quot;&gt;{ formatDate( expense.date!.toString() ) }&lt;/p&gt;</code></p>

              <p>A continuación utilizamos nuestro compo AmountDisplay.tsx, pero como ahora no queremos que nos saque label, lo modificamos para que sea opcional y además no queremos que nos saque los ":" que pusimos, hacemos estos cambios:</p>

              <pre data-line="0"><code class="language-js">
                // AmountDisplay.tsx
                import { formatCurrency } from "../helpers"
                type AmountDisplayProps = {
                    label?: string
                    amount: number
                }

                export default function AmountDisplay({label, amount} : AmountDisplayProps) {
                  return (
                    &lt;p className=&quot;text-2xl text-blue-600 font-bold&quot;&gt;
                        {/* {label}: {&#39;&#39;} */}
                        {label &amp;&amp; `${label}: `}
                        &lt;span className=&quot;text-black&quot;&gt;{formatCurrency(amount)}&lt;/span&gt;
                    &lt;/p&gt;
                  )
                }
              </code></pre>

              <p>Nos falta por mostrar el icono y el texto de la categoría (tenemos el diccionario con toda la información de esas categorías en nuestro <span class="file">data/categories.ts</span>), los iconos en la carpeta public y recordemos que en nuestro state de gastos del reducer, la categoría solo almacena el id, el resto de la info la vamos a tener que sacar de este diccionario.</p>             
            </li>

            <li class="my-1.25">
              Vamos a ver cómo tomar la información de la categoría, porque cuando estamos almacenando en el state solo estamos guardando el id, pero tenemos un diccionario de catergorías en <span class="file">data/categories.ts</span> de donde podemos sacar el nombre (para mostrarlo en mi listado) y el icono para renderizarlo desde public. (es como si lo hiciéramos desde una bbdd, otro gallo cantaría si tuviéramos un arreglo en memoria donde accederíamos directamente a esas props)
              
              <p>Vamos a <span class="file">EspenseDetails.tsx</span> y antes del return creamos nueva variable con useMemo() con dependencia del state expense para ejecutar lo siguiente cada vez que cambie ese state de nuestro reducer: <code class="language-ts">const categoryInfo = useMemo(() => categories.filter(cat => cat.id === expense.category)[0],[expense])</code>,  es decir <span class="destacado">usando filter sobre nuestro diccionario de datos categories, vamos a poder filtrar sobre ese arreglo y encontrar la coincidencia de la categoría del gasto que estamos iterando, permitiéndonos así con el id del gasto que itero traerme todo el objeto correspondiente a ese id y poder acceder a lo que necesito: name y al icono</span>.</p>

              <pre data-line="0"><code class="language-js">
                //ExpenseDetail.tsx
                import { useMemo } from 'react';
                import { categories } from '../data/categories';
                import { formatDate } from '../helpers';
                import { Expense } from '../types/index';
                import AmountDisplay from './AmountDisplay';
                
                type ExpenseDetailsProps = {
                    expense : Expense
                }
                
                export default function ExpenseDetail({expense} : ExpenseDetailsProps) {
                
                    const categoryInfo = useMemo(() => categories.filter(cat => cat.id === expense.category)[0],[expense])
                
                    return (
                    &lt;div className=&quot;bg-white shadow-lg p-10 w-full border-b border-gray-200 flex gap-4 items-center&quot;&gt;
                        &lt;div&gt;
                            &lt;img 
                                src={`./icono_${categoryInfo.icon}.svg`} 
                                alt=&quot;icono gasto&quot;
                                className=&#39;w-20&#39;
                             /&gt;
                        &lt;/div&gt;
                
                        &lt;div className=&#39;flex-1 space-y-2&#39;&gt;
                            &lt;p className=&quot;text-sm font-bold uppercase text-slate-500&quot;&gt;{categoryInfo.name}&lt;/p&gt;
                            &lt;p&gt;{expense.expenseName}&lt;/p&gt;
                            &lt;p className=&quot;text-slate-600 text-sm&quot;&gt;{ formatDate( expense.date!.toString() ) }&lt;/p&gt;
                        &lt;/div&gt;
                
                        &lt;AmountDisplay
                            amount={expense.amount}
                        /&gt;
                    &lt;/div&gt;
                    )
                }
              </code></pre>
            </li>
          </ul>
            
          <p>A continuación empezaremos con la parte de editar y eliminar e instalaremos para ello una librería para la interacción Swipe.</p>     
        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-215').toggle();">
          <h3>215. Agregando interacción de Swipe a los gastos para Editar y Eliminar - <a class="underline text-white" href="https://www.npmjs.com/package/react-swipeable-list" target="_blank">react-swipeable-list</a> - <a class="underline text-white" href="https://gist.github.com/codigoconjuan/e1a67f2a729bc44978c2c7d0f946ce7e" target="_blank">gist para para swipleable List</a></h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-215" class="hidden">
          <p>Vamos con las acciones de editar y eliminar. Podríamos añadir algunos iconos como hemos hecho hasta ahora pero vamos a utilizar un efecto que tiene distintas apps, whatsapp, gmail. amazon... swipeable-list. Instalamos esta dependencia que soporta TS y además tiene actualizaciones recientes: <a class="underline text-black" href="https://www.npmjs.com/package/react-swipeable-list" target="_blank">react-swipeable-list</a> con <span class="destacado">npm i react-swipeable-list</span>. </p>

          <p>Vamos a <span class="file">ExpenseDetail.tsx</span> e importamos varias cosas entre ellas: LeadingActions (las acciones que vienen del lado izquierdo) y TrailingActions (las acciones que vienen del otro lado) así como la hoja de estilos propia que tiene sus propias animaciones. Aunque aún nos queda trabajo, así es como queda de momento nuestro componente con swype inicialmente configurado y si lo probamos en al interfaz vemos que ya hace el swype para ambos lados (actualizar hacia la izquierda y Eliminar hacia la derecha).</p>

          <p><strong>SwipeableList:</strong> tiene que rodear todo nuestro div princpal</p>
          <p><strong>SwipeableListItem:</strong> para especificarle cuales son las acciones y la configuración. Este prop <code class="language-ts">maxSwipe={30}</code> que le pasamos le especifica los px que queremos que recorra para que se dispare. Los props <code class="language-ts">LeadingActions={}</code> y <code class="language-ts">TrailingActions={}</code> son para especificar lo que queremos que haga ese elemento cuando arrastramos respectivamente de izda a derecha o de drecha a izda. Así que creamos las correspondientes funciones que queremos que ejecuten esos props.</p>

          <p>Copiamos en raw el código que ha preparado en este gist <a class="underline text-black" href="https://gist.github.com/codigoconjuan/e1a67f2a729bc44978c2c7d0f946ce7e" target="_blank">gist para para swipleable List</a> con estilos y lo pegamos en nuestro index.css (con @apply leemos las clases que utiliza esa librería y aplico clases de tailwindcss incorporándolas a lo que de por sí tiene esa librería que tomamos de npm).</p>

          <p>La librería nos da unos props muy útiles como por ejemplo: usemos este en el SwipeAction del TrailingAction: <code class="language-ts">destructive={true}</code> visualmente vemos que desaparece de nuestra interfaz, aunque no lo ha eliminado de nuestro state porque tenemos que disparar esa acción.</p>

          <pre data-line="2,7,17-32,35-40,62,63"><code class="language-ts">
            //ExpenseDetail.tsx
            import { useMemo } from 'react';
            import { LeadingActions, SwipeableList, SwipeableListItem, SwipeAction, TrailingActions} from 'react-swipeable-list'
            import { categories } from '../data/categories';
            import { formatDate } from '../helpers';
            import { Expense } from '../types/index';
            import AmountDisplay from './AmountDisplay';
            import "react-swipeable-list/dist/styles.css"
            
            type ExpenseDetailsProps = {
                expense : Expense
            }
            
            export default function ExpenseDetail({expense} : ExpenseDetailsProps) {
            
                const categoryInfo = useMemo(() =&gt; categories.filter(cat =&gt; cat.id === expense.category)[0],[expense])
            
                const leadingActions = () =&gt; (
                    &lt;LeadingActions&gt;
                        &lt;SwipeAction onClick={() =&gt; {}}&gt;
                            Actualizar
                        &lt;/SwipeAction&gt;
            
                    &lt;/LeadingActions&gt;
                )
                const trailingActions = () =&gt; (
                    &lt;TrailingActions&gt;
                        &lt;SwipeAction onClick={() =&gt; {}}&gt;
                            Eliminar
                        &lt;/SwipeAction&gt;
            
                    &lt;/TrailingActions&gt;
                )
            
                return (
                &lt;SwipeableList&gt;  
                    &lt;SwipeableListItem
                        maxSwipe={30}
                        leadingActions = {leadingActions()}
                        trailingActions = {trailingActions()}
                    &gt;
            
                        &lt;div className=&quot;bg-white shadow-lg p-10 w-full border-b border-gray-200 flex gap-4 items-center&quot;&gt;
                            &lt;div&gt;
                                &lt;img 
                                    src={`./icono_${categoryInfo.icon}.svg`} 
                                    alt=&quot;icono gasto&quot;
                                    className=&#39;w-20&#39;
                                /&gt;
                            &lt;/div&gt;
            
                            &lt;div className=&#39;flex-1 space-y-2&#39;&gt;
                                &lt;p className=&quot;text-sm font-bold uppercase text-slate-500&quot;&gt;{categoryInfo.name}&lt;/p&gt;
                                &lt;p&gt;{expense.expenseName}&lt;/p&gt;
                                &lt;p className=&quot;text-slate-600 text-sm&quot;&gt;{ formatDate( expense.date!.toString() ) }&lt;/p&gt;
                            &lt;/div&gt;
            
                            &lt;AmountDisplay
                                amount={expense.amount}
                            /&gt;
                        &lt;/div&gt;
            
                    &lt;/SwipeableListItem&gt;
                &lt;/SwipeableList&gt;
                )
            }    
          </code></pre>
            
          
          


        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-216').toggle();">
          <h3>216. Eliminando un gasto cuando ejecutamos un Swipe</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-216" class="hidden">
          <p>Abrimos budget-reducer.ts y creamos acción nueva para eliminar <code class="language-ts"> </code> y lo que le estamos especificando en el payload es "lo que sea que tenga expense en su campo id, ese mismo type queremos usar". Un poco más abajo en el if de nuestro reducer, podríamos usar algo de lógica para eliminarlo, por ejemplo con un filter y después asignarlo pero también lo podemos poner todo directamente en el return: hacemos una copia del state y a continuación en el filter accedemos a cada gasto y le decimos "traete todos los que sean diferentes al payload que estamos pasando que es el que queremos eliminar"</p>
          <pre><code class="language-js">
            //budget-reducer.ts
            ...
            { type: 'remove-expense', payload: {id: Expense['id']} }
            ...
            if(action.type="remove-expense"){
              return{
                  ...state,
                  expenses: state.expenses.filter( expense => expense.id !== action.payload.id)
              }
            }
          </code></pre>

          <p>Ahora en <span class="file">ExpenseDetail.tsx</span> importamos nuestro custom hook e instanciamos extrayendo dispatch para entonces, ¿¿escribir en mi state esa acción:</p>

          <pre data-line="1,5,10"><code class="language-ts">
            //ExpenseDetail.tsx
            import { useBudget } from '../hooks/useBudget';
            ..
            export default function ExpenseDetail({expense} : ExpenseDetailsProps) {

              const { dispatch } = useBudget()
              ...
              const trailingActions = () =&gt; (
                &lt;TrailingActions&gt;
                    &lt;SwipeAction 
                        onClick={() =&gt; dispatch({type: &#39;remove-expense&#39;, payload: {id: expense.id}})}
                        destructive = {true}
                    &gt;
                        Eliminar
                    &lt;/SwipeAction&gt;

                &lt;/TrailingActions&gt;
              )
          </code></pre>

        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-217').toggle();">
          <h3>217. Seleccionando el Gasto a Editar cuando ejecutamos Swipe en la otra dirección / 218. Llenar el formulario del gasto a editar automáticamente</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-217" class="hidden">
          <p>Vamos a ver cómo editamos los gastos. Lo primero es identificar qué gasto estamos "arrastrando" de izquierda a derecha con el swype, lo colocaremos en el state del que estamos editando, abriremos modal y entonces filtrar el gasto por ese id.</p>
          <ul class="list-disc my-3">
            <li class="my-1.25">Añadimos una nueva propiedad de state en nuestro reducer llamada <strong>'editingId'</strong> de tipo Expense y usamos lookup para buscar id. Registramos una acción nueva <strong>'get-expense-by-id'</strong> que es la que vamos a disparar para que escriba en nuestra prop de state 'editingId'. En nuestro reducer definimos el if de esa acción. En <span class="file">ExpenseDetail.tsx</span> en el cnClick del LeadingActions SwipeActions llamamos con el dispatch a nuestra nueva acción. Quiero que al arrastrar me lance el modal: es muy fácil gracias a reducer, añadimos en el if correspondiente que <code class="language-ts">modal: true</code>. 
              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre data-line="0,3,9,15,18-24"><code class="language-ts">
                    //budget-reducer.ts
                    export type BudgetActions = 
                      ... |
                      { type: 'get-expense-by-id', payload: {id: Expense['id']} } 
            
                    export type BudgetState = {
                      budget: number
                      modal: boolean
                      expenses: Expense[]
                      editingId: Expense['id']
                    }
                    export const initialState: BudgetState = {
                        budget: 0,
                        modal: false,
                        expenses: [],
                        editingId: ''
                    }
                    ...
                    if(action.type === "get-expense-by-id"){
                      return{
                          ...state,
                          editingId: action.payload.id ,
                          modal: true
                      }
                    }
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre data-line="0,3"><code class="language-ts">
                    //ExpenseDetail.tsx
                    const leadingActions = () => (
                      &lt;LeadingActions&gt;
                          &lt;SwipeAction onClick={() =&gt; dispatch({type: &quot;get-expense-by-id&quot;, payload: {id: expense.id}})}&gt;
                              Actualizar
                          &lt;/SwipeAction&gt;
                      &lt;/LeadingActions&gt;
                    )
                  </code></pre>
                </div>
              </div> 
            </li>
            <li class="my-1.25">Llenemos el formulario del modal en función del id que aparece en el state 'editingId': nos vamos a <span class="file">ExpenseForm.tsx</span> y al instanciar nuestro useBudget, además de extraer el dispatch vamos a extraer el state: <code class="language-ts">const { dispatch, state } = useBudget()</code> y entonces utilizamos un useEffect() y le pasamos como dependencia state.editingId (teniendo en cuenta que useEffect siempre se ejecuta al menos una vez así que añadimos if comprobando). Una vez hecho el filter seteamos! regresamos de lo global a lo local (anteriormente lo habíamos movido de local a global) para tener toda la validación y el código que hemos hecho en nuestro compo.
            <pre data-line="0"><code class="language-ts">
              //ExpenseForm.tsx
              const { dispatch, state } = useBudget()

              useEffect(() => {
                if(state.editingId){
                  const editingExpense = state.expenses.filter( currentExpense => currentExpense.id === state.editingId)[0]
                  setExpense(editingExpense)
                }
              },[state.editingId])
            </code></pre>
            </li>
          </ul>

        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-219').toggle();">
          <h3>219. Editando el gasto / 220. Mostrar de forma condicional si es un gasto nuevo o edición</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-219" class="hidden">
          <p>Con lo que llevamos hecho si tratamos de editar un gasto y le damos a enviar vemos que nos agrega uno nuevo. Hemos de identificar cuando estamos editando para actualizar el gasto y si es uno nuevo entonces agregarlo a la lista. Nos vamos a <span class="file">budget-reducer.ts</span> y creamos una acción nueva que se dispara cuando actualizamos. Le pasamos este payload porque cuando estamos actualizando pasamos el objeto completo (estamos actualizando un gasto que ya tiene un id) <code class="language-ts">{ type: 'update-expense', payload: {expense: Expense} } </code>. En el reducer creamos su if correspondiente creando una copia del state actual y con un map vamos a recorrer todos los gastos para identificar cual estoy actualizando vamos a poner(siendo expense el elemento iterado) expense.id === y aquí hay dos formas de hacerlo:</p>

          <ul class="list-disc my-3">
            <li class="my-1.25">Una forma sería con expense.id === state.editingId (porque ese es el activo y el que estamos actualizando)</li>
            <li class="my-1.25">Pero también ese gasto, esta actualización tiene su propio id solo que primero tendríamos que validar en el dispatch 'add-expense' de ExpenseForm.tsx <code class="language-ts">dispatch({type: 'add-expense', payload: {expense}})</code>si hay algo en activo para editar y si es así despechar la acción de editar y si no hay nada PARA EDITAR DESPACHAR la que hay actualmente de agregar el gasto. Lo hacemos así.</li>
          </ul>
        
          <p>Cuando detecte que es igual entonces voy a reescribir de mis gastos con action.payload.expense (es decir el objeto completo) y en caso contrario retorno expense (el gasto sobre el cual estoy iterando) para no perder así los otros gastos.</p>
              <pre><code class="language-ts">
                //budget-reducer.ts
                if(action.type==="update-expense"){
                  return{
                      ...state,
                      expenses: state.expenses.map(expense => expense.id === action.payload.expense.id ? action.payload.expense : expense),
                      modal: false,
                      editingId: ''
                  }
              }
              </code></pre>
            
              <p>Como estamos comparando por al payload, para que mande llamar correctamente a esa función tenemos que ir a <span class="file">ExpenseForm.tsx</span> como decíamos y vamos a comprobar si estamos agregando o actualizando gasto: si agregamos usamos el dispatch como lo teníamos, si estmaos actualizando, usamos la acción recién creada pero el payload es un poco más complejo porque, recordemos, nuestro expense no tenía id, pero al actualizar la estamos pasando que su objeto va a ser ya un gasto que tiene id. Le vamos a decir que el id lo coja del editingId (id: state.editingId), y del resto toma una copia de lo que tenemos en el state como gasto (...expense)</p>

              <pre><code class="language-ts">
                //ExpenseForm.tsx
                //Agregar un nuevo gasto o actualizar uno existente
                if(state.editingId){
                  dispatch({type: 'update-expense', payload: {expense: {id: state.editingId, ...expense}} })
                }else{
                  dispatch({type: 'add-expense', payload: {expense}})
                }
              </code></pre>

          <p>Si nos fijamos, al editar un gasto en cuanto se cierra el modal lo reseteábamos, sin embargo a darle a agregar nuevo gasto a continuación nos sale el último editado de nuevo ¿por qué? mirando 'BudgetProvider' en la pestaña components en RDT vemos que nuestro state 'editingID' SIEMPRE está en activo (usaba un useEffect) entonces cuando lo vuelve a llamar se rellena. Por lo tanto vamos a especificarle tras el cierre del modal que editingId sea un string vacío. Esto mismo lo vamos a especificar en nuestra acción de cierre de modal también para prevenir que si un usuario edita y cierra el modal sin finalizar la acción de editar, este permanezca lleno:
          
          <p>Vamos a mostrar el título del modal diferente si se trata de un nuevo gasto o de una edición. Vamos a ExpenseForm.tsx. Ese título está en un legend y como ya teníamos importado el state de nuestra aplicación podemos hacer lo siguiente:</p>

          <pre><code class="language-ts">
            //ExpenseForm.tsx
            &lt;legend
              className=&quot;uppercase text-center text-2xl font-black border-b-4 border-blue-500 py-2&quot;
            &gt;{state.editingId ? &#39;Guardar Cambios&#39; : &#39;Nuevo gasto&#39;}&lt;/legend&gt;
            ...
            &lt;input 
              type=&quot;submit&quot; 
              className=&quot;bg-blue-600 cursor-pointer w-full p-2 text-white uppercase font-bold rounded-lg&quot;
              value={state.editingId ? &#39;Guardar Cambios&#39; : &#39;Registrar gasto&#39;}
            /&gt;
          </code></pre>
        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-221').toggle();">
          <h3>221. Colocando gastos en LocalStorage</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-221" class="hidden">
          <p>Vamos a nuestro reducer que es donde manejamos el state. Requerimos el presupuesto (budget) pero también los gastos (expenses) así que vamos a tener dos funciones, dos objetos distintos para no tener tanta lógica. De esta manera, separado, es más simple, más fácil de leer, más sencillo de mantener:</p>

          <div class="flex max-sm:flex-col">
            <div class="w-[50%] max-sm:w-[100%]">
              <pre class="rojo" data-line="2,4"><code class="language-js">
                //budget-reducer.ts
                export const initialState: BudgetState = {
                  budget: 0,
                  modal: false,
                  expenses: [],
                  editingId: ''
              }
              </code></pre>
            </div>
            <div class="w-[50%] max-sm:w-[100%]">
              <pre class="verde" data-line="1-8,10,12"><code class="language-js">
                //budget-reducer.ts
                const initialBudget = () : number =>{
                  const localStorageBudget = localStorage.getItem('budget')
                  return localStorageBudget ? +localStorageBudget : 0
                }
                const localStorageExpenses = () : Expense[] => {
                  const localStorageExpenses = localStorage.getItem('expenses')
                  return localStorageExpenses ? JSON.parse(localStorageExpenses) : []
                }
                export const initialState: BudgetState = {
                  budget: initialBudget(),
                  modal: false,
                  expenses: localStorageExpenses(),
                  editingId: ''
              }
              </code></pre>
            </div>
          </div>

          <p>En <span class="file">App.tsx</span> usamos un useEffect() y le pasamos como dependencia para escuchar el state que ya tiene importado ese App.tsx de manera global.</p>
          
          <ul class="list-disc my-3">
            <li class="my-1.25">Seteamos nuestro 'budget' de localStorage usando toString() porque localStorage no acepta números (y recordemos nuestro presupuesto budget es un número) y en typescript tenemos que ser muy específicos.</li>
            <li class="my-1.25">Seteamos nuestro 'expenses' de localStorage usando JSON.stringify() porque localStorage no acepta arreglos (y nuestros gastos lo son)</li>
          </ul>

          <pre data-line="0"><code class="language-ts">
            //App.tsx
            useEffect(() => {
              localStorage.setItem('budget', state.budget.toString())
              localStorage.setItem('expenses', JSON.stringify(state.expenses))
            },[state])
          </code></pre>

        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-222').toggle();">
          <h3>222. Trabajando con el Componente que muestra Presupuesto, Gastado y Disponible</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-222" class="hidden">
          <p>Vamos a trabajar con el compo <span class="file">BudgetTracker.tsx</span> que es donde mostramos Presupuesto, Gastado y Disponible. Vamos a hacerlo como un state derivado, vamos a ir escribiendo algunas funciones que, gracias a que se actualiza el state también se van a ir actualizando. Importamos nuestro useBudget y extraemos el state que es donde vamos a tener nuestro presupuesto, nuestras cantidades y podemos calcular el total a pagar.</p>
          <ul class="list-disc my-3">
            <li class="my-1.25"><strong>Nuestro presupuesto:</strong> Cambiamos el código hardcodeado de 300 que teníamos en el prop Amount del tag AmountDisplay de : <code class="language-ts">amount={300}</code> por <code class="language-ts">amount={state.budget}</code> </li>
            <li class="my-1.25"><strong>Lo gastado: </strong> Vamos a crear una variable 'totalExpenses' y usaremos en ella useMemo() porque queremos que ese cálculo se ejecute cada vez que cambie el state de gastos. usamos reduce() con sus dos parámetros para el cálculo</li>
            <li class="my-1.25">Lo disponible: creamos variable 'remainingBudget' y calculamos la diferencia entre el presupuesto y lo gastado. </li>
          </ul>
         
          <pre data-line="4-5,7,11,15,19"><code class="language-ts">
          //BudhetTracker.tsx
          export default function BudgetTracker() {
            const { state } = useBudget()
        
            const totalExpenses = useMemo( () => state.expenses.reduce((total,expense) => expense.amount + total, 0 )
            , [state.expenses])

            const remainingBudget = state.budget - totalExpenses
            ...
            &lt;AmountDisplay
            label=&quot;Presupuesto&quot;
            amount={state.budget}
            /&gt;
            &lt;AmountDisplay
              label=&quot;Disponible&quot;
              amount={remainingBudget}
            /&gt;
            &lt;AmountDisplay
              label=&quot;Gastado&quot;
              amount={totalExpenses}            
            /&gt;
          </code></pre>
        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-223').toggle();">
          <h3>223. Evitar Excedernos del presupuesto</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-223" class="hidden">
          <p>Veamos como hacer para no pasarnos del presupuesto y evitar añadir/editar un gasto con cuya cantidad se exceda nuestro presupuesto (nos aparecería cifra negativa ahí). Básicamente tendríamos que copiar todo el código que acabamos de crear en el punto anterior también al formulario porque ahí es cuanto queda disponible... sin embargo en vez de tener copias por ahí en nuestro código, nos lo vamos a llevar al context <span class="file">context/BudgetContext.tsx</span> donde estamos utilizando reducer (aunque no tenga que ver esclusivamente con nuestro estate, si lo podemos utilizar en distintos sitios de nuestra app para no tener así código duplicado lo llevamos al context):</p>

          <div class="flex max-sm:flex-col">
            <div class="w-[40%] max-sm:w-[100%]">
              <pre data-line="0"><code class="language-js">
                //context/BudgetContext.tsx
                import { useReducer, createContext, Dispatch, ReactNode } from &#39;react&#39;;
                import { BudgetState, BudgetActions, budgetReducer, initialState } from &quot;../reducers/budget-reducer&quot;
                
                type BudgetContextProps = {
                    state:  BudgetState
                    dispatch: Dispatch&lt;BudgetActions&gt;
                }
                type BudgetProviderProps = {
                    children : ReactNode
                }
                
                export const BudgetContext = createContext&lt;BudgetContextProps&gt;(null!)
                
                export const BudgetProvider = ({children}: BudgetProviderProps) =&gt; {
                
                    const[state, dispatch] = useReducer(budgetReducer, initialState)
                   
                    return(
                        &lt;BudgetContext.Provider
                            value={{
                                state,
                                dispatch
                            }}
                        &gt;
                            {children}
                        &lt;/BudgetContext.Provider&gt;
                    )                
                }
              </code></pre>
            </div>
            <div class="w-[60%] max-sm:w-[100%]">
              <pre class="verde" data-line="7,8,20-22,29,30"><code class="language-js">
                //context/BudgetContext.tsx
                import { useReducer, createContext, Dispatch, ReactNode, useMemo } from &#39;react&#39;;
                import { BudgetState, BudgetActions, budgetReducer, initialState } from &quot;../reducers/budget-reducer&quot;
                
                type BudgetContextProps = {
                    state:  BudgetState
                    dispatch: Dispatch&lt;BudgetActions&gt;
                    totalExpenses: number
                    remainingBudget: number
                }
                type BudgetProviderProps = {
                    children : ReactNode
                }
                
                export const BudgetContext = createContext&lt;BudgetContextProps&gt;(null!)
                
                export const BudgetProvider = ({children}: BudgetProviderProps) =&gt; {
                
                    const [state, dispatch] = useReducer(budgetReducer, initialState)
                
                    const totalExpenses = useMemo( () =&gt; state.expenses.reduce((total,expense) =&gt; expense.amount + total, 0 )
                    , [state.expenses])
                    const remainingBudget = state.budget - totalExpenses
                   
                    return(
                        &lt;BudgetContext.Provider
                            value={{
                                state,
                                dispatch,
                                totalExpenses,
                                remainingBudget
                            }}
                        &gt;
                            {children}
                        &lt;/BudgetContext.Provider&gt;
                    )                
                }
              </code></pre>
            </div>
          </div>

          <p>En <span class="file">BudgetTracker.tsx</span> eliminaríamos entonces ese código que creamos antes y simplemente extraemos esos dos objetos que hemos creado en el context con el importe que resta del presupuesto y la suma del total de los gastos (remainingBudget y totalExpenses). Quedaría así:</p>

          <pre data-line="5"><code class="language-ts">
            //BudgetTracker.tsx
            import { useBudget } from &#39;../hooks/useBudget&#39;;
            import AmountDisplay from &#39;./AmountDisplay&#39;;
            
            export default function BudgetTracker() {
                const { state, remainingBudget, totalExpenses } = useBudget()
            
                return (
                &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-5&quot;&gt;
                    &lt;div className=&quot;flex justify-center&quot;&gt;
                        &lt;img src=&quot;./grafico.jpg&quot; alt=&quot;Gráfica de gastos&quot; /&gt;
                    &lt;/div&gt;
            
                    &lt;div className=&quot;flex flex-col justify-center items-center gap-8&quot;&gt;
                        &lt;button
                            type=&quot;button&quot;
                            className=&#39;bg-pink-600 w-full p-2 text-white uppercase font-bold rounded-lg&#39;&gt;
                                Resetear App
                        &lt;/button&gt;
            
                        &lt;AmountDisplay
                            label=&quot;Presupuesto&quot;
                            amount={state.budget}
                        /&gt;
                        &lt;AmountDisplay
                            label=&quot;Disponible&quot;
                            amount={remainingBudget}
                        /&gt;
                        &lt;AmountDisplay
                            label=&quot;Gastado&quot;
                            amount={totalExpenses}            
                        /&gt;
                    &lt;/div&gt;
                    
                &lt;/div&gt;
                )
            }
          </code></pre>

          <p>Si vemos nuestra app sigue funcionando igual pero al tenerlo en nuestro context ya es algo reutilizable así que vamos a <span class="file">ExpenseForm.tsx</span> en donde, como tenemos ya importado el useBudget, extraemos el objeto remainingBudget y agregamos una segunda validación en nuestro handleSubmit:</p>

          <pre><code class="language-ts">
            //ExpenseForm.tsx
            ...
            const { dispatch, state, remainingBudget } = useBudget()
            ...
            //Validar que no me pase del presupuesto
            if( expense.amount > remainingBudget){
              setError('Ese gasto es mayor que lo que resta de Presupuesto')
              return
            }
          </code></pre>

          <p>Llegados a este punto vemos que el nivel de complejidad es grande y algo nos falla (si intentamos modificar un gasto de 200 y bajarlo a 180 cuando por ejemplo aun nos quedan 100 de presupeusto nos sale error). Vamos a agregar en <span class="file">ExpenseForm.tsx</span> un nuevo state local 'previousAmount' <code class="language-ts">const [previousAmount, setPreviousAmount] = useState(0)</code> para que, cuando estemos editando, vamos a congelar esa cantidad porque la requerimos. Añadimos lo siguiente en nuestro useEffect() de editar:</p>

          <pre data-line="2,9"><code class="language-ts">
            //ExpenseForm.tsx
            ...
            const [previousAmount, setPreviousAmount] = useState(0)
            const { dispatch, state, remainingBudget } = useBudget()

            useEffect(() => {
              if(state.editingId){
                const editingExpense = state.expenses.filter( currentExpense => currentExpense.id === state.editingId)[0]
                setExpense(editingExpense)
                setPreviousAmount(editingExpense.amount)
              }
            },[state.editingId])

          </code></pre>

          <p>y entonces cambiamos nuestra validación de esto a esto e importante reinicar también ese nuevo state previousAmount porqeu en los siguientes que yo agregue queremos iniciar a 0 y entonces cuando se monte el componente, cuando estemos editando que lo tome de ahí:</p>

          <div class="flex max-sm:flex-col">
            <div class="w-[50%] max-sm:w-[100%]">
              <pre class="rojo" data-line="1"><code class="language-js">
                //Validar que no me pase del presupuesto
                if( expense.amount > remainingBudget){
                  setError('Ese gasto es mayor que lo que resta de Presupuesto')
                  return
                }
                ...
                //reiniciar el state
                setExpense({
                  amount: 0,
                  expenseName: '',
                  category: '',
                  date: new Date()
                })
              </code></pre>
            </div>
            <div class="w-[50%] max-sm:w-[100%]">
              <pre class="verde" data-line="1,13"><code class="language-js">
                //Validar que no me pase del presupuesto
                if( (expense.amount-previousAmount) > remainingBudget){
                  setError('Ese gasto es mayor que lo que resta de Presupuesto')
                  return
                }
                ...
                //reiniciar el state
                setExpense({
                  amount: 0,
                  expenseName: '',
                  category: '',
                  date: new Date()
                })
                setPreviousAmount(0)
              </code></pre>
            </div>
          </div>


        </div>

        <!-- Bloque desplegable interior-->
        <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-224').toggle();">
          <h3>224. Agregando una gráfica circular interactiva y RETO 05 - <a class="text-white underline" href="https://www.npmjs.com/package/react-circular-progressbar" target="_blank">React Circular Progressbar</a> / 225. Crear un botón para reiniciar la app</h3>
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
        </div>
        <div id="seccion13-224" class="hidden">
          <p>Veamos como realizar esta gráfica circular dinámica para lo cual instalamos la dependencia <span class="destacado">npm i react-circular-progressbar</span>. Importamos y sustituimos el jpg estático por este componente. El prop value representa el % de lo que se llena, hay que hacerlo dinámico para lo cual hacemos lo siguiente: <code class="language-ts">const percentage = +((totalExpenses / state.budget) * 100).toFixed(2)</code>.</p>

          <div class="flex max-sm:flex-col">
            <div class="w-[50%] max-sm:w-[100%]">
              <pre data-line="1,2,7,13-19"><code class="language-ts">
                //BudgetTracker.tsx
                import { CircularProgressbar, buildStyles } from 'react-circular-progressbar'
                import "react-circular-progressbar/dist/styles.css"
                ...
                export default function BudgetTracker() {
                  const { state, remainingBudget, totalExpenses } = useBudget()
              
                  const percentage = +((totalExpenses / state.budget) * 100).toFixed(2)
                  //console.log(percentage)
              
                  return (
                    &lt;div className=&quot;grid grid-cols-1 md:grid-cols-2 gap-5&quot;&gt;
                      &lt;div className=&quot;flex justify-center&quot;&gt;
                      &lt;CircularProgressbar 
                          value={percentage}
                          styles={buildStyles({
                              pathColor: percentage === 100? &#39;#dc2626&#39; : &#39;#3b82f6&#39;,
                              trailColor: &#39;#f5f5f5&#39;,
                              textSize: 8,
                              textColor: percentage === 100? &#39;#dc2626&#39; : &#39;#3b82f6&#39;
                          })}
                          text={`${percentage}% gastado`}                
                      /&gt;
                      &lt;/div&gt;
                      ...
              </code></pre>
            </div>
            <div class="w-[50%] max-sm:w-[100%] mr-2">
              <img src="./src/assets/img/224.png" alt="img" loading="lazy">
            </div>
          </div>  

          <p>Hagamos el <strong>Reto 05: Reiniciar la App</strong></p>

          <ul class="list-disc my-2.5">
            <li>Hacer funcional el botón de Reiniciar o Resetear App</li>
            <li>Deberemos crear la acción y mandarla llamar con Dispatch</li>
            <li>Seguir las convenciones de nombres del custom hook y reducer</li>
          </ul>

          <p>En <span class="file">budget-reducer.ts</span> agregamos nueva acción sin payload y en el if del reducer tomamos copia del state, inicializamos el presupuesto a 0 y los gastos array vacío (no hace falt poner a false el modal porque el hecho de estar pulsando el botón ya presupone que está cerrado). En <span class="file">BudgetTracker</span> extraemos el dispatch de nuestro useBudget() y lo usamos para crear una función de borrado que llamamos desde el onClick del botón.</p>

          <div class="flex max-sm:flex-col">
            <div class="w-[50%] max-sm:w-[100%]">
              <pre><code class="language-js">
                //budget-reducer.ts
                ...
                { type: 'restart-app' } 
                ...
                if(action.type == "restart-app" ){
                  return{
                      ...state,
                      budget: 0,
                      expenses: []
                  }
              }
              </code></pre>
            </div>
            <div class="w-[50%] max-sm:w-[100%]">
              <pre data-line="1,2,6"><code class="language-ts">
                //BudgetTracker.tsx
                const { state, remainingBudget, totalExpenses, dispatch } = useBudget()
                const resetApp = () =>{dispatch({type: 'restart-app'}) }
                ..
                &lt;button
                    type=&quot;button&quot;
                    className=&#39;bg-pink-600 w-full p-2 text-white uppercase font-bold rounded-lg cursor-pointer&#39;
                    onClick={resetApp}
                &gt;
                    Resetear App
                &lt;/button&gt;
              </code></pre>
            </div>
          </div>

          

        </div>


<!-- Bloque desplegable interior-->
<div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-226').toggle();">
  <h3>226. Creando un componente para filtrar los gastos</h3>
  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
</div>
<div id="seccion13-226" class="">
  <p>Vamos a preparar un compo para poder filtrar los gastos por categorías en caso de que lleguen a ser muchos.</p>

</div>

<!-- Bloque desplegable interior-->
<div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-227').toggle();">
  <h3>227. Escribiendo en el State la categoría a filtrar</h3>
  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
</div>
<div id="seccion13-227" class="hidden">


</div>

<!-- Bloque desplegable interior-->
<div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion13-228').toggle();">
  <h3>228. Mostrar los gastos de la categoría seleccionada y Building de la App</h3>
  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
</div>
<div id="seccion13-228" class="hidden">


</div>




      </div>
      <!-- Fin div colapsable-->

    </div>
    <!-- FIN SECCION XX -->

      <!-- SECCION 12 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 my-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">

        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between" onclick="$('#seccion12').toggle();">
          <h2>Section 12: PROYECTO - Calculadora de Propinas - Migrando hacia useReducer <span class="rojo">PTE. HACER</span></h2>
          <span class="cambiaicono ico_chevron_up mr-2.5" title=""></span>
        </div>

        <div id="seccion12" class="hidden">

            <!-- Bloque desplegable interior-->
            <div class="flex justify-between items-center mt-1.25 cursor-pointer desplegable-interior oscuro" onclick="$('#seccion12-XX').toggle();">
              <h3>XXXXXXXXXXXXXXX</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion12-XX" class="hidden">


            </div>

        </div>
        <!-- Fin div colapsable-->

      </div>
      <!-- FIN SECCION 12 -->

      <!-- SECCION 11 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 my-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">

        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between" onclick="$('#seccion11').toggle();">
          <h2>Sección 11: PROYECTO - Migrar el Carrito de Compras de Guitarras a useReducer</h2>
          <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
        </div>

        <div id="seccion11" class="hidden">
          
          <a class="underline text-rose-600 font-bold" href="https://github.com/and....55/guitarla-ur/" target="blank">https://github.com/and....55/guitarla-ur/</a>
          <p> <span class="destacado">migrar la funcionalidad de nuestro custom hook hacia useReducer</span> <span class="destacado">localStorage</span> <strong>useReducer:</strong> recordemos una excelente forma de manejar states más complejos o hacer operaciones en diferentes estados al mismo tiempo.</p>


            <!-- Bloque desplegable interior-->
            <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion11-ficheros').toggle();">
              <h3>FICHEROS FINALES</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion11-ficheros" class="hidden">
              
              <code class="cursor-pointer" onclick="$('#11-guitar').toggle();">Guitar.tsx</code>
              <pre id="11-guitar" class="hidden"><code class="language-ts">
                  //Guitar.tsx
                  import { Dispatch } from 'react'
                  import type { Guitar } from &#39;../types&#39;
                  import { CartActions } from &#39;../reducers/cart-reducer&#39;

                  type GuitarProps = {
                      guitar : Guitar, 
                      dispatch : Dispatch&lt;CartActions&gt;
                  }

                  export default function Guitar({guitar, dispatch} : GuitarProps) {

                      const { name, image, description, price } = guitar

                      return (
                          &lt;div className=&quot;col-md-6 col-lg-4 my-4 row align-items-center&quot;&gt;
                              &lt;div className=&quot;col-4&quot;&gt;
                                  &lt;img className=&quot;img-fluid&quot; src={`/img/${image}.jpg`} alt=&quot;imagen guitarra&quot; /&gt;
                              &lt;/div&gt;
                              &lt;div className=&quot;col-8&quot;&gt;
                                  &lt;h3 className=&quot;text-black fs-4 fw-bold text-uppercase&quot;&gt;{name}&lt;/h3&gt;
                                  &lt;p&gt;{description}&lt;/p&gt;
                                  &lt;p className=&quot;fw-black text-primary fs-3&quot;&gt;${price}&lt;/p&gt;
                                  &lt;button 
                                      type=&quot;button&quot;
                                      className=&quot;btn btn-dark w-100&quot;
                                      onClick={() =&gt; dispatch({type: &#39;add-to-cart&#39;, payload: {item: guitar} })}
                                  &gt;Agregar al Carrito&lt;/button&gt;
                              &lt;/div&gt;
                          &lt;/div&gt;
                      )
                  }  
              </code></pre>   

              <code class="cursor-pointer" onclick="$('#11-header').toggle();">Header.tsx</code>
              <pre id="11-header" class="hidden"><code class="language-ts">
                import { useMemo, Dispatch } from &quot;react&quot;
                import type { CartItem } from &quot;../types&quot;
                import { CartActions } from &quot;../reducers/cart-reducer&quot;
                
                type HeaderProps = {
                    cart: CartItem[]
                    dispatch: Dispatch&lt;CartActions&gt;
                }
                
                export default function Header({ cart, dispatch } : HeaderProps ) {
                
                    // State Derivado
                    const isEmpty = useMemo( () =&gt; cart.length === 0, [cart])
                    const cartTotal = useMemo( () =&gt; cart.reduce( (total, item ) =&gt; total + (item.quantity * item.price), 0), [cart] )
                
                    return (
                        &lt;header className=&quot;py-5 header&quot;&gt;
                            &lt;div className=&quot;container-xl&quot;&gt;
                                &lt;div className=&quot;row justify-content-center justify-content-md-between&quot;&gt;
                                    &lt;div className=&quot;col-8 col-md-3&quot;&gt;
                                        &lt;a href=&quot;index.html&quot;&gt;
                                            &lt;img className=&quot;img-fluid&quot; src=&quot;/img/logo.svg&quot; alt=&quot;imagen logo&quot; /&gt;
                                        &lt;/a&gt;
                                    &lt;/div&gt;
                                    &lt;nav className=&quot;col-md-6 a mt-5 d-flex align-items-start justify-content-end&quot;&gt;
                                        &lt;div 
                                            className=&quot;carrito&quot;
                                        &gt;
                                            &lt;img className=&quot;img-fluid&quot; src=&quot;/img/carrito.png&quot; alt=&quot;imagen carrito&quot; /&gt;
                
                                            &lt;div id=&quot;carrito&quot; className=&quot;bg-white p-3&quot;&gt;
                                                {isEmpty ? (
                                                    &lt;p className=&quot;text-center&quot;&gt;El carrito esta vacio&lt;/p&gt;
                                                ) : (
                                                &lt;&gt;
                                                    &lt;table className=&quot;w-100 table&quot;&gt;
                                                        &lt;thead&gt;
                                                            &lt;tr&gt;
                                                                &lt;th&gt;Imagen&lt;/th&gt;
                                                                &lt;th&gt;Nombre&lt;/th&gt;
                                                                &lt;th&gt;Precio&lt;/th&gt;
                                                                &lt;th&gt;Cantidad&lt;/th&gt;
                                                                &lt;th&gt;&lt;/th&gt;
                                                            &lt;/tr&gt;
                                                        &lt;/thead&gt;
                                                        &lt;tbody&gt;
                                                            {cart.map( guitar =&gt; (
                                                                &lt;tr key={guitar.id}&gt;
                                                                    &lt;td&gt;
                                                                        &lt;img 
                                                                            className=&quot;img-fluid&quot; 
                                                                            src={`/img/${guitar.image}.jpg`}
                                                                            alt=&quot;imagen guitarra&quot; 
                                                                        /&gt;
                                                                    &lt;/td&gt;
                                                                    &lt;td&gt;{guitar.name}&lt;/td&gt;
                                                                    &lt;td className=&quot;fw-bold&quot;&gt;
                                                                        ${guitar.price}
                                                                    &lt;/td&gt;
                                                                    &lt;td className=&quot;flex align-items-start gap-4&quot;&gt;
                                                                        &lt;button
                                                                            type=&quot;button&quot;
                                                                            className=&quot;btn btn-dark&quot;
                                                                            onClick={() =&gt; dispatch({type: &quot;decrease-quantity&quot;, payload:{id: guitar.id}})}
                                                                        &gt;
                                                                            -
                                                                        &lt;/button&gt;
                                                                            {guitar.quantity}
                                                                        &lt;button
                                                                            type=&quot;button&quot;
                                                                            className=&quot;btn btn-dark&quot;
                                                                            onClick={() =&gt; dispatch({type: &quot;increase-quantity&quot;, payload:{id: guitar.id}})}
                                                                        &gt;
                                                                            +
                                                                        &lt;/button&gt;
                                                                    &lt;/td&gt;
                                                                    &lt;td&gt;
                                                                        &lt;button
                                                                            className=&quot;btn btn-danger&quot;
                                                                            type=&quot;button&quot;
                                                                            onClick={() =&gt; dispatch({type: &#39;remove-from-cart&#39;, payload: {id: guitar.id}})}
                                                                        &gt;
                                                                            X
                                                                        &lt;/button&gt;
                                                                    &lt;/td&gt;
                                                                &lt;/tr&gt;
                                                            ))}
                                                        &lt;/tbody&gt;
                                                    &lt;/table&gt;
                
                                                    &lt;p className=&quot;text-end&quot;&gt;Total pagar: &lt;span className=&quot;fw-bold&quot;&gt;${cartTotal}&lt;/span&gt;&lt;/p&gt;
                                                &lt;/&gt;
                                                )}
                
                                                &lt;button 
                                                    className=&quot;btn btn-dark w-100 mt-3 p-2&quot;
                                                    onClick={()=&gt;dispatch({type: &quot;clear-cart&quot;})}
                                                &gt;Vaciar Carrito&lt;/button&gt;
                                            &lt;/div&gt;
                                        &lt;/div&gt;
                                    &lt;/nav&gt;
                                &lt;/div&gt;
                            &lt;/div&gt;
                        &lt;/header&gt;
                    )
                }                
              </code></pre>

              <code class="cursor-pointer" onclick="$('#11-data').toggle();">data&gt;db.ts</code>
              <pre id="11-data" class="hidden"><code class="language-ts">
                import type { Guitar } from '../types'

                export const db : Guitar[] = [
                    {
                        id: 1,
                        name: 'Lukather',
                        image: 'guitarra_01',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 299
                    },
                    {
                        id: 2,
                        name: 'SRV',
                        image: 'guitarra_02',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 349,
                    },
                    {
                        id: 3,
                        name: 'Borland',
                        image: 'guitarra_03',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 329,
                    },
                    {
                        id: 4,
                        name: 'VAI',
                        image: 'guitarra_04',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 299,
                    },
                    {
                        id: 5,
                        name: 'Thompson',
                        image: 'guitarra_05',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 399,
                    },
                    {
                        id: 6,
                        name: 'White',
                        image: 'guitarra_06',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 329,
                    },
                    {
                        id: 7,
                        name: 'Cobain',
                        image: 'guitarra_07',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 349,
                    },
                    {
                        id: 8,
                        name: 'Dale',
                        image: 'guitarra_08',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 379,
                    },
                    {
                        id: 9,
                        name: 'Krieger',
                        image: 'guitarra_09',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 289,
                    },
                    {
                        id: 10,
                        name: 'Campbell',
                        image: 'guitarra_10',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 349,
                    },
                    {
                        id: 11,
                        name: 'Reed',
                        image: 'guitarra_11',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 399,
                    },
                    {
                        id: 12,
                        name: 'Hazel',
                        image: 'guitarra_12',
                        description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                        price: 379,
                    },
                  ]
              </code></pre>

              <code class="cursor-pointer" onclick="$('#11-reducer').toggle();">reducer&gt;cart-reducer.ts</code>
              <pre id="11-reducer" class="hidden"><code class="language-ts">
                import { db } from &#39;../data/db&#39;
                import type { CartItem, Guitar } from &quot;../types&quot;
                
                export type CartActions = 
                    { type: &#39;add-to-cart&#39;, payload: {item : Guitar}} |
                    { type: &#39;remove-from-cart&#39;, payload: {id : Guitar[&#39;id&#39;]}} |
                    { type: &#39;decrease-quantity&#39;, payload: {id: Guitar[&#39;id&#39;]}} |
                    { type: &#39;increase-quantity&#39;, payload: {id: Guitar[&#39;id&#39;]}} |
                    { type: &#39;clear-cart&#39;}
                
                export type CartState = {
                    data: Guitar[],
                    cart: CartItem[]
                }
                const initialCart = () : CartItem[] =&gt; {
                    const localStorageCart = localStorage.getItem(&#39;cart&#39;)
                    return localStorageCart ? JSON.parse(localStorageCart) : []
                }
                export const initialState : CartState = {
                    data: db, //nuestra bbdd de guitarra con los datos
                    //cart: []
                    cart: initialCart()
                }
                
                const MIN_ITEMS = 1
                const MAX_ITEMS = 5
                
                export const cartReducer = (    
                        state: CartState = initialState,
                        action: CartActions
                    ) =&gt; {
                
                    if (action.type === &quot;add-to-cart&quot;){
                        const itemExists = state.cart.find(guitar =&gt; guitar.id === action.payload.item.id)
                        //console.log(itemExists)
                        let updatedCart : CartItem[] = []
                        if(itemExists ) { // existe en el carrito
                            updatedCart = state.cart.map(item =&gt; {
                                if(item.id === action.payload.item.id){ //ese es el elemento que el user está agregando repetido
                                    if(item.quantity &lt; MAX_ITEMS){ //le permitimos agregarlo
                                        return{...item,quantity: item.quantity + 1 } //copia del item e incrementamos quantity
                                    } else {
                                        return item // llegamos a 5, no se cumple lo anterior pero mantenemos lo que teníamos en el carrito
                                    }
                                } else {//el que no estamos agregando repetido pero no queremos perder
                                    return item
                                }
                            })            
                        } else {
                            const newItem : CartItem = {...action.payload.item, quantity : 1}
                            updatedCart = [...state.cart, newItem]
                        }
                
                        return{
                            ...state,
                            cart: updatedCart
                        }
                    }
                    if (action.type === &quot;remove-from-cart&quot;){
                        const updatedCart = state.cart.filter( item =&gt; item.id !== action.payload.id)       
                        return{
                            ...state,
                            cart: updatedCart
                        }
                    }
                    if (action.type === &quot;decrease-quantity&quot;){
                        const updatedCart = state.cart.map( item =&gt; {
                            if(item.id === action.payload.id &amp;&amp; item.quantity &gt; MIN_ITEMS) {
                                return {
                                    ...item,
                                    quantity: item.quantity - 1
                                }
                            }
                            return item
                        })    
                        return{
                            ...state,
                            cart: updatedCart
                        }
                    }
                    if(action.type === &quot;increase-quantity&quot;){
                        const updatedCart = state.cart.map( item =&gt; {
                            if(item.id === action.payload.id &amp;&amp; item.quantity &lt; MAX_ITEMS) {
                                return {
                                    ...item,
                                    quantity: item.quantity + 1
                                }
                            }
                            return item
                        })        
                        return{
                            ...state,
                            cart: updatedCart
                        }
                    }
                    if(action.type === &quot;clear-cart&quot;){
                        const updatedCart : CartItem[] = []
                        return{
                            ...state,
                            cart: updatedCart
                        }
                    }
                
                    return state
                    
                }
              </code></pre>

              <code class="cursor-pointer" onclick="$('#11-indexts').toggle();">types&gt;index.ts</code>
              <pre id="11-indexts" class="hidden"><code class="language-ts">
                export type Guitar = {
                  id: number
                  name: string
                  image: string
                  description: string
                  price: number
              }
              
              export type CartItem = Guitar & {
                  quantity: number
              }
              
              // export type CartItem = Pick&lt;Guitar, &#39;id&#39; | &#39;name&#39; | &#39;price&#39; &gt; &amp; {
              //     quantity: number
              // }
              // export type CartItem = Omit&lt;Guitar, &#39;id&#39; | &#39;name&#39; | &#39;price&#39; &gt; &amp; {
              //     quantity: number
              // }
              </code></pre>

              <code class="cursor-pointer" onclick="$('#11-app').toggle();">App.tsx</code>
              <pre id="11-app" class="hidden"><code class="language-ts">
                import { useReducer, useEffect } from &quot;react&quot;
                import Guitar from &quot;./components/Guitar&quot;
                import Header from &quot;./components/Header&quot;
                import { cartReducer, initialState } from &quot;./reducers/cart-reducer&quot;
                
                function App() {
                
                  const [state,dispatch] = useReducer(cartReducer, initialState)
                
                  useEffect(() =&gt; {
                    localStorage.setItem(&#39;cart&#39;, JSON.stringify(state.cart))
                  }, [state.cart])
                
                  return (
                    &lt;&gt;
                      &lt;Header 
                        cart={state.cart}
                        dispatch={dispatch}     
                      /&gt;
                      
                      &lt;main className=&quot;container-xl mt-5&quot;&gt;
                          &lt;h2 className=&quot;text-center&quot;&gt;Nuestra Colección&lt;/h2&gt;
                
                          &lt;div className=&quot;row mt-5&quot;&gt;
                              {state.data.map((guitar) =&gt; (
                                  &lt;Guitar 
                                    key={guitar.id}
                                    guitar={guitar}
                                    dispatch={dispatch}
                                  /&gt;
                              ))}
                              
                          &lt;/div&gt;
                      &lt;/main&gt;
                
                
                      &lt;footer className=&quot;bg-dark mt-5 py-5&quot;&gt;
                          &lt;div className=&quot;container-xl&quot;&gt;
                              &lt;p className=&quot;text-white text-center fs-4 mt-4 m-md-0&quot;&gt;GuitarLA - Todos los derechos Reservados&lt;/p&gt;
                          &lt;/div&gt;
                      &lt;/footer&gt;
                    &lt;/&gt;
                  )
                }
                
                export default App                
              </code></pre>

              <code class="cursor-pointer" onclick="$('#11-indexcss').toggle();">index.css</code>
              <pre id="11-indexcss" class="hidden"><code class="language-css">
                @charset "UTF-8";
                .fw-black {
                  font-weight: 900;
                }
                
                .btn-dark {
                  text-transform: uppercase;
                }
                
                .carrito {
                  background-color: transparent;
                  border: none;
                  max-width: 2rem;
                  position: relative;
                  z-index: 100;
                }
                
                .carrito #carrito {
                  display: none;
                  position: absolute;
                  box-shadow: 0px 10px 15px -3px rgba(0,0,0,0.1);
                }
                
                .carrito:hover #carrito {
                  display: block;
                  background-color: white;
                  padding: 10px;
                  height: fit-content;
                  min-width: 350px;
                  width: fit-content;
                  top: 100%;
                  right: 0;
                  left: unset;
                  margin-left: unset;
                  margin-right: unset;
                }
                
                #carrito img {
                  width: 30px;
                }
                
                #carrito .btn-danger {
                  font-size: 10px;
                  border-radius: 50%;
                  padding: 5px 9px;
                }
                
                #carrito .btn-dark {
                  padding: 0 2px;
                  margin: 0 3px;
                }
                .m-0 {
                  margin: 0;
                }
                /*!
                 * Bootstrap  v5.2.3 (https://getbootstrap.com/)
                 * Copyright 2011-2022 The Bootstrap Authors
                 * Copyright 2011-2022 Twitter, Inc.
                 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
                 */
                :root {
                  --bs-blue: #0d6efd;
                  --bs-indigo: #6610f2;
                  --bs-purple: #6f42c1;
                  --bs-pink: #d63384;
                  --bs-red: #dc3545;
                  --bs-orange: #fd7e14;
                  --bs-yellow: #ffc107;
                  --bs-green: #198754;
                  --bs-teal: #20c997;
                  --bs-cyan: #0dcaf0;
                  --bs-black: #000;
                  --bs-white: #FFF;
                  --bs-gray: #6c757d;
                  --bs-gray-dark: #343a40;
                  --bs-gray-100: #f8f9fa;
                  --bs-gray-200: #e9ecef;
                  --bs-gray-300: #dee2e6;
                  --bs-gray-400: #ced4da;
                  --bs-gray-500: #adb5bd;
                  --bs-gray-600: #6c757d;
                  --bs-gray-700: #495057;
                  --bs-gray-800: #343a40;
                  --bs-gray-900: #212529;
                  --bs-primary: #e99401;
                  --bs-secondary: #6c757d;
                  --bs-success: #198754;
                  --bs-info: #0dcaf0;
                  --bs-warning: #ffc107;
                  --bs-danger: #dc3545;
                  --bs-light: #f8f9fa;
                  --bs-dark: #262626;
                  --bs-primary-rgb: 233, 148, 1;
                  --bs-secondary-rgb: 108, 117, 125;
                  --bs-success-rgb: 25, 135, 84;
                  --bs-info-rgb: 13, 202, 240;
                  --bs-warning-rgb: 255, 193, 7;
                  --bs-danger-rgb: 220, 53, 69;
                  --bs-light-rgb: 248, 249, 250;
                  --bs-dark-rgb: 38, 38, 38;
                  --bs-white-rgb: 255, 255, 255;
                  --bs-black-rgb: 0, 0, 0;
                  --bs-body-color-rgb: 33, 37, 41;
                  --bs-body-bg-rgb: 255, 255, 255;
                  --bs-font-sans-serif: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", "Noto Sans", "Liberation Sans", Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
                  --bs-font-monospace: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
                  --bs-gradient: linear-gradient(180deg, rgba(255, 255, 255, 0.15), rgba(255, 255, 255, 0));
                  --bs-body-font-family: Outfit, sans-serif;
                  --bs-body-font-size: 1rem;
                  --bs-body-font-weight: 400;
                  --bs-body-line-height: 1.5;
                  --bs-body-color: #212529;
                  --bs-body-bg: #FFF;
                  --bs-border-width: 1px;
                  --bs-border-style: solid;
                  --bs-border-color: #dee2e6;
                  --bs-border-color-translucent: rgba(0, 0, 0, 0.175);
                  --bs-border-radius: 0.375rem;
                  --bs-border-radius-sm: 0.25rem;
                  --bs-border-radius-lg: 0.5rem;
                  --bs-border-radius-xl: 1rem;
                  --bs-border-radius-2xl: 2rem;
                  --bs-border-radius-pill: 50rem;
                  --bs-link-color: #FFF;
                  --bs-link-hover-color: #FFF;
                  --bs-code-color: #d63384;
                  --bs-highlight-bg: #fff3cd;
                }
                
                *,
                *::before,
                *::after {
                  box-sizing: border-box;
                }
                
                @media (prefers-reduced-motion: no-preference) {
                  :root {
                    scroll-behavior: smooth;
                  }
                }
                
                body {
                  margin: 0;
                  font-family: var(--bs-body-font-family);
                  font-size: var(--bs-body-font-size);
                  font-weight: var(--bs-body-font-weight);
                  line-height: var(--bs-body-line-height);
                  color: var(--bs-body-color);
                  text-align: var(--bs-body-text-align);
                  background-color: var(--bs-body-bg);
                  -webkit-text-size-adjust: 100%;
                  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
                }
                
                 h3, .h3, h2, .h2, h1, .h1 {
                  margin-top: 0;
                  margin-bottom: 0.5rem;
                  font-family: "Outfit", sans-serif;
                  font-weight: 900;
                  line-height: 1.2;
                  color: #e99401;
                }
                
                h1, .h1 {
                  font-size: calc(1.565rem + 3.78vw);
                }
                @media (min-width: 1200px) {
                  h1, .h1 {
                    font-size: 4.4rem;
                  }
                }
                
                h2, .h2 {
                  font-size: calc(1.485rem + 2.82vw);
                }
                @media (min-width: 1200px) {
                  h2, .h2 {
                    font-size: 3.6rem;
                  }
                }
                
                h3, .h3 {
                  font-size: calc(1.385rem + 1.62vw);
                }
                @media (min-width: 1200px) {
                  h3, .h3 {
                    font-size: 2.6rem;
                  }
                }
                
                p {
                  margin-top: 0;
                  margin-bottom: 1rem;
                }
                
                a {
                  color: var(--bs-link-color);
                  text-decoration: none;
                }
                a:hover {
                  color: var(--bs-link-hover-color);
                }
                
                a:not([href]):not([class]), a:not([href]):not([class]):hover {
                  color: inherit;
                  text-decoration: none;
                }
                
                img,
                svg {
                  vertical-align: middle;
                }
                
                table {
                  caption-side: bottom;
                  border-collapse: collapse;
                }
                
                th {
                  text-align: inherit;
                  text-align: -webkit-match-parent;
                }
                
                thead,
                tbody,
                tr,
                td,
                th {
                  border-color: inherit;
                  border-style: solid;
                  border-width: 0;
                }
                
                button {
                  border-radius: 0;
                }
                
                button:focus:not(:focus-visible) {
                  outline: 0;
                }
                
                
                button {
                  margin: 0;
                  font-family: inherit;
                  font-size: inherit;
                  line-height: inherit;
                }
                
                button {
                  text-transform: none;
                }
                
                button,
                [type=button] {
                  -webkit-appearance: button;
                }
                button:not(:disabled),
                [type=button]:not(:disabled) {
                  cursor: pointer;
                }
                
                ::-moz-focus-inner {
                  padding: 0;
                  border-style: none;
                }
                
                ::-webkit-datetime-edit-fields-wrapper,
                ::-webkit-datetime-edit-text,
                ::-webkit-datetime-edit-minute,
                ::-webkit-datetime-edit-hour-field,
                ::-webkit-datetime-edit-day-field,
                ::-webkit-datetime-edit-month-field,
                ::-webkit-datetime-edit-year-field {
                  padding: 0;
                }
                
                ::-webkit-inner-spin-button {
                  height: auto;
                }
                
                /* rtl:raw:
                [type="tel"],
                [type="url"],
                [type="email"],
                [type="number"] {
                  direction: ltr;
                }
                */
                ::-webkit-search-decoration {
                  -webkit-appearance: none;
                }
                
                ::-webkit-color-swatch-wrapper {
                  padding: 0;
                }
                
                ::file-selector-button {
                  font: inherit;
                  -webkit-appearance: button;
                }
                
                .display-2 {
                  font-size: calc(1.575rem + 3.9vw);
                  font-weight: 300;
                  line-height: 1.2;
                }
                @media (min-width: 1200px) {
                  .display-2 {
                    font-size: 4.5rem;
                  }
                }
                
                .img-fluid {
                  max-width: 100%;
                  height: auto;
                }
                
                
                .container-xl {
                  --bs-gutter-x: 1.5rem;
                  --bs-gutter-y: 0;
                  width: 100%;
                  padding-right: calc(var(--bs-gutter-x) * 0.5);
                  padding-left: calc(var(--bs-gutter-x) * 0.5);
                  margin-right: auto;
                  margin-left: auto;
                }
                @media (min-width: 1200px) {
                  .container-xl {
                    max-width: 1140px;
                  }
                }
                @media (min-width: 1400px) {
                   .container-xl {
                    max-width: 1320px;
                  }
                }
                .row {
                  --bs-gutter-x: 1.5rem;
                  --bs-gutter-y: 0;
                  display: flex;
                  flex-wrap: wrap;
                  margin-top: calc(-1 * var(--bs-gutter-y));
                  margin-right: calc(-0.5 * var(--bs-gutter-x));
                  margin-left: calc(-0.5 * var(--bs-gutter-x));
                }
                .row > * {
                  flex-shrink: 0;
                  width: 100%;
                  max-width: 100%;
                  padding-right: calc(var(--bs-gutter-x) * 0.5);
                  padding-left: calc(var(--bs-gutter-x) * 0.5);
                  margin-top: var(--bs-gutter-y);
                }
                
                .col-4 {
                  flex: 0 0 auto;
                  width: 33.33333333%;
                }
                
                .col-8 {
                  flex: 0 0 auto;
                  width: 66.66666667%;
                }
                @media (min-width: 768px) {
                  .col-md-3 {
                    flex: 0 0 auto;
                    width: 25%;
                  }
                  .col-md-6 {
                    flex: 0 0 auto;
                    width: 50%;
                  }
                }
                @media (min-width: 992px) {
                  .col-lg-4 {
                    flex: 0 0 auto;
                    width: 33.33333333%;
                  }
                }
                .table {
                  --bs-table-color: var(--bs-body-color);
                  --bs-table-bg: transparent;
                  --bs-table-border-color: var(--bs-border-color);
                  --bs-table-accent-bg: transparent;
                  --bs-table-striped-color: var(--bs-body-color);
                  --bs-table-striped-bg: rgba(0, 0, 0, 0.05);
                  --bs-table-active-color: var(--bs-body-color);
                  --bs-table-active-bg: rgba(0, 0, 0, 0.1);
                  --bs-table-hover-color: var(--bs-body-color);
                  --bs-table-hover-bg: rgba(0, 0, 0, 0.075);
                  width: 100%;
                  margin-bottom: 1rem;
                  color: var(--bs-table-color);
                  vertical-align: top;
                  border-color: var(--bs-table-border-color);
                }
                .table > :not(caption) > * > * {
                  padding: 0.5rem 0.5rem;
                  background-color: var(--bs-table-bg);
                  border-bottom-width: 1px;
                  box-shadow: inset 0 0 0 9999px var(--bs-table-accent-bg);
                }
                .table > tbody {
                  vertical-align: inherit;
                }
                .table > thead {
                  vertical-align: bottom;
                }
                
                .btn {
                  --bs-btn-padding-x: 0.75rem;
                  --bs-btn-padding-y: 0.375rem;
                  --bs-btn-font-family: ;
                  --bs-btn-font-size: 1rem;
                  --bs-btn-font-weight: 900;
                  --bs-btn-line-height: 1.5;
                  --bs-btn-color: #212529;
                  --bs-btn-bg: transparent;
                  --bs-btn-border-width: 1px;
                  --bs-btn-border-color: transparent;
                  --bs-btn-border-radius: 0;
                  --bs-btn-hover-border-color: transparent;
                  --bs-btn-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.15), 0 1px 1px rgba(0, 0, 0, 0.075);
                  --bs-btn-disabled-opacity: 0.65;
                  --bs-btn-focus-box-shadow: 0 0 0 0.25rem rgba(var(--bs-btn-focus-shadow-rgb), .5);
                  display: inline-block;
                  padding: var(--bs-btn-padding-y) var(--bs-btn-padding-x);
                  font-family: var(--bs-btn-font-family);
                  font-size: var(--bs-btn-font-size);
                  font-weight: var(--bs-btn-font-weight);
                  line-height: var(--bs-btn-line-height);
                  color: var(--bs-btn-color);
                  text-align: center;
                  vertical-align: middle;
                  cursor: pointer;
                  user-select: none;
                  border: var(--bs-btn-border-width) solid var(--bs-btn-border-color);
                  border-radius: var(--bs-btn-border-radius);
                  background-color: var(--bs-btn-bg);
                  transition: color 0.15s ease-in-out, background-color 0.15s ease-in-out, border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
                }
                @media (prefers-reduced-motion: reduce) {
                  .btn {
                    transition: none;
                  }
                }
                .btn:hover {
                  color: var(--bs-btn-hover-color);
                  background-color: var(--bs-btn-hover-bg);
                  border-color: var(--bs-btn-hover-border-color);
                }
                .btn:focus-visible {
                  color: var(--bs-btn-hover-color);
                  background-color: var(--bs-btn-hover-bg);
                  border-color: var(--bs-btn-hover-border-color);
                  outline: 0;
                  box-shadow: var(--bs-btn-focus-box-shadow);
                }
                 :not(.btn-check) + .btn:active, .btn:first-child:active {
                  color: var(--bs-btn-active-color);
                  background-color: var(--bs-btn-active-bg);
                  border-color: var(--bs-btn-active-border-color);
                }
                 :not(.btn-check) + .btn:active:focus-visible, .btn:first-child:active:focus-visible {
                  box-shadow: var(--bs-btn-focus-box-shadow);
                }
                .btn:disabled {
                  color: var(--bs-btn-disabled-color);
                  pointer-events: none;
                  background-color: var(--bs-btn-disabled-bg);
                  border-color: var(--bs-btn-disabled-border-color);
                  opacity: var(--bs-btn-disabled-opacity);
                }
                
                .btn-danger {
                  --bs-btn-color: #FFF;
                  --bs-btn-bg: #dc3545;
                  --bs-btn-border-color: #dc3545;
                  --bs-btn-hover-color: #FFF;
                  --bs-btn-hover-bg: #bb2d3b;
                  --bs-btn-hover-border-color: #b02a37;
                  --bs-btn-focus-shadow-rgb: 225, 83, 97;
                  --bs-btn-active-color: #FFF;
                  --bs-btn-active-bg: #b02a37;
                  --bs-btn-active-border-color: #a52834;
                  --bs-btn-active-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
                  --bs-btn-disabled-color: #FFF;
                  --bs-btn-disabled-bg: #dc3545;
                  --bs-btn-disabled-border-color: #dc3545;
                }
                
                .btn-dark {
                  --bs-btn-color: #FFF;
                  --bs-btn-bg: #262626;
                  --bs-btn-border-color: #262626;
                  --bs-btn-hover-color: #FFF;
                  --bs-btn-hover-bg: #474747;
                  --bs-btn-hover-border-color: #3c3c3c;
                  --bs-btn-focus-shadow-rgb: 71, 71, 71;
                  --bs-btn-active-color: #FFF;
                  --bs-btn-active-bg: #515151;
                  --bs-btn-active-border-color: #3c3c3c;
                  --bs-btn-active-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.125);
                  --bs-btn-disabled-color: #FFF;
                  --bs-btn-disabled-bg: #262626;
                  --bs-btn-disabled-border-color: #262626;
                }
                
                .nav {
                  --bs-nav-link-padding-x: 1rem;
                  --bs-nav-link-padding-y: 0.5rem;
                  --bs-nav-link-font-weight: ;
                  --bs-nav-link-color: var(--bs-link-color);
                  --bs-nav-link-hover-color: var(--bs-link-hover-color);
                  --bs-nav-link-disabled-color: #6c757d;
                  display: flex;
                  flex-wrap: wrap;
                  padding-left: 0;
                  margin-bottom: 0;
                  list-style: none;
                }
                
                @keyframes progress-bar-stripes {
                  0% {
                    background-position-x: 1rem;
                  }
                }
                
                /* rtl:begin:ignore */
                
                /* rtl:end:ignore */
                
                /* rtl:begin:ignore */
                
                /* rtl:end:ignore */
                
                /* rtl:begin:ignore */
                
                /* rtl:end:ignore */
                
                /* rtl:begin:ignore */
                
                /* rtl:end:ignore */
                
                /* rtl:options: {
                  "autoRename": true,
                  "stringMap":[ {
                    "name"    : "prev-next",
                    "search"  : "prev",
                    "replace" : "next"
                  } ]
                } */
                
                @keyframes spinner-border {
                  to {
                    transform: rotate(360deg) /* rtl:ignore */;
                  }
                }
                
                @keyframes spinner-grow {
                  0% {
                    transform: scale(0);
                  }
                  50% {
                    opacity: 1;
                    transform: none;
                  }
                }
                
                @keyframes placeholder-glow {
                  50% {
                    opacity: 0.2;
                  }
                }
                
                @keyframes placeholder-wave {
                  100% {
                    mask-position: -200% 0%;
                  }
                }
                
                .d-flex {
                  display: flex !important;
                }
                
                .w-100 {
                  width: 100% !important;
                }
                
                .justify-content-end {
                  justify-content: flex-end !important;
                }
                
                .justify-content-center {
                  justify-content: center !important;
                }
                
                .align-items-start {
                  align-items: flex-start !important;
                }
                
                .align-items-center {
                  align-items: center !important;
                }
                
                .my-4 {
                  margin-top: 1.5rem !important;
                  margin-bottom: 1.5rem !important;
                }
                
                .mt-3 {
                  margin-top: 1rem !important;
                }
                
                .mt-4 {
                  margin-top: 1.5rem !important;
                }
                
                .mt-5 {
                  margin-top: 3rem !important;
                }
                
                .p-2 {
                  padding: 0.5rem !important;
                }
                
                .p-3 {
                  padding: 1rem !important;
                }
                
                .px-5 {
                  padding-right: 3rem !important;
                  padding-left: 3rem !important;
                }
                
                .py-2 {
                  padding-top: 0.5rem !important;
                  padding-bottom: 0.5rem !important;
                }
                
                .py-5 {
                  padding-top: 3rem !important;
                  padding-bottom: 3rem !important;
                }
                
                .pt-5 {
                  padding-top: 3rem !important;
                }
                
                .gap-4 {
                  gap: 1.5rem !important;
                }
                
                .fs-1 {
                  font-size: calc(1.565rem + 3.78vw) !important;
                }
                
                .fs-3 {
                  font-size: calc(1.385rem + 1.62vw) !important;
                }
                
                .fs-4 {
                  font-size: calc(1.275rem + 0.3vw) !important;
                }
                
                .fs-5 {
                  font-size: 1.25rem !important;
                }
                
                .fw-bold {
                  font-weight: 700 !important;
                }
                
                .text-end {
                  text-align: right !important;
                }
                
                .text-center {
                  text-align: center !important;
                }
                
                .text-uppercase {
                  text-transform: uppercase !important;
                }
                
                /* rtl:begin:remove */
                
                /* rtl:end:remove */
                .text-primary {
                  --bs-text-opacity: 1;
                  color: rgba(var(--bs-primary-rgb), var(--bs-text-opacity)) !important;
                }
                
                .text-black {
                  --bs-text-opacity: 1;
                  color: rgba(var(--bs-black-rgb), var(--bs-text-opacity)) !important;
                }
                
                .text-white {
                  --bs-text-opacity: 1;
                  color: rgba(var(--bs-white-rgb), var(--bs-text-opacity)) !important;
                }
                
                .bg-primary {
                  --bs-bg-opacity: 1;
                  background-color: rgba(var(--bs-primary-rgb), var(--bs-bg-opacity)) !important;
                }
                
                .bg-dark {
                  --bs-bg-opacity: 1;
                  background-color: rgba(var(--bs-dark-rgb), var(--bs-bg-opacity)) !important;
                }
                
                .bg-white {
                  --bs-bg-opacity: 1;
                  background-color: rgba(var(--bs-white-rgb), var(--bs-bg-opacity)) !important;
                }
                @media (min-width: 768px) {
                  .justify-content-md-between {
                    justify-content: space-between !important;
                  }
                  .m-md-0 {
                    margin: 0 !important;
                  }
                  .text-md-start {
                    text-align: left !important;
                  }
                }
                @media (min-width: 1200px) {
                  .fs-1 {
                    font-size: 4.4rem !important;
                  }
                  .fs-3 {
                    font-size: 2.6rem !important;
                  }
                  .fs-4 {
                    font-size: 1.5rem !important;
                  }
                }
                @keyframes animarImagen {
                  0% {
                    opacity: 0;
                    transform: translateX(-10rem);
                  }
                  50% {
                    opacity: 0;
                  }
                  100% {
                    opacity: 1;
                    transform: translateX(0);
                  }
                }
                .header {
                  background-image: linear-gradient(to right, rgba(0, 0, 0, 0.7), rgba(0, 0, 0, 0.7)), url("/img/header.jpg");
                  background-position: 50%;
                  background-size: cover;
                  position: relative;
                }
                .header .header-guitarra {
                  display: none;
                }
                @media (min-width: 992px) {
                  .header .header-guitarra {
                    display: block;
                    position: absolute;
                    right: 0;
                    bottom: 0;
                    animation-duration: 1s;
                    animation-delay: 0s;
                    animation-timing-function: ease-in-out;
                    animation-name: animarImagen;
                    z-index: 10;
                  }
                }
              </code></pre>

              <code class="cursor-pointer" onclick="$('#11-maintsx').toggle();">main.tsx</code>
              <pre id="11-maintsx" class="hidden"><code class="language-js">
                import React from 'react'
                import ReactDOM from 'react-dom/client'
                import App from './App.jsx'
                import './index.css'
                
                ReactDOM.createRoot(document.getElementById('root')!).render(
                  &lt;React.StrictMode&gt;
                    &lt;App /&gt;
                  &lt;/React.StrictMode&gt;,
                )
              </code></pre>                     
            </div>


            <!-- Bloque desplegable interior-->
            <div class="flex justify-between items-center mt-1.25 cursor-pointer oscuro" onclick="$('#seccion11-167').toggle();">
              <h3>167. Primeros pasos</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion11-167" class="hidden">
              <p>Bajamos el .zip de Recursos <strong>06-guitarla-ts-usereducer.zip</strong> y descomprimimos y nos quedamos con el de windows. Yo lo renombro a <span class="file">guitarla-ur</span> e instalamos dependencias <span class="destacado">npm install</span></p>
              <p>Gran parte de nuestro trabajo va a ser abrir nuestro fichero de hooks>useCart.ts y llevar todo ello hacia useReducer:</p>
              <pre><code class="language-js">
                //hooks>useCart.ts
                import { useState, useEffect, useMemo } from &#39;react&#39;
                import { db } from &#39;../data/db&#39;
                import type { Guitar, CartItem } from &#39;../types&#39;
                
                export const useCart = () =&gt; {
                
                    const initialCart = () : CartItem[] =&gt; {
                        const localStorageCart = localStorage.getItem(&#39;cart&#39;)
                        return localStorageCart ? JSON.parse(localStorageCart) : []
                    }
                
                    const [data] = useState(db)
                    const [cart, setCart] = useState(initialCart)
                
                    const MIN_ITEMS = 1
                    const MAX_ITEMS = 5
                
                    useEffect(() =&gt; {
                        localStorage.setItem(&#39;cart&#39;, JSON.stringify(cart))
                    }, [cart])
                
                    function addToCart(item : Guitar) {
                        const itemExists = cart.findIndex(guitar =&gt; guitar.id === item.id)
                        if(itemExists &gt;= 0 ) { // existe en el carrito
                            if(cart[itemExists].quantity &gt;= MAX_ITEMS) return
                            const updatedCart = [...cart]
                            updatedCart[itemExists].quantity++
                            setCart(updatedCart)
                        } else {
                            const newItem : CartItem = {...item, quantity : 1}
                            setCart([...cart, newItem])
                        }
                    }
                
                    function removeFromCart(id : Guitar[&#39;id&#39;]) {
                        setCart(prevCart =&gt; prevCart.filter(guitar =&gt; guitar.id !== id))
                    }
                
                    function decreaseQuantity(id : Guitar[&#39;id&#39;]) {
                        const updatedCart = cart.map( item =&gt; {
                            if(item.id === id &amp;&amp; item.quantity &gt; MIN_ITEMS) {
                                return {
                                    ...item,
                                    quantity: item.quantity - 1
                                }
                            }
                            return item
                        })
                        setCart(updatedCart)
                    }
                
                    function increaseQuantity(id : Guitar[&#39;id&#39;]) {
                        const updatedCart = cart.map( item =&gt; {
                            if(item.id === id &amp;&amp; item.quantity &lt; MAX_ITEMS) {
                                return {
                                    ...item,
                                    quantity: item.quantity + 1
                                }
                            }
                            return item
                        })
                        setCart(updatedCart)
                    }
                
                    function clearCart() {
                        setCart([])
                    }
                
                    // State Derivado
                    const isEmpty = useMemo( () =&gt; cart.length === 0, [cart])
                    const cartTotal = useMemo( () =&gt; cart.reduce( (total, item ) =&gt; total + (item.quantity * item.price), 0), [cart] )
                
                    return {
                        data,
                        cart,
                        addToCart,
                        removeFromCart,
                        decreaseQuantity,
                        increaseQuantity,
                        clearCart,
                        isEmpty,
                        cartTotal
                    }
                }
              </code></pre>

            </div>

            <!-- Bloque desplegable interior-->
            <div class="flex justify-between items-center mt-1.25 cursor-pointer oscuro" onclick="$('#seccion11-168').toggle();">
              <h3>168. Creando el reducer y el type de acciones / 169. Definiendo el State inicial / 170. Escribiendo el resto de las acciones</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion11-168" class="hidden">
              <p>Hacer esto no significa que el custom hook que hemos creado esté mal, hay muchos proyectos que lo hacen así, pero está intentando abrcar todo lo que hay que saber de React.</p>
              <p>Creamos en la carpeta src <span class="file">reducers&gt;cart-reducer.ts</span></p>
              <pre><code class="language-js">
                //reducers/cart-reducer.ts
                export type CartActions = {
    
                }
              </code></pre>
              <p class="naranja">Definiendo el type de acciones</p>
              <p>Cojamos las funciones siguientes de nuestro hook useCart.ts y convirtámoslas en un action en nuestro reducer:</p>
              
              
              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre data-line="0"><code class="language-js">
                    //hooks/useCart.ts                    
                    function addToCart(item : Guitar) { ... }
                    function removeFromCart(id : Guitar['id']) { ... }
                    function decreaseQuantity(id : Guitar['id']) { ... }
                    function increaseQuantity(id : Guitar['id']) { ... }
                    function clearCart() {
                        setCart([])
                    }
                  </code></pre>
                  <div class="bg-white">
                    <svg class="size-6 shrink-0 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                    </svg>
                  </div>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre data-line="0"><code class="language-js">
                    //cart-reducer.ts
                    import type { Guitar } from "../types"

                    export type CartActions = 
                        { type: 'add-to-cart', payload: {item : Guitar}} |
                        { type: 'remove-from-cart', payload: {id : Guitar['id']}} |
                        { type: 'decrease-quantity', payload: {id: Guitar['id']}} |
                        { type: 'increase-quantity', payload: {id: Guitar['id']}} |
                        { type: 'clear-cart'}
                  </code></pre>
                </div>
              </div>
              <p>Ya tenemos definidas todas las acciones y nos hace falta toda la lógica que veremos a continuación.</p>

              <p class="naranja">Definiendo el type de state y state inicial</p>
            
              <p><strong>Definamos el type y state inicial de nuestro carrito</strong> Nuestro proyecto solo tiene 2 states, uno los datos y otro el carrito. Una vez definido el type de nuestro carrito definimos el state inicial (<strong>¡Recordar! este se utiliza cuando utilizamos useReducer</strong>):</p>
              

              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre data-line="0"><code class="language-js">
                    //useCart.ts
                    const [data] = useState(db)
                    const [cart, setCart] = useState(initialCart)
                  </code></pre>
                  <div class="bg-white">
                    <svg class="size-6 shrink-0 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                    </svg>
                  </div>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre data-line="0"><code class="language-js">
                    //cart-reducer.ts
                    import { db } from '../data/db'
                    import type { CartItem, Guitar } from "../types"
                    ...
                    export type CartState = {
                      data: Guitar[],
                      cart: CartItem[]
                    } 
                    export const initialState : CartState = {
                      data: db, //nuestra bbdd de guitarra con los datos
                      cart: [] //de momento arreglo vacío pero recordemos que viene de localStorage, ahora lo hacemos                  
                  }
                  </code></pre>
                </div>
              </div>              

              <p class="naranja">Definiendo el reducer</p>

              <p>Creamos el reducer, con todas la funcionalidad para interaccionar con el state. Por tanto creamos cartReducer (con un export pues también este lo vamos a requerir cuando utilicemos el Hook de useReducer).</p>
              
              <ul class="my-2 list-disc">
                <li class="my-1">En la primera parte de los paréntesis le hacemos saber a este reducer cual es nuestro state y qué acciones son las que tenemos disponibles, colocando como parámetros y con esos types el state y las acciones. Con ello tenemos nuestro maravilloso autocompletado en el reducer.
                  <pre><code class="language-js">
                    //cart-reducer.ts                
                    export const cartReducer = (    
                      state: CartState = initialState,
                      actions: CartActions
                      ) => {
                        
                        reurn state
                    }
                  </code></pre>
                </li>
                <li class="my-1">y entonces ya podemos comenzar a definir todas las acciones. <strong>Vamos colocando los if validando el action.type con los nombres de las acciones que tenemos definidas en la parte superior</strong>:

                  <div class="flex max-sm:flex-col">
                    <div class="w-[50%] max-sm:w-[100%]">
                      <pre><code class="language-js">
                        //cart-reducer.ts                
                        import { db } from '../data/db'
                        import type { CartItem, Guitar } from "../types"
                        
                        export type CartActions = 
                            { type: 'add-to-cart', payload: {item : Guitar}} |
                            { type: 'remove-from-cart', payload: {id : Guitar['id']}} |
                            { type: 'decrease-quantity', payload: {id: Guitar['id']}} |
                            { type: 'increase-quantity', payload: {id: Guitar['id']}} |
                            { type: 'clear-cart'}
                        
                        export type CartState = {
                            data: Guitar[],
                            cart: CartItem[]
                        }
                        export const initialState : CartState = {
                            data: db, //nuestra bbdd de guitarra con los datos
                            cart: [] //de momento arreglo vacío pero recordemos que viene de localStorage, ahora lo hacemos
                        
                        }
                        
                        export const cartReducer = (    
                                state: CartState = initialState,
                                actions: CartActions
                            ) => {
                        
                            if (action.type === "add-to-cart"){
                                return{
                                    ...state
                                }
                            }
                            if (action.type === "remove-from-cart"){
                                return{
                                    ...state
                                }
                            }
                            if (action.type === "decrease-quantity"){
                                return{
                                    ...state
                                }
                            }
                            if(action.type === "increase-quantity"){
                                return{
                                    ...state
                                }
                            }
                            if(action.type === "clear-cart"){
                                return{
                                    ...state
                                }
                            }
                        
                            return state
                            
                        }
                      </code></pre>
                    </div>
                    <div class="w-[50%] max-sm:w-[100%]">
                      <img src="./src/assets/img/170.png" alt="img" loading="lazy">
                    </div>
                  </div>
                  
                </li>
              </ul>
             

              <p><span class="destacado">Ya tenemos los type de acciones, el type de state, state inicial y el reducer</span></p>

            </div>

            <!-- Bloque desplegable interior-->
            <div class="flex justify-between items-center mt-1.25 cursor-pointer oscuro" onclick="$('#seccion11-171').toggle();">
              <h3>171. Instanciando el reducer en la página principal / 172. Migrando del Custom Hook hacia useReducer / 173. Migrando el addToCart hacia useReducer</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion11-171" class="hidden">      
              <p>Como ya tenemos definido en nuestro fichero de reducers&gt;cart-reducer.ts las acciones, state(type y state inicial) y el reducer, ya podemos ir a nuestro compo ppal App.tsx y utilizar useReducer <code class="language-js">import { useReducer } from "react"</code>. Fijémonos que:</p>
              
              <ul class="list-disc">
                <li>de nuestro custom hook con destructuring  ¡¡¡retornamos 9 cosas!!! <span class="destacado">como objeto{}</span> <code class="language-js">const { data, cart, addToCart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart, isEmpty, cartTotal } = useCart()</code>.</li>
                <li>Usando nuestro reducer solo retornamos state y dispatch <span class="destacado">como arreglo[]</span>: <code class="language-js"> const [state,dispatch] = useReducer(cartReducer, initialState)</code> (esos dos parámetros que toma: reducer y el initial state los tenemos exportados en nuestro fichero de reducer así que se importan aquí e la App.tsx)</li>
              </ul> 

              <pre data-line="1,3,7"><code class="language-js">
                //App.tsx
                import { useReducer } from "react"
                ...
                import { cartReducer, initialState } from "./reducers/cart-reducer"
                
                function App() {    
                  const { data, cart, addToCart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart, isEmpty, cartTotal } = useCart()
                  const [state,dispatch] = useReducer(cartReducer, initialState)
              </code></pre>

                <p>Así ya tanto state como dispatch van a tener la información necesaria. Si ponemos un console.log(state) vemos que ya funciona correctamente, lo estamos conectando desde el reducer y en la consola nos retorna lo que hemos colocado como initialState: <strong>cart</strong> que es un array vacío [] y <strong>data</strong> lo que tenemos en nuestra pequeña bbdd.</p>

                <p>Vamos a ir reemplazando cada una de las partes ¿moviendo todo lo que tenemos en nuestro <span class="rojo">x9</span><strong>custom hook useCart()</strong> hacia nuestro <span class="verde">x2</span><strong>reducer useReducer()</strong></p>

                <p class="naranja">Migrando del Custom Hook hacia useReducer</p>
              

                <p>Vamos a mover todo lo de nuestro custom hook al reducer, no es que estuviera mal, simplemente Estamos tratando de usar diferentes técnicas para poner en práctica diferentes escenarios en este caso una función de tipo reducer.</p>

                <p>Comencemos con las guitarras, que es la parte central de nuestro proyecto. Actualmente las tenemos en data de nuestro custom hook pero como ya las tenemos en nuestro state del reducer las mostramos desde ahí:</p>

                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre class="rojo" data-line="1"><code class="language-js">
                      //App.tsx
                      {data.map((guitar) =&gt; (
                        &lt;Guitar 
                          key={guitar.id}
                          guitar={guitar}
                          addToCart={addToCart}
                        /&gt;
                      ))}
                    </code></pre>
                  </div>
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre class="verde" data-line="1"><code class="language-js">
                      //App.tsx
                      {state.data.map((guitar) =&gt; (
                        &lt;Guitar 
                          key={guitar.id}
                          guitar={guitar}
                          addToCart={addToCart}
                        /&gt;
                      ))}
                    </code></pre>
                  </div>
                </div>

                <p>Vamos limpiando: en <span class="file">App.tsx</span> la prop data que extraíamos <code class="language-js">const { data, cart, addToCart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart, isEmpty, cartTotal } = useCart()</code>, en nuestro hook useCart.ts: la variable que usábamos <code class="language-js">const [data] = useState(db)</code> + del return + también quitamos la importación que hacíamos de nuestra bbdd <strong>Para quitar importaciones que ya no se utilicen Ctrl + Mayus + P y escribimos "Quitar importaciones sin usar"</strong></p>

                <p class="naranja">Migrando el addToCart hacia useReducer</p>
                
                <p>Si abrimos RDT (a veces se queda atascado y hay que recargar) y pulsamos en el compo ppal App.tsx vemos los dos cart que de momento tenemos, el del custom hook y el del reducer. Si agrego guitarra veo que se añade en el cart de mi hook pero <strong>queremos que escriba en el de reducer. Para eso tenemos que utilizar un dispatch</strong></p>

                <p>Identificamos la función que es addToCart y esa se está pasando en cada una de las guitarras. Hemos de pasar en su lugar dispatch:</p>

                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre class="borrar" data-line="5"><code class="language-js">
                      //App.tsx
                      {state.data.map((guitar) =&gt; (
                        &lt;Guitar 
                          key={guitar.id}
                          guitar={guitar}
                          addToCart={addToCart}
                        /&gt;
                      ))}
                    </code></pre>
                  </div>
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre class="verde" data-line="5"><code class="language-js">
                      //App.tsx
                      {state.data.map((guitar) =&gt; (
                        &lt;Guitar 
                          key={guitar.id}
                          guitar={guitar}
                          dispatch={dispatch}
                        /&gt;
                      ))}
                    </code></pre>
                  </div>
                </div>

                <p>Si vemos, al hacer este cambio nos da error porque, la firma de nuestro componente guitar (el type) ya no coincide.</p>
                
                <img src="./src/assets/img/173.png" alt="img" loading="lazy">
                
                <p>Lo vamos a coger del IS de VSC para añadirle esa propiedad a la firma de mi compo guitarra (el type de las props). Importamos CartActions (para que el componente conozca todas las acciones que se soportan por el reducer, incluyendo sus payload) y al igual que ya hemos hecho otras veces, en vez de poner <code class="language-js">React.Dispatch&lt;CartActions&gt;</code> podemos quitar el 'React.' previo si importamos Dispatch en el componente. Lo cambiamos también en el destructuring del parámetro y en la llamada al <code class="language-js">onClick = {()=> ... }</code> en el que llamamos al dispatch llamando al type adecuado y a su correspondiente payload, que podemos inferirlo al escribir payload y viendo el IS.</p>

                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre class="rojo" data-line="5,8,13"><code class="language-js">
                      //Guitar.tsx
                      import type { Guitar } from '../types'

                      type GuitarProps = {
                          guitar : Guitar, 
                          dispatch : (item: Guitar) => void
                      }
                      
                      export default function Guitar({guitar, addToCart} : GuitarProps) {
                        ...
                        &lt;button 
                            type=&quot;button&quot;
                            className=&quot;btn btn-dark w-100&quot;
                            onClick={() =&gt; addToCart(guitar)}
                        &gt;Agregar al Carrito&lt;/button&gt;
                    </code></pre>
                  </div>
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre class="verde" data-line="1,3,7,10,15"><code class="language-js">
                      //Guitar.tsx
                      import { Dispatch } from 'react'
                      import type { Guitar } from '../types'
                      import { CartActions } from '../reducers/cart-reducer'
                      
                      type GuitarProps = {
                          guitar : Guitar, 
                          dispatch : Dispatch&lt;CartActions&gt;
                      }

                      export default function Guitar({guitar, dispatch} : GuitarProps) {
                      ...
                        &lt;button 
                            type=&quot;button&quot;
                            className=&quot;btn btn-dark w-100&quot;
                            onClick={() =&gt; dispatch({type: &#39;add-to-cart&#39;, payload: {item: guitar} })}
                        &gt;Agregar al Carrito&lt;/button&gt;
                    </code></pre>
                  </div>
                </div>

                <p>Si en el if del reducer correspondiente a ese type "add-to-cart" ponemos un console.log('desde-add-to-cart') vemos que ya lo llama.</p>

                <p>Veamos a continuación como tomar toda la lógica que teníamos en nuestra función addToCart() de nuestro custom hook y ajustarla para la sintaxis de useReducer.</p>

              </div>

            <!-- Bloque desplegable interior-->
            <div class="flex justify-between items-center mt-1.25 cursor-pointer oscuro" onclick="$('#seccion11-174').toggle();">
              <h3>174. Ajustando el Código para la sintaxis de useReducer / 175. Evitando registros duplicados con sintaxis de Reducer</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion11-174" class="hidden">
              <p>Como la la lógica de useState() que teníamos en la función addToCart() de nuestro custom hook es un poco distinta de la que se usa en useReducer(), vamos a adecuarla para usarla con useReducer(). Si la cogemos y la pegamos en el if correspondiente a esta acción vemos que de entrada nos da todos <span class="rojo">estos casques</span>. Vamos a ir siguiendo los errores para solucionarlos:</p>

              <div class="flex max-sm:flex-col">
                <div class="w-[30%] max-sm:w-[100%]">
                  <img src="./src/assets/img/174.png" alt="img" loading="lazy">
                </div>
                <div class="w-[70%] max-sm:w-[100%]">
                  <ul class="list-disc my-3">
                    <li>1º revisamos si un elemento existe para evitar registros dupicados: <span class="rojo">cart.</span>findIndex() lo cambiamos por <span class="verde">state.cart.</span>findIndex()</li>
                    <li><span class="rojo">item.id</span> falla; ese item era un parámetro de la función addToCart(item: Guitar), le pasábamos ese item que era el elemento sobre el cual presionábamos para agregarlo al carrito, pero ahora mismo eso ya forma parte del action.payload así que cambiamos <span class="rojo">item.id</span> por <span class="verde">action.payload.item.id</span></li>
                    <li><span class="rojo">MAX_ITEMS</span> al igual que <span class="rojo">MIN_ITEMS</span> eran variables que prevenían de que no agregáramos más elementos, de momento no existían en nuestro reducer así que las agregamos justo antes del <code class="language-js">export const cartReducer = (...</code></li>
                    <li>A cuento de <span class="rojo">setCart(updatedCart)</span> Importante: estamos escribiendo en el state en dos lugares (el if y el else) pero el reducer solo tiene un único return{} entonces ese const updatedCart lo declaramos fuera del bloque if pero como let (para poder reasignarlo). le quitamos el const, reasignamos y borramos el SetCart(updatedCart) que ya no lo usamos. ese updatedCart hay que setearlo en el state así que lo añadimos en el return y así lo que hacía el setState, ahora lo hace nuestro reducer.</li>
                    <li>en la parte del else <span class="rojo">...item</span> por <span class="verde">...action.payload.item</span> que recordemos es lo que en el componente Guitar.tsx estamos agregando en el payload cuando hacemos click <code class="language-js">onClick={() => dispatch({type: 'add-to-cart', payload: {item: guitar} })}</code>. Eliminamos el <span class="rojo">setCart([...cart, newItem])</span> que es lo que usábamos con useState y nos quedamos con su contenido: <span class="verde">updatedCart = [...state.cart, newItem]</span></li>
                  </ul>
                </div>
              </div>

              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //useCart.ts
                    function addToCart(item : Guitar) {
                      const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                      if(itemExists >= 0 ) { // existe en el carrito
                          if(cart[itemExists].quantity >= MAX_ITEMS) return
                          const updatedCart = [...cart]
                          updatedCart[itemExists].quantity++
                          setCart(updatedCart)
                      } else {
                          const newItem : CartItem = {...item, quantity : 1}
                          setCart([...cart, newItem])
                      }
                    }
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //cart-reducer.ts
                    if (action.type === "add-to-cart"){
                      const itemExists = state.cart.findIndex(guitar => guitar.id === action.payload.item.id)
                      
                      let updatedCart : CartItem[] = []
                      if(itemExists >= 0 ) { // existe en el carrito
                          if(state.cart[itemExists].quantity >= MAX_ITEMS) return
                          updatedCart = [...state.cart]
                          updatedCart[itemExists].quantity++
                      } else {
                          const newItem : CartItem = {...action.payload.item, quantity : 1}
                          updatedCart = [...state.cart, newItem]
                      }
              
                      return{
                          ...state,
                          cart: updatedCart
                      }
                  }
                  </code></pre>
                </div>
              </div>

              <div class="flex max-sm:flex-col">
                <div class="w-[30%] max-md:w-[100%] mr-1.25">
                  <p>Si miramos en nuestra <span class="file">App.tsx</span> vemos que nos dice que nuestro state posiblemente pueda ser undefined</p>
                  <img src="./src/assets/img/174-2.png" alt="img" loading="lazy">
                </div>
                <div class="w-[70%] max-md:w-[100%]">
                  <p>Si recargamos el navegador, vemos en nuestro RDT App reducer, cómo al agregar guitarra se añade al state, si pulso en la misma guitarra quantity pasa de 1 a 3, a continuación a 5 y a continuación la pantalla se queda en blanco <strong>¿Qué pasa?</strong> algo raro pasa aquí:</p>

                  <pre><code class="language-js">
                    //cart-reducer.ts
                    ...
                    if (action.type === "add-to-cart"){
                      const itemExists = state.cart.findIndex(guitar => guitar.id === action.payload.item.id)
                  </code></pre>

                  <p>y es que probablemente <span class="rojo">findIndex()</span> para este tipo de código/ejemplo no sea la mejor opción y Typescript sabe por adelantado que algo puede fallar. Esto es algo relativamente común que nos puede pasar, tener un código funcional y cuando lo movemos a Redux Toolkit o Zustand dejar de funcionar. <strong>Veamos cómo utilizar .find() en lugar de .findIndex() y adaptar nuestro código</strong>.</p>                  
                </div>
              </div>
              
              <p class="naranja">Evitando registros duplicados con sintaxis de Reducer</p>

              <p>En vez de .findIndex() usamos .find() y en lugar de hacer las comprobaciones como teníamos hasta ahora en el if(), usaremos un .map() para identificar el elemento y entonces ir incrementando las cantidades.</p>

              <ul class="list-disc my-2.5">
                <li>.findIndex() nos retornaba un nº del índice de la posición del elemento en el arreglo del carrito. Utilizando .find() nos retorna el objeto. Lo podemos ver si lo cambiamos aquí, ponemos un console.log(itemExists) (quitamos la lógica del if para que no falle dejando solo lo siguiente) y miramos la consola al pulsar una guitarra que ya habíamos agregado, que ya existía por tanto:
                <pre data-line="2,3,5"><code class="language-js">
                  //cart-reducer.ts
                  if (action.type === "add-to-cart"){
                    const itemExists = state.cart.find(guitar => guitar.id === action.payload.item.id)
                    console.log(itemExists)
                    let updatedCart : CartItem[] = []
                    if(itemExists ) { // existe en el carrito
                        
                    } else {...
                </code></pre>  
                <img src="./src/assets/img/175.png" alt="img" loading="lazy">
                </li>
                <li>Modificamos la lógica del if:
                  <pre><code class="language-js">
                    //cart-reducer.ts
                    if(itemExists ) { // existe en el carrito
                      updatedCart = state.cart.map(item => {
                          if(item.id === action.payload.item.id){ //ese es el elemento que el user está agregando repetido
                              if(item.quantity &lt; MAX_ITEMS){ //le permitimos agregarlo
                                  return{...item,quantity: item.quantity + 1 } //copia del item e incrementamos quantity
                              } else {
                                  return item // llegamos a 5, no se cumple lo anterior pero mantenemos lo que teníamos en el carrito
                              }
                          } else {//el que no estamos agregando repetido pero no queremos perder
                              return item
                          }
                      })            
                  } 
                  </code></pre>
                </li>
              </ul>

              <p>Como ya no estamos utilizando addToCart() la eliminamos de nuestro hook useCart.ts (también de su return) y también del destructuring que hacíamos en la App.tsx <code class="language-js">const { cart, addToCart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart, isEmpty, cartTotal } = useCart()</code></p>
                 

            </div>

            <!-- Bloque desplegable interior-->
            <div class="flex justify-between items-center mt-1.25 cursor-pointer oscuro" onclick="$('#seccion11-176').toggle();">
              <h3>176. Mostrando el contenido del carrito</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion11-176" class="hidden">
              <p>Ya estamos escribiendo en nuestro carrito de nuestro rediucer, si agrego guitarras, vemos en el <strong>RDT App reducer(mirando en el React Developer Tools de Chrome en el reducer de nuestro compo ppal App.tsx)</strong> que se agregan adecuadamente, sin embargo no se están mostrando en la renderización del carrito, porque el código del carrito aun tiene el código de nuestro custom hook useCart.ts</p>            
              
              <pre><code class="language-js">
                //Header.tsx
                ...
                &lt;div id=&quot;carrito&quot; className=&quot;bg-white p-3&quot;&gt;
                  {isEmpty ? (
                      &lt;p className=&quot;text-center&quot;&gt;El carrito esta vacio&lt;/p&gt;
                  ) : (
                  &lt;&gt;
                  ...
              </code></pre>
                
              <p>Vamos a tener que hacer cambios:</p>

              <ul class="list-disc my-2.5">
                <li>Debería bastar con cambiar en nuestro App.tsx la prop que le pasamos en el tag del compo Header.tsx(que es donde renderizamos nuestro carrito) de cart a state.cart:
                  <div class="flex max-sm:flex-col">
                    <div class="w-[50%] max-sm:w-[100%]">
                      <pre class="rojo" data-line="2"><code class="language-js">
                        //App.tsx
                        &lt;Header 
                          cart={cart}
                          removeFromCart={removeFromCart}
                          decreaseQuantity={decreaseQuantity}
                          increaseQuantity={increaseQuantity}
                          clearCart={clearCart}       
                        /&gt;
                      </code></pre>
                    </div>
                    <div class="w-[50%] max-sm:w-[100%]">
                      <pre class="verde" data-line="2"><code class="language-js">
                        //App.tsx
                        &lt;Header 
                          cart={state.cart}
                          removeFromCart={removeFromCart}
                          decreaseQuantity={decreaseQuantity}
                          increaseQuantity={increaseQuantity}
                          clearCart={clearCart}       
                        /&gt;
                      </code></pre>
                    </div>                    
                  </div>

                  <p>sin embargo vemos que en nuestro compo Header.tsx tenemos un código condicional que revisa "si está vacío nuestro carrito para mostrar un texto", y como nosotros ahora mismo esa funcionalidad la tenemos en nuestro reducer pues no se está mostrando nada, de momento se queda siempre en ese 'isEmpty' (esa variable es uno de los 2 states derivados que hemos de mover, que además usan useMemo()):</p>
                      <pre class="verde"><code class="language-js">
                        //Header.tsx                        
                        &lt;div id=&quot;carrito&quot; className=&quot;bg-white p-3&quot;&gt;
                          {isEmpty ? (
                              &lt;p className=&quot;text-center&quot;&gt;El carrito esta vacio&lt;/p&gt;
                          ) : (
                      </code></pre>
                </li>

                <li>
                  <div class="flex max-sm:flex-col">
                    <div class="w-[50%] max-sm:w-[100%]">
                      Movemos estos 2 states derivados que teníamos en nuestro custom hook useCart.ts antes del return (eliminamos la importación de useMemo, también quitamos ambos del return)...
                      <pre class="rojo" data-line="1-3,7-8"><code class="language-js">
                        // useCart.ts
                        // State Derivado
                          const isEmpty = useMemo( () => cart.length === 0, [cart])
                          const cartTotal = useMemo( () => cart.reduce( (total, item ) => total + (item.quantity * item.price), 0), [cart] )
                          ...//(eliminamos ambas del return)
                          return {
                            ...
                            isEmpty,
                            cartTotal
                        }
                      </code></pre>
                    </div>
                    <div class="w-[50%] max-sm:w-[100%]">
                      a nuestro compo Header.tsx justo antes del return, donde también importamos useMemo...
                      <pre class="verde" data-line="1,6-8"><code class="language-js">
                        // Header.tsx
                        import { useMemo } from "react"
                        ...
                          cartTotal
                        } : HeaderProps ) {
                    
                        // State Derivado
                        const isEmpty = useMemo( () =&gt; cart.length === 0, [cart])
                        const cartTotal = useMemo( () =&gt; cart.reduce( (total, item ) =&gt; total + (item.quantity * item.price), 0), [cart] )
                    
                        return (
                          <header className="py-5 header">
                      </code></pre>
                    </div>
                  </div>
                  
                  
                    <div class="flex max-sm:flex-col">
                      <div class="w-[50%] max-sm:w-[100%]">
                        <p>Seguimos los errores limpiando todas esas referencias a los 2 states derivados que hemos movido: en nuestro App.tsx quitamos de la extracción estos 2 states derivados y también cart, que ya no va a estar exportando y también eliminamos los 2 states derivados de las props que le pasábamos en el tag del compo Header.tsx:</p>
                        <pre class="rojo" data-line="2,6,7"><code class="language-js">
                          //App.tsx
                          ...
                          const { cart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart, isEmpty, cartTotal } = useCart()
                          ...
                          &lt;Header 
                            ...
                            isEmpty={isEmpty}
                            cartTotal={cartTotal}
                          /&gt;
                        </code></pre>
                      </div>
                      <div class="w-[50%] max-sm:w-[100%]">
                        <p>También los eliminamos del Header.tsx, tanto del type como las props extraídas:</p>
                        <pre class="rojo" data-line="3,4,9,10"><code class="language-js">
                          //Header.tsx
                          type HeaderProps = {
                            ...
                            isEmpty: boolean
                            cartTotal: number
                          }                         
                        
                          export default function Header({
                                ...
                                  isEmpty, 
                                  cartTotal
                              } : HeaderProps ) {
                        </code></pre>
                      </div>
                    </div>
                </li>                
              </ul>              

            </div>

            <!-- Bloque desplegable interior-->
            <div class="flex justify-between items-center mt-1.25 cursor-pointer oscuro" onclick="$('#seccion11-177').toggle();">
              <h3>177. Trabajando con la acción de eliminar del carrito</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion11-177" class="hidden">
              <p>Trabajamos con la acción de 'remove-from-cart' de nuestro reducer. Nos posicionamos en su correspondiente if. En lugar de usar setCart() que es la función de nuestro custom hook, hemos de crear una variable y esa misma lógica adaptarla</p>
              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //useCart.ts
                    function removeFromCart(id : Guitar['id']) {
                      setCart(prevCart => prevCart.filter(guitar => guitar.id !== id))
                    }
                  </code></pre>
                  
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //cart-reducer.ts
                    if (action.type === "remove-from-cart"){
                      const updatedCart = state.cart.filter( item => item.id !== action.payload.id)       
                      return{
                          ...state,
                          cart: updatedCart
                      }
                    }
                    //sintaxis forma 2
                    if (action.type === "remove-from-cart"){
                      const cart = state.cart.filter( item => item.id !== action.payload.id)       
                      return{
                          ...state,
                          cart
                      }
                    }
                    //sintaxis forma 3
                    if (action.type === "remove-from-cart"){                         
                      return{
                          ...state,
                          cart: state.cart.filter( item => item.id !== action.payload.id) 
                      }
                    }
                  </code></pre>

                </div>
              </div>

              <p><strong>El siguiente paso es disparar esa acción</strong>. Abrimos nuestra App.tsx y en el tag del componente Header sustituimos la antigua llamada a la propiedad removeFromCart por un dispatch. El proceso es el mismo que vimos en el punto 173; cambiamos la firma (cambiar el type, infiriendo de IS, de las props del compo donde se recibe el dispatch) esta vez en el compo Header.tsx. <strong>Buscamos esa llamada que teníamos en el onclick a la antigua función removeFromCart() y la cambiamos por un dispatch</strong></p>

              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre class="rojo" data-line="3,10,15,21,28"><code class="language-js">
                    //App.tsx
                      function App() {

                        const { removeFromCart, decreaseQuantity, increaseQuantity, clearCart } = useCart()
                        const [state,dispatch] = useReducer(cartReducer, initialState)
                    
                        return (
                          &lt;&gt;
                            &lt;Header 
                              ...
                              removeFromCart={removeFromCart}

                    //Header.tsx                        
                      type HeaderProps = {
                          cart: CartItem[]
                          removeFromCart: (id: Guitar['id'] ) => void
                          ...
                      }

                      export default function Header({
                              cart, 
                              removeFromCart, 
                              ...
                          } : HeaderProps ) {
                      ...
                      &lt;button
                          className=&quot;btn btn-danger&quot;
                          type=&quot;button&quot;
                          onClick={() =&gt; removeFromCart(guitar.id)}
                      &gt;X&lt;/button&gt;
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre class="verde" data-line="3,10,15,21,28"><code class="language-js">
                    //App.tsx
                      function App() {

                        const { decreaseQuantity, increaseQuantity, clearCart } = useCart()
                        const [state,dispatch] = useReducer(cartReducer, initialState)
                                            
                        return (
                          &lt;&gt;
                            &lt;Header 
                              ...
                              dispatch={dispatch}

                    //Header.tsx                        
                      type HeaderProps = {
                          cart: CartItem[]
                          dispatch: Dispatch<CartActions>
                          ...
                      }

                      export default function Header({
                              cart, 
                              dispatch, 
                              ...
                          } : HeaderProps ) {
                      ...
                      &lt;button
                          className=&quot;btn btn-danger&quot;
                          type=&quot;button&quot;
                          onClick={() =&gt; dispatch({type: &#39;remove-from-cart&#39;, payload: {id: guitar.id}})}
                      &gt;X&lt;/button&gt;
                  </code></pre>
                </div>
              </div>

              <p><span class="destacado">NOTA: importante tener delante la definición que hemos hecho de los payloads de los CartActions para escribir correctamente el payload y no perderse</span>. Comparamos el ejemplo del punto 173 donde añadíamos una guitarra con este que acabamos de hacer:</p>

              <pre><code class="language-js">
                //cart-reducer.ts
                export type CartActions = 
                { type: 'add-to-cart', payload: {item : Guitar}} |
                { type: 'remove-from-cart', payload: {id : Guitar['id']}} |
                { type: 'decrease-quantity', payload: {id: Guitar['id']}} |
                { type: 'increase-quantity', payload: {id: Guitar['id']}} |
                { type: 'clear-cart'}
              </code></pre>

              <div class="flex max-sm:flex-col">                
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //Guitar.tsx
                    &lt;button
                      type=&quot;button&quot;
                      className=&quot;btn btn-dark w-100&quot;
                      onClick={() =&gt; dispatch({type: &#39;add-to-cart&#39;, payload: {item: guitar} })} 
                    >Agregar al Carrito</button>                   
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //App.tsx
                    &lt;button
                      className=&quot;btn btn-danger&quot;
                      type=&quot;button&quot;
                      onClick={() =&gt; dispatch({type: &#39;remove-from-cart&#39;, payload: {id: guitar.id}})}
                    &gt;X&lt;/button&gt;
                  </code></pre>
                </div>
              </div>
              
              <p>Eliminamos del custom hook useCart.ts nuestra función removeFromCart() que ya no vamos a utilizar (también lo vamos a eliminar del return que lo exportaba) y en nuestro compo ppal App.tsx lo eliminamos de la extracción que hacíamos con destructuring al llamar a nuestro custom hook en <strong>const { <span class="rojo">removeFromCart</span>, decreaseQuantity, increaseQuantity, clearCart } = useCart()</strong>.</p>

            </div>

            <!-- Bloque desplegable interior-->
            <div class="flex justify-between items-center mt-1.25 cursor-pointer oscuro" onclick="$('#seccion11-178').toggle();">
              <h3>178. Trabajando con la acción de incrementar cantidad y RETO 02 / 179. SOLUCION RETO 02 / 180. SOLUCION RETO 03</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion11-178" class="hidden">
              <p>Trabajemos migrando la función increaseQuantity()  anuestro reducer.</p>
              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //useCart.ts
                    function increaseQuantity(id : Guitar['id']) {
                      const updatedCart = cart.map( item => {
                          if(item.id === id && item.quantity &lt; MAX_ITEMS) {
                              return {
                                  ...item,
                                  quantity: item.quantity + 1
                              }
                          }
                          return item
                      })
                      setCart(updatedCart)
                    }
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //cart-reducer.ts
                    if(action.type === "increase-quantity"){
                      const updatedCart = state.cart.map( item => {
                          if(item.id === action.payload.id && item.quantity &lt; MAX_ITEMS) {
                              return {
                                  ...item,
                                  quantity: item.quantity + 1
                              }
                          }
                          return item
                      })        
                      return{
                          ...state,
                          cart: updatedCart
                      }
                  }
                  </code></pre>
                </div>
              </div>

              <p>En App.tsx quitamos la importación de la función antigua, la prop que se pasaba al tag header y en el compo Header.tsx lo quitamos de la firma y también del destructuring de parámetros de la función del componente <span class="destacado">(el dispatch ya centraliza todas las acciones)</span>. Eliminamos la función del custom hook y también de su return. Modificamos la llamada del onclick:</p>

              <div class="flex max-sm:flex-col">
                <div class="w-[40%] max-sm:w-[100%]">
                  <pre class="rojo" data-line="4"><code class="language-js">
                    //Header.tsx
                    &lt;button
                      type=&quot;button&quot;
                      className=&quot;btn btn-dark&quot;
                      onClick={() =&gt; increaseQuantity(guitar.id)}
                    &gt;+&lt;/button&gt;
                  </code></pre>
                </div>
                <div class="w-[60%] max-sm:w-[100%]">
                  <pre class="verde" data-line="4"><code class="language-js">
                    //Header.tsx
                    &lt;button
                      type=&quot;button&quot;
                      className=&quot;btn btn-dark&quot;
                      onClick={() =&gt; dispatch({type: &quot;increase-quantity&quot;, payload: {id: guitar.id}})}
                    &gt;+&lt;/button&gt;
                  </code></pre>
                </div>
              </div>
              
              <p class="naranja">Hacemos lo mismo para decreaseQuantity() <strong>Reto 02: Decrementar cantidades</strong></p>

              <ul class="list-disc my-2.5">
                <li>Hacer funcional el botón de decrementar cantidades, ahora con useReducer</li>
                <li>Tendremos que crear la acción y mandarla llamar con dispatch</li>
                <li>Seguir las convenciones de nombres del custom hook y reducer</li>
              </ul>

              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //useCart.ts
                    function decreaseQuantity(id : Guitar['id']) {
                      const updatedCart = cart.map( item => {
                          if(item.id === id && item.quantity > MIN_ITEMS) {
                              return {
                                  ...item,
                                  quantity: item.quantity - 1
                              }
                          }
                          return item
                      })
                      setCart(updatedCart)
                    }
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //cart-reducer.ts
                    if (action.type === "decrease-quantity"){
                      const updatedCart = state.cart.map( item => {
                          if(item.id === action.payload.id && item.quantity > MIN_ITEMS) {
                              return {
                                  ...item,
                                  quantity: item.quantity - 1
                              }
                          }
                          return item
                      })    
                      return{
                          ...state,
                          cart: updatedCart
                      }
                    }
                  </code></pre>
                </div>
              </div>
              
              <div class="flex max-sm:flex-col">
                <div class="w-[40%] max-sm:w-[100%]">
                  <pre class="rojo" data-line="4"><code class="language-js">
                    //Header.tsx
                    &lt;button
                      type=&quot;button&quot;
                      className=&quot;btn btn-dark&quot;
                      onClick={() =&gt; decreaseQuantity(guitar.id)}
                    &gt;-&lt;/button&gt;
                  </code></pre>
                </div>
                <div class="w-[60%] max-sm:w-[100%]">
                  <pre class="verde" data-line="4"><code class="language-js">
                    //Header.tsx
                    &lt;button
                        type=&quot;button&quot;
                        className=&quot;btn btn-dark&quot;
                        onClick={() =&gt; dispatch({type: &quot;decrease-quantity&quot;, payload:{id: guitar.id}})}
                    &gt;-&lt;/button&gt;
                  </code></pre>
                </div>
              </div>
              
              <p class="naranja"><strong>Reto 03: Limpiar carrito</strong></p>

              <ul class="list-disc my-2.5">
                <li>Hacer funcional el botón de limpiar el carrito de compras ahora con useReducer</li>
                <li>Tendremos que crear la acción y mandarla llamar con dispatch</li>
                <li>Seguir las convenciones de nombres del custom hook y reducer</li>
              </ul>

              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //useCart.ts
                    function clearCart() {
                      setCart([])
                  }
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //cart-reducer.ts
                    if(action.type === "clear-cart"){
                      const updatedCart : CartItem[] = []
                      return{
                          ...state,
                          cart: updatedCart
                      }
                    }
                    //su manera
                    if(action.type === "clear-cart"){                      
                      return{
                          ...state,
                          cart: []
                      }
                  }
                  </code></pre>
                </div>
              </div>

              <p>Limpiamos todas las importaciones que ya no se usan. Como vemos en el tag de nuestro componente Header (que es donde s epinta le carrito) teníamos muchos props y como vemos es algo que se simplifica al incorporar useReducer.</p>
            </div>

            <!-- Bloque desplegable interior-->
            <div class="flex justify-between items-center mt-1.25 cursor-pointer oscuro" onclick="$('#seccion11-181').toggle();">
              <h3>181. Colocando el state en LocalStorage</h3>
              <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
            </div>
            <div id="seccion11-181" class="hidden">
              <p>Vamos a colocar el state en LocalStorage. En nuestro custom hook tenemos dos partes relacionadas con local Storage ahora mismo, la primera va  hacia el reducer y la segunda hacia el componente:</p>

              <pre data-line="4-7,11-13"><code class="language-js">
                //useCart.ts
                ...
                export const useCart = () => {

                    const initialCart = () : CartItem[] => {
                        const localStorageCart = localStorage.getItem('cart')
                        return localStorageCart ? JSON.parse(localStorageCart) : []
                    }
                
                    const [cart, setCart] = useState(initialCart)

                    useEffect(() => {
                        localStorage.setItem('cart', JSON.stringify(cart))
                    }, [cart])

                    return {
                        cart       
                    }
                }
              </code></pre>

              <p>Nos llevamos la primera parte del custom hook relacionada con localStorage a nuestro reducer y la ponemos justo antes de definir el initialState. En el initialState en lugar de que cart sea arreglo vacío, le decimos que sea la nueva función <strong>initialCart()</strong> que nos hemos traído (de ahora en adelante nuestro carrito de compras inicia tomando lo que hay en localStorage o si no hay nada, un arreglo vacío):</p>
              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                
                  <pre><code class="language-js">
                    //useCart.ts
                    const initialCart = () : CartItem[] => {
                      const localStorageCart = localStorage.getItem('cart')
                      return localStorageCart ? JSON.parse(localStorageCart) : []
                  }
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                    <pre data-line="2-5,9"><code class="language-js">
                    //cart-reducer.ts
                    ...
                    const initialCart = () : CartItem[] => {
                        const localStorageCart = localStorage.getItem('cart')
                        return localStorageCart ? JSON.parse(localStorageCart) : []
                    }
                    export const initialState : CartState = {
                        data: db, //nuestra bbdd de guitarra con los datos
                        //cart: [] //antes de usar localStorage iniciábamos el carrito vacío
                        cart: initialCart()
                    }
                  </code></pre>
                </div>
              </div>

              <p>La otra parte, el useEffect, nos la llevamos al compo ppal App.tsx que es donde va a estar nuestro state, lo colocamos justo a continuación y como vemos hace falta que importemos useEffect de react y cambiamos <span class="rojo">cart</span> por <span class="verde">state.cart</span>:</p>

              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //useCart.ts
                    useEffect(() => {
                      localStorage.setItem('cart', JSON.stringify(cart))
                    }, [cart])
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre data-line="1,8,9"><code class="language-js">
                    //App.ts
                    import { useReducer, useEffect } from "react"
                    ...
                    function App() {
                
                      const [state,dispatch] = useReducer(cartReducer, initialState)
                
                      useEffect(() => {
                        localStorage.setItem('cart', JSON.stringify(state.cart))
                      }, [state.cart])
                
                  </code></pre>
                </div>
              </div>

              <p>Ya nuestro custom hook no es necesario, podemos eliminar <span class="file">hooks&gt;useCart.ts</span> pues lo hemos movido todo hacia reducer usando useReducer.</p>
              <p>En nuestro title del index le indicamos las tecnologías usadas en este proyecto: &lt;title&gt;Vite + React + TS + useReducer&lt;/title&gt;</p>
              <p>Hacemos un <span class="destacado">npm run build y así nos aseguramos de que no tenemos ningún error antes de desplegar nuestro proyecto.</span></p>
              
            </div>

        </div>
        <!-- Fin div colapsable-->

      </div>
      <!-- FIN SECCION 11 -->


      <!-- SECCION 10 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
        
        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion10').toggle();">
          <h2>Sección 10: PROYECTO - Contador de Calorías, Consumo y Ejercicios con useReducer</h2>
          <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
        </div>

        <div id="seccion10" class="hidden">
          
          <a class="underline text-rose-600 font-bold" href="https://and....55.github.io/calory-tracker/" target="blank">https://and....55.github.io/calory-tracker/</a>
          <p> <span class="destacado">formularios, useReducer, useState, localStorage</span> Proyecto listo usando useReducer() que es una excelente forma de manejar states más complejos o hacer operaciones en diferentes estados al mismo tiempo. Vemos la <strong>estructura de un reducer</strong>, <strong>para qué utilizamos las acciones</strong>, <strong>para qué utilizamos el dispatch</strong> y <strong>cómo vamos manejando la lógica en nuestro state</strong>.</p>


          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-ficheros').toggle();">
            <h3>FICHEROS FINALES</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-ficheros" class="hidden">            

            <code class="language-html cursor-pointer px-3" onclick="$('#10-ActivityList').toggle();">ActivityList.tsx</code>
            <pre id="10-ActivityList" class="hidden" data-line="0"><code class="language-ts">
              import { useMemo, Dispatch } from &quot;react&quot;
              import { Activity } from &quot;../types&quot;
              import { categories } from &quot;../data/categories&quot;
              import { PencilSquareIcon, XCircleIcon } from &#39;@heroicons/react/24/outline&#39;
              import { ActivityActions } from &quot;../reducers/activity-reducers&quot;
              
              type ActivityListProps = {
                  activities: Activity[]
                  dispatch: Dispatch&lt;ActivityActions&gt;
              }
              
              export default function ActivityList({activities, dispatch}: ActivityListProps) {  
                  
                  const categoryName = useMemo(()=&gt; 
                      (category:Activity[&#39;category&#39;]) =&gt; categories.map( cat =&gt; cat.id === category ? cat.name : &#39;&#39;)
                  , [activities]
                  )
              
                  const isEmptyActivities = useMemo(() =&gt; activities.length === 0, [activities])
              
                  return (
                  &lt;&gt;
                      &lt;h2 className=&quot;text-4xl font-bold text-slate-600 text-center&quot;&gt;Comida y Actividades&lt;/h2&gt;
              
                      {isEmptyActivities 
                          ? &lt;p className=&quot;text-center my-5&quot;&gt;No hay actividades aún&lt;/p&gt; :
                      
                      activities.map(activity =&gt; (
                          &lt;div key={activity.id} className=&quot;px-5 py-10 bg-white mt-5 flex justify-between&quot;&gt;
                              &lt;div className=&quot;space-y-2 relative&quot;&gt;
                                  {/* Muestra actividad: categoría, nombre y calorías */}
                                  &lt;p className={`absolute -top-8 -left-8 px-10 py-2 text-white uppercase font-bold ${activity.category === 1 ? &#39;bg-lime-500&#39; : &#39;bg-orange-500&#39;}`}&gt;
                                      {/* {activity.category} */}
                                      {categoryName(+activity.category)}
                                      
                                  &lt;/p&gt;
                                  &lt;p className=&quot;text-2xl font-bold pt-5&quot;&gt;{activity.name}&lt;/p&gt;
                                  &lt;p className=&quot;font-black text-4xl text-lime-500&quot;&gt;
                                      {activity.calories} {&#39;&#39;}
                                      &lt;span&gt;Calorías&lt;/span&gt;
                                  &lt;/p&gt;
                              &lt;/div&gt;
                              &lt;div className=&quot;flex gap-5 items-center&quot;&gt;
                                  {/* Acciones para editar/eliminar esa actividad */}
                                  &lt;button
                                      className="cursor-pointer"
                                      onClick={() =&gt; dispatch({type:&quot;set-activeId&quot;, payload: {id: activity.id}})}
                                  &gt;
                                      &lt;PencilSquareIcon 
                                          className=&quot;h-8 w-8 text-g&quot;
                                      /&gt;
                                  &lt;/button&gt;
              
                                  &lt;button
                                      className="cursor-pointer"
                                      onClick={() =&gt; dispatch({type:&quot;delete-activity&quot;, payload: {id: activity.id}})}
                                  &gt;
                                      &lt;XCircleIcon 
                                          className=&quot;h-8 w-8 text-red-500&quot;
                                      /&gt;
                                  &lt;/button&gt;
                              &lt;/div&gt;
                              
                          &lt;/div&gt;
                      ))
                      }
                  &lt;/&gt;
                  )
              }                       
            </code></pre>

            <code class="language-html cursor-pointer px-3" onclick="$('#10-calorie').toggle();">CalorieDisplay.tsx</code>
            <pre id="10-calorie" class="hidden"><code class="language-ts">
              type CalorieDisplayProps = {
                calories: number,
                text: string
              }
              
              export default function CalorieDisplay({calories, text}: CalorieDisplayProps) {
                return (        
                  &lt;p className=&quot;text-white font-bold rounded-full grid grid-cols-1 gap-3 text-center&quot;&gt;
                      &lt;span className=&quot;font-black text-6xl text-orange&quot;&gt;{calories}&lt;/span&gt; {text}
                  &lt;/p&gt;
                )
              }      
            </code></pre>            
            
            <code class="language-html cursor-pointer px-3" onclick="$('#10-CalorieTracker').toggle();">CalorieTracker.tsx</code>
            <pre id="10-CalorieTracker" class="hidden"><code class="language-ts">
              import { useMemo } from &quot;react&quot;
              import type { Activity } from &quot;../types&quot;
              import CalorieDisplay from &quot;./CalorieDisplay&quot;
              
              type CalorieTrackerProps = {
                  activities: Activity[]
              }
              
              export default function CalorieTracker({activities}: CalorieTrackerProps) {
              
                  //Contadores
                  const caloriesConsumed = useMemo(() =&gt; activities.reduce((total, activity)=&gt; activity.category === 1 ? total + activity.calories : total, 0), [activities])
                  const caloriesBurned = useMemo(() =&gt; activities.reduce((total, activity)=&gt; activity.category === 2 ? total + activity.calories : total, 0), [activities])
                  const netCalories = useMemo(() =&gt; caloriesConsumed-caloriesBurned, [activities])
              
                  return (
                      &lt;&gt;
                          &lt;h2 className=&quot;text-4xl font-black text-white text-center&quot;&gt;Resumen de calorías&lt;/h2&gt;
              
                          &lt;div className=&quot;flex flex-col-item-center md:flex-row md:justify-between gap-5 mt-10&quot;&gt;
                             
                             &lt;CalorieDisplay 
                              calories={caloriesConsumed}
                              text={&#39;Consumidas&#39;}
                             /&gt;
                             &lt;CalorieDisplay 
                              calories={caloriesBurned}
                              text={&#39;Quemadas&#39;}
                             /&gt;
                             &lt;CalorieDisplay 
                              calories={netCalories}
                              text={&#39;Diferencia&#39;}
                             /&gt;
                              
                          &lt;/div&gt;
                         
                      &lt;/&gt;
                  )
              }              
            </code></pre>            
            
            <code class="language-html cursor-pointer px-3" onclick="$('#10-Form').toggle();">Form.tsx</code>
            <pre id="10-Form" class="hidden"><code class="language-ts">
              import { useState, ChangeEvent, FormEvent, Dispatch, useEffect } from &quot;react&quot;
              import { v4 as uuidv4 } from &#39;uuid&#39;
              import { categories } from &quot;../data/categories&quot;
              import { Activity } from &quot;../types&quot;
              import { ActivityActions, ActivityState } from &quot;../reducers/activity-reducers&quot;
              
              type FormProps = {
                  dispatch: Dispatch&lt;ActivityActions&gt;,
                  state: ActivityState
              }
              
              const initialState : Activity= {
                  id: uuidv4(),
                  category: 1,
                  name: &#39;&#39;,
                  calories: 0
              }
              
              export default function Form({dispatch, state}: FormProps) {
              
                  const[activity, setActivity] = useState&lt;Activity&gt;(initialState) 
              
                  useEffect(() =&gt; {
                     if(state.activeId){
                      //console.log(`ya hay algo en activeId: ${state.activeId}`)
                      const selectActivity = state.activities.filter((actividad)=&gt; actividad.id === state.activeId)[0]
                      //console.log(selectActivity)
                      setActivity(selectActivity)
                     }
                  }, [state.activeId])
              
                  const handleChange = (e: ChangeEvent&lt;HTMLSelectElement&gt; | ChangeEvent&lt;HTMLInputElement&gt; ) =&gt;{   
                      const isNumberField = [&#39;category&#39;,&#39;calories&#39;].includes(e.target.id)
                      setActivity({
                          ...activity,           
                          [e.target.id]: isNumberField ? +e.target.value : e.target.value
                      })
                  }
              
                  const isValidActivity = () =&gt;{
                      const { name, calories } = activity
                      return name.trim() != &#39;&#39; &amp;&amp; calories &gt; 0 //devuelve true cuando ambas se cumplen
                  }
              
                  const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =&gt;{
                      e.preventDefault()
                      dispatch({ type: &#39;save-activity&#39;, payload: {newActivity: activity} })
                      setActivity({
                          ...initialState,
                          id: uuidv4()
                      })
                  }
              
                  return (    
                      &lt;form
                          className=&quot;space-y-5 bg-white shadow p-10 rounded-lg&quot;
                          onSubmit={handleSubmit}
                      &gt;
              
                          &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                              &lt;label htmlFor=&quot;category&quot; className=&quot;font-bold&quot;&gt;Categoría:&lt;/label&gt;
                              &lt;select 
                                  id=&quot;category&quot;
                                  className=&quot;border border-slate-300 p-2 rounded-lg w-full bg-white&quot;
                                  value={activity.category}
                                  onChange={handleChange}
                              &gt;
                                  {categories.map(category =&gt; (
                                      &lt;option
                                          key={category.id}
                                          value={category.id}
                                      &gt;{category.name}&lt;/option&gt;
                                  ))}
                              &lt;/select&gt;
                          &lt;/div&gt;
              
                          &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                              &lt;label htmlFor=&quot;name&quot; className=&quot;font-bold&quot;&gt;Actividad:&lt;/label&gt;
                              &lt;input 
                                  id=&quot;name&quot;
                                  type=&quot;text&quot; 
                                  className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                                  placeholder=&quot;Por ej: Comida, zumo de naranja, ensalada, Ejercicio, Pesas, Bicicleta&quot;
                                  value={activity.name}  
                                  onChange={handleChange}              
                              /&gt;
                          &lt;/div&gt;
              
                          &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                              &lt;label htmlFor=&quot;calories&quot; className=&quot;font-bold&quot;&gt;Calorías:&lt;/label&gt;
                              &lt;input 
                                  id=&quot;calories&quot;
                                  type=&quot;number&quot; 
                                  className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                                  placeholder=&quot;Calorías Por ej: 300, 500&quot;
                                  value={activity.calories}
                                  onChange={handleChange}
                                  /&gt;
                          &lt;/div&gt;
              
                          &lt;input 
                              type=&quot;submit&quot; 
                              className=&quot;bg-gray-800 hover:bg-gray-900 w-full p-2 font-bold uppercase text-white cursor-pointer disabled:opacity-10&quot;
                              value={activity.category === 1 ? &quot;Guardar Comida&quot; : &quot;Guardar Ejercicio&quot;}
                              disabled={!isValidActivity()}
                          /&gt;
                      &lt;/form&gt;  
                  )
              }                     
            </code></pre>            
            
            <code class="language-html cursor-pointer px-3" onclick="$('#10-categories').toggle();">categories.ts</code>
            <pre id="10-categories" class="hidden"><code class="language-js">              
              import type { Category } from "../types"

              export const categories: Category[] = [
                  { id: 1, name: 'Comida'},
                  { id: 2, name: 'Ejercicio'}
              ]      
            </code></pre>            
            
            <code class="language-html cursor-pointer px-3" onclick="$('#10-activity-reducers').toggle();">activity-reducers.ts</code>
            <pre id="10-activity-reducers" class="hidden"><code class="language-js">
              import { Activity } from &quot;../types&quot;

              //ACCIONES - type que va a describir lo que va a pasar en nuestro reducer
              export type ActivityActions = 
                  { type: &#39;save-activity&#39;, payload: { newActivity: Activity } } |
                  { type: &#39;set-activeId&#39;, payload: { id: Activity[&#39;id&#39;] } } |
                  { type: &#39;delete-activity&#39;, payload: { id: Activity[&#39;id&#39;] } } |
                  { type: &#39;restart-app&#39; } 
              
              export type ActivityState = {
                  activities : Activity[], //este state de este reducer se va a llamar activities y va a ser de tipo Activity[](ya lo teníamos definido en types)
                  activeId : Activity[&#39;id&#39;] 
              }
              
              const localStorageActivities = () : Activity[] =&gt;{
                  const activities = localStorage.getItem(&#39;activities&#39;)
                  return activities ? JSON.parse(activities) : []
              }
              //STATE - nuestro state inicial que es un objeto necesita un type (definimos arriba &#39;ActivityState&#39;). En nuestro state de actividades vamos a tener un arreglo.
              export const initialState: ActivityState = {
                  activities: localStorageActivities(),
                  activeId: &#39;&#39;
              }
              
              //REDUCER - que conecta a ambos, nuestras acciones y el state
              export const activityReducer = (
                      state : ActivityState = initialState,
                      action: ActivityActions
                  ) =&gt; {
                  
                  if(action.type === &#39;save-activity&#39;){
                      let updatedActivities : Activity[] = []
                      
                      if(state.activeId){
                          //vamos a iterar sobre cada actividad porque hemos de identificar cual tiene el activeId y pasarle el nuevo payload
                          updatedActivities = state.activities.map( actividad =&gt; actividad.id === state.activeId ? action.payload.newActivity : actividad)
              
                      }else{
                          updatedActivities = [...state.activities, action.payload.newActivity]
                      }
                      
                      return{
                          ...state,
                          //activities: [...state.activities, action.payload.newActivity]
                          activities: updatedActivities,
                          activeId: &#39;&#39;
                      }
                  }
                  
                  if(action.type === &#39;set-activeId&#39;){
                      //Este código maneja la lógica para actualizar el state activeId
                      //console.log(&#39;desde el type de set-activeId&#39;) //console.log(action.payload.id)         
                      return{
                          ...state,
                          activeId: action.payload.id
                      }
                  }
              
                  if(action.type === &#39;delete-activity&#39;){
                      return{
                          ...state,
                          activities: state.activities.filter( activity =&gt; activity.id !== action.payload.id)
                      }
                  }
              
                  if(action.type === &#39;restart-app&#39;){
                      return{
                          activities: [],
                          activeId: &#39;&#39;
                      }
                  }
              
                  return state
              }                   
            </code></pre>            
            
            <code class="language-html cursor-pointer px-3" onclick="$('#10-indexts').toggle();">types&gt;index.ts</code>
            <pre id="10-indexts" class="hidden"><code class="language-js">
              export type Category = {
                id: number
                name: string
              }
              export type Activity = {
                  id: string
                  category: number
                  name: string
                  calories: number
              }              
            </code></pre>
            
            <code class="language-html cursor-pointer px-3" onclick="$('#10-App').toggle();">App.tsx</code>
            <pre id="10-App" class="hidden"><code class="language-js">
              import { useReducer, useEffect, useMemo } from &quot;react&quot;
              import Form from &quot;./components/Form&quot;
              import ActivityList from &quot;./components/ActivityList&quot;
              import { activityReducer, initialState } from &quot;./reducers/activity-reducers&quot;
              import CalorieTracker from &quot;./components/CalorieTracker&quot;
              
              function App() {  
              
                const [state, dispatch] = useReducer(activityReducer, initialState)  
              
                useEffect(() =&gt; {
                  localStorage.setItem(&#39;activities&#39;,JSON.stringify(state.activities))
                }, [state.activities])
              
                const canRestartApp = () =&gt; useMemo(() =&gt; state.activities.length &gt; 0, [state.activities])
              
                return (
                  &lt;&gt;
              
                    &lt;header className=&quot;bg-lime-600&quot;&gt;
                      &lt;div className=&quot;max-w-4xl mx-auto flex justify-between&quot;&gt;
                        &lt;h1 className=&quot;text-center text-lg font-bold text-white uppercase&quot;&gt;
                          Contador de calorías 
                        &lt;/h1&gt;
                        &lt;button 
                          className=&quot;bg-gray-800 hover:bg-gray-900 p-2 font-bold uppercase text-white cursor-pointer rounded-lg text-sm disabled:opacity-10&quot;
                          disabled={!canRestartApp()}
                          onClick={() =&gt; dispatch({type: &#39;restart-app&#39;})}
                          &gt;Reiniciar App&lt;/button&gt;
                      &lt;/div&gt;
                    &lt;/header&gt;
              
                    &lt;div className=&quot;flex max-sm:flex-col&quot;&gt;
                      &lt;section className=&quot;bg-lime-500 py-20 px-5 w-[40%] max-sm:w-full&quot;&gt;
                        &lt;div className=&quot;max-w-4xl mx-auto&quot;&gt;
                          &lt;Form
                            dispatch = {dispatch}
                            state = {state}
                          /&gt;
                        &lt;/div&gt;
                      &lt;/section&gt;
              
                      &lt;section className=&quot;p-10 mx-auto w-[60%] max-sm:w-full&quot;&gt;
                        &lt;ActivityList 
                          activities={state.activities}
                          dispatch={dispatch}
                        /&gt;
                      &lt;/section&gt;
                    &lt;/div&gt;
              
                    &lt;section className=&quot;bg-gray-800 py-10&quot;&gt;
                    &lt;div className=&quot;max-w-4xl mx-auto&quot;&gt;
                      &lt;CalorieTracker 
                        activities = {state.activities}
                      /&gt;
                    &lt;/div&gt;
                    &lt;/section&gt;   
                    
                  &lt;/&gt;
                )
              }
              
              export default App               
            </code></pre>
            
            <code class="language-html cursor-pointer px-3" onclick="$('#10-index').toggle();">index.css y main.tsx</code>
            <pre id="10-index" class="hidden"><code class="language-js">
              //index.css
              @import "tailwindcss";
            
            //main.tsx
              import { StrictMode } from 'react'
              import { createRoot } from 'react-dom/client'
              import './index.css'
              import App from './App.tsx'

              createRoot(document.getElementById('root')!).render(
                &lt;StrictMode&gt;
                  &lt;App /&gt;
                &lt;/StrictMode&gt;,
              )                   
            </code></pre>            
          </div>
          
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-130').toggle();">
            <h3>130. El Proyecto que vamos a construir / 131. Creando el Proyecto / 132. Instalando Tailwindcss</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-130" class="hidden">            

            <p class="mb-3.25">Este proyecto es un contador de calorías para contar las calorías de lo que consumimos y las que quemamos haciendo actividades. Va a ser un poco más complejo pues va a tener <strong>formularios (una de las tareas que más vamos a realizar como Developer)</strong>; leeremos sus datos, lo vamos a procesar y realizar algunas operaciones como validación y mucho más. <strong>Trabajar con formularios en React es complicado. Existen distintas librerías que lo simplifican bastante, y es probable que en el grupo de trabajo se use una librería pero <span class="destacado">nosotros debemos saber trabajar con elementos de formulario, leer y colocar en el state lo que el usuario va metiendo y es la razón de este proyecto</span>.</strong>
              
            <p>También tendrá <strong>localStorage</strong>. Va a ser desarrollado con <strong>UseState</strong> pero también veremos el hook <strong>useReducer</strong> que es un hook especial para manejar states complejos en nuestras apps, como es el caso de este proyecto.</p>   
            
            <ul class="mb-3.75">
              <li><span>Vamos al directorio donde queremos crearlo</span></li>
              <li><span><span class="destacado">npm create vite@latest</span> > <strong>calorie-tracker</strong> > <strong>react TypeScript + SWC</strong> > <span class="destacado">npm install</span></span></li>
              <li><span>arrancamos el servidor de desarrollo <span class="destacado">npm run dev</span> y hacemos limpieza: eliminamos carpeta src>assets, eliminamos src>App.css, borramos el contenido de index.css, en index.html cambiamos el title y eliminamos icono <code class="language-js">&lt;link rel=&quot;icon&quot; type=&quot;image/svg+xml&quot; href=&quot;/vite.svg&quot; /&gt;</code> (borramos también el icono vite.svg de la carpeta public) y limpiamos el compo ppal App.tsx.</span></li>
              <li>instalamos tailwind: <a class="underline" href="https://tailwindcss.com/docs/installation/using-vite" target="_blank">https://tailwindcss.com/docs/installation/using-vite</a> 
                <ul class="mb-3.75">
                  <li><span class="destacado">npm install tailwindcss @tailwindcss/vite</span></li>
                  <li>configurar el plugin: 
                    <pre><code class="language-js">
                      //vite.config.ts
                      import tailwindcss from '@tailwindcss/vite'
                      export default defineConfig({
                        plugins: [
                          tailwindcss(),
                        ],
                      })
                    </code></pre>
                  </li>
                  <li>importar tailwindcss en nuestra css principal: 
                    <pre><code class="language-js">
                      //src>index.css
                      @import "tailwindcss";
                    </code></pre>
                  </li>
                </ul>                   
              </li>
            </ul>
              
            <img class="mx-auto mt-1.25" src="../manual-react/src/assets/img/s1-03.jpg" alt="imagen contador calorias">            
          </div>
            
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-133').toggle();">
            <h3>133. Creando los Contenedores Principales</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-133" class="hidden">
            <p>Agregamos header donde irá nuestro título y el botón para restablecer app y content donde irá nuestro formulario:</p> 
            <p>Creamos nuestro primer componente <strong>Form.tsx</strong> y en nuestro compo ppal App.tsx lo importamos y llamamos a su tag en la sección que acabamos de crear.</p> 
            
            
            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">                
                <pre><code class="language-js">
                  //App.tsx
                  import Form from "./components/Form"
                  function App() {  
    
                    return (
                      &lt;&gt;
                  
                        &lt;header className=&quot;bg-lime-600&quot;&gt;
                          &lt;div className=&quot;flex justify-between max-w-4xl mx-auto&quot;&gt;
                            &lt;h1 className=&quot;text-center text-lg font-bold text-white uppercase&quot;&gt;
                              Contador de calorías 
                            &lt;/h1&gt;
                          &lt;/div&gt;
                        &lt;/header&gt;
                  
                        &lt;section className=&quot;bg-lime-500 py-20 px-5&quot;&gt;
                          &lt;div className=&quot;max-w-4xl mx-auto&quot;&gt;
                            &lt;Form /&lt;
                          &lt;/div&gt;
                        &lt;/section&gt;
                        
                      &lt;/&gt;
                    )
                  }
                  
                  export default App
                </code></pre> 
              </div>
              <div class="w-[50%] max-sm:w-[100%] max-sm:mt-1.25">
                <pre><code class="language-js">
                  //Form.tsx
                  export default function Form() {
                    return (
                      &lt;div&gt;Form&lt;/div&gt;
                    )
                  }
                </code></pre>
                <img class="my-2.5" src="./src/assets/img/133.png" alt="img 133">
              </div>      
            </div>


          </div>
           
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-134').toggle();">
            <h3>134. Agregando el Formulario de Entrada de datos</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-134" class="hidden">
            <p>Trabajar con formularios en React es complicado. Existen distintas librerías que lo simplifican bastante, y es probable que en el grupo de trabajo se use una librería <strong>pero nosotros debemos saber leer y colocar en el state lo que el usuario va metiendo y es la razón de este proyecto</strong>.</p> 
            
            <ul class="mb-3.75">
              <li>Comenzamos a maquetar y darle contenido al componente <span class="file">Form.tsx</span>.</li>
              <li>Para las categorías del select iteramos desde un array de objetos que nos traemos de este <a href="https://gist.github.com/codigoconjuan/d84931241e93bebac46fccc28d096123" class="underline">Gist de categorias</a>. Creamos <strong>data>categories.ts</strong> y el type que van a tener lo vamos a reutilizar así que lo metemos en un archivo genérico de types <strong>types>index.ts</strong></li>
              <li>
                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre><code class="language-js">
                      //type>index.ts
                      export type Category = {
                        id: number,
                        name: string
                      }
                    </code></pre>
                    <pre class="mt-1.25"><code class="language-js">
                      //data>categories.ts
                      import type { Category } from "../types"

                      export const categories: Category[] = [
                          { id: 1, name: 'Comida'},
                          { id: 2, name: 'Ejercicio'}
                      ]                
                    </code></pre>

                    <img class="my-2.5" src="./src/assets/img/134.png" alt="">
                  </div>
                  <div class="w-[50%] max-sm:w-[100%] max-sm:mt-1.25">
                    <pre><code class="language-js">
                      //App.tsx
                      import Form from &quot;./components/Form&quot;
                      function App() {  

                        return (
                          &lt;&gt;

                            &lt;header className=&quot;bg-lime-600&quot;&gt;
                              &lt;div className=&quot;flex justify-between max-w-4xl mx-auto&quot;&gt;
                                &lt;h1 className=&quot;text-center text-lg font-bold text-white uppercase&quot;&gt;
                                  Contador de calorías 
                                &lt;/h1&gt;
                              &lt;/div&gt;
                            &lt;/header&gt;

                            &lt;section className=&quot;bg-lime-500 py-20 px-5&quot;&gt;
                              &lt;div className=&quot;max-w-4xl mx-auto&quot;&gt;
                                &lt;Form /&gt;
                              &lt;/div&gt;
                            &lt;/section&gt;
                            
                          &lt;/&gt;
                        )
                      }

                      export default App
                    </code></pre>
                  </div>
                </div>
              </li>
              <li>
                <pre><code class="language-js">
                  //Form.tsx
                  import { categories } from &quot;../data/categories&quot;

                  export default function Form() {
                    return (    
                      &lt;form
                          className=&quot;space-y-5 bg-white shadow p-10 rounded-lg&quot;
                      &gt;
                  
                          &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                              &lt;label htmlFor=&quot;category&quot; className=&quot;font-bold&quot;&gt;Categoría:&lt;/label&gt;
                              &lt;select 
                                  id=&quot;category&quot;
                                  className=&quot;border border-slate-300 p-2 rounded-lg w-full bg-white&quot;
                              &gt;
                                  {categories.map(category =&gt; (
                                      &lt;option
                                          key={category.id}
                                          value={category.id}
                                      &gt;{category.name}&lt;/option&gt;
                                  ))}
                              &lt;/select&gt;
                          &lt;/div&gt;
                  
                          &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                              &lt;label htmlFor=&quot;name&quot; className=&quot;font-bold&quot;&gt;Actividad:&lt;/label&gt;
                              &lt;input 
                                  id=&quot;name&quot;
                                  type=&quot;text&quot; 
                                  className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                                  placeholder=&quot;Por ej: Comida, zumo de naranja, ensalada, Ejercicio, Pesas, Bicicleta&quot;
                                  /&gt;
                          &lt;/div&gt;
                  
                          &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                              &lt;label htmlFor=&quot;calories&quot; className=&quot;font-bold&quot;&gt;Calorías:&lt;/label&gt;
                              &lt;input 
                                  id=&quot;calories&quot;
                                  type=&quot;number&quot; 
                                  className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                                  placeholder=&quot;Calorías Por ej: 300, 500&quot;
                                  /&gt;
                          &lt;/div&gt;
                  
                          &lt;input 
                              type=&quot;submit&quot; 
                              className=&quot;bg-gray-800 hover:bg-gray-900 w-full p-2 font-bold uppercase text-white cursor-pointer&quot;
                              value=&quot;Guardar Comida o guardar Ejercicio&quot;
                          /&gt;
                      &lt;/form&gt;  
                    )
                  }                  
                </code></pre>
              </li>
            </ul>
            
          </div>
           
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-135').toggle();">
            <h3>135. Creando el State para las Actividades</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-135" class="hidden">
            <p>Vamos a ir almacenando en el state todo lo que el usuario elija/escriba en nuestro formulario. Al tener todo eso en nuestro state va a ser más fácil hacer validaciones.</p>
            <ul class="mb-3.75">
              <li><strong>Importamos useState en nuestro componente Form.tsx.</strong></li>
              <li><strong>Definimos nuestro state.</strong> Como tenemos Categoría, actividad y calorías, normalmente crearíamos un state para cada uno:
                <pre class="border-5 border-red-700"><code class="language-js">
                  //Form.tsx
                  import { useState } from "react"

                  const[category, setCategory] = useState('') 
                  const[name, setName] = useState('')
                  const[calories, setCalories] = useState(0)
                </code></pre>
                  pero como están relacionados entre sí podemos tenerlos en un objeto. <strong>Hagamos un state más genérico que vamos a nombrar como activity</strong>. Inicia como arreglo y vamos a ir definiendo sus propiedades:
                  <pre class="border-5 border-emerald-600"><code class="language-js">
                    //Form.tsx
                    import { useState } from "react"

                    const[activity, setsetActivity] = useState({
                      category: '',
                      name: '',
                      calories: 0
                  }) 
                  </code></pre>
              </li>
              <li><strong>Vamos a conectar las propiedades de nuestro state array 'activity' con los inputs del formulario</strong>:
              
                <ul class="mb-3.75">
                  <li>En el select de category, le añadimos como value<code class="language-js">value={activity.category}</code>
                    
                    <div class="flex max-sm:flex-col">
                      <div class="w-[30%] max-sm:w-[100%]">
                        <pre><code class="language-js">
                          //data>categories.ts
                          export const categories: Category[] = [
                            { id: 1, name: 'Comida'},
                            { id: 2, name: 'Ejercicio'}
                          ]
                        </code></pre>
                      </div>
                      <div class="w-[70%] max-sm:w-[100%] max-sm:mt-1.25">
                        <pre data-line="4"><code class="language-js">
                          //Form.tsx
                          &lt;select 
                              id=&quot;category&quot;
                              className=&quot;border border-slate-300 p-2 rounded-lg w-full bg-white&quot;
                              value={activity.category}
                          &gt;
                        </code></pre> 
                        <p>con lo que si en la propiedad category de nuestro state activity tenemos 1, el select por defecto marca Comida que es el de id1 (si fuera 2 que es el id de ejercicio, por defecto marca Ejercicio)</p>
                        <img class="my-2.5" src="./src/assets/img/135-1.png" alt="">
                      </div>
                    </div> 
                  </li>         
                    
                  <li>El input de actividad (#name --> le hemos dado ese id porque coincidia con el nombre del nuevo state), le añadimos como value <code class="language-js">value={activity.name}</code></li>
                  <li>El input de calorias #calories, le añadimos como value <code class="language-js">value={activity.calories}</code></li>        
                </ul>
              </li>
            </ul>
                
            <pre><code class="language-js">
              //Form.tsx
              import { useState } from &quot;react&quot;
              import { categories } from &quot;../data/categories&quot;
              
              export default function Form() {
              
                  const[activity, setsetActivity] = useState({
                      category: 1,
                      name: &#39;&#39;,
                      calories: 0
                  }) 
              
                return (    
                  &lt;form
                      className=&quot;space-y-5 bg-white shadow p-10 rounded-lg&quot;
                  &gt;
              
                      &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                          &lt;label htmlFor=&quot;category&quot; className=&quot;font-bold&quot;&gt;Categoría:&lt;/label&gt;
                          &lt;select 
                              id=&quot;category&quot;
                              className=&quot;border border-slate-300 p-2 rounded-lg w-full bg-white&quot;
                              value={activity.category}
                          &gt;
                              {categories.map(category =&gt; (
                                  &lt;option
                                      key={category.id}
                                      value={category.id}
                                  &gt;{category.name}&lt;/option&gt;
                              ))}
                          &lt;/select&gt;
                      &lt;/div&gt;
              
                      &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                          &lt;label htmlFor=&quot;name&quot; className=&quot;font-bold&quot;&gt;Actividad:&lt;/label&gt;
                          &lt;input 
                              id=&quot;name&quot;
                              type=&quot;text&quot; 
                              className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                              placeholder=&quot;Por ej: Comida, zumo de naranja, ensalada, Ejercicio, Pesas, Bicicleta&quot;
                              value={activity.name}                
                          /&gt;
                      &lt;/div&gt;
              
                      &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                          &lt;label htmlFor=&quot;calories&quot; className=&quot;font-bold&quot;&gt;Calorías:&lt;/label&gt;
                          &lt;input 
                              id=&quot;calories&quot;
                              type=&quot;number&quot; 
                              className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                              placeholder=&quot;Calorías Por ej: 300, 500&quot;
                              value={activity.calories}
                              /&gt;
                      &lt;/div&gt;
              
                      &lt;input 
                          type=&quot;submit&quot; 
                          className=&quot;bg-gray-800 hover:bg-gray-900 w-full p-2 font-bold uppercase text-white cursor-pointer&quot;
                          value=&quot;Guardar Comida o guardar Ejercicio&quot;
                      /&gt;
                  &lt;/form&gt;  
                )
              }
            </code></pre>

            <p>Si abrimos React Developer tools, al pulsar el componente Form, vemos en hooks nuestro state activity</p>
            <img class="my-2.5" src="./src/assets/img/135-2.png" alt="">
            sin embargo si intentamos cambiar la opción del select categoría o escribir en algún input (actividad o calorías) no nos deja y da error en consola, porque necesitamos un <strong>onChange</strong>
            <img class="my-2.5" src="./src/assets/img/135-3.png" alt="">
                          
          </div>
           
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-136').toggle();">
            <h3>136. Escribiendo en el State / 137. Inferir el type de un evento / 138. Creando el Type de Actividad y seteando los valores en el state</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-136" class="hidden">
            <p>Hemos definido nuestro state y lo hemos conectado con los campos de nuestro formulario (1 select y dos inputs) pero como vimos tenemos en la consola advertencias. Le estamos pasando un value pero <strong>también tenemos que especificarle un onChange (básicamente es como un addEventListener y escuchar por el evento change)</strong>, que se ejecutará cada vez que cambiemos de opción en el select o cada vez que intentemos escribir en los inputs. Podemos hacerlo en el mismo input o tener una función aparte que lo gestione y llamaremos <strong>handleChange</strong>. La llamamos desde cada campo de formulario y ya no tendremos errores:</p>
            <pre><code class="language-js">
              //Form.tsx
              const handleChange = () =>{
                console.log ('algo cambió')
              }
              return ( 
                ...
                onChange={handleChange} // en cada campo del formulario
            </code></pre>
            
            <p>Sin embargo vemos que de momento nada cambia en la vista, y es porque el value del select y los inputs es lo que está en el state y de momento no lo estamos actualizando. Hemos de ir escribiendo en el state para que se vayan actualizando esos values de nuestros campos de formulario ¿como lo hacemos?. <strong>Estamos usando la misma función para un select y dos inputs y hemos de leer lo que el usuario haya metido</strong>. Una técnica muy común es pasarle (e) y hacer un console.log(e.target) para, como vemos en la siguiente captura, identificar sobre qué estamos intentando escribir o hacer cambio: </p>     

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  //Form.tsx
                  const handleChange = (e) =>{
                    console.log (e.target)          
                  }
                  return ( 
                    ...
                    onChange={handleChange} // en cada campo del formulario
                </code></pre>  
                
                <img class="my-2.5" src="./src/assets/img/136-1.png" alt="">
              </div>
              <div class="w-[50%] max-sm:w-[100%] max-sm:mt-1.25">
                <pre><code class="language-js">
                  //Form.tsx
                  const handleChange = (e) =>{
                    console.log (e.target.id)
                  }
                  return ( 
                    ...
                    onChange={handleChange} // en cada campo del formulario
                </code></pre>  
                
                <img class="my-2.5" src="./src/assets/img/136-2.png" alt="">
              </div>
            </div>
            
            <p><span class="destacado">SI NOMBRAMOS LOS ID DE NUESTROS ELEMENTOS DE FORMULARIO CON EL MISMO NOMBRE QUE LAS PROPIEDADES DE NUESTRO STATE...</span> <br>es más sencillo, es como "ir mapeando los datos"</p>
            
            <div class="flex max-sm:flex-col">
              <div class="w-[25%] max-sm:w-[100%]">
                <pre class="verde" data-line="4-6"><code class="language-js">
                  //Form.tsx
                  export default function Form() {
                    
                    const[activity, setsetActivity] = useState({
                      category: 1,
                      name: '',
                      calories: 0
                    }) 
                    
                    const handleChange = (e) =>{
                        //console.log (e.target)
                        console.log (e.target.id)
                      }
                    </code></pre>
                  </div>
                  <div class="w-[25%] max-sm:w-[100%] max-sm:mt-1.25">
                    <pre class="verde" data-line="2"><code class="language-js">
                      //Form.tsx
                      &lt;select 
                      id=&quot;category&quot;
                      className=&quot;border border-slate-300 p-2 rounded-lg w-full bg-white&quot;
                      value={activity.category}
                      onChange={handleChange}
                      &gt;
                      {categories.map(category =&gt; (
                        &lt;option
                        key={category.id}
                        value={category.id}
                        &gt;{category.name}&lt;/option&gt;
                        ))}
                        &lt;/select&gt;
                      </code></pre>
                    </div>
                    
                    <div class="w-[25%] max-sm:w-[100%]">
                      <pre class="verde" data-line="2"><code class="language-js">
                  //Form.tsx
                  &lt;input 
                  id=&quot;name&quot;
                  type=&quot;text&quot; 
                  className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                  placeholder=&quot;Por ej: Comida, zumo de naranja, ensalada, Ejercicio, Pesas, Bicicleta&quot;
                  value={activity.name}  
                  onChange={handleChange}              
                  /&gt;
                </code></pre>
              </div>
              <div class="w-[25%] max-sm:w-[100%] max-sm:mt-1.25">
                <pre class="verde" data-line="2"><code class="language-js">
                  //Form.tsx
                  &lt;input 
                  id=&quot;calories&quot;
                  type=&quot;number&quot; 
                  className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                  placeholder=&quot;Calorías Por ej: 300, 500&quot;
                  value={activity.calories}
                  onChange={handleChange}
                  /&gt;
                </code></pre>
              </div>
            </div>
            
            <p><code class="language-js">e.target.id</code> ¿qué es lo que estoy intentando modificar?¿sobre qué intento actuar?</p>
            <p><code class="language-js">e.target.value</code> ¿qué es lo que estoy escribiendo/cambiando? </p>
            
            <p>La función de nuestro state, 'setActivity' es un objeto así que la llamamos, abrimos corchetes y, usamos el spread operator para que con cada cambio que hagamos en el state al modificar el value de CADA elemento de formulario, siempre mantenga el state que había antes de ese cambio (podemos ver en React Developer tools cómo se comporta el state si no hacemos esto, se cambia con cada intento de cambio en algún elemento del formulario) --> escribe correctamente y no pierde la referencia gracias a que tomamos una copia de lo que tenemos en nuestro state antes de escribir un nuevo state</p>
            
            <pre><code class="language-js">
              //Form.tsx
              const handleChange = (e) =>{        
                setActivity({
                  ...activity,
                  [e.target.id]: e.target.value
                })
              }
            </code></pre>
            
            <p>Podemos hacer así uso de nuestro state en otros lugares como por ejemplo en una validación, una vez que yo presione en guardar comida o guardar ejercicio, validamos eso que tenemos en el state antes de guardarlo.</p>
            
            <p class="esp-15-top esp-0-bottom"><span class="naranja">Inferir el Type de un evento</span></p>           
            
            <p>Si vemos, llevamos arrastrando esta advertencia de que <strong>el parámetro e/evt/event tiene un tipo any implícitamente</strong>.</p>
            
            <img class="my-2.5" src="./src/assets/img/137.png" alt="">
            
            <p>Hemos de especificarle un tipo de dato para que no sea any. Si dejamos anys 'por ahí' vamos a tener más problemas que otra cosa y es como si no estuviéramos usando typescript. Veamos cómo identificar qué tipo de dato le vamos a pasar a este evento, con la ayuda del IS de VSC. Vamos al onChange del elemento select de formulario y en vez de llamar a la función handleChange, cambiamos momentáneamente por un <strong>e =></strong>, de ahí sacamos el tipo <strong>React.ChangeEvent&lt;HTMLSelectElement&gt;</strong> pero solo con ese no nos valdría porque vemos que nos da error en los onChange de los elementos input de nuestro formulario. Si hacemos lo mismo cambiando la llamada a la función por un <strong>e =></strong> sacamos el tipo <strong>React.ChangeEvent&lt;HTMLInputElement&gt;</strong></p>
            
            <img class="my-2.5" src="./src/assets/img/137-2.png" alt="">
            
            <p>Usando un pipe "|" en la definición del tipo de ese parámetro, vamos a indicar que nuestra función handleChange se puede utilizar tanto en un elemento select como en un elemento input. Podemos incluir 'ChangeEvent' en la importación de react y así reducimos la sintaxis del tipado de parámetro</p>
            
            <pre><code class="language-js">
              //Form.tsx
              import { useState, ChangeEvent } from "react"
              
              const handleChange = (e: ChangeEvent&lt;HTMLSelectElement&gt; | ChangeEvent&lt;HTMLInputElement&gt; ) =&gt;{        
                setActivity({
                  ...activity,
                  [e.target.id]: e.target.value
                })
              }
            </code></pre>
            
            <p>Vemos que ya no tenemos avisos de VSC y comprobando el hook de nuestro state activity en las React Developer tools vemos que con cada cambio se guarda adecuadamente lo que modificamos/escribimos. <strong>Sin embargo al cambiar vemos que, tanto la categoría como las calorías me las guarda en el state como string y quiero que sean de tipo número</strong>.</p>
            
            <p class="naranja">Creando el Type de Actividad y seteando los valores en el state</p>
            
            <p>En nuestro objeto state 'activity' vemos que las propiedades category y calories son números mientras que la propiedad name (nombre de la actividad) es un string. De hecho así es si recargamos nuestra app y miramos el state en nuestro compo Form en RDT(React Developer Tools). Pero si cambiamos a Ejercicio (la opción 2 del select que tiene un id de 2) o introducimos por ejemplo 300 calorías vemos que lo asigna todo como string</p>
            
            <img class="my-2.5" src="./src/assets/img/137-3.png" alt="">

            <p>Vamos a agregar un type nuevo para el state de activity en nuestro fichero de types, lo importamos en nuestro componente Form.tsx y se lo asignamos vía generic a nuestro state:</p>

            <pre data-line="8,13"><code class="language-js">
              //types>index.ts
                export type Activity = {
                  category: number,
                  name: string,
                  calories: number
                }
              //Form.tsx
                import { useState, ChangeEvent } from "react"
                import { Activity } from "../types"
                import { categories } from "../data/categories"
                
                export default function Form() {
                
                    const[activity, setActivity] = useState&lt;Activity&gt;({
                        category: 1,
                        name: '',
                        calories: 0
                    }) 
            </code></pre>

            <p>Una vez hecho lo anterior VSC no nos marca errores, porque TS está funcionando bien en esta parte de nuestro compo, en nuestro código, pero no sabe qué es lo que vamos a agregar en ese formulario. <strong>Nosotros hemos de mantener esa integridad de nuestro state activity ¿Como podemos hacer para convertirlos a números antes de setearlos a nuestro state?</strong></p>
            <ul class="mb-3.75">
              <li>Identifiquemos los que queremos que sean números. Creamos una variable de tipo array llamada 'isNumberField' que va a comprobar si donde estoy escribiendo es categoría o calorías: <code class="language-js">const isNumberField = ['category','calories'].includes(e.target.id)</code> --&gt; en caso de que esté escribiendo en category o calories me retorna true</li>
              <li>Teniendo en cuenta la comprobación que hacemos con esta nueva variable, añadimos un ternario a nuestra expresión anterior <code class="language-js">[e.target.id]: e.target.value</code> de manera que si es true convertimos a número con <span class="destacado">+</span> y si no lo dejamos como estaba, que setea string:
              <pre><code class="language-js">
                //Forms.tsx
                const handleChange = (e: ChangeEvent<HTMLSelectElement> | ChangeEvent<HTMLInputElement> ) =>{   
                  const isNumberField = ['category','calories'].includes(e.target.id)
                  setActivity({
                      ...activity,           
                      [e.target.id]: isNumberField ? +e.target.value : e.target.value
                  })
                }
              </code></pre>
              </li>
            </ul>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  //types>index.ts
                    export type Category = {
                      id: number,
                      name: string
                    }
                    export type Activity = {
                        category: number,
                        name: string,
                        calories: number
                    }
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%] max-sm:mt-1.25">
                <pre><code class="language-js">
                  //data>categories.ts
                  import type { Category } from "../types"

                  export const categories: Category[] = [
                      { id: 1, name: 'Comida'},
                      { id: 2, name: 'Ejercicio'}
                  ]  
                </code></pre>
              </div>
            </div>

            <pre><code class="language-js">
              import { useState, ChangeEvent } from &quot;react&quot;
              import { Activity } from &quot;../types&quot;
              import { categories } from &quot;../data/categories&quot;
              
              export default function Form() {
              
                  const[activity, setActivity] = useState&lt;Activity&gt;({
                      category: 1,
                      name: &#39;&#39;,
                      calories: 0
                  }) 
              
                  const handleChange = (e: ChangeEvent&lt;HTMLSelectElement&gt; | ChangeEvent&lt;HTMLInputElement&gt; ) =&gt;{   
                      const isNumberField = [&#39;category&#39;,&#39;calories&#39;].includes(e.target.id)
                      setActivity({
                          ...activity,           
                          [e.target.id]: isNumberField ? +e.target.value : e.target.value
                      })
                  }
              
                return (    
                  &lt;form
                      className=&quot;space-y-5 bg-white shadow p-10 rounded-lg&quot;
                  &gt;
              
                      &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                          &lt;label htmlFor=&quot;category&quot; className=&quot;font-bold&quot;&gt;Categoría:&lt;/label&gt;
                          &lt;select 
                              id=&quot;category&quot;
                              className=&quot;border border-slate-300 p-2 rounded-lg w-full bg-white&quot;
                              value={activity.category}
                              onChange={handleChange}
                          &gt;
                              {categories.map(category =&gt; (
                                  &lt;option
                                      key={category.id}
                                      value={category.id}
                                  &gt;{category.name}&lt;/option&gt;
                              ))}
                          &lt;/select&gt;
                      &lt;/div&gt;
              
                      &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                          &lt;label htmlFor=&quot;name&quot; className=&quot;font-bold&quot;&gt;Actividad:&lt;/label&gt;
                          &lt;input 
                              id=&quot;name&quot;
                              type=&quot;text&quot; 
                              className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                              placeholder=&quot;Por ej: Comida, zumo de naranja, ensalada, Ejercicio, Pesas, Bicicleta&quot;
                              value={activity.name}  
                              onChange={handleChange}              
                          /&gt;
                      &lt;/div&gt;
              
                      &lt;div className=&quot;gris grid-cols-1 gap-3&quot;&gt;
                          &lt;label htmlFor=&quot;calories&quot; className=&quot;font-bold&quot;&gt;Calorías:&lt;/label&gt;
                          &lt;input 
                              id=&quot;calories&quot;
                              type=&quot;number&quot; 
                              className=&quot;w-full border border-slate-300 p-2 rounded-lg&quot;
                              placeholder=&quot;Calorías Por ej: 300, 500&quot;
                              value={activity.calories}
                              onChange={handleChange}
                              /&gt;
                      &lt;/div&gt;
              
                      &lt;input 
                          type=&quot;submit&quot; 
                          className=&quot;bg-gray-800 hover:bg-gray-900 w-full p-2 font-bold uppercase text-white cursor-pointer&quot;
                          value=&quot;Guardar Comida o guardar Ejercicio&quot;
                      /&gt;
                  &lt;/form&gt;  
                )
              }    
            </code></pre>           
          </div>

          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-139').toggle();">
            <h3>139. Validando el Formulario / 140. Mostrar de forma condicional el Texto si es Ejercicio o comida al guardar / 141. Trabajando con el evento de Submit</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-139" class="hidden">
            <p>Veamos como deshabilitar visualmente este formulario, este input de tipo submit</p>              
            <p>Creamos un arrow function, vamos debugeando lo siguiente con console.log y para ello la llamamos en el disabled del button submit:</p>
            <ul class="mb-3.75">
              <li><strong>name.trim() != ''</strong> el name(de actividad) al recortar espacio de inicio y fin es distinto de 0 <strong>true cuando está relleno</strong></li>
              <li>calories > 0 true cuando calorías es mayor que 0</li> 
              <li>Queremos que el botón esté deshabilitado si esta condición no se cumple, por tanto: <code class="language-js">disabled={!isValidActivity()}</code></li>
            </ul>
            <pre data-line="10"><code class="language-js">
              //Form.tsx
              const isValidActivity = () =>{
                const { name, calories } = activity
                return name.trim() != '' && calories > 0 // devuelve true cuando ambas se cumplen
              }
              ...
              &lt;input 
                  type=&quot;submit&quot; 
                  className=&quot;bg-gray-800 hover:bg-gray-900 w-full p-2 font-bold uppercase text-white cursor-pointer&quot;
                  value=&quot;Guardar Comida o guardar Ejercicio&quot;
                  disabled={!isValidActivity()}
              /&gt;
            </code></pre>

            <p>Con ello aseguramos tener deshabilitado el botón, no pasando esa validación hasta qeu no complete los dos campos qyue he especificado en mi función de validación 'isValidActivity' (si rellenáramos con espacios el campo name de actividad no vale por la comprobación que hace el trim()</p>
            <pre><code class="language-js">
              const str = "   foo  ";
              console.log(str.trim()); // 'foo'
            </code></pre>
            
             
            <div class="mt-3 mb-2 ml-1.5 pl-2.5 pt-0.5 pb-2  border-l-2 border-dashed border-l-stone-600 rounded-tl-2xl rounded-bl-2xl bg-neutral-50 shadow-lg">
              <a class="block underline ml-1.5 mb-1.5" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/trim" target="_blank">mdn web docs js referency</a>
              <div class="flex">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="size-6 shrink-0">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3" />
                </svg>
                <span class="bg-neutral-200 px-1.5 py-0.5 italic leading-[24px]">El método trim() de valores tipo string elimina los espacios en blanco de ambos extremos de la cadena y devuelve una nueva cadena, sin modificar la cadena original. Para devolver una nueva cadena con espacios recortados solo en un extremo, usamos trimStart() o trimEnd()</span>
              </div>
            </div>


            <p class="esp-15-top esp-0-bottom"><span class="naranja">Mostrar de forma condicional el Texto del botón si es Ejercicio o comida al guardar</span></p>

            <p>Con el siguiente código que ponemos en el botón, React hace un nuevo render cada vez que cambia el state:</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[33%] max-sm:w-[100%]">
                <pre data-line="2"><code class="language-js">
                  //categories.ts --&gt; los datos
                  import type { Category } from "../types"
                  export const categories: Category[] = [
                      { id: 1, name: 'Comida'},
                      { id: 2, name: 'Ejercicio'}
                  ]
                </code></pre>
              </div>
              <div class="w-[33%] max-sm:w-[100%]">
                <pre data-line="3,11"><code class="language-js">
                  //Form.tsx --&gt; el select categoría
                  &lt;label htmlFor=&quot;category&quot; className=&quot;font-bold&quot;&gt;Categoría:&lt;/label&gt;
                  &lt;select 
                      id=&quot;category&quot;
                      className=&quot;border border-slate-300 p-2 rounded-lg w-full bg-white&quot;
                      value={activity.category}
                      onChange={handleChange}
                  &gt;
                      {categories.map(category =&gt; (
                          &lt;option
                              key={category.id}
                              value={category.id}
                          &gt;{category.name}&lt;/option&gt;
                      ))}
                  &lt;/select&gt;                  
                </code></pre>
              </div>
              <div class="w-[33%] max-sm:w-[100%]">
                <pre data-line="2"><code class="language-js">
                  //Form.tsx --&gt; state de actividad
                  const[activity, setActivity] = useState&lt;Activity&gt;({
                    category: 1,
                    name: '',
                    calories: 0
                  }) 
                </code></pre>
              </div>
            </div>            

            <pre data-line="4"><code class="language-js">
            //Form.tsx
              &lt;input 
                type=&quot;submit&quot; 
                className=&quot;bg-gray-800 hover:bg-gray-900 w-full p-2 font-bold uppercase text-white cursor-pointer disabled:opacity-10&quot;
                value={activity.category === 1 ? &quot;Guardar Comida&quot; : &quot;Guardar Ejercicio&quot;}
                disabled={!isValidActivity()}
            /&gt;
            </code></pre>            

            <p class="esp-15-top esp-0-bottom"><span class="naranja">Trabajando con el evento de Submit</span></p>

            <p>Vamos a empezar a trabajar con el submit de nuestro formulario.<p>
            
              <ul class="mb-3.75">
                <li>Añadimos al tag form onSubmit y llamamos a una nueva arrow function 'handleSubmit' que recibe parámetro e.</li>
                <li>Como nos avisa que es un 'any' buscamos el type con la ayuda del IS de VSC (cambiamos en el submit la llamada a nuestra nueva función por <strong>e = &gt;</strong> y nos indica que <code class="language-js">(parameter) e: React.FormEvent&lt;HTMLFormElement&gt;</code> así que importamos FormEvent y así reducimos la sintaxis en el tipado pudiendo quitar el 'react.' previo
                  <pre data-line="1,3-6,11"><code class="language-js">
                    //Form.tsx
                    import { useState, ChangeEvent, FormEvent } from "react"
                    ...
                    const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =&gt;{
                      e.preventDefault()
                      console.log(&#39;Submit...&#39;)
                    }
                
                    return (    
                        &lt;form
                            className=&quot;space-y-5 bg-white shadow p-10 rounded-lg&quot;
                            onSubmit={handleSubmit}
                        &gt;
                        ...
                  </code></pre>
                </li>
              </ul>
          </div>
           
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-142').toggle();">
            <h3>142. Introducción a useReducer</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-142" class="hidden">
            <p>Hasta ahora hemos estado usando un custom hook, pero cuando tenemos states más complejos podemos ir almacenando en algo conocido como <span class="destacado">reducers</span>. Es una forma de almacenar nuestro state, no de manera global digamos, es un archivo a parte y usamos un hook llamado useReducer. Veamos qué es eso.</p>

            <p>Ya tenemos todo listo para empezar a almacenar nuestras actividades, pero vamos a utilizar un enfoque diferente para almacenar el state de nuestra app, vamos a hacerlo por medio de algo llamado <strong>reducers</strong>. Vamos a ver el <strong>hook useReducer y la terminología nueva que vamos a encontrar trabajando con reducers</strong>. Este hook es la base de herramientas como <span class="destacado">Zustand</span> y <span class="destacado">Redux toolkit</span> asíq ue todo lo qeu aprendamos ahora y con los proyectos que vienen nos vendrá bien para el trabajo posterior con ese tipo de herramientas que son más avanzadas.</p>

            <div class="mt-3 mb-2 ml-1.5 pl-2.5 pt-0.5 pb-2  border-l-2 border-dashed border-l-stone-600 rounded-tl-2xl rounded-bl-2xl bg-neutral-50 shadow-lg">
              <p class="destacado">useReducer, un Hook para manejar state</p>
              <div class="flex">
                <svg class="size-6 shrink-0" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                </svg>
                <div class="bg-neutral-200 px-1.5 py-0.5 italic leading-[24px]">
                  <ul>
                    <li>useReducer es una alternativa de useState. Es un hook para manejar el state.</li>
                    <li><strong>useReducer es un Hook de React que te permite agregar un reducer a tu componente</strong>. Es una sintaxis un poco diferente pero una vez entendida hace muy sencillo administrar el state de las apps.</li>
                    <li>El hook  useReducer en React es una alternativa a Usestate que se utiliza para manejar estados más complejos y transiciones de estado que involucran lógica más complicada (que lo que encontrarías en Usestate). Mientras que useState es perfecto para el manejo de estados simples, useReducer es más adecuado para situaciones donde el nuevo estado depende del estado anterior o cuando hay múltiples sub-valores o lógica condicional a considerar (como múltiples states que se actualizan en base a ciertas acciones).</li>
                  </ul>
                </div>
              </div>
            </div>

            <div class="mt-3 mb-2 ml-1.5 pl-2.5 pt-0.5 pb-2  border-l-2 border-dashed border-l-stone-600 rounded-tl-2xl rounded-bl-2xl bg-neutral-50 shadow-lg">
              <p class="destacado">Composición de useReducer</p>
              <div class="flex">
                <svg class="size-6 shrink-0" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                </svg>
                <div>
                  <pre><code class="language-js">
                    const [state, dispatch] = useReducer(reducer, initialState)
                  </code></pre>
                  <div>
                    <p class="bg-neutral-200 px-1.5 py-0.5 italic leading-[24px]">Se utiliza el Hook useReducer y podemos ver que la estructura es similar a useState con algunas pequeñas diferencias:</p>
                    <ul class="mb-3.75">
                      
                      <li>El Hook useReducer toma dos argumentos:
                          <ul class="list-disc">
                            <li><strong>reducer:</strong> es una función que toma el estado actual y una acción, y devuelve un nuevo estado.</li>
                            <li><strong>initialState:</strong> es el estado inicial de nuestro reducer. Podemos pensar en ello como lo que tenemos actualmente en nuestro ejemplo del formulario del proyecto actual (la categoría 1 el name de actividad como string vacío y las calorías en 0)
                              <!-- <pre><code class="language-js">
                                const[activity, setActivity] = useState&lt;Activity&gt;({
                                  category: 1,
                                  name: '',
                                  calories: 0
                              }) 
                              </code></pre> -->
                            </li>
                          </ul>
                      </li>

                      <li class="mt-2.5">Algunos términos cuando trabajamos con useReducer
                        <ul class="list-disc">
                          <li><strong>state:</strong> es el valor del estado cuya lógica se maneja dentro del reducer.</li>
                          <li><strong>initialState:</strong> es el estado inicial con el que es creado el reducer, es similar a los valores de inicio de useState.</li>
                          <li><strong>Actions:</strong> las acciones o funciones que manejan toda la lógica para modificar nuestro state. Básicamente es una función que desde fuera, desde el componente, llega y modifica nuestro state, muy similar a las funciones que exportábamos en nuestro custom Hooks.</li>
                          <li><strong>Payload: </strong> es la información que modifica nuestro state. Similar a la parte de nuestros custom hooks donde teníamos una función y le pasábamos un id o un objeto con la información, eso modifica el state, eso es lo que se conoce como un Payload cuando trabajamos con Reducers.</li>
                          <li><strong>Dispatch:</strong> es la función que manda llamar la acción con el payload. Las acciones las vamos a definir en nuestro reducer, sin embargo el Dispatch es el que las manda llamar.</li>
                        </ul>
                      </li>
                    </ul>
                  </div>
                </div>
              </div>
            </div>           
                          
          </div>
  
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-143').toggle();">
            <h3>143. Definiendo nuestro reducer</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-143" class="hidden">
            <p>Vamos a crear nuestro primer reducer. Creamos src la carpeta nueva "reducers" y un fichero que podemos nombrar de estas dos maneras:</p>
            <ul>
              <li>src&gt;reducer&gt;<strong>activityReducers.ts</strong></li>
              <li>src&gt;reducer&gt;<strong>activity-reducer.ts</strong></li>
            </ul>

            <div class="mt-3 mb-2 ml-1.5 pl-2.5 pt-0.5 pb-2  border-l-2 border-dashed border-l-stone-600 rounded-tl-2xl rounded-bl-2xl bg-neutral-50 shadow-lg">
              <div class="flex">
                <svg class="size-6 shrink-0" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                </svg>             
                <p class="bg-neutral-200 px-1.5 py-0.5 italic leading-[24px]">Nuestro reducer va a constar de varias partes:</p>
                <ul>
                  <li>Acciones que describen lo que está pasando en la aplicación</li>
                  <li>El state inicial</li>
                  <li>Nuestro reducer que conecta tanto el state inicial como nuestras acciones</li>
                </ul>
              </div>
            </div>           

            <p><strong>HASTA AHORA TENÍAMOS</strong> en nuestro Form.tsx y en nuestro fichero de types>index.ts: (<span class="destacado">él indica crear este type pero YA LO TENÍAMOS y además en este vídeo el actual state de Form.tsx no lo muestra tipado con generic como había hecho hasta ahora. Lo vuelve a hacer, pero nosotros de momento no hemos cambiado nada ni de types>index.ts ni de Forms.tsx</span>)</p>
            <pre><code class="language-js">
              //types>index.ts
                export type Activity = {
                  category: number,
                  name: string,
                  calories: number
                }
              
              //Form.tsx
                const[activity, setActivity] = useState&lt;Activity&gt;({
                    category: 1,
                    name: &#39;&#39;,
                    calories: 0
                }) 
            </code></pre>

            <p>Lo importante, así es como queda de momento nuestro reducer <span class="file">activity-reducers.ts</span> recién creado:</p>
            <pre><code class="language-js">
              //activity-reducers.ts
              import { Activity } from "../types"

              //ACCIONES - type que va a contener las acciones, lo que va a pasar en nuestro reducer
              export type ActivityActions = {
              
              }
              
              export type ActivityState = {
                  activities : Activity[] //el state de este reducer se va a llamar activities y va a ser de tipo Activity[](ya lo teníamos definido en types)
              }              
              //STATE - nuestro state inicial que es un objeto necesita un type (definimos arriba 'ActivityState'). En nuestro state de actividades vamos a tener un arreglo.
              export const initialState: ActivityState = {
                  activities: [] //inicia como arreglo vacío
              }
              
              //REDUCER - que conecta a ambos, nuestras acciones y el state
              export const activityReducer = (
                      state : ActivityState = initialState,
                      action: ActivityActions
                  ) => {
                      
                  return state  
              }
            </code></pre>
          </div>
  
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-144').toggle();">
            <h3>144. Definiendo acciones en el Reducer</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-144" class="hidden">

            <div class="mt-3 mb-2 ml-1.5 pl-2.5 pt-0.5 pb-2  border-l-2 border-dashed border-l-stone-600 rounded-tl-2xl rounded-bl-2xl bg-neutral-50 shadow-lg">
              <p><strong>Las acciones nos van a ayudar a describir qué es lo que está pasando y qué información es la que va a modificar qué parte de nuestro state.</strong></p>
              <div class="flex">
                <svg class="size-6 shrink-0" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                </svg>
                <span class="bg-neutral-200 px-1.5 py-0.5 italic leading-[24px]">Aunque suena complicado, básicamente una acción consta de dos partes: el type que es la descripción y el Payload que es la información que vamos a agregar a nuestro state (o que lo modifica). <strong>Dejémonos llevar y veamos las diferentes acciones y funciones de nuestro reducer para que vaya quedando todo más claro.</strong></span>
              </div>
            </div>
           
            
            <p>Una vez que rellenemos el formulario vamos a tener una categoría, una actividad y las calorías. <strong>Cuando presionemos el botón de Guardar (lo que sea) estaremos creando una nueva actividad, ya sea ejercicio o comida.</strong> 
              <pre><code class="language-js">  
                //Form.tsx 
                const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =&gt;{
                  e.preventDefault()
                  //console.log(&#39;Submit...&#39;)
                }
                  return (    
                    &lt;form
                        className=&quot;space-y-5 bg-white shadow p-10 rounded-lg&quot;
                        onSubmit={handleSubmit}
                    &gt;  
                
              </code></pre>

              <p>y lo vamos a conectar con esta otra parte, el reducer, para que ejecute cierta parte de nuestro código:</p>
              <pre><code class="language-js">
                //activity-reducers.ts
                //REDUCER - que conecta a ambos, nuestras acciones y el state
                export const activityReducer = (
                    state : ActivityState = initialState,
                    action: ActivityActions
                  ) => {
                  
                  return state  
                }
              </code></pre>              
              
              <p>Así que en la parte de acciones de nuestro reducer, preparemos nuestro primer action definiendo:
                
              <ul>
                <li>El <strong>type</strong>, que es lo que describe lo que está sucediendo/lo que va a pasar en nuestro reducer. Una vez que hayamos enviado el formulario vamos a decirle a nuestro reducer <strong>"ejecuta el type 'save-activity'"</strong>
                  <pre><code class="language-js">
                    //ACCIONES - type que va a contener las acciones, lo que va a pasar en nuestro reducer
                    export type ActivityActions = 
                        { type: 'save-activity', payload: { newActivity: Activity} } 
                  </code></pre>
    
                  <p>Usando el pipe como unión "|" podríamos tener múltiples actions, todos los que requiramos en  nuestra aplicación:</p>
              
                  <pre><code class="language-js">
                    //ACCIONES - type que va a contener las acciones, lo que va a pasar en nuestro reducer
                    export type ActivityActions = 
                        { type: 'save-activity', payload: { newActivity: Activity} } |
                        { type: 'save-activity', payload: { newActivity: Activity} } |
                        { type: 'save-activity', payload: { newActivity: Activity} } 
                  </code></pre>                
                </li>
                <li>
                  <p>El <strong>payload</strong>; cuando yo genere esta actividad nueva 'save-activity', tenemos que pasarle cierta información, lo que el usuario ingresó en el formulario. Eso es lo que se conoce como el payload, y podemos pensar en ello como <strong>los datos que se van a agregar a nuestro state (actualmente está vacío)</strong>.</p>

                  <p>en la parte del reducer antes se trabajaba con switch, (nunca le han gustado) pero prefiere usar if. Y explica que, desde el momento en que tenemos 'conectado' aquí el state y el action, el autocompletado de VSC nos sugiere las posibles opciones en cuanto comenzamos a trabajr con ello:</p>

                  <img src="./src/assets/img/144.png" loading="lazy" alt="img 144">
      
                  <pre data-line="0"><code class="language-js">
                    //activity-reducers.ts
                    //REDUCER - que conecta a ambos, nuestras acciones y el state
                    export const activityReducer = (
                            state : ActivityState = initialState,
                            action: ActivityActions
                        ) => {
                        
                        if(action.type === 'save-activity'){
                            //Este código maneja la lógica para actualizar el state
                            console.log('desde el type de save-activity')
                        }
      
                        return state
      
                    }
                  </code></pre>
                
                </li>
              </ul>

             

           
          </div>
  
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-145').toggle();">
            <h3>145. Ejecutando las acciones con dispatch</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-145" class="hidden">
            <p><strong>Vamos a llamar nuestra primera acción de nuestro reducer</strong> y en el siguiente apartado veremos como actualizar nuestro state.</p> 
            <p>Abrimos nuestro <span class="file">App.tsx</span> porque aún no tenemos un estado global así que para poder usar nuestro reducer tenemos que importar el Hook useReducer y pasarlo vía props (mientras no tengamos un estado global, tenemos que hacer esto con todas las funciones que requerimos en nuestros componentes). A continuación lo usamos antes de nuestro return. Si recordamos, useReducer toma dos parámetros, el reducer y el state inicial (que también tenemos que importar). Eso lo tenemos en nuestro: <span class="file">activity-reducers.ts</span>:</p>
            
            <img src="./src/assets/img/145.png" alt="">

            <pre data-line="1,3,7"><code class="language-js">
              //App.tsx
              import { useReducer } from "react"
              import Form from "./components/Form"
              import { activityReducer, initialState } from "./reducers/activity-reducers"
              
              function App() {  
              
                const [state, dispatch] = useReducer(activityReducer, initialState)
            </code></pre>

            <p>este arreglo <code class="language-js">const [state, dispatch] =...</code> nos retorna <strong>el state de ese reducer</strong> (puede ser vacío o conforme se vaya actualizando) y <strong>dispatch que es una función especial que nos va a permitir ejecutar las acciones que tengamos en nuestro reducer</strong>. Nuestro proyecto no sabe en qué momento queremos ejecutar esas acciones, pero cuando yo presione en Guardar comida y una vez pase toda la validación descrita en Form.tsx, entonces puedo disparar/ejecutar esas acciones en el momento en que yo las necesite.</p>
              
            <div class="mt-3 mb-2 ml-1.5 pl-2.5 pt-0.5 pb-2  border-l-2 border-dashed border-l-stone-600 rounded-tl-2xl rounded-bl-2xl bg-neutral-50 shadow-lg">              
              <div class="flex">
                <svg class="size-6 shrink-0" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                </svg>
                <span class="bg-neutral-200 px-1.5 py-0.5 italic leading-[24px]"> Supongamos que vamos a utilizar este reducer para consumir una API y queremos mostrar un listado de clientes tan pronto como cargue el componente. Podríamos colocar un useEffect y entonces utilizar dispatch para traernos una acción que hubiéramos definido para traer resultados de una API; entonces como no sabe exactamente en qué momento queremos utilizarlo nos da esta función especial para nosotros mandarlo llamar con nuestro código.</span>
              </div>
            </div>

            <p>Como no tenemos un estado global, tenemos que pasar como prop este dispatch hacia mi componente Form.tsx. </p>
            <pre data-line="10"><code class="language-js">
              //App.tsx
              import { useReducer } from "react"
              import Form from "./components/Form"
              import { activityReducer, initialState } from "./reducers/activity-reducers"

              function App() {  

                const [state, dispatch] = useReducer(activityReducer, initialState)
                ...
                &lt;Form 
                dispatch = {dispatch}
                /&gt;
            </code></pre>
              
            <p>Sale en rojo, <strong>nosotros queremos asignarle nuestras acciones para que el autocompletado de VSC sugiera las acciones que retorna al utilizar el activityReducer del primer parámetro.</strong></p>
            
            <pre data-line="2"><code class="language-js">
              //activity.reducers.ts
              //ACCIONES - type que va a contener las acciones, lo que va a pasar en nuestro reducer
              export type ActivityActions = 
                  { type: 'save-activity', payload: { newActivity: Activity} } 
            </code></pre>
            
            <p>En nuestro componente Form.tsx definimos un type nuevo para las props que le pasamos (en este caso dispatch) en el que le indicamos que ese dispatch es <strong>de tipo Dispatch (se importa automáticamente en la importación de react superior)</strong> y con un generic le vamos a pasar las acciones que tenemos en nuestro reducer (ponemos ActivityActions y automáticamente aparece arriba importado). De esta manera, este dispatch <code class="language-js">type FormProps = { dispatch: ...</code> que se está creando con este useReducer <code class="language-js">... = useReducer(activityReducer,...</code> que viene desde activity-reducer.ts, tiene la información sobre qué acciones tiene el reducer que lo ha creado:</p>
            
            <pre data-line="1,4,6-8"><code class="language-js">
              //Form.tsx
              import { useState, ChangeEvent, FormEvent, Dispatch } from "react"
              import { categories } from "../data/categories"
              import { Activity } from "../types"
              import { ActivityActions } from "../reducers/activity-reducers"

              type FormProps = {
                  dispatch: Dispatch&lt;ActivityActions&gt;
              }
            </code></pre>          
              

            <p>Una vez extraemos y tipamos ese prop en la llamada de la fcn de nuestro componente, ya tenemos acceso a ese dispatch:</p>
            <pre data-line="3"><code class="language-js">  
              type FormProps = {
                  dispatch: Dispatch&lt;ActivityActions&gt;
              }
              export default function Form({dispatch}: FormProps) {
              </code></pre>

              <p>¿Cuando disparamos esa acción? Cuando presionemos en el botón, validación + submit de nuestro formulario:</p>

              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <p>Así que <strong>como argumento del dispatch (y aprovechando el autocompletado) le pasamos la acción que queremos disparar de las que están definidas en nuestro reducer (de momento solo tenemos una)</strong>.</p>
                  <pre data-line="4"><code class="language-js">
                    //Form.tsx
                    const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =>{
                      e.preventDefault()
                      //console.log('Submit...')
                      dispatch({ type: 'save-activity', payload: {newActivity: activity} })
                  }
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <p>como vemos coincide (copy-pasteamos) con la acción que tenemos definida en nuestro reducer</p>
                  <pre data-line="2"><code class="language-js">
                    //activity-reducers.ts                
                    export type ActivityActions = 
                        { type: 'save-activity', payload: { newActivity: Activity} } 
                  </code></pre>
                </div>
              </div>

              <p class="destacado">Recapitulemos:</p>
              
              <ul class="my-3.5">
                <li><span class="file">activity-reducers.ts</span> 
                  <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                  </svg>
                  Definimos nuestro reducer y tenemos nuestras acciones (en nuestro caso solo una, 'save-activity', que toma un payload=la información (es básicamente el parámetro que le estaríamos pasando hacia este reducer) y le decimos que va a tomar una nueva actividad de tipo actividad. Y <strong>en la parte inferior del archivo 'activity-reducers.ts' (en la 3º parte, la del reducer que conecta ambos, las acciones y el state) evaluamos que si el action es de tipo 'save-activity' ejecute el código que está en ese if</strong>.
                  <pre data-line="5,21-24"><code class="language-js">
                    //activity-reducers.ts
                    import { Activity } from "../types"
        
                    //ACCIONES - type que va a contener las acciones, lo que va a pasar en nuestro reducer
                    export type ActivityActions = 
                        { type: 'save-activity', payload: { newActivity: Activity} } 
                    
                    export type ActivityState = {
                        activities : Activity[] //el state de este reducer se va a llamar activities y va a ser de tipo Activity[](ya lo teníamos definido en types)
                    }
                    //STATE - nuestro state inicial que es un objeto necesita un type (definimos arriba 'ActivityState'). En nuestro state de actividades vamos a tener un arreglo.
                    export const initialState: ActivityState = {
                        activities: [] //inicia como arreglo vacío
                    }
                    
                    //REDUCER - que conecta a ambos, nuestras acciones y el state
                    export const activityReducer = (
                            state : ActivityState = initialState,
                            action: ActivityActions
                        ) => {
                        
                        if(action.type === 'save-activity'){
                            //Este código maneja la lógica para actualizar el state
                            console.log('desde el type de save-activity')
                        }
                    
                        return state
                    }
                  </code></pre>
                </li>

                <li><span class="file">App.tsx</span> 
                  <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                  </svg>
                  Para usar este reducer hemos de importar el Hook useReducer de react. Como podemos tener múltiples reducers hemos de pasarle en qué reducer queremos utilizarlo (lo que nos va a dar acceso al state de ese reducer y las funciones de ese type) y un estado inicial
                <pre data-line="1,3,7"><code class="language-js">
                  //App.tsx
                  import { useReducer } from "react"
                  import Form from "./components/Form"
                  import { activityReducer, initialState } from "./reducers/activity-reducers"

                  function App() {  

                    const [state, dispatch] = useReducer(activityReducer, initialState)  
                </code></pre>
                Así ya tenemos acceso al estado:
                  <pre data-line="1-3"><code class="language-js">
                    //activity-reducers.ts
                    export const initialState: ActivityState = {
                      activities: [] //inicia como arreglo vacío
                    }
                  </code></pre>
                  
                ..y al dispatch, que son estas acciones que están conectadas con nuestras acciones:
                  <pre data-line="5-8"><code class="language-js">
                    //activity-reducers.ts              
                    export const activityReducer = (
                            state : ActivityState = initialState,
                            action: ActivityActions
                        ) => {                    
                        if(action.type === 'save-activity'){
                            //Este código maneja la lógica para actualizar el state
                            console.log('desde el type de save-activity')
                        }
                    }
                  </code></pre>
                </li>
                <li><span class="file">Form.tsx</span>
                  <svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                  </svg>
                  Como esas acciones se pueden ejecutar en diferentes momentos de nuestra App (no especificados), tenemos acceso a esa función de dispatch que la pasamos como prop hacia nuestro Form.tsx, donde la extraemos y, tras validar nuestro formulario entonces mandamos llamar ese dispatch, diciéndole que queremos ejecutar ese save-activity.
                
                <pre data-line="6-8,10,15"><code class="language-js">
                  //Form.tsx
                  import { useState, ChangeEvent, FormEvent, Dispatch } from "react"
                  import { categories } from "../data/categories"
                  import { Activity } from "../types"
                  import { ActivityActions } from "../reducers/activity-reducers"
                  
                  type FormProps = {
                      dispatch: Dispatch&lt;ActivityActions&gt;
                  }
                  
                  export default function Form({dispatch}: FormProps) {
                    ...
                    const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =>{
                      e.preventDefault()
                      //console.log('Submit...')
                      dispatch({ type: 'save-activity', payload: {newActivity: activity} })
                    } 
                </code></pre>
                  
                  Por lo tanto este dispatch manda llamar de nuevo a mi reducer y evalúa ¿qué código tiene el action.type de 'save-activity' y entonces ejecuta ese código y por eso aparece el console log que dice 'desde el type de save.activity'</li>
              </ul>

              <p>Sí, son muchas cosas a tener en cuenta pero:</p>
              <ul class="my-3.5">
                <li>Tenemos un autocompletado muy bueno que facilita escribir código y evitar errores.</li>
                <li>La forma en la que vamos a manejar el state y nuestras acciones va a hacer que tengamos un código muy bueno, que sea muy sencillo de mantener o agregar más acciones.</li>
                <li>Una forma muy escalable de escribir código.</li>
              </ul>
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-146').toggle();">
            <h3>146. Escribiendo en el reducer / 147. Reiniciando el Formulario después de añadir una actividad</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-146" class="hidden">
            <p>Ya estamos disparando las acciones de nuestro reducer (aparece el console.log('desde el type de save.activity'). Nuestro estate es muy sencillo, pero es un objeto y podríamos tener múltiples elementos (simplemente tendríamos que sincronizarlo con lo definido en su correspondiente type):</p>
            <pre><code class="language-js">
              //activity-reducers-ts
              export type ActivityState = {
                activities : Activity[] //el state de este reducer se va a llamar activities y va a ser de tipo Activity[](ya lo teníamos definido en types)
              }
              //STATE - nuestro state inicial que es un objeto necesita un type (definimos arriba 'ActivityState').
              export const initialState: ActivityState = {
                  activities: [], //inicia como arreglo vacío
                  activities: [], 
                  activities: [], 
                  activities: [], 
                  activities: [], 
              }
            </code></pre>
            <p>Estamos utilizando un dispatch y le estamos pasando la actividad ¿como le hago para poder obtener la información que el usuario está ingresando en el formulario? . La acción de 'save-activity' va a tomar un payload (un payload son los datos) de newActivity que tiene que tener la forma de Activity:</p>
            <pre><code class="language-js">
              //activity-reducers.ts
              //ACCIONES - type que va a contener las acciones, lo que va a pasar en nuestro reducer
              export type ActivityActions = 
              { type: 'save-activity', payload: { newActivity: Activity } } 
            </code></pre>

            <p>Vamos a cambiar el console.log por <code class="language-js">console.log(action.payload.newActivity)</code> y, en cuanto pulsamos el boton, vamos a ver en la consola los datos que hemos ingresado en el formulario:</p>
            <img src="./src/assets/img/146-1.png" alt="">
            <p>le estamos pasando la información desde nuestro dispatch con el payload:
              <div class="mt-3 mb-2 ml-1.5 pl-2.5 pt-0.5 pb-2  border-l-2 border-dashed border-l-stone-600 rounded-tl-2xl rounded-bl-2xl bg-neutral-50 shadow-lg">
                <div class="flex">
                  <svg class="size-6 shrink-0" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
                  </svg>
                  <span class="bg-neutral-200 px-1.5 py-0.5 italic leading-[24px]">El payload son los datos que le pasamos junto a la acción. La forma en que lo recuperamos es con action.payload y el nombre del payload que le hemos dado en unestro archivo de reducer <code class="language-js">action.payload.newActivity</code></span>
                </div>
              </div>
            </p>
            
            <p>Escribamos en nuestro state. En estos if siempre hemos de tener un return que va adevolver el estado actualizado, y antes de ese return manejamos toda la lógica de evitar registros duplicados o lo que considremos que sea necesario para tener nuestro state. También de manera habitual al principio del return vamos a tener una copia de lo que ya tenemos en el state porque este tpo de patrones en los reducers nos permiten modificar múltiples propiedades de nuestro state (ahora solo tenemos una) y con la copia <strong>...state</strong> no perdemos nada de lo que ya tuviéramos almacenado) <strong>las líneas marcadas, las vamos a tener en todas las acciones de nuestros reducers:</strong></p>
            <pre data-line="2,4,5"><code class="language-js">
              //activity-reducers.ts
              ...
              if(action.type === 'save-activity'){
                //Este código maneja la lógica para actualizar el state             
                return{
                  ...state,
                  activities: [...state.activities, action.payload.newActivity]
                }
              }
              ...
            </code></pre>
        
            <p>Probémoslo viendo con el RDT el componente donde usamos el reduce (App.tsx) y como vemos cada vez que agregamos, se añade a nuestro state una actividad:</p>
            
            <img src="./src/assets/img/146-2.png" alt="">
            
            <p class="naranja">Reiniciando el Formulario después de añadir una actividad</p>

            <p>Lo ideal es que el formulario se reinice una vez hayamos añadido una actividad al state (para partir de la situación inicial). Vayamos a nuestro Form.tsx y después del dispatch vamos a reiniciar nuestro state 'activity', podemos hacerlo así:</p>
            <pre><code class="language-js">
              //Form.tsx
              const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =&gt;{
                e.preventDefault()
                dispatch({ type: &#39;save-activity&#39;, payload: {newActivity: activity} })
                setActivity({
                    category: 1,
                    name: &#39;&#39;,
                    calories: 0
                })
              }
            </code></pre>

            <p>mejoremos nuestro código definiendo una constante que tenga esos valores y la usamos tanto en el initial state como en este reinicio que hacemos tras el dispatch.</p>
            
            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre class="rojo" data-line="3-7,12-16"><code class="language-js">
                  //Form.tsx
                  export default function Form({dispatch}: FormProps) {

                    const[activity, setActivity] = useState&lt;Activity&gt;({
                        category: 1,
                        name: &#39;&#39;,
                        calories: 0
                    }) 
                    ...
                    const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =&gt;{
                      e.preventDefault()
                      dispatch({ type: &#39;save-activity&#39;, payload: {newActivity: activity} })
                      setActivity({
                          category: 1,
                          name: &#39;&#39;,
                          calories: 0
                      })
                  }
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre data-line="1-5,8,13" class="verde"><code class="language-js">
                //Form.tsx
                const initialState = {
                  category: 1,
                  name: &#39;&#39;,
                  calories: 0
                }              
                export default function Form({dispatch}: FormProps) {
                
                  const[activity, setActivity] = useState&lt;Activity&gt;(initialState) 
                  ...
                  const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =&gt;{
                    e.preventDefault()
                    dispatch({ type: &#39;save-activity&#39;, payload: {newActivity: activity} })
                    setActivity(initialState)
                }  
                </code></pre>
              </div>
            </div>

            <p>A continuación veremos como listar lo que tenemos en el state y también tenemos que poder diferenciaros de manera única, de momento no tenemos un identificador único para cada una de esas actividades almacenadas en nuestro state.</p>
          </div>         

          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-148').toggle();">
            <h3>148. Generando ID's unicos</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-148" class="hidden">
            <p>Veamos como mostrar las actividades que vamos creando. Primero, vemos que no tenemos un id único que identifique cada actividad añadida (nos podemos comer una manzana por la mañana y otra por la tarde). Para generar un identificador único, vamos a instalar una dependencia <span class="destacado">npm i uuid</span> y en nuestro Form.tsx la importamos: <code class="language-js">import { v4 as uuidv4 } from 'uuid'</code>. Podríamos crear otro type para una actividad que no ha sido almacenada y entonces asignarle un id o también lo podemos hacer aquí en el state inicial:</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[33%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  //Form.tsx
                  import { useState, ChangeEvent, FormEvent, Dispatch } from "react"
                  import { categories } from "../data/categories"
                  import { Activity } from "../types"
                  import { ActivityActions } from "../reducers/activity-reducers"
      
                  type FormProps = {
                      dispatch: Dispatch&lt;ActivityActions&gt;
                  }
      
                  const initialState = {
                    category: 1,
                    name: '',
                    calories: 0
                  }
                </code></pre>
              </div>
              <div class="w-[33%] max-sm:w-[100%]">
                <pre class="verde" data-line="2,11,12"><code class="language-js">
                  //Form.tsx
                  import { useState, ChangeEvent, FormEvent, Dispatch } from "react"
                  import { v4 as uuidv4 } from 'uuid'
                  import { categories } from "../data/categories"
                  import { Activity } from "../types"
                  import { ActivityActions } from "../reducers/activity-reducers"
      
                  type FormProps = {
                      dispatch: Dispatch&lt;ActivityActions&gt;
                  }
      
                  const initialState : Activity = {
                    id: uuidv4(),
                    category: 1,
                    name: '',
                    calories: 0
                  }
                </code></pre>
              </div>
            
              <div class="w-[33%] max-sm:w-[100%]">
                <p>Tenemos que añadirlo en la correspondiente definición de type:</p>
                <pre class="verde" data-line="1"><code class="language-js">
                  //types&gt;index.tsc
                  export type Activity = {
                    id: string
                    category: number
                    name: string
                    calories: number
                  }
                </code></pre>
              </div>
            </div>          
            
            <p>Si miramos en RDT nuestro componente App, vemos que todas las actividades añadidas tiene el mismo id:</p>
            <img src="./src/assets/img/148.png" alt="img 148">              
                
            <p>Para tener un id único por actividad aún tenemos que hacer esto en nuestro handleSubmit del Form.tsx: modificamos el setActivity para que tome una copia del acutal y le añada un id nuevo a la nueva actividad que estamos almacenando.</p>
            
            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  //Form.tsx
                  const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =&gt;{
                    e.preventDefault()
                    dispatch({ type: &#39;save-activity&#39;, payload: {newActivity: activity} })
                    setActivity(initialState)
                  }
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre class="verde" data-line="4-7"><code class="language-js">
                  //Form.tsx
                  const handleSubmit = (e:FormEvent&lt;HTMLFormElement&gt;) =&gt;{
                    e.preventDefault()
                    dispatch({ type: &#39;save-activity&#39;, payload: {newActivity: activity} })
                    setActivity({
                      ...initialState,
                      id: uuidv4()
                    })
                  }
                </code></pre>
              </div>
            </div>
              
            <img src="./src/assets/img/148.png" alt="img 148">          
            
          </div>
           
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-149').toggle();">
            <h3>149. Creando el Componente para listar Actividades y Comidas / 150. Añadiendo más información al listado de Actividades</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-149" class="hidden">
            <p>Veamos cómo mostrar nuestras actividades. ¿Cómo hacemos para mostrar el state ya en nuestros componentes?. App.tsx nos retorna el state y el dispatch. Dispatch es para llamar las acciones de nuestro reducer y state nos devuelve el estado del reducer. Así que como ya lo tenemos coloquemos un console.log(state) y veremos en la consola las actividades que tenemos añadidas:</p>
            <pre><code class="language-js">
              //App.tsx
              const [state, dispatch] = useReducer(activityReducer, initialState) 
              console.log(state)
            </code></pre>

            <p>Así que teniéndolo en este state podemos iterar, crear componentes, etc... Creamos una sección nueva en nuestro App.tsx qeu contiene el tag del nuevo componente que creamos para listar las actividades: <strong>ActivityList</strong>. Le podríamos pasar como prop el state entero <code class="language-js">state={state}</code>, sin embargo como este componente solo va a renderizar la lista de actividades le pasamos como propsolo esas actividades <code class="language-js">activities={state.activities}</code>:</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  //App.tsx
                  import ActivityList from "./components/ActivityList"
                  ...
                  &lt;section className=&quot;p-10 mx-auto max-w-4xl&quot;&gt;
                    &lt;ActivityList 
                      activities={state.activities}
                    /&gt;
                  &lt;/section&gt;
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  //ActivityList.tsx
                  import { Activity } from &quot;../types&quot;

                  type ActivityListProps = {
                      activities: Activity[]
                  }
                  
                  export default function ActivityList({activities}: ActivityListProps) {  
                      //console.log(activities)
                      return (
                      &lt;&gt;
                          &lt;h2 className=&quot;text-4xl font-bold text-slate-600 text-center&quot;&gt;Comida y Actividades&lt;/h2&gt;
                  
                          {activities.map(activity =&gt; (
                              &lt;div key={activity.id} className=&quot;px-5 py-10 bg-white mt-5 flex justify-between&quot;&gt;
                                  &lt;div className=&quot;space-y-2 relative&quot;&gt;
                                      {/* Muestra actividad: categoría, nombre y calorías */}
                                      &lt;p&gt;{activity.category}&lt;/p&gt;
                                      &lt;p className=&quot;text-2xl font-bold pt-5&quot;&gt;{activity.name}&lt;/p&gt;
                                      &lt;p className=&quot;font-black text-4xl text-lime-500&quot;&gt;
                                          {activity.calories} {&#39;&#39;}
                                          &lt;span&gt;Calorías&lt;/span&gt;
                                      &lt;/p&gt;
                                  &lt;/div&gt;
                                  &lt;div&gt;
                                      {/* Acciones para editar esa actividad o eliminarla */}
                  
                                  &lt;/div&gt;
                                  
                              &lt;/div&gt;
                          ))
                          }
                      &lt;/&gt;
                      )
                  }
                </code></pre>
              </div>
            </div>

            <p class="naranja">Añadiendo más información al listado de Actividades</p>
            
            <p>Ahora mismo vemos que nuestra App nos muestra así las actividades que introducimos (usando el id de nuestros datos=diccionario de actividades) y queremos usar el name para que sea un poco más descriptivo:</p>

            <img src="./src/assets/img/150.png" alt="img 150">

            <p>Con el id iteramos sobre nuestras categorías y muestro el label en vez del id. <span class="rojo">COMPLEJO, REPASAR</span></p>

            <pre data-line="11-14,26"><code class="language-js">
              //ActivityList.tsx
              import { Activity } from &quot;../types&quot;
              import { useMemo } from &quot;react&quot;
              import { categories } from &quot;../data/categories&quot;
              
              type ActivityListProps = {
                  activities: Activity[]
              }
              
              export default function ActivityList({activities}: ActivityListProps) {  
                  
                  const categoryName = useMemo(()=&gt; 
                      (category:Activity[&#39;category&#39;]) =&gt; categories.map( cat =&gt; cat.id === category ? cat.name : &#39;&#39;)
                  , [activities]
                  )
              
                  return (
                  &lt;&gt;
                      &lt;h2 className=&quot;text-4xl font-bold text-slate-600 text-center&quot;&gt;Comida y Actividades&lt;/h2&gt;
              
                      {activities.map(activity =&gt; (
                          &lt;div key={activity.id} className=&quot;px-5 py-10 bg-white mt-5 flex justify-between&quot;&gt;
                              &lt;div className=&quot;space-y-2 relative&quot;&gt;
                                  {/* Muestra actividad: categoría, nombre y calorías */}
                                  &lt;p className={`absolute -top-8 -left-8 px-10 py-2 text-white uppercase font-bold ${activity.category === 1 ? &#39;bg-lime-500&#39; : &#39;bg-orange-500&#39;}`}&gt;
                                      {/* {activity.category} */}
                                      {categoryName(+activity.category)}
                                      
                                  &lt;/p&gt;
                                  &lt;p className=&quot;text-2xl font-bold pt-5&quot;&gt;{activity.name}&lt;/p&gt;
                                  &lt;p className=&quot;font-black text-4xl text-lime-500&quot;&gt;
                                      {activity.calories} {&#39;&#39;}
                                      &lt;span&gt;Calorías&lt;/span&gt;
                                  &lt;/p&gt;
                              &lt;/div&gt;
                              &lt;div&gt;
                                  {/* Acciones para editar esa actividad o eliminarla */}
              
                              &lt;/div&gt;
                              
                          &lt;/div&gt;
                      ))
                      }
                  &lt;/&gt;
                  )
              }
            </code></pre>

            <img src="./src/assets/img/150-2.png" alt="img 150-2">

          </div>                  
           
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-151').toggle();">
            <h3>151. Agregando un Icono para Editar</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-151" class="hidden">
            <p>Veamos como editar una actividad que ya hemos metido en el state. Instalamos la dependencia de heroicons <span class="destacado">npm install @heroicons/react</span></p>
          
            <pre><code class="language-js">
              //ActivityList.tsx
              import { PencilSquareIcon } from '@heroicons/react/24/outline'
              ...
              &lt;div className=&quot;flex gap-5 items-center&quot;&gt;
                {/* Acciones para editar esa actividad o eliminarla */}
                &lt;button&gt;
                    &lt;PencilSquareIcon 
                        className=&quot;h-8 w-8 text-g&quot;
                    /&gt;
                &lt;/button&gt;
            &lt;/div&gt;
            </code></pre>
            <p>Para poder editar vamos a tener que registrar un atributo nuevo en nuestro reducer. Ese va a ser el id activo en el cual yo estoy presionando para editar y de esa forma vamos a poder identificar en nuestro formulario qué es lo que estamos editando. De ahí tenemos que pasar las actividades para poder llenar el formulario en automático, es decir, se va a tener que llenar la categoría, la actividad y las calorías (más trabajo para el programador, pero menos para el usuario). Veamos a continuación como identificar a qué actividad le estamos dando click.</p>
          </div>
           
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-152').toggle();">
            <h3>152. Creando la acción para seleccionar la actividad a editar</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-152" class="hidden">
            <p><svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
            </svg> En nuestro reducer, <strong>en la parte de states vamos a crear un nuevo state para identificar cual es el activeId (el correspondiente al icono de editar que se pulsa)</strong> y si presiono en otra se va a ir actualizando así que siempre va a tener una. Lo iniciamos como string vacío y, al definirle arriba el tipo podemos ponerle estring o directamente como el state que ya existe, de tipo Activity pero con un lookup de id:</p>

            <p><svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
            </svg> ¿Cómo vamos a establecer este elemento <code class="language-js">activeId: ''</code> como el id activo?. <strong>Al pulsar en el botón de editar lo primero que he de hacer es registrar una acción, con lo cual creo una acción nueva en laparte de las acciones de nuestro reducer</strong>. <strong>En esta acción vamos a setear qué elemento es el que está activo para luego editarlo, así que el payload simplemente es el id</strong>:</p>

            <p><svg class="size-6 shrink-0 inline" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 8.25 21 12m0 0-3.75 3.75M21 12H3"></path>
            </svg> A continuación en la parte del reduce donde definimos los if según las acciones, añadimos el if correspondiente a esta nueva actividad (Fijémonos que el autocompletado en las comillas simples ya nos sugiere nuestro nueva action, no la que ya tenemos definida). ¿Cómo lo definimos? básicamente lo que le pasamos como Payload es lo que define ese state, así que en el return regresamos una copia del state <code class="language-js">...state</code> para que las diferentes actividades que ya estaban se mantengan, y además escribimos en activeId <strong>lo que le estoy pasando como payload <code class="language-js"></code></strong></p>  

            <pre data-line="6,15,33-40"><code class="language-js">
              //activity-reducers.ts
              import { Activity } from "../types"

              //ACCIONES - type que va a describir lo que va a pasar en nuestro reducer
              export type ActivityActions = 
                  { type: 'save-activity', payload: { newActivity: Activity } } |
                  { type: 'set-activeId', payload: { id: Activity['id'] } } 

              export type ActivityState = {
                  activities : Activity[], //este state se va a llamar activities y va a ser de tipo Activity[]
                  activeId : Activity['id']
              }
              //STATE - nuestro state inicial que es un objeto necesita un type (definimos arriba 'ActivityState'). En nuestro state de actividades vamos a tener un arreglo.
              export const initialState: ActivityState = {
                  activities: [],
                  activeId: ''
              }

              //REDUCER - que conecta a ambos, nuestras acciones y el state
              export const activityReducer = (
                      state : ActivityState = initialState,
                      action: ActivityActions
                  ) => {
                  
                  if(action.type === 'save-activity'){
                      //Este código maneja la lógica para actualizar el state activities
                      //console.log('desde el type de save-activity') //console.log(action.payload.newActivity)         
                      return{
                          ...state,
                          activities: [...state.activities, action.payload.newActivity]
                      }
                  }
                  
                  if(action.type === 'set-activeId'){
                      //Este código maneja la lógica para actualizar el state activeId
                      //console.log('desde el type de set-activeId') //console.log(action.payload.id)         
                      return{
                          ...state,
                          activeId: action.payload.id
                      }
                  }

                  return state
              }
            </code></pre>
                
            <p>Veremos a continuación como disparar esta nueva acción, ya nuestros componentes usan el dispatch.</p>


          </div>
           
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-153').toggle();">
            <h3>153. Almacenando el ID a editar</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-153" class="hidden">
            <p><span class="destacado">Nosotros tenemos las acciones que definen lo que va a pasar pero el dispatch es el momento exacto en el que se va a escribir ese state.</span> El dispatch siempre lo vamos a usar en nuestros componentes y en esta caso en concreto con el que estamos, va  a ser cuando el usuario presione el botón de editar que tenemos en nuestro componente ActivityList.tsx. Veamos cómo se relacionan acciones, state y el dispatch de nuestras acciones.</p>

            <p>En el compo ppal App.tsx ya tenemos nuestro dispatch. Es lo mismo, la misma función que pasamos como prop, porque es el mismo state y las mismas acciones <code class="language-js">const [state, dispatch] = useReducer(activityReducer, initialState)</code> (en otros proyectos podríamos tener múltiples reducers y cada uno tendrá su propio dispatch, pero no es el caso) así que lo vamos a pasar hacia el compo ActivityList.tsx como ya hemos hecho antes hacia el compo Form.tsx</p>

            <p>Una vez lo pasamos como prop hacia nuestro compo ActivityList.tsx y lo extraemos y tipamos adecuadamente lo usamos en el onclick del botón para editar.</p>

          
                <pre><code class="language-js">
                  //App.tsx
                  const [state, dispatch] = useReducer(activityReducer, initialState)  
      
                  return (
                  ...
                  &lt;section className=&quot;p-10 mx-auto max-w-4xl&quot;&gt;
                    &lt;ActivityList 
                      activities={state.activities}
                      dispatch={dispatch}
                    /&gt;
                  &lt;/section&gt;
                </code></pre>
              
                <pre data-line="1,5,9,,12,15"><code class="language-js">
                  //ActivityList.tsx
                  import { useMemo, Dispatch } from "react"
                  import { Activity } from "../types"
                  import { categories } from "../data/categories"
                  import { PencilSquareIcon } from '@heroicons/react/24/outline'
                  import { ActivityActions } from "../reducers/activity-reducers"

                  type ActivityListProps = {
                      activities: Activity[]
                      dispatch: Dispatch&lt;ActivityActions&gt;
                  }

                  export default function ActivityList({activities, dispatch}: ActivityListProps) {  
                  ...
                  &lt;button
                    onClick={() =&gt; dispatch({type:&quot;set-activeId&quot;, payload: {id: activity.id}})}
                  &gt;
                    &lt;PencilSquareIcon 
                        className=&quot;h-8 w-8 text-g&quot;
                    /&gt;
                  &lt;/button&gt;
                </code></pre>
              

            <p>Podemos probar tras añadir varias actividades que el active id que se almacena es el correspondiente al de la actividad desde donde pulsamos el lápiz</p>
            
            <img src="./src/assets/img/153.png" alt="">
          
          </div>
                   
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-154').toggle();">
            <h3>154. Llenando el Formulario cuando editamos una actividad</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-154" class="hidden">
            <p>Veamos cómo identificar y llenar nuestro formulario una vez que el usuario presione en una actividad para editarla. <strong>¿Cómo vamos a hacer para que nuestro componente Form.tsx sepa en qué momento nuestro reducer tiene un elemento en el state activeId? Suena complejo, son archivos completamente separados, siendo uno un componente y otro el reducer que maneja el state.</strong></p>

            <p>En nuestro compo ppal App.tsx, en este <strong>state</strong> vamos a tener tanto activities[] como activeId</p>

            <pre><code class="language-js">
              //App.tsx
                function App() {  
                  const [state, dispatch] = useReducer(activityReducer, initialState)
              
              //activity-reducers.ts
                export type ActivityState = {
                    activities : Activity[], //activities va a ser de tipo Activity[](ya lo teníamos definido en types)
                    activeId : Activity['id'] //para tipa este activeId que es un id, usamos el lookup for 'id' en Activity
                }
                //STATE - nuestro state inicial que es un objeto necesita un type (definimos arriba 'ActivityState'). 
                export const initialState: ActivityState = {
                    activities: [],
                    activeId: ''
                }
            </code></pre>

            <p>por lo tanto vamos a pasar como prop a nuestro compo Form.tsx nuestro state. Si abrimos el compo Form.tsx vemos que <span class="destacado">la firma (él se refiere así al type que define los props que le llegan a mi compo)</span> solo tiene el dispatch, pero podemos inferir qué tipo ha de tener el state que estamos pasando si nos colocamos con el IS en la declaración del state del compo ppal App.tsx y vemos que es <strong>ActivityState</strong>, así que usamos esa información para completar la firma y a continuación lo extraemos con destructuring en la declaración de la función ppal del compo para poder usarlo:<p>
              <pre><code class="language-js">
                //Form.tsx --&gt;no tenía exportado desde mi reducer el type ActivityState así que al escribirlo no se importaba automáticamente
                //para que se importe automáticamente como vemos en esta línea de import, tengo que añadir la palabra 'export' al type ActivityState
                //en el reducer (ver prism anterior donde ya lo he puesto)
                import { ActivityActions, ActivityState } from "../reducers/activity-reducers"

                type FormProps = {
                    dispatch: Dispatch<ActivityActions>,
                    state: ActivityState
                }
                ...
                export default function Form({dispatch, state}: FormProps) {...}
              </code></pre>

              <p><span class="destacado">¿Como identificamos en qué momento nuestro state tiene un activeId? Lo podemos hacer con el versátil Hook useEffect</span> (similar al watch en vue.js) que como vimos en el punto 82 (almacenar carrito en localStorage), <span class="destacado">además de ser útil cuando el componente está listo, es muy útil para manejar los "efectos secundarios" de un cambio en nuestro state (cuando cambie mi state ejecutar cierto código).</span> Así que:</p>

              <ul class="my-3.5 list-disc">
                <li>lo importamos en nuestro compo Form.tsx</li>
                <li>lo colocamos tras la declaración de nuestro useState (recordar que  siempre es un callback)</li>
                <li>le indicamos que su dependencia sea el <strong>state.activeId</strong></li>
                <li>se va a ejecutar primero una vez (cuando está listo el componente) y después siempre que esa dependencia cambie, así que comprobamos con un if si hay algo ya en ese activeId y qué:
                <pre><code class="language-js">
                  //Form.tsx
                  export default function Form({dispatch, state}: FormProps) {

                    const[activity, setActivity] = useState&lt;Activity&gt;(initialState) 
                
                    useEffect(() => {
                      if(state.activeId){
                        console.log(`ya hay algo en activeId: ${state.activeId}`)
                      }
                    }, [state.activeId])
                </code></pre>
                </li>
                <li>Como en el state ya tengo también las activities además del activeId, recordar:
                  <pre><code class="language-js">
                    //activity-reducers.ts
                    export type ActivityState = {
                      activities : Activity[]
                      activeId : Activity['id'] 
                  }
                  </code></pre>
                  ¡puedo traérme la actividad y setearla! creo una variable para no hacerlo tdo en una sola línea, se va a llamar selectActivity y, usando el array method filter(), guardamos en esa nueva variable la actividad que tiene el mismo id que el que yo presioné en el lápiz. <strong>Como el .filter() retorna un arreglo, le añado posición 0 para que retorne un objeto [0]</strong>:
                  <pre><code class="language-js">
                    //Form.tsx
                    useEffect(() => {
                      if(state.activeId){
                      //console.log(`ya hay algo en activeId: ${state.activeId}`)
                      const selectActivity = state.activities.filter((actividad)=> actividad.id === state.activeId)[0]
                      //console.log(selectActivity)
                      setActivity(selectActivity)
                      }
                  }, [state.activeId])
                  </code></pre>
                </li>              
              </ul>

              <p>Si probamos a presionar ahora cada icono de editar en las actividades que hemos añadido y aparecen en la parte inferior vemos que se modifica la parte superior de la interfaz actualizando los campos... Otra cosa es que aún no hemos modificado la lógica para que al guardar se modifique la correspondiente (de momento nos añadiría una nueva). <strong>Tenemos que modificar un poco la lógica en el if de nuestro reducer correspondiente a la actividad "save-activity" --> si activeId tiene algo queremos identificar cual y agregarlo nuevo, mientras que si no hay activeId entonces sí es nueva actividad</strong></p>

          </div>
                   
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-155').toggle();">
            <h3>155. Actualizando las actividades</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-155" class="hidden">
            <p>Lo ideal es que si estamos editando reescriba la actividad que ya tenemos y no genere una nueva. <strong>Va a ser el activeId de nuestro state, la bandera que utilicemos para identificar que ésta es la actividad que estamos editando</strong>. Vamos al <code>if(action.type === 'save-activity'){</code> de nuestro reducer y escribimos la lógica que necesitamos antes del return().</p>
            
            <p>Comenta que podríamos(que funciona) tener un return por cada casuística de "si existe el activeId"/"si no existe el activeID", pero que lo normal es solo tener un return() por acción por lo que, con esta nueva lógica hemos de modificar el return que teníamos hasta ahora. Generamos con let una variable 'updatedActivities' de tipo array Activity vacía que en base a una u otra acción se va a llenar:</p>
            <pre data-line="2"><code class="language-js">
              //activity-reducers.ts
              if(action.type === 'save-activity'){
                let updatedActivities : Activity[] = []
                
                if(state.activeId){
                    //vamos a iterar sobre cada actividad porque hemos de identificar cual tiene el activeId y pasarle el nuevo payload
                    updatedActivities = state.activities.map( actividad => actividad.id === state.activeId ? action.payload.newActivity : actividad)
        
                }else{
                    updatedActivities = [...state.activities, action.payload.newActivity]
                }
                
                return{
                    ...state,
                    //activities: [...state.activities, action.payload.newActivity]
                    activities: updatedActivities
                }
              }
            </code></pre>

            <p>Si lo dejamos así y probamos, vemos que, en principio parece funcionar y cuando le damos a editar y guardamos la actividad de abajo se actualiza, sin embargo si justo a continuación añadiéramos otra actividad, nos reescribiría la editada porque <span class="destacado">el activeId sigue activo. ¡¡Tenemos que reiniciarlo después de cada llamada a esa acción <code class="language-js">'save-activity'</code>!! porque si no, sigue siendo el mismo activeId y va a reescribirlo cada vez. Por lo tanto, cada vez que haya una nueva actividad 'save-activity'</span> (sin meterme en problemas de comprobar si estoy agregando una nueva actividad o editando una previa)  voy a reiniciar <code class="language-js">activeId= ''</code></p>
            
            <pre data-line="15"><code class="language-js">
              //activity-reducers.ts
              if(action.type === 'save-activity'){
                let updatedActivities : Activity[] = []
                
                if(state.activeId){
                    //vamos a iterar sobre cada actividad porque hemos de identificar cual tiene el activeId y pasarle el nuevo payload
                    updatedActivities = state.activities.map( actividad => actividad.id === state.activeId ? action.payload.newActivity : actividad)        
                }else{
                    updatedActivities = [...state.activities, action.payload.newActivity]
                }
                
                return{
                    ...state,
                    //activities: [...state.activities, action.payload.newActivity]
                    activities: updatedActivities,
                    activeId= ''
                }
              }
            </code></pre>

            <p><span class="destacado">Gran ventaja de useReducer:</span> <strong>nos permite escribir múltiples states en una sola línea en un mismo return, a diferencia de useState en el cual hay que modificar la función que modifica el state por cada vez que queramos escribir en diferentes partes de nuestro state.</strong>. Algo importante es que justo antes del return de la acción es zona segura para escribir código de typescript que pueda manejar toda la lógica (revisar si un elemento existe, si es así actualizarlo y si es nuevo agregarlo a nuestro arreglo).</p>
            
            <p>Así ya tenemos la edición lista (que suele ser lo que más trabajo toma del <strong>CRUD</strong>: <strong>C</strong>reate <strong>R</strong>ead <strong>U</strong>ptade <strong>D</strong>elete</p>

          </div>
                    
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-156').toggle();">
            <h3>156. Creando la acción para eliminar actividades / 157. Creando el botón para llamar la acción de eliminar / 158. Mostrando un mensaje cuando no hay actividades</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-156" class="hidden">
            <p class="naranja">Creando la acción para eliminar actividades</p>
            <p>Veamos como se haría utilizando nuestro reducer. Creamos nueva acción que concatenamos con un pipe '|' la nombramos adecuadamente y para eliminar solo requerimos el id osea que el resto es igual que la anterior acción:</p>

            <pre data-line="5"><code class="language-js">
              //activity-reducers.ts
              //ACCIONES - type que va a describir lo que va a pasar en nuestro reducer
              export type ActivityActions = 
                  { type: 'save-activity', payload: { newActivity: Activity } } |
                  { type: 'set-activeId', payload: { id: Activity['id'] } } |
                  { type: 'delete-activity', payload: { id: Activity['id'] } } 
            </code></pre>

            <p>Definámosla en el código de nuestro reducer, en su if correspondiente: (podemos crear una variable y aplicar un filter igual que en el ejemplo actual al editar una actividad, o podemos hacerlo directamente) Tomamos una copia del state actual (lo que sea que esté... puede ser que tengamos un elemento activo en el formulario y el usuario presiona en eliminar otro) y a continuación con el array method .filter() accedemos a cada actividad y nos vamos a traer las que sean diferentes a lo que le mandemos como payload:</p>
            <pre><code class="language-js">
              //activity-reducers.ts
              if(action.type === 'delete-activity'){
                return{
                    ...state,
                    activities: state.activities.filter( activity => activity.id !== action.payload.id)
                }
              }
            </code></pre>

            <p class="naranja">Creando el botón para llamar la acción de eliminar</p>

            <p>Vamos a trabajar con el dispatch de la acción para eliminar actividad que acabamos de crear. Si recordamos, en nuestro compo ppal de App.tsx ya le estamos pasando como prop el dispatch al componente ActivityList.tsx que es el que lo utiliza. es el mismo dispatch que tenemos para editar solo que con una acción diferente, así que podemos copy-pastear el mismo button que tenemos para editar y modificarlo un poco:</p>

            <pre><code class="language-js">
              //ActivityList.tsx
              import { PencilSquareIcon, XCircleIcon } from '@heroicons/react/24/outline'
              ...
              &lt;button
                  onClick={() =&gt; dispatch({type:&quot;delete-activity&quot;, payload: {id: activity.id}})}
              &gt;
                  &lt;XCircleIcon 
                      className=&quot;h-8 w-8 text-red-500&quot;
                  /&gt;
              &lt;/button&gt;
            </code></pre>

            <p class="naranja">Mostrando un mensaje cuando no hay actividades</p>

            <p>Vamos al componente de ActivityList.tsx y podemos hacerlo de dos maneras:</p>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <p>directamente antes del mapeo de activities</p>
                <pre data-line="3,4"><code class="language-js">
                  //ActivityList.tsx
                  return (
                    ...
                  {activities.length === 0 ? 
                    &lt;p className=&quot;text-center my-5&quot;&gt;No hay actividades aún&lt;/p&gt; :
        
                    activities.map(activity =&gt; (
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <p>Igual pero usando una variable que guarda y useMemo() con la dependencia de [activities]</p>
                <pre data-line="1,5-6"><code class="language-js">
                  //ActivityList.tsx
                  const isEmptyActivities = useMemo(() =&gt; activities.length === 0, [activities])

                  return (
                    ...
                    {isEmptyActivities ? 
                      &lt;p className=&quot;text-center my-5&quot;&gt;No hay actividades aún&lt;/p&gt; :
        
                      activities.map(activity =&gt; (
                </code></pre>
              </div>
            </div>

            <p>Vamos a incorporar localStorage a este proyecto</p>          
          </div>          
                    
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-159').toggle();">
            <h3>159. Almacenando las actividades en LocalStorage</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-159" class="hidden">
            <p>Una buena adición y muy simple de implementar para este proyecto es localStorage. Veamos cómo hacerlo. ¿Donde podríamos colocar la función que escriba en localStorage? Mi reducer podría ser un buen lugar?¿dentro del if de 'save-activity' justo antes del return? sincronizando lo que esté en el state, sería una opción. Sin embargo también habría que agregarlo en el if de la acción 'delete-activity' y en más acciones si las agregara.<span class="destacado"> Otra opción, quizás la más sencilla, es hacerlo en el App.tsx y sincronizar únicamente el state de actividades y pasarlo como dependencia en un useEffect()</span>. <strong>La dependencia en el useEffect, lo que nos interesa que 'esté escuchando para actualizar las actividades guardadadas" es [state.activities]</strong></p>

            <pre data-line="7-9"><code class="language-js">
              //App.tsx
              import { useReducer, useEffect } from "react"
              ...
              function App() {  

                const [state, dispatch] = useReducer(activityReducer, initialState)  
              
                useEffect(() => {
                  localStorage.setItem('activities',JSON.stringify(state.activities))
                }, [state.activities])
            </code></pre>

            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <p>Si miramos en la <strong>pestaña aplicación del WDT</strong> vemos que al añadir una actividad nueva se agrega ahí, y si la editamos se actualiza perfectamente porque está sincronizado con el state.</p>
                <img src="./src/assets/img/159-1.png" alt="img" loading="lazy">
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <p>Sin embargo si recargamos la página se pierde todo y eso es así porque en nuestro activity-reducers.ts estamos especificando que las actividades inicien como un arreglo vacío con lo que se ejecuta ese useEffect con el arreglo vacío y lo setea en el state.</p>
                <pre data-line="2"><code class="language-js">
                  //activity-reducers.ts --&gt; nuestro state de actividades se inicia como arreglo vacío.
                  export const initialState: ActivityState = {
                    activities: [],
                    activeId: ''
                  }
                </code></pre>
                <img src="./src/assets/img/159-2.png" alt="img" loading="lazy">
              </div>
            </div>

            <p class="my-3">Por tanto <span class="destacado">en vez de tener ese valor inicial de arreglo vacío <strong>[]</strong> hemos de tener algo que revise si tenemos algo en localStorage:</span></p>
            
            <ul class="my-3">
              <li>Creamos variable nueva arrow function 'localStorageActivities' (como esto va a residir en localStorage no en nuestro código, TS no puede inferir, así que le especificamos que esta variable arrow function sea de tipo Activity[])</li>
              <li>esta función contiene a su vez una variable 'activities' en la que recuperamos lo que haya en el item 'activities' de localStorage</li>
              <li>return de esa variable; con un ternario especificamos que si tiene algo haga un JSON.parse() de ello y si no sea un arreglo vacío []</li>
              <li>Llamamos a nuestra 'localStorageActivities()' como inicialización de nuestro state</li>
            </ul>
            <pre data-line="1-4,6"><code class="language-js">
              //activity-reducers.ts --&gt; iniciamos nuestro state con esta comprobación de si hay algo en localStorage
              const localStorageActivities = () : Activity[] =>{
                const activities = localStorage.getItem('activities')
                return activities ? JSON.parse(activities) : []
              }
              export const initialState: ActivityState = {
                  activities: localStorageActivities(),
                  activeId: ''
              }
            </code></pre>
            
          
          </div>
                    
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-160').toggle();">
            <h3>160. Creando la acción para reiniciar la app</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-160" class="hidden">
            <p>Vamos a agregar un botón en la parte superior para limpiar todas las actividades, para reiniciar la app:</p>
            <ul class="my-3">
              <li>Vamos a activity-reducer.ts y creamos una actividad nueva que llamamos 'restart-app y como va a ser un botón que uso para reiniciar (vamos a limpiar y reiniciar a sus valores iniciales tanto activities como activeId) no va a tomar ningún payload.
                <pre data-line="5"><code class="language-js">
                  //activity-reducers.ts
                  export type ActivityActions = 
                    { type: 'save-activity', payload: { newActivity: Activity } } |
                    { type: 'set-activeId', payload: { id: Activity['id'] } } |
                    { type: 'delete-activity', payload: { id: Activity['id'] } } |
                    { type: 'restart-app' } 
                </code></pre>
              </li>
              <li>después del action (el if) de 'delete-activity' vamos a definir con su propio if este nuevo action para resetear la app:
                <pre><code class="language-js">
                  //activity-reducers.ts
                  if(action.type === 'restart-app'){
                    return{
                        activities: [],
                        activeId: ''
                    }
                }
                </code></pre>
              </li>
              <li>Vamos a nuestro App.tsx: <strong>creamos el botón y definimos una función para controlar que el botón esté deshabilitado si no hay actividades</strong>. Al botón le añadimos un onClick con el correspondiente dispatch (ojo que hay que poner el callback antes del dispatch, si no nos marca advertencia en el onClick) No toma payload, simplemente espera que ocurra ese evento:
                <pre><code class="language-js">
                  //App.tsx
                  const canRestartApp = () => useMemo(() => state.activities.length > 0, [state.activities])

                  return (
                    ...
                    &lt;button 
                      className=&quot;bg-gray-800 hover:bg-gray-900 p-2 font-bold uppercase text-white cursor-pointer rounded-lg text-sm disabled:opacity-10&quot;
                      disabled={!canRestartApp()}
                      onClick={dispatch({type.})}
                      &gt;Reiniciar App&lt;/button&gt;
                </code></pre>
              </li>
            </ul>

            <p>Es muy similar a un botón de cerrar sesión en el cual limpias todo el state de la aplicación del usuario.</p>
          </div>
                    
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-161').toggle();">
            <h3>161. Creando un Componente para mostrar el total de Calorias / 162. Mostrando las calorias consumidas / 163. Mostrando las calorias quemadas</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-161" class="hidden">
            <p>El siguiente paso de nuestro proyecto es crear una serie de estadísticas, vamos a ir sumando las calorías consumidas, las calorías quemadas haciendo ejercicio y un diferencial (si hemos consumido más de las uqe hemos quemado va a ser la tercera opción. Ya no vamos a hacer nada en el reducer, hemos definido todas nuestras acciones, simplemente vamos a hacr una serie de estadísticas).</p>
            
            <p>En nuestro compo ppal App.tsx creamos un nuevo section tras el form donde vamos a incluir el tag de nuestro nuevo componente <strong>CalorieTracker</strong> que es el que va a mostrar las calorías consumidas, las quemadas por los ejercicios y el balance. Este nuevo componente solo requiere el state de actividades así que se lo pasamos como prop <span class="destacado">TRUQUI: siempre que paso prop, cuando tipo la nueva prop en el compo nuevo para extraerla, se me suele olvidar si es de arreglo añadirle el [] así que FIJARSE EN EL ERROR/ADVERTENCIA DE VSC CUANDO AÑADO LA PROPO AL TAG DEL NUEVO COMPO EN App.tsx PARA INFERIR ESE TYPE CORRECTAMENTE EN EL COMPO SIN QUE SE ME OLVIDE</span>:</p>
              

              <div class="flex max-sm:flex-col">
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //App.tsx
                    import CalorieTracker from "./components/CalorieTracker"
                    ...
                    &lt;section className=&quot;bg-gray-800 py-10&quot;&gt;
                      &lt;div className=&quot;max-w-4xl mx-auto&quot;&gt;
                        &lt;CalorieTracker 
                          activities={state.activities}
                        /&gt;
                      &lt;/div&gt;
                    &lt;/section&gt;
                  </code></pre>
                </div>
                <div class="w-[50%] max-sm:w-[100%]">
                  <pre><code class="language-js">
                    //ActivityTracker.tsx
                    import type { Activity } from "../types"

                    type CalorieTrackerProps = {
                        activities: Activity[]
                    }
                    export default function CalorieTracker({activities}: CalorieTrackerProps) {
                      return (
                        &lt;&gt;
                            &lt;h2 className=&quot;text-4xl font-black text-white text-center&quot;&gt;Resumen de calorías&lt;/h2&gt;
                        &lt;/&gt;
                      )
                    }
                  </code></pre>
                </div>
              </div>

              <p class="naranja">Mostrando las calorias consumidas y las calorias quemadas</p>
              <p>Comencemos a calcular las calorías, una forma muy sencilla de hacerlo es con reduce()</p>
              <p>En nuestro nuevo componente CalorieTracker.tsx, antes del return bajo el comentario <code class="language-js">//contadores</code> creamos las  variables para calcular las calorías consumidas 'caloriesConsumed' y las  calorías quemadas 'caloriesBurned' y voy a usar useMemo() pasándole como dependencia activities, para que cada vez que haya cambio en actividades el código especificado en cada una de esas variables se vuelva a ejecutar <code class="language-js">const caloriesConsumed = useMemo(() => , [activities])</code> <code class="language-js">const caloriesBurned = useMemo(() => , [activities])</code>. ¿Como lo vamos a calcular? tenemos el state de activities, y tenemos un arreglo y almacenamos la categoría; la categoría de calorías consumidas es la nº 1 y la de quemadas es la nº2 si recordamos nuestros datos en categories.ts:</p>
              <pre data-line="1"><code class="language-js">
                //categories.ts
                export const categories: Category[] = [
                    { id: 1, name: 'Comida'},
                    { id: 2, name: 'Ejercicio'}
                ]
              </code></pre>

              <p>así que calorías consumidas = actividades con categoría 1 y calorías quemadas =  actividades con categoría 2. Con el reduce en un solo paso revisamos la actividad actual en cada caso:</p>
              <ul>
                <li> ¿tiene el id nº1? ¿si? entonces ese sí lo sumo, en caso contrario paso el total como está al siguiente objeto para que lo sume y compruebe lo mismo, si pertenece a comida entonces lo suma y si no, pase al siguiente elemento...</li>
                <li>¿tiene el id nº2? ¿si? entonces ese sí lo sumo, en caso contrario paso el total como está al siguiente objeto para que lo sume y compruebe lo mismo, si pertenece a comida entonces lo suma y si no, pase al siguiente elemento...</li>
              </ul></p>
              <pre><code class="language-js">
                //Contadores
                const caloriesConsumed = useMemo(() => activities.reduce((total, activity)=> activity.category === 1 ? total + activity.calories : total, 0), [activities])
                const caloriesBurned = useMemo(() => activities.reduce((total, activity)=> activity.category === 2 ? total + activity.calories : total, 0), [activities])
                ...
                &lt;div className=&quot;flex flex-col-item-center md:flex-row md:justify-between gap-5 mt-10&quot;&gt;
                  &lt;p className=&quot;text-white font-bold rounded-full grid grid-cols-1 gap-3 text-center&quot;&gt;
                      &lt;span className=&quot;font-black text-6xl text-orange&quot;&gt;{caloriesConsumed}&lt;/span&gt; Consumidas
                  &lt;/p&gt;
                  &lt;p className=&quot;text-white font-bold rounded-full grid grid-cols-1 gap-3 text-center&quot;&gt;
                      &lt;span className=&quot;font-black text-6xl text-orange&quot;&gt;{caloriesBurned}&lt;/span&gt; Quemadas
                  &lt;/p&gt;
                &lt;/div&gt;
              </code></pre>
              
              <img class="max-sm:mx-auto" src="./src/assets/img/162.png" alt="img" loading="lazy">

              <p>Como vemos tenemos 2 textos y 2 cantidades, si nos pidieran cambiar cualquiera de esos texto habríamos de cambiarlo en dos lugares... Ya que tenemos contenedores con los mismos estilos veamos como construir un componente reutilizable para consumidas, quemadas y también el balance...</p>
              
          </div>

      
                    
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-164').toggle();">
            <h3>164. Creando un Componente para las cantidades</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-164" class="hidden">
            <p>Creamos el componente CalorieDisplay.tsx. Como vamos a pasarle desde CalorieTracker.tsx como props estas 4 cosas que son lo que varían con respecto a esa estructura común:</p>
            <img src="./src/assets/img/164.png" alt="img" loading="lazy">
            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">
                <p>usamos el tag del nuevo compo y le pasamos en cada llamada como prop lo adecuado:</p>
                <pre><code class="language-js">
                  //CalorieTracker.tsx
                  ...
                  &lt;CalorieDisplay 
                    calories={caloriesConsumed}
                    text={&#39;Consumidas&#39;}
                  /&gt;
                  &lt;CalorieDisplay 
                    calories={caloriesBurned}
                    text={&#39;Quemadas&#39;}
                  /&gt;
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <p>definimos un type para esas props en el nuevo componente ylas extraemos con destructuring como siempre para usarlas en la maquetación del compo:</p>
                <pre><code class="language-js">
                  //CalorieDisplay.tsx
                  type CalorieDisplayProps = {
                    calories: number,
                    text: string
                  }
                  
                  export default function CalorieDisplay({calories, text}: CalorieDisplayProps) {
                    return (        
                      &lt;p className=&quot;text-white font-bold rounded-full grid grid-cols-1 gap-3 text-center&quot;&gt;
                          &lt;span className=&quot;font-black text-6xl text-orange&quot;&gt;{calories}&lt;/span&gt; {text}
                      &lt;/p&gt;
                    )
                  }
                </code></pre>
              </div>
            </div>
          </div>
                    
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-165').toggle();">
            <h3>165. Mostrando el diferencial de Calorias</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-165" class="hidden">
            <p>Vamos a ver las calorías totales para tener un balance de calorías. Básicamente van a ser las consumidas menos las calorías quemadas</p>
            <pre><code class="language-js">
              //CalorieTracker.tsx
              const netCalories = useMemo(() => caloriesConsumed-caloriesBurned, [activities])
              ...
              &lt;CalorieDisplay 
                calories={netCalories}
                text={&#39;Diferencia&#39;}
               /&gt;
            </code></pre>

            <p>Así ya tenemos este proyecto listo usando useReducer() que es una excelente forma de utilizar estados más complejos o hacer operaciones en diferentes estados al mismo tiempo. Vimos la estructura de un reducer, para qué utilizamos las acciones, para qué el dispatch y cómo vamos manejando la lógica en nuestro state. Vamos a seguir dandole a useReducer, a continuación migraremos a useReducer el proyecto de guitarras.</p>
          </div>
                    
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion10-166').toggle();">
            <h3>166. Build y Deployment de la App</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion10-166" class="hidden">
            <p>Hacemos el run npm build y nos llevamos a mano a netlify la carpeta dist para nuevo site. En este punto, manual de deply automático en netlify de <strong>mi Diario.</strong></p>
          </div>

          


                   
        
        


        </div>
        <!-- Fin div colapsable-->  
     
      </div>
      <!-- FIN SECCION 10 -->

      
      <!-- SECCION 9-->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
      
        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer"
          onclick="$('#seccion9').toggle();">
          <h2>Sección 9: PROYECTO - Calculadora de propinas con TypeScript</h2>
          <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
        </div>
      
        <div id="seccion9" class="hidden">
          <a class="underline text-rose-600 font-bold" href="https://and....55.github.io/calculadora_propinas/" target="blank">https://and....55.github.io/calculadora_propinas/</a>
         
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-104105').toggle();">
            <h3>104. El Proyecto que vamos a construir / 105. Creando el proyecto</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-104105" class="hidden">
      
            <div class="block md:flex">
              <img class="w-50 w-100-m mr-1.25" src="./src/assets/img/s1-02.jpg" alt="Calculadora de proyectos">
              <div class="w-50 w-100-m">
                <p>Esta calculadora de propinas y consumos es un proyecto 100% TS, con nuestra carpeta de Data, algunos
                  Helpers, Hook personalizado, archivo de Types. Todos los proyectos de ahora en adelante.</p>
                <p>Vemos un botón de Guardar orden, para que el restaruante tenga un control de las ventas diarias (como aún
                  no hemos visto APIS simularemos que lo almacena en algún sitio.</p>
                <p>Este proyecto va a ser 100% TypeScript desde el inicio (no vamos a escribir js y después convertirlo sino
                  directamente ts), estaremos practicando mucho sobre el state, custom hook y demás.</p>
              </div>
            </div>
      
            <p class="mt-1.25 mb-0"><span class="naranja">Creamos proyecto nuevo:</span></p>
            <ul class="mb-3.75">
              <li>Tengo todos mis proyectos de React dentro de <strong>Curso React</strong> así que me ubico ahí y para
                crearlo</li>
              <li><span class="destacado">npm create vite@latest</span> crea el proyecto con la última versión de vite</li>
              <li>Lo nombro <strong>calculadora_propinas</strong></li>
              <li>Elijo framework <span class="destacado">React</span></li>
              <li>Elijo variante <span class="destacado">TypeScript + SWC</span> (puede que a futuro ya no salga "SWC" porque
                es el compilador que van a usar)</li>
              <li>Nos ubicamos en el nuevo directorio creado <strong>calculadora_propinas</strong> e instalamos las
                dependencias del proyecto con <span class="destacado">npm install</span></li>
              <li>Abrimos nuestro proyecto en Visual Studio Code (con botón derecho agrego la nueva carpeta en el área de
                trabajo)</li>
              <li>Arrancamos el servidor de desarrollo con <span class="destacado">npm run dev</span> --&gt; <a
                  href="http://localhost:5174/" target="blank">http://localhost:5174/</a> (<a href="http://localhost:5173/"
                  target="blank">http://localhost:5173/</a> la suelo usar para el manual)</li>
            </ul>
            <img class="my-2.5" src="./src/assets/img/105.png" alt="" />
      
            <p><span class="destacado">Hagamos limpieza de algunos archivos</span>:</p>
            <ul class="mb-3.75">
              <li>Eliminamos el .svg: public&gt;<strong>vite.svg</strong></li>
              <li>Eliminamos la carpeta entera assets: src&gt;<strong>assets</strong></li>
              <li>Eliminamos la css: src&gt;<strong>App.css</strong></li>
              <li>Limpiamos src&gt;<strong>App.tsx</strong> dejandolo así:
                <script type="text/plain" class="language-js">
                          function App() {
      
                            return (
                              <>
                                <h1>Hola mundo</h1>
                              </>
                            )
                          }
                          
                          export default App
                        </script>
              </li>
              <li>Eliminamos todo el contenido de la css src&gt;<strong>index.css</strong></li>
              <li>Dejamos como está el src&gt;<strong>main.tsx</strong>. Importante la llamada que aquí se hace a nuestra css
                <strong>index.css</strong> porque <span class="destacado">vamos a instalar el framework TailwindCSS</span>
                <pre data-line="2"><code class="language-js">
                          import &lcub; StrictMode &rcub; from &apos;react&apos;
                          import &lcub; createRoot &rcub; from &apos;react-dom/client&apos;
                          import &apos;./index.css&apos;
                          import App from &apos;./App.tsx&apos;
                          
                          createRoot(document.getElementById(&apos;root&apos;)!).render(
                            &lt;StrictMode&gt;
                              &lt;App /&gt;
                            &lt;/StrictMode&gt;&comma;
                          )
                        </code></pre>
              </li>
            </ul>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-106107').toggle();">
            <h3>106. Introducción a TailwindCSS / 107. Instalando TailwindCSS y extensión para VSCode</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-106107" class="hidden">
            <p>Es un framework de CSS pero está basado en utilidades</p>
            <ul class="mb-3.75">
              <li><strong>Tailwind CSS es lo que se conoce como un framework de CSS, pero está basado en utilidades</strong>
              </li>
              <li><strong>A diferencia de Bootstrap, que es otro framework de CSS donde una clase contiene diferentes
                  propiedades de CSS</strong> (Por ejemplo, para crear un botón utilizas una clase llamada btn y si quieres
                cambiar el color utilizas btn danger; Esos van a tener muchas propiedades de CSS, solo da la apariencia de
                botón.) <strong>En el caso de Tailwind, cada clase es una propiedad de CSS que tiene un nombre
                  similar</strong>. <span class="destacado">Bootstrap descargas una css de 10000 líneas y usas las css vs
                  Tailwind modo JIT (Just In Time) solo las clases que utilices en tus js, tsx, ts, js se van a utilizar para
                  generar la css final, lo cual nos va a dar una css lo más ligera posible.</span></li>
              <li>Su ventaja principal es que escribes el código CSS en tus componentes sin hojas externas. ¿Que se deja de
                utilizar el componente? se elimina tambi´ne su código de css (a diferencia de lo que pasa en las hojas de
                estilos generales con miles de líneas y mal mantenidas).</li>
              <li>Otra ventaja es que tampoco es necesario por la herencia en CSS (especificidades, !important infinitos,
                pisado de código de otras partes del proyecto)</li>
              <li>Nos olvidamos del problema de cómo nombrar nuestras clases.</li>
              <li>La documentación es excelente: hay bastantes ejemplos muy gráficos muy visuales que van a permitirte saber
                qué clase es la que puedes utilizar.</li>
              <li>La extensión de Visual Studio Code también es excelente. El autocompletado es muy bueno y también te dice
                qué valor o cuánto se está aplicando en ciertas propiedades de CSS enfocadas a tamaño, por ejemplo el font
                size, etcétera.</li>
            </ul>
      
            <p class="mt-1.25 mb-0"><span class="naranja">Instalando TailwindCSS y extensión para VSCode: </span>
              Vamos al link de <strong><a href="https://tailwindcss.com/" target="blank"
                  class="text-[#000000]">https://tailwindcss.com/</a> > docs > installation > Framework guides:</strong>
              contiene guías específicas de framework para instalar TailwindCSS en un gran número distinto de entornos Vite /
              Next.js / Angular / Ruby on Rails / Parcel / Symfony / Astro / ... nosotros elegimos Vite. A partir de aquí los
              pasos varían con respecto a lo que indica en el vídeo porque la versión es más nueva, ver <a
                class="text-[#000000]" href="https://tailwindcss.com/docs/installation/using-vite"
                target="_blank">https://tailwindcss.com/docs/installation/using-vite</a>:
            </p>
      
            <ul class="mb-3.75">
              <li>Creación del proyecto y ubicarse en la carpeta ya lo hicimos</li>
              <li>Instalamos Tailwind CSS: instalamos las dependencias 'tailwindcss' y '@tailwindcss/vite' via npm:
                <pre><code class="language-js">
                          npm install tailwindcss @tailwindcss/vite
                        </code></pre>
              </li>
              <li><strong>Configurar el plugin de vite:</strong> añadimos el plugin '@tailwindcss/vite' a nuestra
                configuración de vite en <span class="file">vite.config.ts</span>
                <pre data-line="1,8"><code class="language-js">
                      import { defineConfig } from 'vite'
                      import tailwindcss from '@tailwindcss/vite'
                      import react from '@vitejs/plugin-react-swc'
                      
                      // https://vite.dev/config/
                      export default defineConfig({
                        plugins: [
                          react(),
                          tailwindcss()
                        ],
                      })
                    </code></pre>
              </li>
              <li><strong>Importar Tailwind CSS en nuestra css:</strong> <span class="file">src&gt;index.css</span> <code
                  class="language-css">@import "tailwindcss";</code></li>
              <li><strong>Comenzar a utilizar las utility classes de Tailwind CSS para dar estilo a nuestro contenido</strong>
                <script type="text/plain" class="language-html">
                      <h1 className="text-3xl font-bold underline">
                        Hello world!
                      </h1>
                    </script>
              </li>
            </ul>
      
            <p><span class="destacado">Instalamos la extensión Tailwind CSS IntelliSense en el Visual Studio Code</span>.</p>
            <p><strong>Le veo de momento un par de inconvenientes: no cubren todas las casuísticas de tamaños (por cuenta
                ajena si el diseño viene marcado desde agencia o Dpto con tamaños no contemplados en este FW estamos haciendo
                un pan con unas tortas. Además ¡OJO! hay nombres de clases que PARA NADA son descriptivos de lo que hacen como
                por ejemplo font-black que lo que hace es actuar sobre un font-weight!!!)</strong></p>
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-112').toggle();">
            <h3>108. Creando el Header / 109. Agregando los Productos / 110. Agregando los contenedores principales / 111.
              Extensiones par React / 112. Listano los productos del menú</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-112" class="hidden">
            <p class="mt-1.25 mb-0"><span class="naranja">Creamos el Header</span></p>
            <p>En el return de nuestro <span class="file">App.tsx</span> agregamos el header pero simplemente como tag html5
              semántico y practicamos algo de Tailwind CSS.</p>
            <script type="text/plain" class="language-html">
                    <header className="bg-teal-400 py-5">
                      <h1 className="text-center text-4l font-black">Calculadora de propinas y consumo</h1>
                    </header>
                  </script>
      
            <p class="mt-1.25 mb-0"><span class="naranja">Agregando los productos</span> - <a class="text-[#000000]"
                href="https://gist.github.com/codigoconjuan/7ff5b34a0a0773f8c48fd13b51a508aa" target="blank">Gist de
                Productos</a></p>
            <p>Aún no hemos visto como consumir una API, consultar una BBDD, todo eso lo veremos más adelante. Así que de
              momento vamos a trabajar como el proyecto anterior, <strong>con un archivo plano que tiene un arreglo de
                productos</strong>. Vamos a consumirlo y mostrarlo.</p>
      
            <p>Vamos a crear 2 archivos .ts (no .tsx que tienen código html y/o eventos de React:</p>
            <ul class="mb-3.75">
              <li>Creamos <strong>src&gt;db&gt;<span class="file">db.ts</span></strong>: metemos en su interior lo que
                copiamos en formato raw del <a class="text-[#000000]"
                  href="https://gist.github.com/codigoconjuan/7ff5b34a0a0773f8c48fd13b51a508aa" target="blank">Gist de
                  Productos</a>. Con el IS vemos que TS infiere cual es el tipo de dato de cada propiedad así que tenemos un
                array de objetos y eso está bien, pero <strong>está aún mejor crear un type personalizado "MenuItem" y
                  asignárselo para tener un mejor autocompletado y para que, en caso de que alguna de mis propiedades no
                  cumpla con lo tipado, nos lo marque como error</strong>.
                <pre data-line="0,2"><code class="language-js">
                      import type { MenuItem } from "../types" 
      
                      export const menuItems : MenuItem[] = [
                          {
                            "id": 1,
                            "name": "Pizza a la Leña Chica",
                            "price": 30
                          },                     
                    </code></pre>
              </li>
              <li>Creamos <strong>src&gt;types&gt;<span class="file">index.ts</span> en donde creamos este primer type
                  MenuItem</strong>
                <pre><code class="language-js">
                  //src>types>index.ts
                      export type MenuItem = {
                        id: number,
                        name: string,
                        price: number
                    }
                    </code></pre>
              </li>
              <li>En nuestra <span class="file">App.tsx</span> vamos a importar los datos y si hacemos un console.log ya vemos
                que tenemos disponibles esos datos.
                <div class="flex max-sm:flex-col">
                  <div class="w-[50%] max-sm:w-[100%]">
                    <pre><code class="language-js">
                      //App.tsx
                        import { menuItems } from "./data/db"
      
                        function App() {
      
                        console.log(menuItems)
      
                        return (
                        </code></pre>
                  </div>
                  <div class="w-[50%] max-sm:w-[100%]">
                    <img class="my-2.5" src="./src/assets/img/109.png" alt="" />
                  </div>
                </div>
              </li>
            </ul>
      
            <p class="mt-1.25 mb-0"><span class="naranja">Agregando los contenedores principales:</span> acabamos de crear
              nuestro primer type (MenuItem) y se lo hemos agregado a nuestros datos. Vamos a ver como mostrar la información
              en pantalla, como renderizar lo que ahora mismo vemos en consola <code
                class="language-js">console.log(menuItems)</code>para que se vea en nuestra interfaz.</p>
      
            <p>En el return de nuestro <span class="file">App.tsx</span> agregamos el main pero simplemente como tag html5
              semántico y seguimos practicando algo de Tailwind CSS <span class="destacado">revisar/empollar uso de Tailwind:
                <a class="text-[#ffffff]" href="https://certidevs.com/tutorial-tailwindcss-introduccion"
                  target="_blank">Tutorial certidevs</a></span> por ejemplo Mediaquerys en Tailwind: las clases como
              <strong>sm:, md:, lg:, xl:, y 2xl:</strong> permiten aplicar estilos específicos basados en el tamaño de la
              pantalla. ¿Como funciona? queremos 2 columnas a partir del tamaño md: ponemos <strong>md:grid-cols-2</strong>
            </p>
            <pre><code class="language-html">
                      &lt;main className=&quot;max-w-7xl mx-auto py-20 grid grid-cols-2&quot;&gt;
                        &lt;div&gt;
                          &lt;h2&gt;Menú&lt;/h2&gt;
                        
                        &lt;/div&gt;
                
                        &lt;div&gt;
                          &lt;h2&gt;Consumo&lt;/h2&gt;
                        
                        &lt;/div&gt;
                      &lt;/main&gt;
                    </code></pre>
      
            <p>Ya con nuestro div para el menú vamos a renderizar lo que ahora vemos en la consola <code
                class="language-js">console.log(menuItems)</code> que es como una pequeña base de datos</p>
      
            <ul class="mb-3.75">
              <li>Creamos <strong>components&gt;MenuItem.tsx</strong></li>
              <li>Antes de empezar a picar recomienda instalar estas dos <span class="naranja">extensiones para React en
                  VSCode: </span> <strong>ES7+ React/Redux/React-Native snippets</strong> y <strong>Simple React
                  Snippets</strong>. Con esto por ejemplo si escribimos en <span class="file">MenuItem.jsx</span>
                <strong>rfc</strong> vemos que nos autocompleta la estructura básica de nuestro componente, tanto con el
                export default como con el return: (con <strong>rafc</strong> la crearía como arrow function). El import react
                no es necesario así que lo eliminamos
                <pre class="rojo" data-line="0"><code class="language-js">
                      import React from 'react'
      
                      export default function MenuItem() {
                        return (
                          <div>MenuItem</div>
                        )
                      }
                    </code></pre>
              </li>
              <li> En nuestro <span class="file">App.tsx</span> renderizamos nuestro nuevo componente MenuItems una vez por
                cada elemento que tengamos en nuestro array que simula la base de datos:
                <pre><code class="language-js">
                      {menuItems.map(item =&gt; (
      
                        &lt;MenuItem 
                          key = {item.id} //siempre que iteramos, recordar añadir key único
                        /&gt;            
                      ))}
                    </code></pre>
                <p>En este punto si miramos la renderización nos aparece "menuItem" 12 veces (porque es lo que ahora mismo nos
                  renderiza el return del componente: &lt;div&gt;MenuItem&lt;/div&gt;</p>
              </li>
            </ul>
      
            <p class="mt-1.25 mb-0"><span class="naranja">Listando los productos del menú:</span> Veamos como pasarle los
              props y escribir el type para este componente, hacerlo dinámico para que imprima la información de nuestra
              pequeña BBDD.</p>
            <p>En el tag de llamada al componente del return de nuestro <span class="file">App.tsx</span> creamos un prop
              llamado item y le pasamos el objeto de item <code class="language-js">item={item}</code>. Nos da error porque el
              componente de momento no espera ninguna propiedad. Si, en nuestro <span class="file">MenuItem.tsx</span>
              aplicamos destructuring para que reciba ese item: <code
                class="language-ts">export default function MenuItem({item}) {</code> vamos a ver que es de tipo Any
              implícito, (mientras que ese item que pasamos como prop en App.tsx sí es de tipo item)<strong>, <span
                  class="destacado">osea se pierde la referencia entre nuestros componentes App.tsx y MenuItem.tsx</strong> y
              nosotros tenemos que especificarle qué tipo de dato va a ser</span>. Para ello vamos a crear en el <span
                class="file">MenuItem.tsx</span> un type nuevo <strong>MenuItemProps</strong>(que solo va a usarse en este
              compo por lo que no tenemos que crearlo en archivo común de types):</p>
      
            <pre><code class="language-js">
                    import type { MenuItem } from &quot;../types&quot;
      
                    export type MenuItemProps = {
                        item: MenuItem
                    }
                    
                    export default function MenuItem({item}: MenuItemProps) {
                      return (
                        &lt;&gt;
                            &lt;p&gt;{item.name}&lt;/p&gt;
                            &lt;p className=&quot;font-black&quot;&gt;{item.price}&lt;/p&gt;
                        &lt;/&gt;
                      )
                    }
                  </code></pre>
      
            <p>La idea es que al ir presionando en cada elemento se vaya colocando a la derecha. Para ello tenemos que
              agregarles un evento y por buenas prácticas no debemos hacerlo en el p así que convertimos el fragment
              &lt;&gt;&lt;/&gt; en un botón &lt;button&gt;&lt;/button&gt; que es donde vamos a tener un evento que veremos
              como registrarlo. Seguimos practicando algo de Tailwind CSS dándole estilos a nuestros contenedores <span
                class="destacado">revisar/empollar uso de Tailwind</span> Quedan de la siguiente manera: </p>
      
            <div class="flex max-sm:flex-col">
              <div class="w-[50%] max-sm:w-[100%]">                
                <pre><code class="language-js">
                  //App.tsx
                  import MenuItem from &quot;./components/MenuItem&quot;
                  import { menuItems } from &quot;./data/db&quot;
                  
                  function App() {
                  
                    return (
                      &lt;&gt;
                        
                        &lt;header className=&quot;bg-teal-400 py-5&quot;&gt;
                          &lt;h1 className=&quot;text-center text-4l font-black&quot;&gt;Calculadora de propinas y consumo&lt;/h1&gt;
                        &lt;/header&gt;
                  
                        &lt;main className=&quot;max-w-7xl mx-auto py-20 grid grid-cols-2&quot;&gt;
                          &lt;div className=&quot;p-5&quot;&gt;
                            &lt;h2 className=&quot;text-4xl font-black&quot;&gt;Menú&lt;/h2&gt;
                  
                            &lt;div className=&quot;space-y-2 mt-10&quot;&gt;
                              {menuItems.map(item =&gt; (
                                &lt;MenuItem
                                  key = {item.id} //siempre que iteramos, recordar añadir key único
                                  item = {item}
                                /&gt;
                              ))}
                            &lt;/div&gt;
                          
                          &lt;/div&gt;
                  
                          &lt;div&gt;
                            &lt;h2&gt;Consumo&lt;/h2&gt;
                          
                          &lt;/div&gt;
                        &lt;/main&gt;
                        
                      &lt;/&gt;
                    )
                  }
                  
                  export default App
                </code></pre>
              </div>
              <div class="w-[50%] max-sm:w-[100%]">
                <pre><code class="language-js">
                  //MenuItem.tsx
                  import type { MenuItem } from &quot;../types&quot;

                  export type MenuItemProps = {
                      item: MenuItem
                  }
                  
                  export default function MenuItem({item}: MenuItemProps) {
                    return (
                      &lt;button className=&quot;border-2 border-teal-400 hover:bg-teal-200 w-full p-3 flex justify-between&quot;&gt;
                          &lt;p&gt;{item.name}&lt;/p&gt;
                          &lt;p className=&quot;font-black&quot;&gt;{item.price}&lt;/p&gt;
                      &lt;/button&gt;
                    )
                  }                       
                </code></pre>
              </div>      
            </div>
      
            <p>A continuación vamos a crear un custom Hook para ir almacenando nuestra orden.</p>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-113').toggle();">
            <h3>113. Creando un Hook para la orden <span class="destacado">Generics en TS</span></h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-113" class="hidden">
            <p>Creamos nuestro <span class="file">useOrder.ts</span> <strong>hooks&gt;useOrder.ts</strong>
            <pre><code class="language-js">
                    export default function useOrder() {
      
                      return{
                          
                      }
                    }     
                  </code></pre>
            </p>
            <p>Definimos un state en el que vamos colocando los elementos que forman parte de nuestra orden. Iniciamos como un
              arreglo vacío. Si vemos, así lo hicimos en el anterior proyecto de las guitarras pero con el IS vemos que nos da
              que order es de tipo Never por lo que lo ideal es aplicarle un tipo de dato en específico.</p>
            <pre><code class="language-js">
                    import { useState } from "react"
      
                    export default function useOrder() {
                      const [order, setOrder] = useState([])
      
                      return{
                        
                      }
                    }
                  </code></pre>
            <p>En nuestro fichero de types vamos a crear un tipe nuevo <span class="type">OrderItem</span> para la orden y va
              a requerir lo mismo que el tipo <span class="type">MenuItem</span> pero además tiene que tener cantidad por lo
              que lo declaramos así <span class="file">types&gt;index.ts</span>:</p>
            <pre data-line="5-7"><code class="language-js">
                    export type MenuItem = {
                      id: number,
                      name: string,
                      price: number
                    }
                    export type OrderItem = MenuItem & {
                      quantity: number
                    }
                  </code></pre>
      
            <p>Lo importamos en nuestro hook <span class="file">useOrder.ts</span> <code
                class="language-ts">import { OrderItem } from "../types"</code>. ¿Cómo hacemos para asignar a ese state
              'order' nuestro type OrderITem y que tenga esos atributos definidos incluyendo quantity? <span
                class="destacado">Generics en TypeScript: es una característica que nos va a permitir escribir código más
                flexible y reutilizable</span>. Veamos estos 3 states para ver que, en los casos en que nuestros tipos son un
              poco más complejos (y no solo tenemos un valor inicial de state sencillo como puede ser un
              number/string/boolean..) viene bien especificarle con el generic nuestro type. Así todo lo que agreguemos a ese
              state order, React va a revisar que tenga la estructura del tipo definido. En el caso de los que tienen un valor
              inicial más sencillo que TS puede inferir bien, no es necesario el generic:</p>
            <pre><code class="language-js">
                    const [order, setOrder] = useState&lt;OrderItem[]&gt;([]) //Nuestro tipo (OrderItem) es más complejo y queremos especificarle que sea ese, sí requiere generic
                    const [total, setTotal] = useState&lt;number&gt;(0) //No sería necesario el generic es redundante porque con el valor inicial se infiere bien
                    const [auth, setAuth] = useState&lt;boolean&gt;(false) //No sería necesario el generic es redundante porque con el valor inicial se infiere bien
                  </code></pre>
      
            <p>Los generics por tanto son muy útiles cuando tenemos estructuras propias o más complejas porque TS no sabe qué
              queremos hacer y de esta manera le decimos "sí, esto va a ser un arreglo/objeto pero tiene que tener estas
              propiedades</p>
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-114').toggle();">
            <h3>114. Creando la función para Añadir articulos a la orden</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-114" class="hidden">
            <p>Creamos en nuestro hook un arrow function nueva para agregar items y la exportamos en el return. </p>
            <pre><code class="language-js">
                    export default function useOrder() {
                      const [order, setOrder] = useState<OrderItem[]>([])
                  
                      const addItem = () => {
                          console.log('Añadiendo item')
                      }
                  
                          return{
                              addItem
                          }
                  }
                  </code></pre>
      
            <p>La importamos en nuestra <span class="file">App.tsx</span>, vamos a ver como tener un estado global. Vemos a
              continuación como usando destructuring extraigo de nuestro custom hook useOrder la nueva función addItem, que a
              su vez hemos de pasar como prop a nuestro componente MenuItem.jsx (porque cada vez que presione uno de esos
              menús es una función con valores diferentes).</p>
            <pre><code class="language-js">
                    import useOrder from "./hooks/useOrder"
      
                    function App() {
                    
                        const { addItem } = useOrder() 
                  </code></pre>
            <p>Si nos colocamos en el destructuring encima de ese addItem vemos con el IS que es un arrow function () => void.
              Usamos esa información para <strong>completar el type exclusivo que definimos en nuestro componente <span
                  class="file">MenuItem.tsx</span></strong> y añadimos el segundo parámetro en la declaración de nuestra
              función de componente y el onClick con la llamada a la función, como callback porque tengo que pasarle qué es lo
              que quiero agregar.</p>
            <pre data-line="2,5,9"><code class="language-js">
                    type MenuItemProps = {
                      item: MenuItem,
                      addItem: () => void // muy común cuando pasamos una fcn vía props. VOid significa que no retorna nada. A veces sí tomará parámetro y a veces retornaraá un valor
                  }
                  
                  export default function MenuItem({item, addItem}: MenuItemProps) {
                    return (
                      &lt;button 
                        className=&quot;border-2 border-teal-400 hover:bg-teal-200 w-full p-3 flex justify-between&quot;
                        onClick = {() =&gt; addItem()}
                        &gt;
                  </code></pre>
      
            <p>En <span class="file">App.tsx</span> tenemos que pasarle esa función a nuestro componente vía props</p>
            <pre data-line="5"><code class="language-js">
                    &lt;div className=&quot;space-y-2 mt-10&quot;&gt;
                      {menuItems.map(item =&gt; (
                        &lt;MenuItem
                          key = {item.id} //siempre que iteramos, recordar añadir key único
                          item = {item}
                          addItem = {addItem}
                        /&gt;
                      ))}
                    &lt;/div&gt;
                  </code></pre>
      
            <p>Una vez que presionemos en ese botón queremos añadir ese elemento con el nombre, con el id y con el precio.</p>
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-115').toggle();">
            <h3>115. Agregando el signature a la función de agregar articulo con TypeScript</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-115" class="hidden">
            <p>Vamos a ver como escribir en el state de useOrder, ahora mismo solo estamos sacando un mensaje en consola al
              pulsar. Tenemos que pasarle un argumento desde la llamada del onClick en el componente hasta nuestro custom
              hook. Para ello en nuestro hook tenemos que decirle que la función addItem va a tomar un elemento, le ponemos
              como parámetro 'item' y vemos que se nos pone en color rojo, si vamos a la App.tsx vemos que también en rojo nos
              indica el IS "bueno tú le estás pasando un item que actualmente tiene el tipo de dato Any y tu firma, lo que tú
              has colocado, es una función que no toma nada y que no retorna nada (la firma nos dice que tiene muy pocos
              argumentos)": </p>
      
            <img class="my-2.5" src="./src/assets/img/115.png" alt="">
      
            <p>Vamos a nuestro componente <span class="file">MenuItem.tsx</span> y en el type <span
                class="type">MenuItemProps</span> también le añadimos el parámetro item al definir el tipo de la función, se
              pone inmediatamente en rojo y el IS nos indica que es un any y hemos de corregirlo, además en el arrow function
              del onclick nos marca en rojo también la llamada a la función porque, habiendo especificado que le pasamos algo
              como argumento aún no lo hemos indicado:</p>
      
            <img class="my-2.5" src="./src/assets/img/115-2.png" alt="">
      
            <p><span class="destacado">Vayamos siguiendo los errores para corregirlos:</span> indicamos en nuestro type <span
                class="type">MenuItemProps</span> que el parámetro item que pasamos como argumento es de tipo <span
                class="type">MenuItem</span> y en la arrow function del onClick le especificamos el parámetro item.</p>
      
            <pre data-line="4,11"><code class="language-js">
                    import type { MenuItem } from &quot;../types&quot;
      
                    type MenuItemProps = {
                        item: MenuItem,
                        addItem: (item: MenuItem) =&gt; void
                    }
                    
                    export default function MenuItem({item, addItem}: MenuItemProps) {
                      return (
                        &lt;button 
                          className=&quot;border-2 border-teal-400 hover:bg-teal-200 w-full p-3 flex justify-between&quot;
                          onClick = {() =&gt; addItem(item)}
                          &gt;
                            &lt;p&gt;{item.name}&lt;/p&gt;
                            &lt;p className=&quot;font-black&quot;&gt;{item.price}&lt;/p&gt;
                        &lt;/button&gt;
                      )
                    }
                  </code></pre>
      
            <p><span class="destacado">Hemos de irle diciendo siempre <span class="type">qué tipo de dato vamos a tener
                  tanto</span> en nuestras funciones como en los parámetros que le vamos pasando</span>. En <span
                class="file">useOrder.ts</span> nos queda por corregir especificar el tipo de dato de item (<strong>Vemos que
                al declararlo como type <span class="type">MenuItem</span> al no estar importado en el fichero, el IS nos da
                la opción de corregirlo y automáticamente aparece en las importaciones de arriba</strong>). Ya en el console
              logo podemos indicarle {item}</p>
      
            <pre data-line="1,6"><code class="language-js">
                    import { useState } from &quot;react&quot;
                    import { MenuItem, OrderItem } from &quot;../types&quot;
                    
                    export default function useOrder() {
                        const [order, setOrder] = useState&lt;OrderItem[]&gt;([])
                    
                        const addItem = (item: MenuItem) =&gt; {
                            console.log({item})
                        }
                    
                            return{
                              addItem
                            }
                    }
                  </code></pre>
      
            <p><span class="destacado">Importante:</span> nuestra función del custom hook <span
                class="file">useOrder.ts</span> <code class="language-js">export default function useOrder() {</code>: </p>
            <pre><code class="language-js">
                    const addItem = (item: MenuItem) => {
                      console.log({item})
                    } 
                  </code></pre>
            <p>toma un item de tipo MenuItem, sin embargo cuando desde nuestra <span class="file">App.tsx</span> pasa como
              prop al componente <span class="file">MenuItem.tsx</span> se pierde esa referencia y nosotros tenemos que,
              digamos, recuperar o reasignar esa referencia para que TS sepa que tiene que hacer y sobre todo qué atributos de
              ese type es a los uqe va a tener acceso. Si probamos la App veremos que cada vez que presionamos un producto nos
              aparece en consola el item correspondiente con lo que la comunicación es correcta. A continuación vamos a
              empezar a escribir en nuestro state de nuestro hook de useOrder().</p>
      
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-116').toggle();">
            <h3>116. Añadiendo elementos al state de Orden</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-116" class="hidden">
            <p>Vamos a escribir en nuestro state de órdenes pero recordemos que <span class="file">useOrder.ts</span> este
              estate order <code class="language-js">const [order, setOrder] = useState&lt;OrderItem[]&gt;([])</code> lo
              definimos con un <strong>generic</strong> como un array de tipo <span class="type">OrderItem</span>, y ese tipo
              tenía una cantidad 'quantity'.</p>
      
            <pre><code class="language-js">
                    export type OrderItem = MenuItem & {
                      quantity: number
                  }
                  </code></pre>
      
            <p>Entonces lo que tenemos que hacer es castear o cambiar el valor pero tenemos que agregarle una cantidad así que
              veamos como hacerlo.</p>
      
            <p>Quitamos el console.log y llamamos a la función del state para, como es un arreglo, tomar una copia de lo
              previo y le pasamos el item, pero podemos ver que en seguida nos saca error. ¿por qué?</p>
      
            <img class="my-2.5" src="./src/assets/img/116.png" alt="">
      
            <p>Estamos intentando pasar como argumento un 'item' que es de tipo <span class="type">MenuItem</span> que tiene
              estos atributos:</p>
      
            <pre><code class="language-js">
                    export type MenuItem = {
                      id: number,
                      name: string,
                      price: number
                    }
                  </code></pre>
      
            <p>mientras que nuestro state de order es de tipo <span class="type">OrderItem</span> que, recordemos tiene los
              atributos de <span class="type">MenuItem</span> más la cantidad 'quantity'</p>
      
            <pre><code class="language-js">
                    export type MenuItem = {
                      id: number,
                      name: string,
                      price: number
                  }
                  export type OrderItem = MenuItem & {
                    quantity: number
                  }
                </code></pre>
      
            <p>Lo resolvemos creando una variable nueva <strong>newItem</strong> que va a ser un objeto y en el que incluyo
              una copia del item que paso + quantity inicializada a 1 para la primera vez que añado una orden (más adelante
              iremos ajustando esta cantidad según casuística). Le pasamos ese newItem a la función del state y ya no tenemos
              errores. Si nos ponemos encima de esta nueva variable vemos con el IS que tiene los atributos de <span
                class="type">OrderItem</span> más no es como tal un OrderItem, podríamos castearlo especificando el tipo:
              <code class="language-js">const newItem: OrderItem = {...item, quantity: 1}</code> aunque no es necesario y él
              no lo hace porque en la declaración de nuestro state ya especificamos con el generic que las órdenes van a tener
              ese tipo de dato.</p>
      
            <pre><code class="language-js">
                  import { useState } from &quot;react&quot;
                    import { MenuItem, OrderItem } from &quot;../types&quot;
                    
                    export default function useOrder() {
                      const [order, setOrder] = useState&lt;OrderItem[]&gt;([])
                      
                      const addItem = (item: MenuItem) =&gt; {
                        //console.log({item})
                        const newItem = {...item, quantity: 1}
                        setOrder([...order, newItem])
                      }
                      console.log(order)
                      
                      return{
                        addItem
                      }
                    }
                  </code></pre>
      
            <p>Añadimos un console.log de order para ver que si repetimos en alguna orden se añade varias veces.</p>
            <img class="my-2.5" src="./src/assets/img/116-2.png" alt="">
            <p>Lo ideal es que no se repita sino controlar eso con la cantidad. Por la inmutabilidad de React es un poco más
              complicado así que vemos como hacerlo a continuación</p>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-117').toggle();">
            <h3>117. Evitando duplicados</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-117" class="hidden">
            <p>Vamos a revisar si una orden existe en el arreglo:</p>
            <ul class="mb-3.75">
              <li><strong>¿No existe?:</strong> este código está bien:
                <pre><code class="language-js">
                        const newItem: OrderItem = {...item, quantity: 1}
                        setOrder([...order, newItem])
                      </code></pre>
              </li>
              <li><strong>¿Existe?:</strong> hemos de revisar cantidad</li>
            </ul>
      
            <p>Usamos el array method <strong>.find()</strong> para encontrar un elemento de un array en base a una condición
              y empleamos dentro del find un arrow function <strong>(recordar que el parámetro aquí usado (una variable
                temporal en la ejecución de este find) lo llamamos COMO QUERAMOS en este ejemplo 'orderItem' y hace referencia
                a cada uno de los objetos que AHORA MISMO HAY en nuestro state array order)</strong>. <span
                class="destacado">Ojo al escribir el código de la comprobación, cómo funciona el autocompletado de VSC para
                cada uno de los 2 objetos implicados (el que hace referencia a cada uno de los elementos del state order
                actual 'orderItem' y el que hace referencia al item que la pasamos al clickar).</span> Así es como queda
              nuestro código de momento con un console.log que nos avise si pulsamos en una orden que ya existe:</p>
      
            <pre><code class="language-js">
                    const addItem = (item: MenuItem) => {
                        
                      const itemExist = order.find(orderItem => orderItem.id === item.id) // buscamos en el state order el elemento cuyo id sea igual al id del item que estamos pasando
                      if (itemExist) {
                        console.log('El item ya existe') 
                      } else {
                          const newItem: OrderItem = {...item, quantity: 1}
                          setOrder([...order, newItem])
                      }
                      
                  }
                  </code></pre>
      
            <p>Si existe el elemento que intentamos agregar, hay que encontrar cual es, incrementar su cantidad pero siempre
              sin mutar el state. Para ello utilizamos el <strong>.map() y algunos spreads</strong></p>
      
            <pre><code class="language-js">
                    export default function useOrder() {
                      const [order, setOrder] = useState&lt;OrderItem[]&gt;([])
                  
                      const addItem = (item: MenuItem) =&gt; {
                          
                          const itemExist = order.find( orderItem =&gt; orderItem.id === item.id )
                          if (itemExist) { //El item ya existe         
                            const updatedOrder = order.map( orderItem =&gt; orderItem.id === item.id ? // identificamos el elemento duplicado, busca el elemento de la orden cuyo id sea igual al id del elemento que viene en item (click)
                              {...orderItem, quantity: orderItem.quantity + 1} : //toma una copia de lo que tenemos en nuestra orden e incrementa la cantidad en 1
                              orderItem)//contiene el resto de artículos de la orden que no cumplen el condicional del ternario (los no duplicados)
                              //gracias al .map() nos retorna un arreglo nuevo y podemos setear nuestra orden
                              setOrder(updatedOrder)
                          } else { // El item no existe
                              const newItem: OrderItem = {...item, quantity: 1}
                              setOrder([...order, newItem])
                          }
                          
                      }
                      console.log(order)
                  
                          return{
                            addItem
                          }
                    }
                  </code></pre>
      
            <p>Veamos cómo mostrar el state order en pantalla (ahora solo podemos verlo en consola o en React Developer tools)
            </p>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-118').toggle();">
            <h3>118. Mostrando el Consumo de la orden</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-118" class="hidden">
            <p>Estamos escribiendo en nuestro state de órdenes, ahora queremos ir mostrando a la derecha todo lo que yo pulso
              a la izquierda. Vamos así a comunicar distintos componentes con las interacciones del usuario para crear apps
              que sean más dinámicas. Vamos al <span class="file">App.tsx</span> y creamos un div con estas propiedades de
              estilo usando tailwindcss (dentro de él llamamos al nuevo componente que creamos a continuación): </p>
            <pre><code class="language-js">
                    import OrderContents from "./components/OrderContents"
      
                    &lt;div className=&quot;border border-dashed border-slate-300 p-5 rounded-lg space-y10&quot;&gt; 
                      &lt;OrderContents /&gt;
                    &lt;/div&gt;
                  </code></pre>
            <p>Creamos un componente nuevo <span class="file">OrderContents.tsx</span> en el cual creamos el componente con el
              snippet <strong>rfc</strong> le ponemos un título y en él iteraremos sobre nuestra orden:</p>
            <pre><code class="language-js">
                    export default function OrderContents() {
                      return (
                        &lt;div&gt;
                            &lt;h2 className=&quot;font-black text-4xl&quot;&gt;Consumo&lt;/h2&gt;
                    
                        &lt;/div&gt;
                      )
                    }
                  </code></pre>
            <p>y lo llamamos desde nuestra App.tsx</p>
            <p>A continuación exportamos "order" desde nuestro Hook <span class="file">useOrder.ts</span>:</p>
            <pre data-line="23"><code class="language-js">
                    //useOrder.ts
                    import { useState } from &quot;react&quot;
                    import { MenuItem, OrderItem } from &quot;../types&quot;
                    
                    export default function useOrder() {
                        const [order, setOrder] = useState&lt;OrderItem[]&gt;([])
                        const addItem = (item: MenuItem) =&gt; {
                            
                            const itemExist = order.find( orderItem =&gt; orderItem.id === item.id )
                            if (itemExist) { //El item ya existe         
                              const updatedOrder = order.map( orderItem =&gt; orderItem.id === item.id ? // identificamos el elemento duplicado, busca el elemento de la orden cuyo id sea igual al id del elemento que viene en item (click)
                                {...orderItem, quantity: orderItem.quantity + 1} : //toma una copia de lo que tenemos en nuestra orden e incrementa la cantidad en 1
                                orderItem)//contiene el resto de artículos de la orden que no cumplen el condicional del ternario (los no duplicados)
                                //gracias al .map() nos retorna un arreglo nuevo y podemos setear nuestra orden
                                setOrder(updatedOrder)
                            } else { // El item no existe
                                const newItem: OrderItem = {...item, quantity: 1}
                                setOrder([...order, newItem])
                            }
                            
                        }
                        console.log(order)    
                            return{
                              order,
                              addItem
                            }
                    }
                  </code></pre>
      
            <p><span class="destacado">Aún no hemos visto como tener un estado global (¿en al App.tsx?)</span> así que no lo
              podemos importar directamente en nuestro <strong>OrderContents.tsx</strong> porque es como tener una clase nueva
              entonces pierde la referencia??. En <span class="file">App.tsx</span>, que importamos nuestro Hook, en el
              destructuring de nuestro hook <strong>useOrder</strong> <span class="destacado">extraemos también la orden que
                vamos a pasar como prop al nuevo componente</span>:</p>
            <pre data-line="5"><code class="language-js">
                      //App.tsx
                      import useOrder from "./hooks/useOrder"
                      import OrderContents from "./components/OrderContents"
      
                      function App() {
      
                        const { order, addItem } = useOrder()
                    </code></pre>
      
            <p>Si somos limpios usando el mismo orden que usamos en el Hook para declarar y retornar las variables será más
              fácil tenerlo todo controlado; si vemos nuestro hook:</p>
            <pre data-line="2,3,8,9"><code class="language-js">
                    //useOrder.ts
                    export default function useOrder() {
                      const [order, setOrder] = useState&lt;OrderItem[]&gt;([])
                      const addItem = (item: MenuItem) =&gt; {      
      
                          ....
                  
                          return{
                            order,
                            addItem
                          }
                    }
                  </code></pre>
      
            <p>Al asignarle la prop me marca un error porque, esa propiedad que enviamos desde App.tsx hacia OrderContents.tsx
              hemos de tiparla, no tenemos ningún type asociado.</p>
      
            <pre class="rojo" data-line="2"><code class="language-js">
                    //App.tsx
                    &lt;OrderContents 
                    order = { order }
                  /&gt;
                  </code></pre>
      
            <p><strong>En nuestro nuevo componente OrderContents.tsx creamos un nuevo type específico y en su definición
                indicamos que la order es del tipo array OrderItem (hemos de importar ese tipo)</strong>.</p>
      
            <div class="flex">
              <div class="w-50">
                <pre><code class="language-js">
                        //OrderContents.tsx
                        export default function OrderContents() {
                          return (
                            &lt;div&gt;
                                &lt;h2 className=&quot;font-black text-4xl&quot;&gt;Consumo&lt;/h2&gt;
                        
                            &lt;/div&gt;
                          )
                        }
                      </code></pre>
              </div>
              <div class="w-50">
                <pre><code class="language-js">
                        //OrderContents.tsx
                        import { OrderItem } from &quot;../types&quot;
      
                        type OrderContentsProps = {
                            order: OrderItem[]
                        }
                        
                        export default function OrderContents({order}: OrderContentsProps) {
                          return (
                            &lt;div&gt;
                                &lt;h2 className=&quot;font-black text-4xl&quot;&gt;Consumo&lt;/h2&gt;
                        
                            &lt;/div&gt;
                          )
                        }
                      </code></pre>
              </div>
            </div>
      
            <p>Comentamos el console.log(order) de nuestro hook para comenzar a mostrarlo en nuestro componente. Añadimos este
              contenedor con esta comprobación:</p>
      
            <pre><code class="language-js">
                    //OrderContents.tsx
                    &lt;div className=&quot;space-y-3 mt-5&quot;&gt;
                      { order.length === 0 ? 
                          &lt;p className=&quot;text-center&quot;&gt;La orden está vacía&lt;/p&gt;
                          : 
                          //&lt;p className=&quot;text-center&quot;&gt;La orden tiene algo&lt;/p&gt;
                          ( order.map( item =&gt; (
                              &lt;div key={item.id}&gt;
                                  &lt;p&gt;{item.name}&lt;/p&gt;
                              &lt;/div&gt;
                              )
                          ))
                      }
                    &lt;/div&gt;
                  </code></pre>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-119').toggle();">
            <h3>119. Formateando el Consumo y mostrando cantidades</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-119" class="hidden">
      
            <p>Sigamos con nuestro html, vamos a mostrar nombre, precio, cantidad y un botón para eliminar los elementos.
              Añadimos el precio y en vez de poner a pelo el signo del $, crea carpeta y fichero <span
                class="file">helpers&gt;index.ts</span> donde mete la función '<strong>formatCurrency()</strong>':</p>
            <pre><code class="language-js">
                    //helpers>index.ts
                    export default function formatCurrency(quantity: number){
                      return new Intl.NumberFormat('en-US', {
                          style: 'currency', currency: 'USD'
                      }).format(quantity)
                  }
                  </code></pre>
            <pre><code class="language-js">
                    //OrderContents.tsx
                    (order.map( item =&gt; (
                      &lt;div 
                          className=&quot;flex justify-between items-center border-t border-gray-200 py-5 last-of-type:border-b&quot;
                          key={item.id}
                      &gt;
                          &lt;div&gt;
                              &lt;p className=&quot;text-lg&quot;&gt;
                                  {item.name} - {formatCurrency(item.price)}
                              &lt;/p&gt;
                              &lt;p className=&quot;font-black&quot;&gt;
                                  Cantidad: {item.quantity} - {formatCurrency(item.price * item.quantity)}
                              &lt;/p&gt;
                          &lt;/div&gt;
                          &lt;button className=&quot;bg-red-600 h-8 w-8 rounded-full text-white font-black&quot;&gt;X&lt;/button&gt;
                      &lt;/div&gt;
                      )
                    ))
                  </code></pre>
      
            <img class="my-2.5" src="./src/assets/img/119.png" alt="Imagen 119">
      
      
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-120').toggle();">
            <h3>120. Eliminando articulos de la orden</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-120" class="hidden">
            <p>Creamos función nueva para eliminar items de la orden y vemos todos los cambios necesarios en App.tsx, nuestro
              custom hook y el componente implicado.</p>
            <pre><code class="language-js">
                    //useOrder.ts 
                    // - creamos una nueva función para borrar items
                    // - le ponemos como parámetro id y lo tipamos como MenuItem con un lookup para id 
                    // - (lo podríamos poner como number pero si cambiáramos la BBDD a Mongo DB que son string, la liamos sin ese "seguimiento de tipados" del lookup)
                    // - en el console.log comprobamos la comunicación ¿OK? --&gt; seteamos ese state en base a nuestra condición. Accedemos a nuestro state 'order' y usamos el array method filter para crear un nuevo array con los elementos del order actual de los que se exluye el elemento cuyo id coincida con el que le pasamos como argumentoal pulsar el click.
                    // - la exportamos en el return para hacerla disponible en nuestros componentes
                      import formatCurrency from "../helpers"
                      import { MenuItem, OrderItem } from "../types"
                      export default function useOrder() {
                        const [order, setOrder] = useState&lt;OrderItem[]&gt;([])
                      ...
                      const removeItem = (id: MenuItem['id']) => { 
                        //console.log('Eliminando', id)
                        setOrder(order.filter(item => item.id != id))
                      
                      }
                      return{
                          order,
                          addItem,
                          removeItem
                      }
      
                    //App.tsx 
                    //- extraemos de nuestro hook con destructuring esta nueva función
                      const { order, addItem, removeItem } = useOrder()
      
                    //- en el tag de nuestro compocreamos un prop nuevo 'removeItem' que le pasa esa fcn el compo desde donde se va a utilizar "OrderContents.tsx"    
                      &lt;OrderContents 
                        order = { order }
                        removeItem = {removeItem}
                      &gt;
                      // saldrá en rojo hasta que en el componente donde se usa "OrderContents.tsx" hagamos lo siguiente: 
      
                    //OrderContents.tsx 
                    //- lo incluimos como parámetro (necesitamos incluirlo en el tipo personalizado type OrderContentsProps) 
                    //- recibe un parámetro que tipamos como lookup for 'id' del type MenuItem
                    //- añadimos la llamada a la función para borrar desde el onclick del botón y le pasamos como argumento el id del item.
                    
                      type OrderContentsProps = {
                        order: OrderItem[],
                        removeItem: (id: MenuItems['id']) => void
                      }
                      ...
                      export default function OrderContents({order,removeItem}: OrderContentsProps) {
                      ...
                      &lt;button 
                          className=&quot;bg-red-600 h-8 w-8 rounded-full text-white font-black&quot;
                          onClick={() =&gt; removeItem(item.id)}
                      &gt;X&lt;/button&gt;
                  </code></pre>
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-121').toggle();">
            <h3>121. Creando el Componente con los totales</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-121" class="hidden">
            <p>Vamos a crear un nuevo componente para los totales que irá justo debajo de la lista de contenidos de nuestra
              orden. A diferencia del proyecto anterior en donde también la fcn para totales la teníamos en nuestro custom
              hook, dado que en este caso solo se va a requerir su uso en el componente totales la vamos a especificar ahí.
            </p>
      
            <pre><code class="language-js">
                    //OrderTotals.tsx (nuevo componente para totales)
      
                    //App.tsx
                    //-importamos nuestro componente
                    //-Lo renderizmaos en el return() a continuación del componente &lt;MenuItem /&gt;
                      import OrderTotals from "./components/OrderTotals"
                      ...
                      &lt;OrderTotals /&gt;
      
                    //OrderTotals.tsx
                    //- div con las cantidades 
                    //- button para almacenar o reiniciar la orden (mas adelante veremos como conectar BBDD con servidor de node de momento simulamos que la almacenamos )
                      export default function OrderTotals() {
                        return (
                          &lt;&gt;
                      
                            &lt;div className=&quot;space-y-3&quot;&gt;
                              &lt;h2 className=&quot;font-black text-2xl&quot;&gt;Totales y propina:&lt;/h2&gt;
                              &lt;p&gt;Subtotal a pagar:
                                &lt;span className=&quot;font-bold&quot;&gt;$0&lt;/span&gt;
                              &lt;/p&gt;
      
                              &lt;p&gt;Propina:
                                &lt;span className=&quot;font-bold&quot;&gt;$0&lt;/span&gt;
                              &lt;/p&gt;
                      
                              &lt;p&gt;Total a pagar: 
                                &lt;span className=&quot;font-bold&quot;&gt;$0&lt;/span&gt;
                              &lt;/p&gt;
                            &lt;/div&gt;
                      
                            &lt;button&gt;&lt;/button&gt;
                      
                          &lt;/&gt;
                        )
                      }
      
                  </code></pre>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-122').toggle();">
            <h3>122. Calculando el Consumo y más TypeScript</h3>
            <span class="cambiaicono ico_chevron_up_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-122" class="hidden">
            <p><strong>Calculemos el subtotal a pagar en base al precio de los artículos y sus cantidades.</strong> Si
              agregamos varios elementos, vemos que el subtotal tiene que ser el resultado de sumar cada precio por la
              cantidad. Eso antes era más complejo hacerlo pero <strong>gracias a las "nuevos"(2015) array methods como
                <strong>useMemo() o reduce() </strong>es más sencillo simplifican el código, evitando tener que tener renders
                adicionales</strong>. Como ese cálculo viene desde <strong>order</strong> vamos a nuestro App.tsx</p>
            <pre><code class="language-js">
                    //App.tsx
                    //- en el tag de nuestro nuevo componente &lt;OrderTotals/&gt; le pasamos como propiedad la order para que esté conectado y sepa cuáles son los contenidos de nuestra orden (lo podemos hacer en el hook o en el componente, con react tenemos siempre distintas formas)
                      &lt;OrderTotals 
                      order = { order }/&gt;
                  </code></pre>
      
            <pre><code class="language-js">
                  //OrderTotals.tsx  
                  //- importamos useMemo y nuestra función formatCurrency() de helpers que los vamos a usar
                    import { useMemo } from "react"
                    import formatCurrency from "../helpers"
      
                  //- como esa prop 'order' va a ser de tipo array OrderItem, importamos ese type
                  //- nuestro componente va a recibir como parámetro esa prop así que creamos type personalizado para este componente
                    import {OrderItem} from &quot;../types&quot;
                    type OrderTotalsProps = {
                      order: OrderItem[]
                    }
      
                    export default function OrderTotals({order}: OrderTotalsProps) {
      
                    //- creamos función nueva 'subtotalAmount' para calcular el subtotal a pagar en base al precio de los artículos y sus cantidades:
                      const subtotalAmount = useMemo(() => order.reduce( (total, item) => total + (item.quantity * item.price), 0), [order])
      
                      //- usamos useMemo; va a ser siempre un callback y la dependencia es lo que hay tras la coma --&gt; useMemo(()=&gt; ,[]order).
                      // nos permite que el código se renderice o se ejecute cada vez que cambia la dependencia (en nuestro caso cada vez que cambia la orden).
                      //- usamos el array method .reduce() que es uno de los pocos que toma dos parámetros (acumulado temporal y el item sobre el  que iteramos): 
                        // total(temporal) es un acumulado, en cada iteración que se va dando va almacenando en memoria (en nuestro caso la suma del total temporal con (menuItems.quantity * item*price))
                        // item(elemento sobre el que estamos iterando) --&gt; tras la coma, 0 es el valor inicial de la iteracion
                  
                    //- usando en el return{} nuestra función formatCurrency() de helper, ya podemos ver el subtotal:
                      return (
                        &lt;&gt;
                          &lt;p&gt;Subtotal a pagar:
                            &lt;span className=&quot;font-bold&quot;&gt;{ formatCurrency(subtotalAmount) }&lt;/span&gt;
                          &lt;/p&gt;
      
                    
      
                    
                    
                    
      
                      
                      
      
                  </code></pre>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-123').toggle();">
            <h3>123. Primeros pasos con las propinas / 124. Añadiendo la cantidad seleccionada de Propina</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-123" class="hidden">
            <p>Vamos a tener un formulario en el que vamos a indicar cuánto queremos dejar de propina. Creamos componente
              nuevo <span class="file">TipPercentageForm.tsx</span> en el que usamos como const <a
                href="https://gist.github.com/codigoconjuan/93fd42da96258357fc9f78eb1d17a6b3" class="underline"
                target="_blank">Gist Arreglo con objetos (id, value, label) para iterarlo y mostrarlo en el formulario</a></p>
            <pre><code class="language-js">
                    //App.tsx
                    import TipPercentageForm from "./components/tipPercentageForm"
      
                    &lt;TipPercentageForm /&gt;
                  </code></pre>
            <pre><code class="language-js">
                    //TipPercentageForm.tsx
                    const tipOptions = [
                    {
                      id: &#39;tip-10&#39;,
                      value: .10,
                      label: &#39;10%&#39;
                    },
                    {
                      id: &#39;tip-20&#39;,
                      value: .20,
                      label: &#39;20%&#39;
                    },
                    {
                      id: &#39;tip-50&#39;,
                      value: .50,
                      label: &#39;50%&#39;
                    },
                  ]
      
                  export default function TipPercentageForm() {
                    return (
                      &lt;&gt;
                          &lt;h3 className=&quot;font-black text-2xl&quot;&gt;Propina:&lt;/h3&gt;
      
                          &lt;form&gt;
                              {tipOptions.map( tipOption =&gt; (
                                  &lt;div
                                      key={tipOption.id}
                                      className=&quot;flex gap-2&quot;
                                  &gt;
                                      &lt;label htmlFor={tipOption.id}&gt;{tipOption.label}&lt;/label&gt;
                                      &lt;input 
                                          id={tipOption.id} 
                                          type=&quot;radio&quot;
                                          name=&quot;tipOption&quot;
                                          value={tipOption.value}
                                      /&gt;
                                  &lt;/div&gt;
                              ))}  
                          &lt;/form&gt;
                      &lt;/&gt; 
                    )
                  }
                  </code></pre>
      
            <p class="naranja">Añadiendo la cantidad seleccionada de Propina</p>
      
            <p>vamos a colocar el state de propina en nuestro hook useOrder():</p>
            <pre><code class="language-js">
                    //useOrder.ts 
                    export default function useOrder() {
                        const [order, setOrder] = useState<OrderItem[]>([])
                        const [tip, setTip] = useState(0)
      
                        return{
                          order,
                          tip,
                          setTip,
                          addItem,
                          removeItem
                      }
      
                    //App.tsx
                    - extraigo ambos: tip y setTip para tenerlos disponibles Y
                    - pasarlos como propiedades del componente 
      
                      const { order, addItem, removeItem, tip, setTip } = useOrder()
      
                        &lt;TipPercentageForm 
                          setTip = {setTip}
                        /&gt;
                      
                    //TipPercentageForm.tsx
                    //- definimos type nuevo específico para la función setTip que estamos pasando ¿donde lo miramos? dejamos que VSC nos lo infiera
                    //y con el Intellisense de VSC lo copiamos 'setTip: React.Dispatch&lt;React.SetStateAction&lt;number&gt;&gt;' 
                    // significa funcion que dispara la accion de modificar el state de tipo number
                    
      
                        type TipPercentageFormProps = {
                          setTip: React.Dispatch&lt;React.SetStateAction&lt;number&gt;&gt;
                        }
                        
                        export default function TipPercentageForm({setTip}:TipPercentageFormProps) {
      
                    //También podríamos reducir un poco nuestro código del nuevo type para esta propor importando de react los dos types:
                        import type { Dispatch, SetStateAction } from "react"
      
                        type TipPercentageFormProps = {
                          setTip: Dispatch<SetStateAction<number>>
                      }
      
                    // - usamos setTip en nuestro input, en el onChange modificamos el value, sin embargo vemos que al escribir onChange={ e =&gt; setTip(e.target.value)}
                    // nos marca en rojo, TS escanea nuestro código y setTip es number y el value de un input es string. Lo podemos solucionar de dos manera:
                    //  * signo + antes de lo que lee como string, lo convierte a number  onChange={ e =&gt; setTip(+e.target.value)}
                    //  * añadirle el sufijo AsNumber onChange={ e =&gt; setTip(e.target.valueAsNumber)} PERO ESTO NO FUNCIONA CON LAS INPUT RADIO!!!
                      &lt;form&gt;
                        {tipOptions.map( tipOption =&gt; (
                            &lt;div
                                key={tipOption.id}
                                className=&quot;flex gap-2&quot;
                            &gt;
                                &lt;label htmlFor={tipOption.id}&gt;{tipOption.label}&lt;/label&gt;
                                &lt;input 
                                    id={tipOption.id} 
                                    type=&quot;radio&quot;
                                    name=&quot;tipOption&quot;
                                    value={tipOption.value}
                                    //onChange={ e =&gt; setTip(e.target.value)}
                                    onChange={ e =&gt; setTip(+e.target.value)}
                                /&gt;
                            &lt;/div&gt;
                        ))}  
                      &lt;/form&gt;
                  </code></pre>
            <img class="my-2.5" src="./src/assets/img/124.png" alt="imagen 124">
      
            <p>Veamos como pasar ese tip o el porcentaje hacia OrderTotals.tsx para hacer los dos últimos cálculos, propinas y
              total a pagar.</p>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-125').toggle();">
            <h3>125. Calculando el Total de la propina / 126. Calculando el Total a pagar</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-125" class="hidden">
            <pre><code class="language-js">
                    //App.tsx
                      &lt;OrderTotals 
                        order = {order}
                        tip = {tip}
                      &gt;
                  </code></pre>
            <pre><code class="language-js">
                    //OrderTotals.tsx
                    //- completamos el type de propiedades de ese componente con la nueva que pasamos, tip que es de tipo number
                    //- la extraemos
                    //- como tip solo tiene el % (0.1 para 10% y así...) creamos variable nueva para formatearlo: 'tipAmount' y usamos useMemo() porque esa propina puede cambiar:
                    //  * cuando cambiemos la propina marcada 'tip'
                    //  * cuadno cambie nuestra orden 'order'
                    // por tanto empleamos esas dos dependencias para que, tanto cuando cambiemos el radio de la propina como cuando añadamos o eliminemos de nuestra orden, todo se Actualicemos
                    // - creamos nueva variable para el total 'totalAmount' y también usamos useMemo()
                      import { useMemo } from "react"
                      import { OrderItem } from &quot;../types&quot;
                      import formatCurrency from &quot;../helpers&quot;
      
                      type OrderTotalsProps = {
                        order: OrderItem[]
                        tip: number
                      }
      
                      export default function OrderTotals({order, tip}: OrderTotalsProps) {
      
                        const subtotalAmount = useMemo(() =&gt; order.reduce( (total, item) =&gt; total + (item.quantity * item.price), 0), [order])
                        const tipAmount = useMemo(() =&gt; subtotalAmount * tip, [tip, order])
                        const totalAmount = useMemo(()=&gt; subtotalAmount + tipAmount, [tip, order])
      
                        return (
                          &lt;&gt;
      
                            &lt;div className=&quot;space-y-3&quot;&gt;
                              &lt;h2 className=&quot;font-black text-2xl&quot;&gt;Totales y propina:&lt;/h2&gt;
                              &lt;p&gt;Subtotal a pagar:
                                &lt;span className=&quot;font-bold&quot;&gt; {formatCurrency( subtotalAmount )}&lt;/span&gt;
                              &lt;/p&gt;
                              &lt;p&gt;Propina:
                                &lt;span className=&quot;font-bold&quot;&gt; {formatCurrency( tipAmount )}&lt;/span&gt;
                              &lt;/p&gt;
                              &lt;p&gt;Total a pagar: 
                                &lt;span className=&quot;font-bold&quot;&gt; {formatCurrency( totalAmount )}&lt;/span&gt;
                              &lt;/p&gt;
                            &lt;/div&gt;
                            &lt;button&gt;&lt;/button&gt;
      
                          &lt;/&gt;
                        )
                      }
                  </code></pre>
      
          </div>
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-127').toggle();">
            <h3>127. Diferencia entre useMemo y useCallback</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-127" class="hidden">
            <p>Existe otra funcíón que es exactamente igual que useMemo() pero su sintaxis es diferente: useCallback()
              <strong>simplemente es añadir los () en cada llamada que se haga a las distintas funciones. El código anterior
                de nuestro componente OrderTotals.tsx quedaría así: </strong></p>
      
            <pre><code class="language-js">
                    //OrderTotals.tsx
                      import { useMemo, useCallback } from "react"
      
                      export default function OrderTotals({order, tip}: OrderTotalsProps) {
      
                        const subtotalAmount = useCallback(() =&gt; order.reduce( (total, item) =&gt; total + (item.quantity * item.price), 0), [order])
                        const tipAmount = useCallback(() =&gt; subtotalAmount() * tip, [tip, order])
                        const totalAmount = useCallback(()=&gt; subtotalAmount() + tipAmount(), [tip, order])
                      
                        return (
                          &lt;&gt;
                      
                            &lt;div className=&quot;space-y-3&quot;&gt;
                              &lt;h2 className=&quot;font-black text-2xl&quot;&gt;Totales y propina:&lt;/h2&gt;
                              &lt;p&gt;Subtotal a pagar:
                                &lt;span className=&quot;font-bold&quot;&gt; {formatCurrency( subtotalAmount() )}&lt;/span&gt;
                              &lt;/p&gt;
                              &lt;p&gt;Propina:
                                &lt;span className=&quot;font-bold&quot;&gt; {formatCurrency( tipAmount() )}&lt;/span&gt;
                              &lt;/p&gt;
                              &lt;p&gt;Total a pagar: 
                                &lt;span className=&quot;font-bold&quot;&gt; {formatCurrency( totalAmount() )}&lt;/span&gt;
                              &lt;/p&gt;
                            &lt;/div&gt;
                            &lt;button&gt;&lt;/button&gt;
                      
                          &lt;/&gt;
                        )
                      }
                  </code></pre>
      
          </div>
      
      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro"
            onclick="$('#seccion9-128').toggle();">
            <h3>128. Reiniciando la Orden / 129. Deployment del Proyecto</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion9-128" class="hidden">
            <p>Vamos a trabajar con e botón del final de nuestro componente OrderTotals.tsx</p>
            <pre><code class="language-js">
                    // OrderTotals.tsx
                    // - le damos estilos y lo deshabilitamos si el total es 0. 
                    // - aprovehamos las clases de tailwind para formatear aspecto cuando esté deshabilitado
                    &lt;button 
                      className=&quot;w-full bg-black p-3 uppercase text-white font-bold mt-10 rounded-sm cursor-pointer disabled:opacity-10 disabled:cursor-auto&quot;
                      disabled={totalAmount === 0 }
                      &gt; 
                      Guardar Orden
                    &lt;/button&gt;
                  </code></pre>
      
            <p>Creamos función nueva de tipo arrow 'placeOrder' y recordar el orden de propagación: <br>
              <span class="destacado">hook</span> <strong>useOrder.ts</strong> -> <span class="destacado">compo ppal</span>
              <strong>App.tsx</strong> -> <span class="destacado">compo donde se utiliza</span>
              <strong>OrderTotal.tsx</strong>
            </p>
      
            <pre><code class="language-js">
                    //useOrder.ts
                        const placeOrder = () => {
                          console.log('guardando...')
                      }
                      return{
                          order,
                          tip,
                          setTip,
                          addItem,
                          removeItem,
                          placeOrder
                      }
      
                    //App.tsx
                      function App() {
      
                        const { order, tip, setTip, addItem, removeItem, placeOrder } = useOrder()
                      
                        return (
                          &lt;&gt;
                          &lt;OrderTotals 
                            order = {order}
                            tip = {tip}
                            placeOrder = {placeOrder}
                          /&gt;
      
                    //OrderTotals.tsx
                      type OrderTotalsProps = {
                        order: OrderItem[]
                        tip: number,
                        placeOrder: ()=>void
                      }
                      
                      export default function OrderTotals({order, tip, placeOrder}: OrderTotalsProps) {   
                        
                        &lt;button 
                          className=&quot;w-full bg-black p-3 uppercase text-white font-bold mt-10 rounded-sm cursor-pointer disabled:opacity-10 disabled:cursor-auto&quot;
                          disabled={totalAmount === 0 }
                          onClick={placeOrder}
                          &gt; 
                          Guardar Orden
                        &lt;/button&gt;
                  </code></pre>
      
            <p>Si probamos se restablece todo, pero el radio queda marcado ¿como conseguimos que no queda marcado? Hemos de
              pasarle al componente TipPercentageForm.tsx como propiedad desde App.tsx la propina tip para poder añadirle al
              input esta comprobación: <code class="language-js">checked={tipOption.value === tip}</code>. <strong>Cuando
                restablecemos la orden el state tip cambia porque tiene las dos dependencias mencionadas antes con lo cual
                deja de cumplirse la condición para que permanezca marcado</strong></p>
      
            <pre><code class="language-js">
                    //App.tsx
                    &lt;TipPercentageForm 
                      tip = {tip}
                      setTip = {setTip}
                      &gt;
      
                    //TipPercentageForm.tsx
                      type TipPercentageFormProps = {
                        tip: number,
                        setTip: Dispatch&lt;SetStateAction&lt;number&gt;&gt;
                      }
                      export default function TipPercentageForm({tip, setTip}:TipPercentageFormProps) {
                        return (
                          &lt;&gt;
                              &lt;h3 className=&quot;font-black text-2xl&quot;&gt;Propina:&lt;/h3&gt;
                      
                              &lt;form&gt;
                                  {tipOptions.map( tipOption =&gt; (
                                      &lt;div
                                          key={tipOption.id}
                                          className=&quot;flex gap-2&quot;
                                      &gt;
                                          &lt;label htmlFor={tipOption.id}&gt;{tipOption.label}&lt;/label&gt;
                                          &lt;input 
                                              id={tipOption.id} 
                                              type=&quot;radio&quot;
                                              name=&quot;tip&quot;
                                              value={tipOption.value}
                                              onChange={ e =&gt; setTip(+e.target.value)}
                                              checked={tipOption.value === tip}
                                          /&gt;
                                      &lt;/div&gt;
                                  ))}  
                              &lt;/form&gt;
                          &lt;/&gt; 
                        )
                      }    
                  </code></pre>
      
            <p>Cuando le damos a "Guardar Orden" (simulando ese envío a BBDD) y se restablece... si la orden está vacía,
              probablemente no tenga sentido cargar nada de esto:</p>
            <img class="my-2.5" src="./src/assets/img/128.png" alt="">
      
            <p>Vemos que en OrderContents.tsx. teníamos un ternario para mostrar "La orden está vacía" o en caso de que bo lo
              estuviera el/los elementos agregados:</p>
            <pre><code class="language-js">
                    //OrderContents.tsx
                      &lt;div className=&quot;space-y-3 mt-10&quot;&gt;
                        //{ order.length === 0 ? 
                          //&lt;p className=&quot;text-center&quot;&gt;La orden está vacía&lt;/p&gt;
                          //: 
                            {order.map( item =&gt; (
                              &lt;div 
                                  className=&quot;flex justify-between items-center border-t border-gray-200 py-5 last-of-type:border-b&quot;
                                  key={item.id}
                              &gt;
                                &lt;div&gt;
                                    &lt;p className=&quot;text-lg&quot;&gt;
                                        {item.name} - {formatCurrency(item.price)}
                                    &lt;/p&gt;
                                    &lt;p className=&quot;font-black&quot;&gt;
                                        Cantidad: {item.quantity} - {formatCurrency(item.price * item.quantity)}
                                    &lt;/p&gt;
                                &lt;/div&gt;
                                &lt;button 
                                    className=&quot;bg-red-600 h-8 w-8 rounded-full text-white font-black cursor-pointer&quot;
                                    onClick={() =&gt; removeItem(item.id)}
                                &gt;X&lt;/button&gt;
                              &lt;/div&gt;
                            )}
                          ///))}
                        //}
                        
                        &lt;/div&gt;
                  </code></pre>
      
            <p>Cambiemos el compo ppal App.tsx para meter aquí la comprobación, mejorando así el rendimiento porque en caso de
              que la orden esté vacía no se renderiza ninguno de los 3 componentes:</p>
            <pre><code class="language-js">
                    &lt;div className=&quot;border border-dashed border-slate-300 p-5 rounded-lg space-y10&quot;&gt;    
                      &lt;h2 className=&quot;font-black text-4xl&quot;&gt;Consumo&lt;/h2&gt;
                      {order.length &gt; 0  ? (
                        &lt;&gt;
                          &lt;OrderContents 
                            order = { order }
                            removeItem = {removeItem}
                          /&gt;            
                          &lt;TipPercentageForm 
                            tip = {tip}
                            setTip = {setTip}
                          /&gt;
                          &lt;OrderTotals 
                            order = {order}
                            tip = {tip}
                            placeOrder = {placeOrder}
                          /&gt;
                        &lt;/&gt;
                      ) : (
                        &lt;p className=&quot;text-center&quot;&gt;La orden está vacía&lt;/p&gt;
                      )}  
                    &lt;/div&gt;
                  </code></pre>
      
            <p>Hemos estado viendo performance (useMemo, useCallback) tips sobre cómo inferir el tipo de dato. Más adelante
              retomaremos este proyecto para ver cómo almacenarlo en una BBDD, y así poder incluirlo en nuestro portfolio.</p>
      
          </div>
      
      
        </div>
        <!-- Fin div colapsable-->
      
      </div>
      <!-- FIN SECCION 9 -->

     
      <!-- SECCION 8 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">

          <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion08').toggle();">
            <h2>Sección 8: PROYECTO - Carrito de Compras - Migrando a TypeScript paso a paso</h2>
            <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
          </div>

          <div id="seccion08" class="hidden">
        

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-91').toggle();">
                  <h3>91. ¿Qué es TypeScript y sus ventajas?</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-91" class="hidden">
                  <p class="font-bold">Typescript ¿qué es? y ventajas</p>
                  <ul class="mb-3.75">
                    <li>Es un lenguaje de programación de código abierto. Sí, es un lenguaje completo, desarrollado y mantenido por Microsoft. También se le conoce como un <strong>superconjunto tipado para JavaScript, lo que significa que cualquier código de JavaScript válido es también código de TypeScript válido</strong>.</li>                    
                    <li>La principal característica de TypeScript es que agrega un sistema de tipos estático a JavaScript, lo que permite detectar errores y proporcionar herramientas de desarrollo más sólidas.</li>
                  </ul>

                  <p class="font-bold">¿Cuáles son las ventajas de implementar TypeScript?</p>
                  <ul class="mb-3.75">
                    <li>El sistema de tipado de tipos de TypeScript permite al programador especificar los tipos de variable, parámetros de función, valores de retorno y más. Esto va a brindar la capacidad de realizar la comprobación de tipos durante la compilación (cuando estás escribiendo tu código) y detectar posibles errores antes de que el código sea ejecutado. --&gt; Entonces su principal ventaja es que no necesitas que el proyecto esté en producción para revisar que todo esté bien. Con TypeScript puedes tener la garantía de que tu código va a funcionar correctamente.</li>
                    <li>Mejora enormemente el autocompletado o Intellisense que vas a obtener con Visual Studio Code (Ver presentación 10.html del curso de Angular).
                    <img class="my-2.5" src="./src/assets/img/91.png" alt="" />
                    </li>
                  </ul>

                  <p class="font-bold">Typescript y Javascript / React</p>

                  <ul class="mb-3.75">
                    <li>Una vez que has escrito el código en TypeScript, este código siempre se compila a JavaScript. Como tal, el navegador no soporta TypeScript, por lo tanto se tiene que compilar siempre hacia código de JavaScript</li>
                    <li>React y Vite incluyen soporte a TypeScript también, lo que ayuda bastante en el desarrollo de proyectos. Una vez que esté listo tu proyecto, lo construyes con build, se va a compilar a código de JavaScript y entonces puede ser publicado en Internet.</li>
                    <li>Hoy en día, TypeScript se ha convertido en un estándar para crear aplicaciones React, Angular y View. Incluso se pide en vacantes de Junior Developer por lo que es el momento adecuado para comenzar a aprender TypeScript.</li>
                  </ul>
                  

                </div>
                <!-- Fin bloque desplegable interior-->

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-92').toggle();">
                  <h3>92. Creando el Proyecto con TypeScript</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-92" class="hidden">
                  <p>Vamos a crear un proyecto nuevo <span class="destacado">npm create vite@latest</span> lo nombramos <strong>guitarla-ts</strong> que sea <strong>react con el nuevo compilador</strong>. Vamos a la carpeta e instalamos las dependencias con <span class="destacado">npm install</span>. Lanzamos el servidor de desarrollo con <strong>npm run dev</strong>.</p>

                  <p>Vemos que básicamente la estructura del proyecto es como la que hemos visto hasta ahora con algunas diferencias:</p>
                  <ul class="mb-3.75">
                    <li>vemos que hay 3 ficheros de configuración de typescript con extensión .json: tsconfig.app.json,tsconfig.json y tsconfig.node.json. Normalmente no tocaremos nada en ellos.</li>
                    <li>Si abrimos la carpeta src veremos que la extensión ya no es .jsx sino tsx.</li>                
                  </ul>

                  <p>Aunque el resto de proyectos los haremos desde cero con typescript, ahora vamos a convertir el proyecto de carrito de compras de guitarras <strong>guitarla-useCart</strong> a typescript. Copiamos entre proyectos de ese a este nuevo <strong>guitarla-ts</strong>:</p>

                  <ul class="mb-3.75">
                    <li>borramos el archivo public/vite.svg</li>
                    <li>copiamos y pegamos la carpeta public/img</li>
                    <li>En la carpeta principal del proyecto, borro src del nuevo y copio src.</li>
                    <li>Cambiamos todos los .jsx --> .tsx y los .js --> .ts. veremos que nos empieza a marcar en rojo en muchos archivos. Si abrimos el componente Header.tsx por ejemplo vemos que los errores los resalta en los parámetros que toma este componente. Ahí es "donde entra typescript" en los parámetros, objetos que vamos creando vamos a ir definiendo el tipo de dato que le estamos pasando a nuestras funciones, componentes... Vamos a ir viéndolo paso a paso.</li>
                    <li>Error del main.tsx --> document.getElementById('root'). Veamos la explicación de esto. Si creamos una variable en ese mismo <span class="file">main.tsx</span>y le asignamos eso <code class="language-js">const div = document.getElementById('root')</code>, vemos en el Intellisense que TypeScript <span class="destacado">INFIERE</span> que el tipo de dato de ese elemento es un HTMLElement o null.<br>
                      
                      <img class="my-2.5" src="./src/assets/img/92.png" alt="" />

                      <p>Es decir, <span class="destacado">TypeScript nos marca eso como error porque estamos utilizando un parámetro que puede ser null. Para eliminar esa posibilidad, fijamos el tipo de dato de esta manera:</span> <code class="language-js">const div = document.getElementById('root') as HTMLElement</code> y entonces podríamos quitar ese error como se hacía hasta no hace mucho aunque no se considera buena práctica porque con <code class="language-js">as HTMLElement</code> le estamos diciendo a typeScript "confia en mí, este va a ser el tipo de dato":</p>

                      <pre class="verde" data-line="0"><code class="language-js">
                        ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
                          &lt;React.StrictMode&gt;
                            &lt;App /&gt;
                          &lt;/React.StrictMode&gt;&comma;
                        )
                      </code></pre>                      
                        <p><span class="verde">Otra manera es utilizar el <strong>operador de Assertionnot null = non null assertion operator "!"</strong> que es una manera de asegurarle a TypeScript que ese elemento no va a ser null:</span></p>
                        <pre class="verde" data-line="0"><code class="language-js">
                          ReactDOM.createRoot(document.getElementById('root')!).render(
                            &lt;React.StrictMode&gt;
                              &lt;App /&gt;
                            &lt;/React.StrictMode&gt;&comma;
                          )
                        </code></pre>
                    </li>                 
                  </ul>

                  <p>Vamos a ir viendo como solucionar el resto de errores que nos aparecen en los ficheros.</p>
                </div>
                <!-- Fin bloque desplegable interior-->
                

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-93').toggle();">
                  <h3>93. Introducción a TypeScript - Primitive Types</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-93" class="hidden">
                  <p>Vamos a comenzar a solucionar los errores que encuentra Typescript en el código. Vemos que en App.tsx, Guitar.tsx, Header.tsx, useCard.ts se van pintando en rojo algunos de estos archivos. No es que el código esté mal escrito (si arrancamos el servidor de desarrollo y probamos vemos que todo funciona bien) sino que más bien tneemos que darle más información a TypeScript. esa información normalmente se la pasamos con algo llamado <span class="destacado">Primitive Type</span>.</p>

                  <ul class="mb-3.75">
                    <li>Los Primitive Types son los tipos de datos que soporta TypeScript de forma nativa.</li>
                    <li>Estos son number, string, boolean, null y undefined. Cuando creamos un objeto, hemos de especificar qué tipo de dato (primitive type) es el que tiene cada propiedad de ese objeto. De igual manera si creamos una variable o si le pasamos parámetros a una función.</li>
                    <li>En el caso de arrays hay una sintaxis especial para crearlos</li>
                  </ul>

                  <p>Abrimos nuestro <span class="file">App.tsx</span> y tras importar state <code class="language-js">import { useCart } from './hooks/useCart'</code>, creamos un nuevo state para verificar si un usuario está autenticado, así es como lo hemos hecho hasta ahora poniendole como valor inicial que el usuario no está logado: <code class="language-js">const [auth, setAuth] = useState(false)</code>. Si nos ponemos encima de auth el intellisense nos muestra que TypeScript infiere que el tipo de auth va a ser boolean, pero si le cambiamos el valor inicial a '20' y volvemos a ponernos encima de auth el IS nos muestra que TS infiere que el valor es number. Si inmediatamente hago un <code class="language-js">setAuth(true)</code> nos lo marca como error y el IS nos indica algo como "no le puedes asignar un booleano porque tú dijiste que era un número". <span class="destacado">En este tipo de acciones es donde TypeScript nos va a proteger, el evitarnos que estemos asignando diferente tipo de dato nos va a permitir escribir un mejor código.</span></p>

                  <img class="my-2.5" src="./src/assets/img/93.png" alt="" />
                  

                  <p>Explica que hay algunos casos de uso para especificar el tipo entre tags <span class="destacado">&lt;&gt;</span> por ejemplo: <code class="language-js">const [auth, setAuth] = useState&lt;number&gt;(20)</code> Pero que no lo hacemos así porque es dar información redundante.</p>

                  <p>Si abrimos nuestro <span class="file">data&gt;db.ts</span> y nos ponemos encima de db vemos como TypeScript infiere el tipo de dato para cada elemento id, name,... Poría decirse que va a escanear nuestro código y va a ser nuestro mejor asistente. De hecho si al segundo elemento de nuestro array le dijeramos que el id es "2" y volviéramos a consultar el IS, veríamos lo que aparece a la derecha de la siguiente captura, que <strong>TS nos especifica que puede ser un number o un string</strong>:</p>
                  <img class="my-2.5" src="./src/assets/img/93-2.png" alt="" />

                  <p>Sin embargo estas guitarras y lo que tenemos en useCart.ts en nuestro carrito es básicamente lo mismo, vamos agregando nosotros las guitarras salvo con algunas excepciones y <span class="destacado">cuando trabajas con objetos, la recomendación es no dejar que TypeScript infiera ese tipo de dato sino que nosotros crearemos nuestros propios grupos de tipo de dato que se les conoce como Types e Interfaces.</span></p>

                </div>
                <!-- Fin bloque desplegable interior-->
                

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-94').toggle();">
                  <h3>94. Introducción a TypeScript - Types e Interfaces</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-94" class="hidden">
                  <p>Si nos colocamos en la variable db vemos un objeto que tiene diferentes propiedades. Cuando tenemos una estructura de este tipo lo mejor es crear lo que se conoce como un Type o Interface. Básicamente es lo mismo, pero veamos un poco más de información de este tema.</p>

                  <ul class="mb-3.75">
                    <li>Types e Interfaces son dos de las características que más vamos a utilizar en TypeScript.</li>                  
                    <li>Ambas pueden ser utilizadas incluso de forma intercambiable, hay muy pocas diferencias entre ambos y en la comunidad vas a encontrar ejemplos con ambos (La verdad es que la comunidad está dividida, unos dicen utilizar interfaces, otros types...) Cuál vas a utilizar en un proyecto? Bueno, el que ya estén utilizando.</li>
                    <li><strong>Es una forma de crear una estructura y definir qué tipo de dato tiene cada propiedad de un objeto o agrupar propiedades de un objeto</strong>.</li>                
                  </ul>

                  <p>Veamos algunos ejemplos. Creemos nuestro primer type para nuestras guitarras. <span class="file">db.ts</span>: la convención de nombrado es con la primera mayúscula.</p>

                  <pre data-line="0-6,7"><code class="language-js">
                    type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  export const db : Guitar[] = [
                      {
                          id: 1,
                          name: 'Lukather',
                          image: 'guitarra_01',
                          description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                          price: 299,
                      },
                  </code></pre>

                  <p>Definimos nuestra estructura Types, la aplicamos a nuestra información y si el tipo de dato no es el correcto nos va a marcar el error. si cambiáramos el tipo de id a string veríamos que nos saca un error y ahí es donde TS nos va a yudar mucho, no vamos a necesitar compilar el proyecto para ver si tiene errores, desde le momento en que estamos escribiendo TS ya nos va marcando si tenemos algún error.</p>

                  <p>La sintaxis para definir nuestra interface es similar usando la palabra interface y sin el "="</p>

                  <pre data-line="0,7"><code class="language-js">
                    interface Guitar {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  export const db : Guitar[] = [
                      {
                          id: 1,
                          name: 'Lukather',
                          image: 'guitarra_01',
                          description: 'Morbi ornare augue nisl, vel elementum dui mollis vel. Curabitur non ex id eros fermentum hendrerit.',
                          price: 299,
                      },
                  </code></pre>

                  <p>La preferencia es types porque es mas corto de escribir pero ambos valen igual. <span class="destacado">Como hemos visto, a nuestra constante db le estamos añadiendo el type Guitar: <code class="language-js">export const db : Guitar[] = [</code> y de hecho si abrimos nuestro <span class="file">useCart.ts</span> vemos que ahí estamos seteando ese db <code class="language-js">const [data] = useState(db)</code>. Si nos ponemos encima de data el IS nos dice que tiene el type Guitar[] por tanto se propaga en nuestro código ese tipo de dato.</span></p>

                  <img class="my-2.5" src="./src/assets/img/93-3.png" alt="" />

                  <p>Si nos ponemos encima de cart el IS nos dice tipo de dato any; en otros componentes como <span class="file">Guitar.jsx</span> vemos que si nos ponemos encima de addToCart el IS nos dice tipo de dato any implícito. <span class="destacado">any en TypeScript es veneno.</span> Veamos cómo solucionarlo.</p>

                  <img class="my-2.5" src="./src/assets/img/93-4.png" alt="" />

                </div>
                <!-- Fin bloque desplegable interior-->
                

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-95').toggle();">
                  <h3>95. Asignar Types a tus Props - Inline Type</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-95" class="hidden">
                  <p>Si nos llenamos de Any es como si no estuviéramos utilizando TS. Hemos de facilitar más información a TS. Vamos a <span class="file">Guitar.tsx</span> donde tenemos <code class="language-js">export default function Guitar({guitar, addToCart}) {</code> ese guitar que es un objeto y el addToCart que es una función. ¿Cómo convertimos esos props hacia TS? hay dos opciones:</p>

                  <ul class="mb-3.75">
                    <li><strong>inline type</strong></li>
                    <li><strong>separate type</strong></li>
                  </ul>

                  <p class="font-bold">inline type</p> 
                  
                  <p>en nuestro <span class="file">Guitar.tsx</span> <span class="destacado">añadimos el type</span></p> 
                  <pre><code class="language-js">
                    type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  </code></pre>
                  <p><span class="destacado">y a continuación especificamos el tipado a esas dos props que toma como parámetro la función de nuestro componente (objeto "guitarra" y funcion "addToCart"). Para especificar el tipo de dato usamos la sintaxis con ":"</span></p>

                  <pre><code class="language-js">                    
                  export default function Guitar({guitar, addToCart} : {guitar : Guitar, addToCart: (item: Guitar) => void}) {
                  </code></pre>

                  <p><span class="destacado">El primer parámetro es un objeto de tipo Guitar</span> y en cuanto lo tipamos vemos que del parámetro ya nos desaparece el aviso/error (antes el IS nos lo marcaba como any y ya nos aparece que es de tipo Guitar); </p>
                      
                  <img class="my-2.5" src="./src/assets/img/95-1.png" alt="" />

                  <p>Fijémonos que todas las propiedades que definimos en nuestro type </p>
                  <pre><code class="language-js">
                    type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }                      
                  </code></pre>

                  <p>si en el return() de nuestro componente Guitarra (la parte de la vista) sustituyéramos por ejemplo <code class="language-js">{name}</code> por <code class="language-js">{guitar.}</code> vemos como en el IS solo me aparecen disponibles esas opciones (los tipos de datos que yo definí en ese objeto es lo que puedo imprimir ahí), no tenemos que enviarlo a la consola, ya lo tenemos disponible en VSC y eso va hacer que escribamos código más rápidamente:</p>

                  <img class="my-2.5" src="./src/assets/img/95-2.png" alt="" />
                  
                  <p>Para definir el tipo del segundo parámetro (función addToCart que toma una guitarra), nos vamos al fichero <span class="file">App.tsx</span> e inspeccionamos el aviso del IS al ponernos encima del prop addToCart que aún no hemos tipado --&gt; <strong>item(any) =&gt; void</strong>.</p>
                    
                  <img class="my-2.5" src="./src/assets/img/95-3.png" alt="" />

                  <p>Copiamos ese código. "void" es algo muy común en java, se usa cuando una función no devuelve nada. El any vamos a quitarlo: cuando yo agrego un elemento con el onClick del botón, le paso una guitarra completa:</p> 

                  <script type="text/plain" class="language-js">
                    <button 
                      type="button"
                      className="btn btn-dark w-100"
                      onClick={() => addToCart(guitar)}
                  >Agregar al Carrito</button>
                  </script>

                  <p>así que cambiamos ese any por Guitar, le decimos así que el item que maneja esa función que agrega tiene que ser una guitarra de tipo Guitarra. <span class="destacado">Y en definitiva estamos tipando ese parámetro como una función que toma un objeto Guitarra y no retorna nada.</span></p>
                      
                  <img class="my-2.5" src="./src/assets/img/95-1.png" alt="" />

                  <p>Ya desaparecen los errores/avisos. Estamos tipando fuertemente. Si por ejemplo me voy a la <span class="file">App.tsx</span> y le quitamos la propiedad addToCart de aquí:</p>

                  <script type="text/plain" class="language-js">
                    <div className="row mt-5">
                      {data.map((guitar) => (
                          <Guitar 
                            key={guitar.id}
                            guitar={guitar}
                            addToCart={addToCart}
                          />
                      ))}              
                  </div>
                  </script>

                  <p>vemos que nos marca un error. Por tanto nos va a indicar si le falta algo, si escribimos algo mal, si le pasamos un valor de forma incorrecta</p>
                    
                  <img class="my-2.5" src="./src/assets/img/95-4.png" alt="" />

                  <p>Vamos a ver la otra sintasis de <strong>separate type</strong> que él indica que le gusta más.</p>

                </div>
                <!-- Fin bloque desplegable interior-->
                

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-96').toggle();">
                  <h3>96. Asignar Types a tus Props - Type Separado</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-96" class="hidden">
                  <p class="font-bold">separate type</p> 
                  <p>Veamos esta otra sintaxis que es menos confusa: podríamos hacer salto de línea a lo que tenemos ahora mismo para que quedara un poco más ordenado:</p>

                  <pre><code class="language-js">
                    export default function Guitar({guitar, addToCart} : {
                      guitar : Guitar, 
                      addToCart: (item: Guitar) => void
                  }) {
                  </code></pre>

                  <p>Sin embargo es mejor tener un type (o una interface) y tenerlo separado para minimizar la posibilidad de cometer errores:</p>

                  <pre><code class="language-js">
                    type GuitarProps = {
                      guitar : Guitar, 
                      addToCart: (item: Guitar) => void
                  }                
                  export default function Guitar({guitar, addToCart} : GuitarProps) {
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
                

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-97').toggle();">
                  <h3>97. Creando un Archivo de Types ¿Donde y como hacerlo?</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-97" class="hidden">
                  <p>Vamos a crear un archivo que centralice los types que se van a compartir más de una vez. Si nos fijamos ahora mismo el type Guitar que hemos creado lo tenemos tanto en <span class="file">db.ts</span> como en <span class="file">Guitar.tsx</span>, si tuviéramos que modificarlo porque el proyecto por ejemplo crece, el mantenimiento se hace complicado. <span class="destacado">Cuando tenemos un type que se comparte en diferentes componentes o Hooks lo mejor es ponerlo en su propio archivo</span>, hay dos maneras de hacerlo.</p>

                  <p>Si en en src creamos un archivo nuevo <strong>types.d.ts</strong> y metemos ahí nuestro types, creado así con ese nombre no necesitaríamos importarlo. Sin embargo ¡¡el equipo de desarrollo de TS no recomienda hacerlo de esta forma!!!</p>

                  <p>Creamos carpeta y archivo <strong>types>types.ts</strong> (también se podría llamar index.ts). En el solo metemos el type Guitar al cual le ponemos delante la palabra export:</p>

                  <pre><code class="language-js">
                    export type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  </code></pre>

                  <p>importamos ese type en los ficheros donde se va a utilizar: <span class="file">db.ts</span> y <span class="file">Guitar.tsx</span> </p>
                  
                  <ul class="mb-3.75">
                    <li>si hemos nombrado el fichero como <strong>index.ts</strong> lo importaremos así: <code class="language-js">import type {Guitar} from '../types'</code></li>
                    <li>si hemos nombrado el fichero como <strong>types.ts</strong> lo importaremos así: <code class="language-js">import type {Guitar} from '../types/types'</code></li>                  
                  </ul>
                  
                  <p>Como vemos no metemos en ese archivo exclusivo de types el otro type GuitarProps, porque no se trata de un type que vayamos a utilizar en diferentes componentes o diferentes Hooks; en este caso es un type exclusivo del componente <span class="file">Guitar.tsx</span>. <span class="destacado">Habitualmente así es como vamos a definir nuestros types, en el componente donde se requieren y en el caso de que se vaya a compartir en mas sitios (otros componentes y/o Hooks) entonces se mueve al archivo específico de types.</span></p>

                  <p>Como vemos, ya están completamente tipados nuestro <span class="file">db.ts</span> y nuestro componente de guitarra<span class="file">Guitar.tsx</span>. Migremos a continuación nuestro Hook personalizado para solucionar esos Any que aparecen en nuestro cart.</p>
                </div>
                <!-- Fin bloque desplegable interior-->


                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-98').toggle();">
                  <h3>98. Añadiendo un Type para los elementos del Carrito / 99. Heredar y extender un Type</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-98" class="hidden">
                  <p>Si miramos nuestro custom Hook <span class="file">useCart.ts</span> vemos que tenemos dos states: data tiene el type Guitar pero cart tiene un tipo Any.</p>
                  <pre><code class="language-js">
                    const [data] = useState(db)
                    const [cart, setCart] = useState(initialCart)
                  </code></pre>
                  <p><span class="destacado">Algo muy común en TS es que cuando obtenemos datos externos, sea de localStorage o de una consulta con FetchAPI, a TS se le hace muy complicado inferir el tipo de dato.</span> ¿Como hacemos para indicar que este const initialCart va a ser de tipo Guitar (o un tipo de elemento en un carrito)?</p>
                  <pre><code class="language-js">
                    const initialCart = () => {
                      const localStorageCart = localStorage.getItem('cart')
                      return localStorageCart ? JSON.parse(localStorageCart) : []
                  }
                  </code></pre>

                  <p>Importamos nuestro type <code class="language-js">import type { Guitar } from '../types/types'</code> Le especificamos a ese initialCart que el tipo de dato va a ser Guitar[] (pero array, que es un carrito):</p>

                  <pre data-line="0"><code class="language-js">
                    const initialCart = () : Guitar[] => {
                      const localStorageCart = localStorage.getItem('cart')
                      return localStorageCart ? JSON.parse(localStorageCart) : []
                  }
                  </code></pre>

                  <p>sin embargo inmediatamente vemos en nuestro código que TS se queja: <strong>"oye, estas diciendo que esto es un tipo Guitar, pero hasta en 3 funciones de tu Hook se intenta utilizar una propiedad "quantity" que no existe en ese tipo Guitar"</strong>. Cuando intentamos agregar una guitarra al carrito, sí es un objeto Guitar pero tiene una propiedad adicional llamada "quantity" que se requiere para estar en el carrito</p>
                  <img class="my-2.5" src="./src/assets/img/98.png" alt="" />
                  
                  <p>Podríamos resolverlo, añadiendo un nuevo type en nuestro archivo <span class="red">types.ts</span>:</p>
                  <pre><code class="language-js">
                    export type CartItem = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                      quantity: number
                    }
                  </code></pre>
                  <p>Importamos nuestro type <code class="language-js">import type { CartItem } from '../types/types'</code> Le especificamos a ese initialCart que el tipo de dato va a ser CartItem[] (pero array, que es un carrito):</p>
                  
                  <pre data-line="0"><code class="language-js">
                    const initialCart = () : CartItem[] => {
                      const localStorageCart = localStorage.getItem('cart')
                      return localStorageCart ? JSON.parse(localStorageCart) : []
                    }
                  </code></pre>
                  
                  <p>así ya nos desaparecen los errores con el quantity que teníamos en nuestras funciones (aunque aún quedan algunos errores en parámetros que los veremos). </p>
                  <img class="my-2.5" src="./src/assets/img/98-2.png" alt="" />

                  <p>Este código funciona pero se puede mejorar porque los atributos id, name, image, description, price son exactamente iguales en los dos types Guitar y CartItem.</p>
                  
                  <pre data-line="1-5,8-12"><code class="language-js">
                    export type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  export type CartItem = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                      quantity: number
                  }
                  </code></pre>

                  <p>TypeScript nos permite heredar como si fuera de una clase a otra y podemos hacerlo heredando todos esos atributos dentro de cartItem</p>

                  <p class="naranja">Heredar y extender un Type</p>

                  <p>Ya hemos definido nuestro segundo tipo de dato. Teníamos <strong>Guitar</strong> pero como nuestro carrito de compras tiene una propiedad adicional "quantity" hemos creado un type llamado <strong>CartItem</strong>. Ambos comparten muchos atributos por lo que apliquemos herencia para simplicar el código, también para que si cambia alguno de ellos el mantenimiento sea más sencillo. Como es un poco diferente en types e interfaces veos ambos.</p>

                  <p class="font-bold">herencia en types</p>

                  <p><span class="destacado">Borramos los atributos duplicados del type que hereda y en su declaración tras el "=" añadimos el nombre del type del que queremos que herede seguido de "&"</span></p>

                  <pre data-line="7"><code class="language-js">
                    export type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  export type CartItem = Guitar & {
                      quantity: number
                  }
                  </code></pre>

                  <p><strong>Podríamos perfectamente generar una interface y heredar de nuestro type:</strong> <span class="destacado">el "=" se cambia por la palabra "extends", de manera similar a lenguages como Java o php y se elimina el "&"</span></p>
                  <pre data-line="7"><code class="language-js">
                    export type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  export interface CartItem extends Guitar {
                      quantity: number
                  }
                  </code></pre>

                  <p>Existe otra forma de hacerlo, con los <span class="destacado">utility types</span>, solo se puede hacer con la sintaxis de type</p>
                
                </div>
                <!-- Fin bloque desplegable interior-->


                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-100').toggle();">
                  <h3>100. Utility Types en TypeScript</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-100" class="hidden">
                  <p>Acabamos de ver como se aplica herencia utilizando types e interfaces pero eso hereda todo el tipo de dato y sus atributos completos. Si bien podríamos hacer algo como cambiarle el number por string al atributo id del type original (no lo tengo muy claro que haga lo que dice por lo que veo en el IS)</p>

                  <pre data-line="1,9"><code class="language-js">
                    export type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                  }
                  export type CartItem = Guitar & {
                      quantity: number
                      id: string
                  }
                  </code></pre>

                  <p>Otras veces lo que vamos a querer es, manteniendo los mismos tipos de datos simplemente tener algunos atributos de un type y/o omitir otros. Para eso es muy útil lo que se conoce como <span class="destacado"><a class="text-[#ffffff]" href="https://www.typescriptlang.org/docs/handbook/utility-types.html" target="_blank">Utility Types</a></span>. Hay unos cuantos, en cada nueva versión se agregan más, va a hacer que nuestro código sea más corto y son muy útiles cuando comenzamos a tener varios  types interdependientes que comparten atributos. Pone como ejemplo estos dos para explicar sintaxis y como se utilizan <strong>Pick&lt;Type&comma; Keys&gt;</strong> y <strong>Omit&lt;Type&comma; Keys&gt;</strong></p>

                  <p>En el siguiente ejemplo el Utility Type Pick selecciona del type Guitar los atributos id, name y price y los coloca en este nuevo type CartItem:</p>
                  <script type="text/plain" class="language-js">
                    export type CartItem = Pick<Guitar, 'id' | 'name' | 'price'>
                  </script>

                  <p>aquí le agregaríamos el atributo extra "quantity" que no existe en ese type Guitar:</p>
                  <script type="text/plain" class="language-js">
                    export type CartItem = Pick<Guitar, 'id' | 'name' | 'price'> & {
                      quantity: number
                    }
                  </script>

                  <p>Omit es para lo contrario, excluir los atributos que se especifiquen:</p>
                  <script type="text/plain" class="language-js">
                    export type CartItem = Omit<Guitar, 'id' | 'name' | 'price'> & {
                      quantity: number
                  }
                  </script>

                  <p>Veamos a continuación como especificar type a los parámetros que aún nos marca en nuestro código como aviso/error</p>
                </div>
                <!-- Fin bloque desplegable interior-->
                          

                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-101').toggle();">
                  <h3>101. Agregando el Nuevo Type a nuestro código / 102. Creando un Type para el ID de la guitarra</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion8-101" class="hidden">
                  <p>Vamos a nuestro Hook <span class="file">useCart.ts</span>para "terminar de migrar a TS" nuestras funciones:</p>
                  
                  <p class="font-bold">function addToCart(item){}</p>
                  <p>Importamos nuestro type Guitar y le especificamos al parámetro de la fcn que es de tipo Guitar</p>
                  <pre data-line="0"><code class="language-js">
                    function addToCart(item : Guitar) {
                      const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                      if(itemExists >= 0 ) { // existe en el carrito
                          if(cart[itemExists].quantity >= MAX_ITEMS) return
                          const updatedCart = [...cart]
                          updatedCart[itemExists].quantity++
                          setCart(updatedCart)
                      } else {
                          item.quantity = 1
                          setCart([...cart, item])
                      }
                  }
                  </code></pre>
                  <p>Vemos que nos marca estos errores ¿por qué?</p>
                  <img class="my-2.5" src="./src/assets/img/101-1.png" alt="" />
                  
                  <p>Si miramos nuestro fichero de <span class="file">types.ts</span> vemos que el type Guitar no tiene ninguna propiedad quantity, sin embargo sí habíamos definido un nuevo type CartItem que heredaba del type Guitar al que le añadíamos esa propiedad:</p>          
                  <pre><code class="language-js">
                    export type Guitar = {
                      id: number
                      name: string
                      image: string
                      description: string
                      price: number
                    }
                    export type CartItem = Guitar & {
                      quantity: number
                    }
                  </code></pre>
                  
                  <p><span class="destacado">Vamos a castear: tomar un tipo de dato y convertirlo a otro:</span> <strong>creamos una nueva variable newItem de tipo CartItem que toma una copia de lo que le estamos pasando a esta función item (usamos el operador spread) y además tiene la nueva propiedad quantity</strong>:</p>
                  
                  <pre class="verde" data-line="8,9"><code class="language-js">
                    function addToCart(item : Guitar) {
                      const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                      if(itemExists >= 0 ) { // existe en el carrito
                        if(cart[itemExists].quantity >= MAX_ITEMS) return
                        const updatedCart = [...cart]
                        updatedCart[itemExists].quantity++
                        setCart(updatedCart)
                      } else {
                        const newItem : CartItem = {...item, quantity : 1}
                        setCart([...cart, newItem])
                      }
                    }
                  </code></pre>        
                  
                  <p class="naranja">Creando un Type para el ID de la guitarra</p>
        
                  <p>Si nos fijamos en nuestro archivo <span class="file">types.ts</span> vemos que el id de las guitarras es de tipo number con lo que podríamos solucionar fácilmente nuestro "problema" en las tres funciones que nos quedan por migrar de nuestro custom Hook <span class="file">useCart.ts</span> tipando como <strong>number</strong> los tres parámetros id de las funciones:</p>
                  <pre><code class="language-js">
                    function removeFromCart(id) { --> function removeFromCart(id : number) {
                      function decreaseQuantity(id) { --> function decreaseQuantity(id : number) {
                        function increaseQuantity(id) { --> function increaseQuantity(id : number) {
                        </code></pre>

                  <p>pero <strong>¿qué pasaría si a futuro migramos y digamos que ya dejamos de utilizar MySQL o PostgreSQL, que tienen los IDS como tipo number y nos vamos hacia MongoDB que utiliza strings?</strong> pues que tendríamos que tener cuidado de cambiar el tipo string en nuestro fichero de types y también en todos los lugares en donde en nuestro custom Hook usáramos esos ids. <strong>Normalmente queremos que los posibles cambios repercutan en los menores lugares posibles, buscamos un código sencillo con buen mantenimiento.</strong> Por ello podemos:</p>
                  
                  <ul class="mb-3.75">
                    <li>Crear un nuevo type empleando el <span class="destacado">Utility Type Pick</span>, de manera que si eso cambia a futuro solo tenemos que tocar el type Guitar: <code class="language-js">export type GuitarID = Pick&lt;Guitar &comma; &apos;id&apos;&gt;</code></li>
                    <li>Crear un nuevo type empleando algo que se conoce como <span class="destacado">Lookup:</span> <code class="language-js">export type GuitarID = Guitar['id']</code>. En vez de tenerlo en este archivo de types lo podemos utilizar tal cual en nuestro Hook:
                    <pre><code class="language-js">
                    function removeFromCart(id) { --> function removeFromCart(id : Guitar['id']) {
                    function decreaseQuantity(id) { --> function decreaseQuantity(id : Guitar['id']) {
                    function increaseQuantity(id) { --> function increaseQuantity(id : Guitar['id']) {
                    </code></pre></li>
                  </ul>
                  
                  <p>Este evento no es necesario porqeu se setea en automático así que lo quitamos (la e):</p>
                  
                  <img class="my-2.5" src="./src/assets/img/101-2.png" alt="" />

                  <p><strong>Los que vemos que TS infiere bien, como por ejemplo los states derivados isEmpty (retorna un boolean) y carTotal (devuelve un number), no hay que ser redundantes y no hacemos nada más.</strong> Si TS no lo puede inferir como era el caso con LocalStorage nosotros intervenimos, y de esa forma tenemos completamente tipado nuestro Hook.</p>

                  <p>En el siguiente vídeo vamos a typar los props del Header, algunas son funciones y tienen una sintaxis particular.</p>              
                </div>
              <!-- Fin bloque desplegable interior-->
              

              <!-- Bloque desplegable interior-->
              <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion8-103').toggle();">
                <h3>103. Typando los Props del Header y Building del proyecto</h3>
                <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
              </div>
                <div id="seccion8-103" class="hidden">
                  <p>Añadamos TS a nuestro <span class="file">Header.tsx</span> que tiene entre otras cosas nuestro cart y los states derivados. Vamos a crear el type no inline (que es mas complicado en cuanto a sintaxis) sino separado y además solo en este .tsx (no lo metemos en el fichero de definición de types) porque es exclusivo para Header:</p>

                  <pre data-line="0,2,3,7"><code class="language-js">
                    import type { CartItem, Guitar } from '../types/types'

                    type HeaderProps = {                      
                    }
                    export default function Header({
                      cart, removeFromCart, decreaseQuantity, 
                      increaseQuantity, clearCart, isEmpty, cartTotal
                  } : HeaderProps) {
                  </code></pre>

                  <p>Para el siguiente prop <strong>removeFromCart</strong>, que es una función miramos en App.tsx, en la parte de la vista donde el tag del componente Header que es donde se envía ese prop; el IS nos dice que es una función que envía un id de tipo number y no devuelve nada. Pues eso mismo es lo que vamos a especificar en la definición de nuestro type HeaderProps. Y hacemos lo mismo con las siguientes props funciones <strong>decreaseQuantity</strong> e <strong>increaseQuantity</strong></p>

                  <pre><code class="language-js">
                    type HeaderProps = {
                        cart: CartItem[] //el carrito cart es de tipo CartItem como arreglo
                        removeFromCart: (id: Guitar['id']) => void
                        decreaseQuantity: (id: Guitar['id']) => void
                        increaseQuantity: (id: Guitar['id']) => void
                        clearCart: () => void
                        isEmpty: boolean
                        cartTotal: number
                    }

                    export default function Header({
                      cart, removeFromCart, decreaseQuantity, 
                      increaseQuantity, clearCart, isEmpty, cartTotal
                  } : HeaderProps) {
                  </code></pre>

                  <p>Comenta que una vez que hemos agregado <code class="language-js">type HeaderProps = {}</code> que se le conoce como el <span class="destacado">function signature o firma</span> estamos mucho más protegidos por parte de TS para que no pasemos cosas indebidas a nuestros componentes etc. Vemos ese tipo de posibles errores desde el momento en que estamos escribiendo el código, sin necesidad de esperar a compilar.</p>

                  <p>Compilamos nuestro proyecto. Vemos en el <span class="file">package.json</span> en el bloque de scripts>build que se llama a "tsc && vite build". <strong>tsc es el TypeScript Compiler</strong>. <span class="destacado">npm run build</span> construye nuestro proyecto haciendo todas las transformaciones de typescript hacia javascript. <span class="destacado">Ya con el build listo podemos subirlo a Netlify o Vercel o Github</span>.</p>

                </div>
                <!-- Fin bloque desplegable interior-->
                

              
          </div>
          <!-- Fin div colapsable-->

      </div>
      <!-- FIN SECCION 8 -->  
       
   	
      <!-- SECCION 7 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
        
        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion07').toggle();">
          <h2>Sección 7: PROYECTO - Carrito de Compras - Crear tus propios Hooks</h2>
          <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
        </div>

        <div id="seccion07" class="hidden">          

          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion85-90').toggle();">
            <h3>85. Ventajas y Como crear tus propios Hooks / 86. Instalando dependencias / 87. Creando el Hook de useCart</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion85-90" class="hidden">
            <p class="naranja">Ventajas y Como crear tus propios Hooks</p>
            
            <p class="font-bold">Crear nuestro propios Hooks</p>
            <ul class="mb-3.75">
              <li><strong>Existe una gran ventaja de crear tus propios hooks, y esta es la de incorporar state y otros hooks de React en tu propio código para poderlo reutilizar en otros proyectos:</strong> esta es una gran ventaja porque actualmente nuestro código reside en nuestros componentes y nuestros componentes tienen cierta presentación, lo que lo hace que nuestro código no sea muy reutilizable para otros proyectos. Sin embargo, con un hook personalizado podemos copiar y adaptar todo lo que requerimos.</li>
              <li><strong>Otra gran ventaja es la de organizar tu código:</strong> de esta forma el hook se va a encargar de toda la lógica, mientras que tu componente solamente se encarga de mostrar la información, la vista, solamente se encarga de mostrar la presentación y el código HTML.</li>
              <li><strong>Nuestro código personalizado tendrá todas las ventajasde React, como son tener su propio State, podremos agregar Effects, integrar otros hooks de React y el performance que esto incluye.</strong></li>
              <li><strong>Va a ser reutilizable con otros proyectos</strong></li>
              <li>va a ser fácil de escribir testing de escribir las pruebas para tu código.</li>
            </ul>

            <p class="font-bold">¿Cómo vamos a crear nuestros propios hooks?</p>
            <ul class="mb-3.75">
              <li>Los hooks son funciones de JavaScript, pero tienen algunas reglas como vimos anteriormente.</li>
              <li><strong>Nuestros hooks deben seguir la convención de nombrado que utiliza React, que es <span class="destacado">use</span> seguido del nombre de nuestro hook, como vimos anteriormente con los hooks <strong>Usestate, useEffect, etcétera</strong></strong> de esta forma React escanea tu código en búsqueda de posibles problemas con las reglas de los hooks y se segura de que nuestro código personalizado cumpla los estándares de React.</li>
              <li><span class="destacado">Importante!</span> un hook normalmente solo debe de tener lógica y no presentación, porque para la parte de presentación están los componentes.</li>
            </ul>

            <p class="naranja">Instalando dependencias y Creando el Hook de useCart</p>
            <p>Vamos a convertir el proyecto que llevamos hasta ahora de guitarla para que use un <strong>custom hook</strong>. Descargamos la carpeta (guitarla-useCart), la agregamos al area de trabajo en VSC, boton derecho "abrir en terminal integrado" e instalamaos dependencias con <span class="destacado">npm install</span> que son en base al sistema operativo.</p>

            <p>Vamos a estar moviendo todo el código de antes del return() del App.jsx que maneja bastante lógica a un custom Hoook, para dejar limpio nuestro componente y hacerlo más reutilizable</p>

            <p><span class="destacado">Creamos carpeta hooks donde se colocan los custom hooks</span>. Dentro creamos nuestro archivo hook personalizado que llamamos <strong>useCart.ts</strong> (recordar que no es .jsx porque eso tiene parte de vista es el template). Los hooks son funciones de js con lo cual podemos definirlo como función "normal" o función arrow function pero <span class="destacado">siempre el nombre tiene que tener la palabra use y así React "escanea" el código para posibles violaciones de las reglas de los hooks</span>:</p>
            <span class="file">useCart.ts</span><br>
            <pre><code class="language-js">
              function useCart(){
                
              }
            </code></pre>
            <pre><code class="language-js">
              const useCart = () => {

              }
            </code></pre>

            <p>aquí es donde vamos a tener toda la lógica, todo lo que está antes de los return() del App.js y Header.jsx. Todo eso vamos a exportarlo para poder importarlo en otros componentes o donde sea que vamos a utilizar nuestro custom hook, pudiendo exportarlo de todas las maneras que se hacen exports en js:</p>
            <pre><code class="language-js">
              const useCart = () => {

              }
              export default useCart
            </code></pre>
            <pre><code class="language-js">
              const useCart = () => {
                
              }
              export {
                useCart//de esta forma cuando lo importemos tenemos que usar ese mismo nombre
              }
            </code></pre>
            <pre><code class="language-js">
              export const useCart = () => {
                console.log('Desde useCart')  
              }                 
            </code></pre>

            <p>Para usar el custom Hook en nuestra App.jsx hemos de importarlo <code class="language-js">import { useCart } from './hooks/useCart'</code>. Si quisiéramos llamarlo dentro de nuestro componente principal de aplicación App.jsx hay que llamar a la función de igual manera que hacíamos con los otros hooks: <code class="language-js">useCart()</code></p>
          </div>
          <!-- Fin bloque desplegable interior-->

          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion88').toggle();">
            <h3>88. Definir Valores y extraerlos en el Hook</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion88" class="hidden">
            <p>¿Como hacemos para que el comportamiento de nuestro custom hook sea mas similar digamos al useState en <code class="language-js">const[data] = useState(db)</code> devolviendo algo. Supongamos que creamos una variable <code class="language-js">const auth = true</code> ¿como hacemos para que esté disponible en nuestro App.jsx? <strong>tenemos que agregar un return a continuación, que puede ser un Array pero se recomienda que sea un objeto.</strong> <span class="destacado">La ventaja de que sea un objeto es, que el mismo nombre con el que nombremos nuestras variables, funciones o state va a ser el mismo nombre para usarlo en nuestro componente.</span> Si usáramos un arreglo los retorna por posición, pero como normalmente vamos a tener en nuestro hook personalizado diferentes funciones/variables/states personalizados, lo ideal es que podamos acceder a ellos por medio de su nombre específico.</p>
            
            <span class="file">useCart.ts</span>
            <pre><code class="language-js">
              export const useCart = () => {

                const auth = true
                return {
                  auth //de esta forma esta variable estará disponible donde yo esté utilizando mi custom hook
                }
              }
            </code></pre>

            <p>Por tanto. Una vez creada mi variable llamada auth, y colocada en el return de mi custom hook, en mi componente accedo a ella de la siguiente manera:</p>

            <span class="file">App.jsx</span>
            <pre data-line="3"><code class="language-js">
              import { useCart } from './hooks/useCart'

              function App() {
                const { auth } = useCart()
                console.log(auth)
            </code></pre>

            <p>De hecho si hacemos la prueba en nuestro componente de extraer una nueva variable <strong>carrito</strong> que en mi custom hook sí he definido pero no he metido en el return, obtengo un <strong>Undefined</strong> porque no podemos acceder a ese valor. Hemos de meterla en el return, separada por coma del resto de variables/funciones. Es muy similar a un export de los módulos de ECMAScript.</p>

            <span class="file">useCart.ts</span>
            <pre><code class="language-js">
              export const useCart = () => {

                const auth = true
                const carrito = []
                return {
                  auth,
                  carrito
                }
              }
            </code></pre>
            <span class="file">App.jsx</span>
            <pre data-line="3"><code class="language-js">
              import { useCart } from './hooks/useCart'

              function App() {
                const { auth, carrito } = useCart()
                console.log(auth)
            </code></pre>

            <p>Por tanto si tenemos distintas variables/funciones/states en nuestro custom hook hemos de colocarlas separadas por "," en el return de nuestro custom hook y, en nuestro componente, vamos a acceder a todo ello en estas "{}" de aquí ¡con el mismo nombre que tienen! <code class="language-js">const { auth, carrito } = useCart()</code></p>

            <p>Veamos como migrar la lógica de nuestro carrito para usar nuestro custom hook</p>
            
          </div>
          <!-- Fin bloque desplegable interior-->


          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion89').toggle();">
            <h3>89. Migrando el Código hacia useCart / 90. Finalizando el Hook y Consideraciones</h3>
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion89">
            <ul class="mb-3.75">
              <li>Tomamos toda la lógica de antes del return de nuestro componente principal App.jsx y nos la llevamos a nuestro custom kook useCart.ts.</li>
              <li>Como los Hooks useState,useEffect y useMemo ya no se usan en los componentes sino en nuestro hook personalizado useCart.ts, quitamos el import de nuestros componentes y nos llevamos ahí la importación. También hacemos lo mismo con los datos:
                <span class="file">useCart.ts</span>
                <pre><code class="language-js">
                  import { useState, useEffect, useMemo } from 'react'
                  import { db } from '../data/db'

                  //necesitamos exportar toda esa funcionalidad para hacerla disponible donde quiera que yo importe mi custom hook
                  return {
                    data,
                    cart,
                    addToCart,
                    removeFromCart,
                    decreaseQuantity,
                    increaseQuantity,
                    clearCart,
                    isEmpty,
                    cartTotal
                }
                </code></pre>
                </li>
                <li>
                <p>
                  <span class="file">App.jsx</span> Esta sería la expresión total para usar nuestro custom Hook y las funciones que tiene disponibles:</p>
                  <pre><code class="language-js">
                    import { useCart } from './hooks/useCart'
                  
                    function App() {                      
                      const { data, cart, addToCart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart, isEmpty, cartTotal } = useCart()
                  </code></pre>
                  
                  <p>También quitamos del tag Guitar el prop <strong>setCart={setCart}</strong> porque esa función <code class="language-js">const [cart, setCart] = useState(initialCart)</code>ya no está disponible al haberlo migrado a nuestro custom hook junto al resto de la funcionalidad:</p>
                  <pre class="rojo" data-line="3"><code class="language-js">
                    &lt;Guitar 
                    key=&lcub;guitar.id&rcub;
                    guitar=&lcub;guitar&rcub;
                    setCart=&lcub;setCart&rcub;
                    addToCart=&lcub;addToCart&rcub;
                  /&gt;	
                  </code></pre>
                <p>Como vemos nuestro Hook tiene todas estas funciones. Algunos Hooks tienen más funciones otros menos, por ejemplo useState nos devuelve dos valores (state y funcion) y useEffect no devuelve nada es más toma como parámetro un callback. Si probamos de nuevo nuestra app vemos como funciona todo correctamente.</p>
                
              </li>
              <li><p>Movamos también la lógica que tenemos presente en el componente que tiene la vista del carrito Header.jsx: tanto el import de useMemo como este código nos lo llevamos a nuestro custom Hook <code class="language-js">import { useMemo } from 'react'</code></p>
              <pre><code class="language-js">
                // State Derivado
                const isEmpty = useMemo( () => cart.length === 0, [cart])
                const cartTotal = useMemo( () => cart.reduce( (total, item ) => total + (item.quantity * item.price), 0), [cart] )
              </code></pre>
              </li>
              <p>Recordemos que también tenemos que hacer disponibles estas dos funciones, añadiéndolas a la "lista objeto" de exportación que aparece en el return de nuestro Hook</p>

              <p>Si probamos, vemos que tenemos muchos errores. Podríamos pensar en importar en nuestro componente Header.jsx el custom Hook y crear una nueva variable para usar las dos funciones isEmpty y cartTotal del custom Hook useCart(). Pero en ese caso vemos que no nos agrega guitarras al carrito ni funciona ¿por qué? <span class="destacado">Porque los custom Hooks funcionan como instancias de una clase, de esa manera con una variable en cada componente haciendo lo siguiente, en cada componente estaríamos creando un carrito distinto:</span></p>
              <span class="file">App.jsx</span><br>
              <pre data-line="2"><code class="language-js">
                import { useCart } from './hooks/useCart'
                function App() {                    
                  const { data, cart, addToCart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart} = useCart()
              </code></pre>
              <span class="file">Header.jsx</span><br>
              <pre data-line="2"><code class="language-js">
                import { useCart } from './hooks/useCart'
                function App() {                    
                  const { sEmpty, cartTotal } = useCart()
              </code></pre>
              <p>Los carritos no saben de la existencia uno del otro, no están conectados, no están sincronizados. Sí, toda esa lógica está solo en nuestro custom Hook useCart.ts que es único, pero cada vez que instanciamos (ver los dos códigos anteriores) estamos creando un nuevo data y un nuevo cart:</p>

              <span class="file">useCart.ts</span>
              <pre><code class="language-js">
                const [data] = useState(db)
                const [cart, setCart] = useState(initialCart)
              </code></pre>

              <p>No funcionaría porque es como si estuviéramos creando nuevos objetos que siempre van a ser diferentes. <span class="destacado">Por tanto solo podemos tener una instacia de nuestro carrito de compras.</span> Eliminamos ese código de Header.jsx y extraemos en App.jsx esas dos nuevas funciones carTotal y isEmpty que acabamos de añadir en nuestro custom Hook, las pasamos via props y las extraemos en el Header:</p>
              
              <span class="file">App.jsx</span>
              <pre data-line="0,10-11"><code class="language-js">
                const &lcub; data&comma; cart&comma; addToCart&comma; removeFromCart&comma; decreaseQuantity&comma; increaseQuantity&comma; clearCart&comma; isEmpty&comma; cartTotal &rcub; = useCart()

                return (
                &lt;&gt;
                  &lt;Header 
                  cart=&lcub;cart&rcub;
                  removeFromCart=&lcub;removeFromCart&rcub;
                  decreaseQuantity=&lcub;decreaseQuantity&rcub;
                  increaseQuantity=&lcub;increaseQuantity&rcub;
                  clearCart=&lcub;clearCart&rcub;
                  isEmpty=&lcub;isEmpty&rcub;
                  cartTotal=&lcub;cartTotal&rcub;
                  /&gt;
              </code></pre>

              <span class="file">Header.jsx</span>
              <pre><code class="language-js">
                export default function Header({cart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart, isEmpty, cartTotal}) {
                  return (
              </code></pre>

              <p>Y así finalmente no vamos a tener errores y va a estar sincronizado nuestro state con las funciones de nuestro custom Hook. Aquí comenta que para manejar múltiples instancias de un objeto se maneja con un administrador global del estado como puede ser Redux toolkit, sustance, context API que lo vamos a ver un poco mas adelante</p>

              <p>Como vemos nuestros componentes quedan limpios sin lógica, <strong>aún habrá ciertos casos donde necesitemos poner código antes del return de nuestro componente como apps con múltiples páginas usando React Router DOM o quieres ejecutar algún query una vez cargues en cierto componente.</strong></p>
            </li>
            </ul>
            

          </div>
          <!-- Fin bloque desplegable interior-->           

           
        </div>
        <!-- Fin div colapsable-->
      
      </div>
      <!-- FIN SECCION 7 -->
      
      
      <!-- SECCIÓN 6 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
      
        <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion6').toggle();">	
          <h2>Sección 6: PROYECTO: Carrito de Compras - Creando el Carrito, introducción a Hooks y más</h2>				
          <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
        </div>
        
        <div id="seccion6" class="hidden">        
              
              
          <!-- BLOQUE CÓDIGO PROVISIONAL -->
          <div>
            <p class="rojo">App.jsx</p>
            <script type="text/plain" class="language-js h-300">
              import { useState, useEffect } from "react"
              import Guitar from "../components/Guitar"
              import Header from "../components/Header"
              import { db } from "./data/db"
              
              function App() {
                  //console.log(db)
                  // const [data, setData] = useState([])
                  // useEffect( () => {
                  //     setData(db)
                  // },[])
              
                  const initialCart = () => {
                      const localStorageCart = localStorage.getItem('cart') // lo primero es recuperar de localStorage
                      //a continuación comprobamos si hay algo en esa variable:
                      return localStorageCart ? JSON.parse(localStorageCart): []
                  }
                  const [data] = useState(db)    
                  const [cart, setCart] = useState(initialCart)
                  const MAX_ITEMS = 5
                  const MIN_ITEMS = 1
              
                  useEffect(() => {
                      localStorage.setItem('cart', JSON.stringify(cart))
                  }, [cart])
                  
              
                  function addToCart(item){
                      const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                      if(itemExists >= 0){//existe en cart
                          if(cart[itemExists].quantity >= MAX_ITEMS) return
                          const updatedCart = [...cart] //copia nueva de mi state, no modifica mi carrito       
                          updatedCart[itemExists].quantity++
                          setCart(updatedCart)
                      } else{//NO EXISTE en cart
                          item.quantity = 1
                          setCart(prevCart =>[...prevCart, item])
                      }       
                  }
              
                  function removeFromCart(id){
                      //console.log('Eliminando...', id)      
                      setCart(prevCart => prevCart.filter(guitar => guitar.id !== id))
                  }    
              
                  function decreaseQuantity(id){
                      //console.log('Decrementando...', id)
                      const updatedCart = cart.map( item => {
                          if(item.id === id && item.quantity > MIN_ITEMS){
                              return{
                                  ...item,//ponemos esto porque no queremos perder la referencia de lo que ya tenemos en el cart
                                  quantity: item.quantity -1 //si pusiéramos solo esto solo nos devolvería la cantidad
                              }
                          }
                          return item //cuando no se cumple la condición: mantiene el resto de elementos sobre los que no dimos click en decrementar cantidad
                      })
                      setCart(updatedCart)
                  }
              
                  function increaseQuantity(id){
                      //console.log('Incrementando...', id)
                      const updatedCart = cart.map ( item => {
                          if(item.id === id && item.quantity < MAX_ITEMS){
                              return{
                                  ...item,//ponemos esto porque no queremos perder la referencia de lo que ya tenemos en el cart
                                  quantity: item.quantity + 1 //si pusiéramos solo esto solo nos devolvería la cantidad
                              }
                          }
                          return item //cuando no se cumple la condición: mantiene el resto de elementos sobre los que no dimos click en aumentar cantidad
                      })
                      setCart(updatedCart) //esa variable la seteamos al carrito
                  }
              
                  function clearCart(){
                      setCart([]) //seteamos un arreglo vacío
                  }
              
                  return (
                      <>   
                      <Header
                          cart = {cart}
                          removeFromCart = {removeFromCart}
                          decreaseQuantity = {decreaseQuantity}
                          increaseQuantity = {increaseQuantity}
                          clearCart = {clearCart}           
                      />
                    
                      <main className="container-xl mt-5">
                          <h2 className="text-center">Nuestra Colección</h2>
              
                          <div className="row mt-5">
                              {data.map((guitar) => (                    
                                  <Guitar
                                      key = {guitar.id} 
                                      propguitar = {guitar} 
                                      setCart = {setCart}    
                                      addToCart = {addToCart}                     
                                  />
                              )
                              )}         
                          </div>
                      </main>
              
                      <footer className="bg-gray-300 mt-5 py-5">
                          <div className="container-xl">
                              <p className="text-white text-center fs-4 mt-4 m-md-0">GuitarLA - Todos los derechos Reservados</p>
                          </div>
                      </footer>        
                      </>
                  )
              }
              
              export default App                         
            </script>
          </div>

          <div class="flex block-s">                 
            <div class="w-50 w-100-s">
              <p class="rojo">Guitar.jsx</p>
              <script type="text/plain" class="language-js">
                export default function Guitar({propguitar, addToCart}){

                  //console.log(propguitar)
                  const { id, name, image, description, price } = propguitar
              
                  const handleClick = (guitar) => {
                      //setCart([...cart, guitar])
                      
                  }
              
                  return(
                      <div className="col-md-6 col-lg-4 my-4 row align-items-center">
                          <div className="col-4">
                              <img className="img-fluid" src={`/img/${image}.jpg`} alt="imagen guitarra" />
                          </div>
                          <div className="col-8">
                              <h3 className="text-black fs-4 fw-bold text-uppercase">{name}</h3>
                              <p>{description}</p>
                              <p className="fw-black text-primary fs-3">${price}</p>
                              <button 
                                  type="button"
                                  className="btn btn-dark w-100"
                                  onClick={() => addToCart(propguitar)}
                              >Agregar al Carrito</button>
                          </div>
                      </div>
                  )
              }       
              </script>
            </div>
            <div class="w-50 w-100-s">
              <p class="rojo">Header.jsx</p>
              <script type="text/plain" class="language-js">
                import { useMemo } from 'react'

                export default function Header({cart, removeFromCart, decreaseQuantity, increaseQuantity, clearCart}){
                
                    //State derivado
                    const isEmpty = useMemo( () => cart.length === 0, [cart])
                    const cartTotal = useMemo( () => cart.reduce( (total, item) => total + (item.quantity * item.price), 0), [cart])
                    
                    return(
                
                        <header className="py-5 header">
                            <div className="container-xl">
                                <div className="row justify-content-center justify-content-md-between">
                                    <div className="col-8 col-md-3">
                                        <a href="index.html">
                                            <img className="img-fluid" src="/img/logo.svg" alt="imagen logo" />
                                        </a>
                                    </div>
                                    <nav className="col-md-6 a mt-5 d-flex align-items-start justify-content-end">
                                        <div className="carrito">
                                            <img className="img-fluid" src="/img/carrito.png" alt="imagen carrito" />
                
                                            <div id="carrito" className="bg-white p-3">
                                                
                                                {isEmpty ? (
                                                    <p className="text-center">El carrito esta vacio</p>                                            
                                                ):(    
                                                    <>                          
                                                    <table className="w-100 table">
                                                        <thead>
                                                            <tr>
                                                                <th>Imagen</th>
                                                                <th>Nombre</th>
                                                                <th>Precio</th>
                                                                <th>Cantidad</th>
                                                                <th></th>
                                                            </tr>
                                                        </thead>
                                                    
                                                        <tbody>
                                                            {cart.map( guitar =>( 
                                                            <tr key={guitar.id}>
                                                                <td>
                                                                    <img className="img-fluid" src={`/img/${guitar.image}.jpg`} alt="imagen guitarra" />
                                                                </td>
                                                                <td>{guitar.name}</td>
                                                                <td className="fw-bold">
                                                                        ${guitar.price}
                                                                </td>
                                                                <td className="flex align-items-start gap-4">
                                                                    <button
                                                                        type="button"
                                                                        className="btn btn-dark"
                                                                        onClick={() => decreaseQuantity(guitar.id)}>
                                                                        -
                                                                    </button>
                                                                        {guitar.quantity}
                                                                    <button
                                                                        type="button"
                                                                        className="btn btn-dark"
                                                                        onClick={() => increaseQuantity(guitar.id)}>
                                                                        +
                                                                    </button>
                                                                </td>
                                                                <td>
                                                                    <button
                                                                        className="btn btn-danger"
                                                                        type="button"
                                                                        onClick={() => removeFromCart(guitar.id)}>
                                                                        X
                                                                    </button>
                                                                </td>
                                                            </tr>
                                                            ))}
                                                        </tbody>
                                                    </table>
                                                    <p className="text-end">Total pagar: <span className="fw-bold">${cartTotal}</span></p>
                                                    </>
                                                )}
                
                                                
                                                <button 
                                                    className="btn btn-dark w-100 mt-3 p-2"
                                                    onClick={clearCart}
                                                >Vaciar Carrito</button>
                                            </div>
                                        </div>
                                    </nav>
                                </div>
                            </div>
                        </header>
                
                    )
                
                }       
              </script>
            </div>
          </div>
          <!-- FIN BLOQUE CÓDIGO PROVISIONAL -->

      
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-52').toggle();">	
            <h3>52. La estructura de archivos de React</h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-52" class="hidden">
            <p><strong>index.html:</strong> Archivo html sobre el cual se monta la app de React. </p>	
            <p><strong>App.jsx:</strong> nuestro componente principal de aplicación. Es donde estaremos agregando nuestros componentes.</p>	
            <p><strong>index.css:</strong> para código css que aplique en toda la app</p>	
            <p><strong>main.jsx:</strong> donde importamos la hoja de estilo y el componente ppal para que se inyecten en ese index.html</p>	

              
            <p>React es una librería de JS por tanto todo el código de JS que se genera es inyectado en el div <code class="language-html">&lt;div id="root"&gt;&lt;/div&gt;</code>. Por tanto es un DOM virtual, es código html que fue generado Unicamente con js. En este index podemos meter las google fonts o librerías de animaciones de css. Es nuestro archivo principal pero usualmente no vamos a hacer cambios aquí (solo el title)</p>
            <p><strong>package-lock.json:</strong> no tocamos se genera a partir del package.json y las dependencias indicadas ahí</p>
            <p><strong>package.json:</strong> dependencias y qué versiones están instaladas y utiliza este proyecto. De hecho en la parte de scripts, vemos que el de dev manda ejecutar <span class="destacado">vite</span>.</p>
            <pre><code class="language-js">
              "scripts": {
                "dev": "vite",
                "build": "vite build",
                "lint": "eslint .",
                "preview": "vite preview"
                },
            </code></pre>	
              
            <p>Si vamos añadiendo dependencias se van colocando aquí en el bloque siguiente de dependencias de proyecto y en el siguiente dependencias de desarrollo.</p>
            <p>Nos fijamos en los dos logos que aparecen en la página de inicio. carpeta public --> 'vite.svg' y carpeta src>assets --> 'react.svg'. Vemos en nuestro <strong>App.jsx</strong> como se llaman esos logos usando la sintaxis propia de react conocida como <span class="destacado">jsx</span>: que nos permite combinar código html con código js. <span class="destacado">Importante como se importa cada cosa en función de donde esté (solo / si en public vs ./ si en src)</span></p>
            <pre><code class="language-js">
              import reactLogo from './assets/react.svg'
              import viteLogo from '/vite.svg'
            </code></pre>
            <pre><code class="language-html">
              &lt;a href=&quot;https://vite.dev&quot; target=&quot;&lowbar;blank&quot;&gt;
              &lt;img src=&lcub;viteLogo&rcub; className=&quot;logo&quot; alt=&quot;Vite logo&quot; /&gt;
              &lt;/a&gt;
              &lt;a href=&quot;https://react.dev&quot; target=&quot;&lowbar;blank&quot;&gt;
              &lt;img src=&lcub;reactLogo&rcub; className=&quot;logo react&quot; alt=&quot;React logo&quot; /&gt;
              &lt;/a&gt;							
            </code></pre>

            <p>Vemos como el componente principal se llama App.jsx y también tenemos una css que se llama igual que ese componente App.css</p>
            <p>Eliminamos la css, los logos y sus importaciones y uso en App.js, también el import y la const del state (mas adelante veremos) y dejamos solo lo siguiente:</p>
            <pre><code class="language-js">		
              function App() &lcub;
              
                return (
                &lt;&gt;
                  
                  &lt;h1&gt;GuitarLA&lt;/h1&gt;
                  
                &lt;/&gt;
                )
              &rcub;
              
              export default App
            </code></pre>

            <p><strong>main.jsx:</strong> es el archivo principal de nuestra aplicación de React. Recordemos que en index.html todo se agrega en el div <code class="language-html">&lt;div id="root"&gt;&lt;/div&gt;</code>. Este main.jsx lee ese div y entonces monta toda nuestra aplicación de React en ese div. Si nos fijamos en el main.jsx vemos que importamos dos librerias React (librería ligera) y react-dom que es lo que nos permite la integración con nuestro html (hay otra react-native para crearr apps para android y iphone). También aquí se importa el archivo css <strong>index.css</strong> que nos permite agregar estilos globales a todo nuestro proyecto. Lo vaciamos (y así el h1 ya no sale centrado verticalmente)</p>
            <pre><code class="language-js">
              import &lcub; StrictMode &rcub; from &apos;react&apos;
              import &lcub; createRoot &rcub; from &apos;react-dom/client&apos;
              import &apos;./index.css&apos;
              import App from &apos;./App.jsx&apos;
              
              createRoot(document.getElementById(&apos;root&apos;)).render(
                &lt;StrictMode&gt;
                &lt;App /&gt;
                &lt;/StrictMode&gt;&comma;
              )	
            </code></pre>
          </div>
          <!-- Fin bloque desplegable interior-->

          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-53').toggle();">	
            <h3>53. Copiando el código HTML estatico a React</h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-53" class="hidden">
            
          </div>
          <!-- Fin bloque desplegable interior-->

    
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-54').toggle();">	
            <h3>54. Como Escribir código CSS en React</h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-54" class="hidden">
            <p></p>
            
          </div>
          <!-- Fin bloque desplegable interior-->


          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-55').toggle();">	
            <h3>55. ¿Qué son los Componentes en React?</h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-55" class="hidden">
            <p>Una vez copiado (estructurado) el código estático de guitarras que descargamos, sigue siendo estático. Este App.jsx ya es un componente:</p>
            <ul class="mb-3.75">
              <li>Es una función y su nombre empieza por mayúsculas (para evitar problemas en la compilación). Lo que esté entre las llaves es el contenido de ese componente pero podemos pasarlo a otros por medio de algo llamado props (lo veremos mas adelante)</li>
              <li>Tiene un return que devuelve lo que se ve en pantalla</li>
              <li>Lo que está antes del return se utiliza para algo</li>
              <li>lo que está después tiene otro fin</li>
              <li>Básicamente es tener HTML y JS en un solo archivo</li>
              <li><strong>¿Qué son los coponentes en React?</strong> React utiliza componentes para la creación de aplicaciones y sitios web. Actualmente nuestro App.jsx tiene demasiado código; (tiene mas de 100 líneas, podemos pensar en dividirl en componentes)</li>
              <li><strong>Un componente puede tener la extensión <span class="destacado">.jsx (si utilizamos js)</span> o <span class="destacado">.tsx (si utilizamos typescript)</span>.</strong> .js taambién es posible pero se recomiendan las dos primeras</li>
              <li><strong>Un componente normalmente tiene dos propósitos:</strong> ser reutilizable y/o separar la funcionalidad. Si se cumplen ambas mejor.</li>
              <li><strong>Siempre tiene que tener un <span class="destacado">return()</span> que es lo que se muestra en pantalla</strong></li>
              <li></li>
            </ul> 

            <p>Creemos en una nueva carpeta que llamamos "components" nuestro primer componente: <strong>Header.jsx</strong>. Si en el return metemos un h1, vemos que en la app no se muestra nada porque nuestro componente principal App.jsx no sabe de la existencia de este nuevo componente Header.jsx. Hay que exportarlo e importarlo. podemos poner al final del archivo <strong>export default Header</strong> o mejor, colocarlo antes de la palabra function y lo tenemos en una sola línea <span class="destacado">export default function Header(){}</span>. Ahora ya podemos importarlo en cualquier otro componente:</p>
            <pre><code class="language-js">
              export default function Header(){

                return(
                  <h1>Desde Header</h1>
                )
                
              }							
            </code></pre>
              
            <p>Lo importamos en nuestro componente ppal de Aplicación App.jsx usando al ppio la palbra import y con el autocompletado ya nos sale nuestro Header.</p>
            <p>Aún tenemos que renderizarlo (como si fueran tags HTML). Importante:</p>

            <pre><code class="language-html">
              &lt;Header/&gt; &lt;!-- sintaxis de componente React --&gt;
              &lt;header&gt; &lt;!-- tag HTML --&gt;							
            </code></pre>
            
            <p>Si volvemos a nuestro primer componente y nos fijamos en lo que hay dentro del return() vemos que tenemos un tag de html h1. Esto de primeras parece un poco raro, veamos qué es el jsx</p>
          </div>
          <!-- Fin bloque desplegable interior-->


          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-56').toggle();">	
            <h3>56. ¿Qué es JSX? / 57. Renombrando class a className de nuestro proyecto / 58. Creando un Componente para cada Guitarra </h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-56" class="hidden">

            <ul class="mb-3.75">
              <li><span class="destacado">JSX</span> <strong>Javascript Syntax Extension:</strong> es una extensión del lenguage desarrollada también por META (Facebook) para React y es una sintaxis especial para poder agregar HTML y JS en un solo lugar. Al ppio parece un poco complicado pero se ven los beneficios conforme comenzamos a trabajar con ella.</li>
              <li>Parece JS (los componentes son funciones) pero muestra código HTML. Básicamente <strong>es un lenguage de Templates/Vistas</strong> que muestra HTML pero tiene todas las funciones de Javascript (todo js puede usarse en los archivos .jsx)</li>
              <li><strong>Una vez compilado son archivos JS con funciones y objetos</strong></li>
            </ul>

            <p>En la parte anterior del return() podemos colocar código js, probemos con una variable const = name. Para comunicar esto en nuestra vista (dentro del return) <span class="destacado">hay que hacerlo entre llaves {}</span>. <br><span class="rojo">Ojo!</span> si intentamos poner solo {name} sin ningún tag nos da error. También si pongo dos o mas tags html seguidos!!!! Veamos las reglas de JSX y evitar estos errores</p>

            <ul class="mb-3.75">
              <li>A diferencia de HTML, <strong>en JSX si un elemento HTML tiene tag de apertura ha de tener también el de cierre (los tag &lt;link&gt; &lt;img&gt;A o &lt;input&gt; habr&aacute; que cerrarlas con /&gt;)</strong></li>
              <li><strong>Cada componente debe tener un return</strong></li>
              <li><strong>En el return solo puede haber un elemento (un tag) en el nivel superior=máximo</strong> --&gt; podría tener un &lt;div&gt; padre englobando todo en el return pero al final cargaríamos nuestro código con divs innecesarios. Para evitar eso usamos los <span class="destacado">Fragment</span>. esta sintaxis que vemos en el ejemplo de nuestro componente principal de aplicación App.jsx es una de las 3 maneras de usar Fragment: <strong>&lt;&gt;</strong>
                <ul class="mb-3.75">
                  <li><code class="language-js">import { Fragment } from "react"</code> <code class="language-html">&lt;Fragment&gt;&lt;/Fragment&gt;</code></li>
                  <li><code class="language-js">import React from "react"</code> <code class="language-html">&lt;React.Fragment&gt;&lt;/React.Fragment&gt;</code></li>
                  <li>Sin hacer ninguna importación simplemente usamos: <code class="language-html">&lt;&gt;&lt;/&gt;</code></li>
                </ul>
              
              </li>
            </ul>

            <p>Veamos un resumen de lo que es un componente:</p>

            <img class="my-2.5" src="./src/assets/img/56.jpg" alt="" />
            <p>Si vemos la consola nos sale este mensaje de error y es porque en React "class" es una palabra reservada del lenguage js. Con objeto de no mezclar el uso de ese "class" (que es de estilos) con el uso de la palabra reservada de js cuando definamos states, variables..., se soluciona sustituyendolo por className:</p>

            <img class="my-2.5" src="./src/assets/img/57.jpg" alt="" />

            <p><span class="destacado">Se recomienda usar tags HTML semantico pero en lugar de class usamos className</span> (eso conecta en automático con el archivo de css de nuestro proyecto). Esto es solo de cara a desarrollo, una vez que compila el proyecto se agregan clases normales. Nos llevamos todo el códiog del header al nuevo componente Header.</p>

            <p>Creamos un nuevo componente <strong>Guitar.jsx</strong> con el contenido de la primera guitarra y borramos las otras del App.jsx. Lo llamamos desde nuestro App.jsx (la integración con VSCode es muy buena, no hace falta que tecleemos la línea de importar ese cpomponente, con solo escribirlo y enter en el autocompletado nos añade la línea.)</p>

            <p>Veamos a continuación que son los React Hooks que nos van a permitir Integrar toda las funcionalidades de React con nuestra interfaz</p>
            
          </div>
          <!-- Fin bloque desplegable interior-->
    
    
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-59').toggle();">	
            <h3>59. Introducción a los React Hooks / 60. ¿Qué es el State en React? y useState / 61. Reglas de los Hooks / 62. ¿Qué es useEffect?</h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-59" class="hidden">
            <p>Los <span class="destacado">React Hooks</span> son la base de React. Nos van a permitir Integrar toda las funcionalidades de React con nuestra interfaz.</p>
            <ul class="mb-3.75">
              <li><strong>Los Hooks permiten usar las diferentes funciones de React en nuestros componentes. React tiene una serie de Hooks pero también podemos crear los nuestros.</strong></li>
              <li><strong>Los Hooks están disponibles desde la versión 16.8 de React, previo a ello se tenían que crear Classes para crear y modificar el state, con los Hooks no es necesario.</strong></li>
              <li><strong>Existen muchos y se dividen entre Básicos y adicionales</strong></li>
              <li>Son los siguientes (como vemos, el nombre de todos empieza con la palabra <strong>use</strong>). Los básicos que están en casi todos los proyectos son los 3 de la izquierda. Los otros son más avanzados que se utilizan para librerías o casos más específicos.</li>
              <li><img class="my-2.5" src="./src/assets/img/hooks.jpg" alt="" /></li>
              
              <li>También podemos crear nuesros propios Hooks así podremos separar nuestro código en funciones reutilizables y sacar todo el beneficio de lo que React ofrece.</li>
            </ul>

            <p>Comenzamos utilizando el más común de todos <span class="destacado">useState</span>. Tiene un <a href="https://gist.github.com/codigoconjuan/f333ee8422b0b8c4fde227e81e626cce" target="_blank">Gist con todas las guitarras</a> preparado para utilizarlo en nuestra App simulando una base de datos, pero primero hemos de ver el Hook más común de todos <strong>useState()</strong> y ello nos lleva a ver qué es el <span class="destacado">state en React</span> que es la pieza central de React.</p>

            <p class="font-bold naranja">¿Qué es el State en React?</p>
            <ul class="mb-3.75">
              <li><strong>El Estado o State en React es una variable con información relevante en nuestra aplicación de React</strong>, algunas veces el state pertenece a un componente en específico y otras veces quieres que sea compartido a lo largo de diferentes componentes.</li>
              <li><strong>Pensemos en el state como el resultado de alguna interacción en el sitio o aplicación web: el listado de clientes, la imagen a mostrar en una galería, si un usuario está autenticado o no,...</strong></li>
              <li><strong>El state es creado con el Hook useState()</strong>. Veamos un ejemplo:</li>
            </ul>

            <p>Importamos el Hook <code class="language-js">import { useState } from "react"</code> y la forma en que vamos a definir nuestro state es así: <code class="language-js">const [customer, setCustomer] = useState({});</code> Creamos una variable const y colocamos entre corchetes [] (useState siempre va a devolver un Array (aquí estamos aplicando Array Destructuring)) y podemos ver que estamos nombrando nuestro state como <strong>customer</strong> y usamos <strong>setCustomer</strong> (este nombre, usar "set", es una convención) a continuación un = seguido de un objeto dentro de paréntesis <strong>({})</strong>, es lo que se conoce como el valor inicial. Veamos más ejemplos de state y cómo, el valor inicial será una u otra cosa en función de qué tipos de datos tengamos:</p>
            <pre><code class="language-js">
              const [customer, setCustomer] = useState({})
              const [total, setTotal] = useState(0)
              const [products, setProducts] = useState([])
              const [modal, setModal] = useState(false)	
            </code></pre>

            <p class="font-bold">Anatomía de useState: state, función y valor inicial</p>
            <p><code class="language-js">
              const [customer, setCustomer] = useState({});</code></p>
            <ul class="mb-3.75">
              <li><strong>customer</strong> es el state, la variable que va a tener toda la información</li>
              <li><strong>setCustomer</strong> es la función que modifica el state, es la fcn que siempre vamos a usar cuando queramos realizar cambios en nuestro state (en este ejemplo customer)</li>
              <li><strong>useState</strong> es el Hook que nos da React</li>
              <li>el objeto vacío <strong>({})</strong> es el valor inicial</li>	
            </ul>

            <p class="font-bold">React reacciona en base al state</p>
            <ul class="mb-3.75">
              <li>Cada vez que el state cambia, la aplicación de React va a renderizar y actualizarse con esos cambios, no es necesario hacer nada más (recargar página o actualizar el DOM) y nuestra interfaz siempre va a estar sincronizada con el state.</li>
              <li>Para modificar el state, se utiliza la función que extraemos cuando declaramos el state en nuestro componente.</li>
            </ul>

            <p>Para implementar useState en nuestra App Guitarlab, cerramos todo y dejamos abierto únicamente el componente principal de App, <strong>App.jsx</strong>.</p>
            <ul class="mb-3.75">
              <li><code class="language-js">import { useState } from "react"</code></li>
              <li><strong>El state hay que definirlo en nuestro componente, ni fuera de él ni dentro del return() sino justo antes del return</strong>. Hay ciertas reglas para los Hooks que estaremos viendo a continuación. </li>
              <li>lo más básico que nos da react es esto: <code class="language-js">const [] = useState()</code> pero <strong>nosotros tenemos que definir nombre del state, nombre de la función y su valor inicial.</strong>. Supongamos que vamos a crear un state para revisar si un usuario está autenticado o no, si lo está le mostramos un componente y si no lo llevamos al panel de iniciar sesión. <code class="language-js">const [auth, setAuth] = useState(false)</code>. Si sacamos un console.log del state lo vemos (y de hecho 2 veces, uno desde el Componente ppal App.jsx y otro desde el InstallHook.jsx, no nos preocupemos, React forzó en nuevas versiones este doble render para garantizar que se hace buen uso de React). Pero en vez de por consola usemos React developer tools.</li>
              <li><strong><a href="https://chromewebstore.google.com/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=es&pli=1" target="_blank">React developer tools: </a></strong> una vez instalado y reiniciado chrome, en web developer tools tenemos una pestaña nueva llamada components, en la que vamos a ver intuitivamente el árbol de componentes de nuestro proyecto de React (App, Header, Guitar). Si pulsamos en App, vemos en el apartado de Hooks el state y su valor.</li>
            </ul>                    

            <p class="naranja">Reglas de los Hooks</p>

            <p>Vamos a crear más states. Va a ser muy normal que una App tengamos varios states o el uso de varios Hooks:</p>
            <pre><code class="language-js">
              const [auth, setAuth] = useState(false)
              const [total, setTotal] = useState(0)	
              const [cart, setCart] = useState([])
            </code></pre>

            <p class="font-bold">Reglas de los Hooks en React</p>
            <ul class="mb-3.75">
              <li><strong>Los Hooks se colocan en la parte superior de los componentes de React.</strong> ni dentro de bucles/interacciones, ni dentro de funciones.</li>
              <li><strong>No se deben colocar dentro de condicionales ni después de un return:</strong> los Hooks no se pueden registrar en base a una condición porque esa condición puede cambiar en algún momento y entonces tendremos un error.</li>
            </ul>

            <p class="naranja">¿Qué es el Hook useEffect?</p>
            <ul class="mb-3.75">
            <li>Tras el useState, <strong>useEffect es el segundo Hook más común que vamos a usar, es muy versátil y lo usaremos mucho</strong>. </li>
            <li><strong>useEffect siempre es un callback</strong> que, dependiendo como lo declares, va a realizar diferentes acciones.</li>
            <li>Es el Hook más versátil, sustituto de lo que, en versiones previas de React donde había Clases y métodos del ciclo de vida, era conocido como <strong>componentDidMount()</strong> y <strong>componentDidUpdate()</strong></li>
            </ul>

            <p>Importamos el Hook <code class="language-js">import { useEffect } from "react"</code> y para usar este Hook, dentro del () vemos que tiene un calllback que se puede poner como function o como arrow function. Los corchetes del final es lo que se llama <strong>arreglo de dependencias</strong> que ahora veremos:</p>
            <pre><code class="language-js">
              useEffect( () => {
                console.log('El componente está listo')
              }, [])	
            </code></pre>

            <p class="font-bold">Usos de useEffect()</p>
            <ul class="mb-3.75">
              <li>Al ejecutarse automáticamente cuando el componente está listo, es un buen lugar para colocar código para consultar una API o para obtener datos del LocalStorage.</li>
              <li>Debido a que le podemos pasar una dependencia (que usualmente va a ser un state) va a estar escuchando por los cambios que suceden en una variable, pudiendo actualizar el componente (o ejecutar ciertas funciones) cuando ese cambio ocurra (podemos estar sincronizando con LocalStorage por ejemplo).</li>
              <li>Dependiendo del valor que pasemos en el array de dependencias (o si no pasamos nada) el Hook userEffect va a hacer algo diferente:
                <ul class="mb-3.75">
                  <li>Si dejamos el arreglo de dependencias vacío (significa que no tiene dependencias) el código especificado en el Hook solo se ejecuta una vez, y lo hace cuando el componente esté listo. Si sacamos un console.log por consola veremos que solo sale 1 vez (sale 2 pero por loq ue decíamos de la comprobación del modo estricto en el main incluido por el equipo de React en versiones recientes)
                    <pre><code class="language-js">					
                      useEffect ( () => {
                        console.log('Componente listo')
                      }, [])					
                    </code></pre>
                  </li>
                  <li>Si le pasamos un state (o varios), cada vez que cambie cada uno de esos states se ejecuta el efecto (la función) que especifiquemos en el Hook useEffect. En este caso añadimos un setTimeout que nos cambia el state Auth pasados 3 segundos. Veremos que se ejecuta una vez cuando el componente está listo (vemos esas 2 del modo estricto del main.jsx) y pasados 3 sg al cambiar el state auth se vuelve a ejecutar:
                    <pre><code class="language-js">
                      useEffect ( () => {
                        console.log('Componente listo o escuchando por auth')
                      }, [auth])
                    
                      setTimeout(() => {
                        setAuth(true)
                      }, 3000); 
                    </code></pre>
                  </li>
                </ul>
                
                <p>De esta forma, podemos tener funciones que se ejecuten cuando cambie algún state en nuestra aplicación, para eso es el useEffect(). Es muy útil.</p>
                <p>¿podríamos hacer lo siguiente? meter un condicional para ejecutar un código solo en el caso de que el usuario esté autenticado? (comenta que hay gente que dice que no se puede usar eso dentro de un useEffect, pero él afirma que se utiliza muchas veces y que es correcto)</p>
                <pre><code class="language-js">
                  const [auth, setAuth] = useState(false)
                
                  useEffect ( () => {
                    if(auth){
                      console.log('Componente listo o escuchando por auth')
                    }
                  }, [auth])
                  
                  setTimeout(() => {
                    setAuth(true)
                  }, 3000);				
                </code></pre>

              </li>
            </ul>
          </div>
          <!-- Fin bloque desplegable interior-->


          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-63').toggle();">	
            <h3>63. Añadiendo los Productos al State / 64. Iterando sobre los productos en React / 65. Props / 66. Mostrando la Información de cada Guitarra- 
              <a class="text-[#000000]" href="https://gist.github.com/codigoconjuan/f333ee8422b0b8c4fde227e81e626cce" target="_blank">Gist Guitarras</a></h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-63" class="hidden">
            <p>Veamos como incorporar este <a href="https://gist.github.com/codigoconjuan/f333ee8422b0b8c4fde227e81e626cce" target="_blank">listado de Gist que simula ser una pequeña base de datos de guitarras</a> para hacer nuestra interfaz dinámica y no mostrar una única guitarra. Sobre todo también hacer el componente <strong>Guitar</strong> más inteligente.</p>

            <p>Creamos en src una carpeta para los datos y un .js con los datos de ese git copiados en raw: <strong>data/db.js</strong>. Es una pequeña base de datos con 12 guitarras cada una con un id, descripción y precio; las imágenes están mapeadas con nuestra carpeta de imágenes. Vamos a nuestro componente principal <strong>App.jsx</strong> e importamos esta base de datos ayudándonos del autocompletado: <code class="language-js">import { db } from "./data/db"</code>. Si hacemos un console.log(db) podemos ver esa bbdd local. Hagámoslo al estilo de React. Se puede hacer de dos formas:</p>

            <ul class="mb-3.75">
              <li>Como es un archivo local, podemos ponerle que el valor inicial del state data es lo que tengamos en db
                <pre><code class="language-js">const [data, setData] = useState(db)</code></pre>. Vemos en la pestaña de componentes, en el compo App > hooks toda la información de nuestro state. Está bien porque es un archivo local, lo va a leer, importar montar y después montar nuestro componente.</li>
              <li>Si trabajáramos con una API usualmente usaremos un useEffect, esto en caso de hacerlo sin dependencias (hay muchas dependencias enfocadas a consumir APIS que se integran bastante bien con React y que lo hacen con un rendimiento excelente aunque es más para grandes proyectos, pero no es nuestro caso). <span class="destacado">Con mi arreglo de dependencias vacío, una vez el componente esté listo especificamos setData(db), es decir seteo en mi state mi base de datos que tenemos en el archivo indicado en la importación.</span>
              <pre><code class="language-js">
                const [data, setData] = useState([])
                useEffect( () => {
                  setData(db)
                },[])			
              </code></pre>
              si miramos en la pestaña componentes del web developer vemos que se coloca la información de las guitarras dentro del state.
              <img class="my-2.5" src="./src/assets/img/63-db-productos-en-state.jpg" alt="" /></li>
            </ul>	

            <p>Si esto lo haces desde una API esta forma es la más recomendada porque una API va a conectarse y traerse la información, no sabemos cuando, entonces quieres que se mande llamar una vez que el componente esté listo. Un poco más adelante cuando veamos cómo integrar APIS con React volveremos sobre esto.</p>

            <p>Una vez tenemos en nuestro state la información de la BBDD de nuestras guitarras, veamos cómo iterar sobre él y comenzar a mostrar la información de nuestras guitarras.</p>

            <p class="naranja">Iterando sobre los productos en React</p>

            <p>¿Como sabemos cual es el valor inicial de nuestro state? En nuestro caso es un arreglo y tenemos dos elementos. Hay muchas formas de iterar un arreglo, un for, un forEach. <span class="destacado">Es importante mencionar que antes de nuestro return() podemos escribir lo que se conoce como statements o expresiones, sin embargo dentro del return solo podemos escribir expresiones</span></p>

            <ul class="mb-3.75">
              <li><strong>Statement</strong> Una app de js es una serie de statements. Cada statement es una instrucción para hacer algo. Algunos statements muy comunes son <strong>creación de variables</strong>, <strong>códigos condicionales con if</strong>, <strong>lanzar errores con throw new Error()</strong>, <strong>Iterar con While o For</strong></li>
              <li><strong>Expressions</strong> Una expresión es algo que produce un valor. Algunos ejemplos de Expressions son <strong>ternarios</strong>, <strong>utilizar un Array method que genere un nuevo array</strong>, <strong>map() que genera un nuevo array a diferencia de forEach</strong></li>
            </ul>

            <p>Por tanto, tenemos un Array queremos iterar sobre él y como hemos visto un bucle For o un While no se puede usar en la parte del return() pero sí un .map(). Podríamos usar un for para iterar en la parte superior sobre data, pero queremos hacerlo en pantalla por lo que tenemos que hacerlo en el return() del componente, por tanto usamos para ello la expresión .map() que cada vez que lo utilicemos nos genera un array nuevo. El map() va a ejecutarse una vez por cada elemento en nuestro Array. Veamos el siguiente código y como aparece 12 veces el párrafo especificado. Sustituyamos ese párrafo por el componente que teníamos hecho:</p>

            <pre><code class="language-js">
              const [data, setData] = useState(db)
            </code></pre>
            <pre><code class="language-html">
              &lcub;data.map(() =&gt; (
                //&lt;p&gt;Desde Guitarra&lt;/p&gt;
                &lt;Guitar/&gt;	
              )
              )&rcub;
              
            </code></pre>

            <p>¿qué hemos hecho? accedemos a data que es parte de nuestro state, utilizamos el array method map() y al comenzar a iterar generamos un componente Guitar por cada elemento presente en el arreglo (12 elementos). Nos aparece 12 veces el mismo componente estático &lt;Guitar/&gt;. <strong>En el siguiente vídeo con el uso de props  haremos nuestro componente estático más inteligente, más dinámico.</strong></p>

            <p class="naranja">¿Qué son los Props en React?</p>

            <p><strong>Props en React:</strong> es una forma de compartir inofrmación entre componentes</p>
            <ul class="mb-3.75">
              <li><strong>Los componentes de React utilizan Props para comunicarse entre ellos</strong>. Puedes pasarle información de un componente padre al hijo por medio de estos props. </li>
              <li><strong>Los props se parecen mucho a los atributos HTML, la sintaxis es muy similar, pero puedes pasarle arrays, objetos o funciones</strong></li>
              <li><strong>Los Props de pasan del padre al hijo, nunca se pueden pasar del hijo al padre</strong>
                <ul class="mb-3.75">
                  <li>Si tenemos un state que se va a pasar por diferentes componentes, lo mejor es colocarlo en el archivo principal</li>
                  <li>Cada Nivel de Componentes deberá tomar y pasar el Prop hacia otros componentes. Tecnologías como Redux, Zustand, Jotai o Context evitan tener que hacerlo de esta forma (aunque implementar estas tecnologías para algo tan simple no es recomendado. Algunas las estaremos viendo en este curso)</li>
                  <li></li>
                </ul>
              </li>
            </ul>

            <p>Supongamos que tenemos un componente llamdo &lt;Header/&gt;. La sintaxis de los Props es como sigue: la parte de la izquierda del "=" es como lo vamos a llamar y poder acceder en el componente hijo, es decir en Header. Lo del lado derecho entre llaves es la información necesaria para ese componente que le vamos a pasar (datos, state, funciones, objetos...).</p>

            <pre><code class="language-js">
              &lt;Header
                nombreProp=&lcub; datos / state o Funciones &rcub;
              /&gt;
            </code></pre>

            <p>Podemos tener múltiples Props, veamos un componente llamado Users:</p>
            <pre><code class="language-js">
              &lt;Users
                users=&lcub; users &rcub;
                setUsers=&lcub; setUsers &rcub;
                title="Listado de Usuarios"
              /&gt;
            </code></pre>

            <p>Implementemos Props en nuestro componente de guitarras &lt;Guitar /&gt;. Le añadimos este Props a nuestro componente:</p>
            <pre><code class="language-js">
              &lcub;data.map(() =&gt; (                    
                &lt;Guitar
                  price = &lcub;100&rcub;
                /&gt;
              )
              )&rcub;		
            </code></pre>

            <p>A nuestro componente Guitar.jsx hemos de añadirle como parámetro la palabra reservada <strong>props</strong>. Si hacemos un console log (antes del return()) de ese props veremos en la consola  ese {price: 100}; viene como un objeto porque le podemos pasar múltiples props. También lo podemos ver en la pestaña de components de React Developer Tools</p>
            <pre><code class="language-js">
              export default function Guitar(props){
                console.log(props)
                return(
            </code></pre>

            <img class="my-2.5" src="./src/assets/img/63-props1.jpg" alt="" />

            <p>Pasémosle más de un props:</p>
            <pre><code class="language-js">
              &lcub;data.map(() =&gt; (                    
                &lt;Guitar
                  price = &lcub;100&rcub;
                  auth = true;
                /&gt;
              )
              )&rcub;		
            </code></pre>
            <p>¿Cómo puedo acceder individualmente a estos valores <strong>price</strong> y <strong>auth</strong>? Como es un objeto:</p>
            <pre><code class="language-js">
              export default function Guitar(props){
                console.log(props.price)
                console.log(props.auth)
                return(
            </code></pre>

            <p>Pero incluso mejor, podemos aplicar destructuring:</p>
            <pre><code class="language-js">
              export default function Guitar({price,auth}){
                console.log(price)
                console.log(auth)
                return(
            </code></pre>

            <p class="naranja">Mostrando la Información de cada Guitarra</p>

            <p>Tenemos el array db.js y cada uno tiene un objeto con la información de cada guitarra. Estamos utilizando un map() para iterar en él así que vamos a acceder a cada uno de esos objetos (en la función de flecha le ponemos el nombre que queramos por ejemplo <strong>guitar</strong>). Creamos el prop guitar y le pasamos como valor el objeto guitar (explica que no hay ningún inconveniente en tener mismo nombre de prop que del objeto que deseas pasarle al prop):</p>

            <pre><code class="language-js">
              const &lsqb;data&comma; setData&rsqb; = useState(db)

              &lcub;data.map((guitar) =&gt; (                    
                &lt;Guitar
                  guitar = &lcub;guitar&rcub; 
                  key = &lcub;guitar.id&rcub; // Cuando iteremos en una lista, React nos requiere que siempre utilicemos un prop especial llamado <strong>key</strong> y pasarle un valor único.                      
                /&gt;
              )
              )&rcub; 
            </code></pre>
            <p>Si hacemos un console.log(props) veremos que tenemos un prop que va a tener el objeto de guitarra</p>
            <pre><code class="language-js">
              export default function Guitar(props){
              console.log(props)
            </code></pre>

            <p>Si aplicamos destructuring quedaría así y en la consola ya vemos que aparece la información propia de cada guitarra:</p>
            <pre><code class="language-js">
              export default function Guitar({guitar}){
              console.log(guitar)
            </code></pre>
            <img class="my-2.5" src="./src/assets/img/66-1.jpg" alt="" />

            <p>Para cada elemento html que teníamos en el código estático (nombre, imagen, precio...) que queremos que cargue de forma dinámica hacemos el reemplazo por ejemplo el nombre de la  guitarra que está en el h3, 'Lukather', lo cambiamos por <code class="language-js">{guitar.name}</code>. Si actualizamos el navegador vemos que cada guitarra ya muestra un nombre diferente, porqeu ya estamos leyendo la información de nuestra pequeña base de datos. <span class="destacado">Así vemos el beneficio de los props junto al state junto a emplear array methods para iterar en nuestro state --> crear componentes reutilizables optimizando el código a escribir</span></p>

            <p>En vez de llamar cada dato así <code class="language-js">{guitar.name}</code>, creemos una variable cont nueva para hacer destructuring del objeto guitar que recibimos como propiedad del compoennte padre App.jsx y simplificar el código de la siguiente manera:</p>
              
            <pre><code class="language-js">
              export default function Guitar({guitar}){

                const { id, name, image, description, price } = guitar		
            </code></pre>

            <p>Hago unos leves cambios de nombre con respecto a lo explicado para rastrear mejor lo que estoy haciendo:</p>

            <img class="my-2.5" src="./src/assets/img/66-2.jpg" alt="" />

            <p>En el siguiente video comenzamos con el carrito de la compra.</p>
          </div>
          <!-- Fin bloque desplegable interior-->


          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-67').toggle();">	
            <h3>67. Eventos en JSX / 68. Creando un State de Carrito / 69. Agregando Guitarras al Carrito / 70. Detectar si un elemento existe en el carrito / 71. Agregando guitarras al Carrito con Cantidad / 72. Incrementando cantidad si un articulo ya estaba agregado</h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-67" class="hidden">

            <p class="naranja">Eventos en JSX</p>

            <p>Cuando presione en cada guitarra se tienen que ir listando en el carrito. En ese carrito tenemos que poder ajustar la cantidad y eliminar los que queramos. Si tienes exp en js eso se hace con un addEventListener</p>

            <p class="font-bold">Sobre los eventos en React</p>
            <ul class="mb-3.75">
              <li>La forma en que React maneja los eventos es muy similar a como lo hace JavaScript de forma nativa con algunos cambios.</li>
              <li><strong>Los eventos son camelCase</strong>, es decir en lugar de <strong>onclick</strong> <span class="destacado">onClick</span>, en lugar de <strong>onchange</strong>, <span class="destacado">onChange</span></li>
              <li>A diferencia de JS y HTML en los que se coloca el nombre de la función en un string, <strong>en React (JSX) se utiliza la función entre llaves <span class="destacado">{}</span></strong></li>
              <li>Ejemplo click en HTML: <code class="language-html">&lt;button onclick=&quot;getLatestOrders()&quot;&gt;Descargar pedidos&lt;/button&gt;</code></li>
              <li>Ejemplo click en React(JSX): <code class="language-js">&lt;button onClick=&lcub;getLatestOrders()&rcub;&gt;Descargar pedidos&lt;/button&gt;</code><br>Esa función se recomienda que esté <strong>en el mismo componente antes del return()</strong> o <strong>en un Hook personalizado, otro archivo</strong></li>
              <li>Ejemplo submit en HTML: agregarCliente() es la función que va a procesar un formulario de ajax o FetchAPI; también le colocamos un return false): 
              <pre><code class="language-html">
                &lt;form onsubmit=&quot;agregarCliente()&semi; return false&quot;&gt;
                  &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt;
                &lt;/form&gt;
              </code></pre>
              </li>
              <li>Ejemplo submit en React(JSX): como vemos hay una convención (similar a cuando en los states nombramos las funciones correspondientes del estate con la palabra<strong><span class="destacado">set</span>NombreState</strong>), y para eventos se recomienda usar la palabra <strong><span class="destacado">handle</span>NombreEvento</strong>
                <pre><code class="language-html">
                  &lt;form onSubmit=&lcub;handleSubmit&rcub;&gt;
                  &lt;button type=&quot;submit&quot;&gt;A&ntilde;adir cliente&lt;/button&gt;
                &lt;/form&gt;				
                </code></pre>
                </li>
            </ul>

            <p class="font-bold">Vamos a registrar un evento en nuestras guitarras</p>
            <p>Como cuando yo presione en agregar al carrito quiero realizar una acción, <strong>vamos a agregarle/registrarle a nuestro botón el evento de onClick</strong>:</p>

            <pre><code class="language-js">
              const handleClick = () => {
                console.log('Diste click')
              }
            </code></pre>
            <pre><code class="language-html">
              &lt;button 
              type=&quot;button&quot;
              className=&quot;btn btn-dark w-100&quot;
              onClick={handleClick}
            &gt;Agregar al Carrito&lt;/button&gt;		
            </code></pre>

            <p>Me gustaría poder identificar desde qué guitarra estoy haciendo click. ¿Cómo le pasamos un valor para identificar un parámetro o um argumento? Podríamos añadir paréntesis con el id dentro <code class="language-js">onClick={handleClick(id)}</code> ya que el id lo tenemos en la destructuración del prop "propguitar" <code class="language-js">const { id, name, image, description, price } = propguitar</code>. Hagamos que la función handleClick reciba ese argumento y lo vemos en consola. Vemos en la consola que salen TODOS los clicks porque esta expresión <code class="language-js">onClick={handleClick(id)}</code> está mandando llamar la función, no espera que ocurra el evento</p>

            <p><strong>Cuadno tenemos argumentos, si tenemos funciones que toman parámetros, hay que colocar en la llamada un callback, por ejemplo un arrow function, <code class="language-js">onClick={() =>handleClick(id)}</code> y de esa forma ya no se manda llamar en automático sino que espera el evento.</strong></p>

            <p>Mejor vamos a pasarle como argumento, en vez de solo el id, todo el objeto de guitarra: <code class="language-js">onClick={() => handleClick(guitar)}</code> y miramos la consola donde nos sale toda la información:</p>
            
            <div class="flex">
              <div class="w-50 w-100-s">	
                <p class="verde">Guitar.jsx</p>:
                <pre><code class="language-js">
                  export default function Guitar({propguitar}){

                    const { id, name, image, description, price } = propguitar
                  
                    const handleClick = (algo) => {
                      console.log('Diste click', algo)
                    }
                  
                    return(
                      &lt;div className=&quot;col-md-6 col-lg-4 my-4 row align-items-center&quot;&gt;
                        &lt;div className=&quot;col-4&quot;&gt;
                          &lt;img className=&quot;img-fluid&quot; src=&lcub;&grave;/img/$&lcub;image&rcub;.jpg&grave;&rcub; alt=&quot;imagen guitarra&quot; /&gt;
                        &lt;/div&gt;
                        &lt;div className=&quot;col-8&quot;&gt;
                          &lt;h3 className=&quot;text-black fs-4 fw-bold text-uppercase&quot;&gt;&lcub;name&rcub;&lt;/h3&gt;
                          &lt;p&gt;&lcub;description&rcub;&lt;/p&gt;
                          &lt;p className=&quot;fw-black text-primary fs-3&quot;&gt;$&lcub;price&rcub;&lt;/p&gt;
                          &lt;button 
                            type=&quot;button&quot;
                            className=&quot;btn btn-dark w-100&quot;
                            onClick=&lcub;() = &gt;handleClick(propguitar)&rcub;
                          &gt;Agregar al Carrito&lt;/button&gt;
                        &lt;/div&gt;
                      &lt;/div&gt;
                    )
                  }
                </code></pre>	
                <img class="my-2.5" src="./src/assets/img/67.png" alt="" />
              </div>

              <div class="w-50 w-100-s">
                <p class="verde">App.jsx:</p>
                <pre><code class="language-js">
                  import &lcub; useState&comma; useEffect &rcub; from &quot;react&quot;
                  import Guitar from &quot;../components/Guitar&quot;
                  import Header from &quot;../components/Header&quot;
                  import &lcub; db &rcub; from &quot;./data/db&quot;
                  
                  function App() &lcub;
                  
                    //console.log(db)
                    const &lsqb;data&comma; setData&rsqb; = useState(db)
                  
                    // const &lsqb;data&comma; setData&rsqb; = useState(&lsqb;&rsqb;)
                    // useEffect( () =&gt; &lcub;
                    //     setData(db)
                    // &rcub;&comma;&lsqb;&rsqb;)
                  
                    return (
                      &lt;&gt;   
                      &lt;Header/&gt;
                    
                      &lt;main className=&quot;container-xl mt-5&quot;&gt;
                        &lt;h2 className=&quot;text-center&quot;&gt;Nuestra Colecci&oacute;n&lt;/h2&gt;
                  
                        &lt;div className=&quot;row mt-5&quot;&gt;
                          &lcub;data.map((guitar) =&gt; (                    
                            &lt;Guitar
                              propguitar = &lcub;guitar&rcub; 
                              key = &lcub;guitar.id&rcub;                       
                            /&gt;
                          )
                          )&rcub;         
                        &lt;/div&gt;
                      &lt;/main&gt;
                  
                      &lt;footer className=&quot;bg-gray-300 mt-5 py-5&quot;&gt;
                        &lt;div className=&quot;container-xl&quot;&gt;
                          &lt;p className=&quot;text-white text-center fs-4 mt-4 m-md-0&quot;&gt;GuitarLA - Todos los derechos Reservados&lt;/p&gt;
                        &lt;/div&gt;
                      &lt;/footer&gt;        
                      &lt;/&gt;
                    )
                  &rcub;
                  
                  export default App
                </code></pre>
              </div>
            </div>

            <p class="naranja">Creando un State de Carrito</p>

            <p>Veamos como agregar nuestras guitarras. Hagamos un state nuevo de carrito. No es bueno tener 30 o 40 states (en esos casos quizás sean mejores otras opciones como sustain, J, Context API o como Redux Toolkit). Sin embargo, tampoco se recomienda tener un solo state muy grande, porque tener un state muy grande te va a llevar a tener que escribir una lógica muy grande cuando quieras actualizar o modificar ese state.</p>

            <p>lo creamos en nuestro componente de App.jsx (no lo creamos en Guitar.jsx. cada guitarra es un componente distinto y si crearar ahí un state de carrito tendría 12 diferentes :D). Como va a ser un carrito de compras su valor inicial será un Array vacío <code class="language-js">const [cart, setCart] = useState([])</code> de manera que vamos a tener acceso a ciertos métodos de array para agregar elementos, eliminarlos, revisar si ya existe un elemento y evitar duplicados, si está vacío. <span class="destacado">Son muchos los beneficios de utilizar el tipo de dato adecuado a nuestro state inicial</span>. Si abrimos la pestaña componentes de React Developer Tools vemos que en el componente App tenemos nuestro state de guitarras, pero también este nuevo state de carrito que está vacío (con lo cual, se registró correctamente).</p>

            <p>¿Cómo agregamos elementos a nuestro carrito? tenemos varias formas de hacerlo:</p>

            <ul class="mb-3.75">
              <li>la más simple: para agregar elementos a nuestro state "cart" vamos a tener que utilizar simepre la función "setCart". El evento de agregarlos se está presentando en el componente Guitar.jsx. Recordemos que podemos pasar vía props desde el componente padre App.jsx strings, objetos y <strong>funciones</strong>, así que pasamos nuestra función setCart del state cart <span class="verde">App.jsx:</span>
                <pre><code class="language-js">
                  &lcub;data.map((guitar) =&gt; (                    
                    &lt;Guitar
                      key = &lcub;guitar.id&rcub; 
                      propguitar = &lcub;guitar&rcub; 
                      setCart = &lcub;setCart&rcub;                          
                    /&gt;
                  )
                  )&rcub;
                </code></pre>
                <span class="verde">Guitar.jsx:</span> <code class="language-js">export default function Guitar({propguitar, setCart}){</code>
              <img class="my-2.5" src="./src/assets/img/68-1.png" alt="" /></li>
              <li>otra forma de hacerlo: tenemos en el botón nuestro <code class="language-js"> onClick={() => handleClick(propguitar)}</code> modificamos la función para pasarle la guitarra a nuestro state cart: <span class="destacado">esperamos que ocurra el click, cuando pinchas se le pasa la guitarra y seteamos al carrito</span>
              <pre><code class="language-js">
                const handleClick = (guitar) => {
                  setCart(guitar)
                }			
              </code></pre>
              <p>cada vez que pinchamos se modifica el state agregando el objeto guitarra, pero si presiono otro reemplaza lo que hay, y en un carrito no queremos reemplazar sino agregar. Lo está escribiendo correctamente pero tenemos que mantener lo que ya teníamos en el carrito. En vez de un objeto quiero que me escriba un array pero nos seguirá pasando lo mismo, cada vez que pulsemos una guitarra reemplazará a la anterior en el state cart:</p>
              <img class="my-2.5" src="./src/assets/img/68-2.png" alt="" />
              <p>¿Como hago para que los datos que agregué al carrito persistan? Tenemos que tener la referencia de nuestro state de carrito cart, así que lo pasamos desde nuestro componente padre App.jsx al componente Guitar.jsx: <span class="verde">App.jsx:</span></p>
              <pre><code class="language-js">
                &lcub;data.map((guitar) =&gt; (                    
                  &lt;Guitar
                    key = &lcub;guitar.id&rcub; 
                    propguitar = &lcub;guitar&rcub; 
                    cart = &lcub;cart&rcub;
                    setCart = &lcub;setCart&rcub;                          
                  /&gt;
                )
                )&rcub;
              </code></pre>
              <span class="verde">Guitar.jsx:</span> <code class="language-js">export default function Guitar({propguitar, cart, setCart}){</code>
              <img class="my-2.5" src="./src/assets/img/68-3.png" alt="" />
              </li>
              <li>Otra manera: eliminemos la función 
                <pre><code class="language-js">
                  const handleClick = (guitar) => {
                    setCart([...cart, guitar])
                  }			
                </code></pre>
                y llamarla directamente en el onClick: <code class="language-js">onClick={() => setCart([...cart, propguitar])}</code>. <span class="destacado">Algo importante es que ese <strong>setCart</strong> ya sabe lo que hay en el state. Desde que declaramos el state de cart esa función setCart siempre va a estar asociada con ese estate de carrito (sabe de su existencia, sabe qué hay, sabe que tiene que escribir en ese cart, nunca se va a mezclar con otras de otros states.) Por tanto no haría falta pasarle como propiedad el carrito (la función ya sabe lo que tiene).</span> En la nueva función de flecha nótese la convención de nombre <strong>prev</strong>Cart por tanto quedaría así <br><code class="language-js">onClick={() => setCart(prevCart =>[...prevCart, propguitar])}</code><br> No tenemos que pasar el state, la función setCart toma la copia del state actual</li>
              </ul>

            
              <p class="naranja">Agregando Guitarras al Carrito</p>

              <p>Con el enfoque actual, se hace un poco complicado porque tendríamos que añadir lógica en la llamada del onclick para revisar si un registro está duplicado o no etc... y no queremos lógica en nuestros templates. Para tener lógica usamos la parte de antes del return() o un Hook aparte. Cambiemos el enfoque y modifiquemos nuesto código:</p>

              <p>En App.jsx antes del return creamos una nueva función intermedia que sea más descriptiva de loq ue se está haciendo y en donde con cierta lógica podamos evitar problemas ocmo elementos duplicados etc: <strong>function addToCart(){}</strong> y la pasamos como prop para que esté disponible para otros componentes de manera que se pueda agregar ese elemento al carrito. Al parámetro lo llamamos <strong>item</strong> también por convención para reutilización de lógica de carrito.</p>

              <pre><code class="language-js">
                function addToCart(item){
                  setCart(prevCart =>[...prevCart, item])
                }
              </code></pre>

              <p class="naranja">Detectar si un elemento existe en el carrito</p>

              <p>No queremos tener registros duplicados en un carrito de compras ¿como lo evitamos? antes de setear al carrito de compras hemos de verificar si ese elemento ya existe en el Array, si existe actualizaremos la cantidad y si no existe lo agregamos. Esto nos lleva a un tema que es muy importante en React <span class="destacado">¿Qué significa la inmutabilidad en React?</span> ¿qué significa que un state es inmutable? Si vemos la función que acabamos de crear. setCart(prevCart =>[...prevCart, item]) <strong>no estamos modificando el state, tomamos una copia del state y agregamos el nuevo elemento</strong>. Otros array methods que nos permiten añadir elementos a un array serían por ejemplo <strong>cart.push(item): sin embargo esto modifica el state original</strong>. Y nuestro state tiene que ser inmutable. Por eso siempre se utiliza la función asociada al state. Incluso si utilizáramos la función e hiciéramos algo como setCart(prevCart => cart.push(item) estaríamos modificando el state original. Para saber qué array methods de js mutan el state original y cuales no consultamos: <a href="https://doesitmutate.xyz/" class="text-[#000000]" target="blank">https://doesitmutate.xyz/</a>
              </p>

              <p>Para saber si ya existe un elemento en un array vamos a usar el método de arrays <span class="destacado">.findIndex()</span> que no provoca mutación; va a iterar sobre nuestro carrito de compras cart y va ir creando un objeto temporal que por ejemplo llamamos "guitar" (no lo llamamos item porque nuestra función ya tiene un parámetro que se llama así y provocaríamos confusión). En la parte derecha del arrow function añadimos la comprobación de si el elemento nuevo que estamos añadiendo es el mismo que ya existe en mi state. <strong>Si el elemento está presente en el array devuelve el índice que ocupa en el array y si no lo encuentra devuelve -1</strong>. En este punto nuestra función va así y hagamos un console.log() para entenderlo.</p>

              <pre><code class="language-js">
                function addToCart(item){
                  const itemExists = cart.findIndex(guitar => guitar.id === item.id) // ese "guitar" es el nombre que queramos poner
                  console.log(itemExists)
              
                  setCart(prevCart =>[...prevCart, item])
                }			
              </code></pre>

              <p>Como vemos haga lo que haga, de momento seguimos seteando elementos al state. Tendremos que meter una comprobación para antes de setear, si existe en el array actualizaremos la cantidad y si no existe lo agregamos.</p>

              <p class="naranja">Agregando guitarras al Carrito con Cantidad</p>

              <p>Agreguemos la cantidad de guitarras para poder reflejarlo en el carrito.</p>
              <pre><code class="language-js">
                function addToCart(item){
                  const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                  if(itemExists >= 0){//existe en cart
                    console.log('ya existe')            
                  } else{
                    //console.log('NO EXISTE, agregando...')
                    item.quantity = 1
                    setCart(prevCart =>[...prevCart, item])
                  }       
                }	
              </code></pre>

              <p class="naranja">Incrementando cantidad si un artículo ya estaba</p>
              <p>Cuando ya existe, hemos de tener cuidado en no romper ciertas reglas del state. Por ejemplo si en nuestra función añadiéramos esto cuando el elemento existe:
              <code class="language-js">cart[itemExists].quantity++</code> <span class="rojo">¡estaríamos modificando directamente nuestro state!</span></p>
              <pre><code class="language-js">
                function addToCart(item){
                  const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                  if(itemExists >= 0){//existe en cart
                    console.log('ya existe')  
                    cart[itemExists].quantity++ //estaríamos modificando nuestro estate ¡Y EL STATE ES INMUTABLE!!         
                  } else{
                    //console.log('NO EXISTE, agregando...')
                    item.quantity = 1
                    setCart(prevCart =>[...prevCart, item])
                  }       
                }
              </code></pre>

              <p>creamos una copia del carrito usando el spread operator, incrementamos la cantidad y seteamos:</p>
              <pre><code class="language-js">
                function addToCart(item){
                  const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                  if(itemExists >= 0){//existe en cart
                    const updatedCart = [...cart] //copia nueva de mi state, no modifica mi carrito       
                    updatedCart[itemExists].quantity++
                    setCart(updatedCart)
                  } else{//NO EXISTE en cart
                    item.quantity = 1
                    setCart(prevCart =>[...prevCart, item])
                  }       
                }
              </code></pre>
            
          </div>
          <!-- Fin bloque desplegable interior-->

          
          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-81').toggle();">	
            <h3>73. Mostrando los Contenidos del carrito / 74. Detectando si el carrito está vacío / 75. State derivado / 76. Calculando el Total a pagar / 77. useMemo para mejorar el performance de nuestro código / 78. Eliminando artículos del carrito / 79/80. Creando una Función para Incrementar las cantidades y RETO 01 / 81. Función limpiar carrito</h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-81" class="hidden">
            <p>Vamos a empezar a hacer dinámica la sección del carrito de compra. Está en nuestro Header.jsx, vamos a hacer dinámica esta parte y sincronizarla con nuestro state. En nuestro componente App.jsx, al Header le vamos a pasar el carrito <strong>el prop se va a llamar cart y el valor también cart, para no tener que pensar en nombres diferentes es recomendable ponerl el mismo que tiene ese state</strong>.</p>
            <pre><code class="language-js">
              &lt;Header
              cart = &lcub;cart&rcub;
            /&gt;
            </code></pre>

            <pre><code class="language-js">
              export default function Header({cart}){
            </code></pre>

            <p>la estructura del carrito es con una tabla. Iteramos en el tbody para que genere un tr por cada elemento en nuestro carrito:</p>
            <pre><code class="language-js">
              &lcub;cart.map( guitar =&gt;( 
                &lt;tr&gt;
                  &lt;td&gt;
                    &lt;img className=&quot;img-fluid&quot; src=&quot;./public/img/guitarra&lowbar;02.jpg&quot; alt=&quot;imagen guitarra&quot; /&gt;
                  &lt;/td&gt;
                  &lt;td&gt;SRV&lt;/td&gt;
                  &lt;td className=&quot;fw-bold&quot;&gt;
                      $299
                  &lt;/td&gt;
                  &lt;td className=&quot;flex align-items-start gap-4&quot;&gt;
                    &lt;button
                      type=&quot;button&quot;
                      className=&quot;btn btn-dark&quot;
                    &gt;
                      -
                    &lt;/button&gt;
                      1
                    &lt;button
                      type=&quot;button&quot;
                      className=&quot;btn btn-dark&quot;
                    &gt;
                      &plus;
                    &lt;/button&gt;
                  &lt;/td&gt;
                  &lt;td&gt;
                    &lt;button
                      className=&quot;btn btn-danger&quot;
                      type=&quot;button&quot;
                    &gt;
                      X
                    &lt;/button&gt;
                  &lt;/td&gt;
                &lt;/tr&gt;
              ))&rcub;
            </code></pre>

            <p>Comenta sobre la posibilidad de que este tr lo hiciéramos componente y habla sobre el inconveniente de tener demasiados componentes pequeños, tener que andar enviando y manejando demasiados props (que se podría manejar con Redux toolkit o manejador de estado global pero aún no hemos visto ese tema ni conviene para un proyecto tan pequeño como este.) </p>

            <img class="my-2.5" src="./src/assets/img/73.png" alt="" />

            <p>no lo estoy pasando via props, pero el objeto <strong>guitar</strong> existe dentro de ese paréntesis y puedo acceder a sus propiedades. Si vemos en consola nos da un aviso de id único para Header. Tenemos que darle un key único al tr.</p>
            
            <pre><code class="language-js">
              &lt;tbody&gt;
              &lcub;cart.map( guitar =&gt;( 
              &lt;tr key=&lcub;guitar.id&rcub;&gt;
                &lt;td&gt;
                  &lt;img className=&quot;img-fluid&quot; src=&lcub;&grave;/img/$&lcub;guitar.image&rcub;.jpg&grave;&rcub; alt=&quot;imagen guitarra&quot; /&gt;
                &lt;/td&gt;
                &lt;td&gt;&lcub;guitar.name&rcub;&lt;/td&gt;
                &lt;td className=&quot;fw-bold&quot;&gt;
                    $&lcub;guitar.price&rcub;
                &lt;/td&gt;
                &lt;td className=&quot;flex align-items-start gap-4&quot;&gt;
                  &lt;button
                    type=&quot;button&quot;
                    className=&quot;btn btn-dark&quot;
                  &gt;
                    -
                  &lt;/button&gt;
                    &lcub;guitar.quantity&rcub;
                  &lt;button
                    type=&quot;button&quot;
                    className=&quot;btn btn-dark&quot;
                  &gt;
                    &plus;
                  &lt;/button&gt;
                &lt;/td&gt;
                &lt;td&gt;
                  &lt;button
                    className=&quot;btn btn-danger&quot;
                    type=&quot;button&quot;
                  &gt;
                    X
                  &lt;/button&gt;
                &lt;/td&gt;
              &lt;/tr&gt;
              ))&rcub;
            &lt;/tbody&gt;
            </code>
            </pre>

            <p class="naranja">Detectando si el carrito está vacío</p>
            <p>¿Hemos de crear un state para eso? no es necesrio crear un state para cada cosa. Veamos un par de alternativas para hacer esto. Estamos pasando como prop desde App.jsx nuestro cart, y en el código del componente Header.jsx iteramos el tr sobre cart. <span class="destacado">En este punto podemos escribir un ternario</span>. <strong>Como vimos en la parte de statements y expresiones, no podemos tener un if pero sí un ternario</strong>:</p>
            <pre><code class="language-js">
              &lcub;cart.length === 0 ? (
                &lt;p className=&quot;text-center&quot;&gt;El carrito esta vacio&lt;/p&gt;                                            
                ):( 
                //El resto de la tabla
              )&rcub;
            </code></pre>
            <p>También podemos usar un state derivado en lugar de ese <code class="language-js">cart.length === 0</code></p>

            <p class="naranja">State derivado</p>

            <p>Algunas veces queremos derivar el state. Actualmente tenemos nuestro state de carrito <code class="language-js">const [cart, setCart] = useState([])</code>. En lugar de crear un state nuevo que estemos revisando y su valor dependa de que cart tenga algo, podemos crear una variable/funcion cuyo valor vaya a depender mucho de este otro state. Lo podemos tener ¿en el return del App.jsx? o en el Header.jsx donde lo usamos (opta por esta). La idea es mantener la lógica fuera del template:</p>

            <pre><code class="language-js">
              export default function Header({cart}){

                //State derivado
                const isEmpty = () => cart.length === 0

                {isEmpty() ? (
                  &lt;p className=&quot;text-center&quot;&gt;El carrito esta vacio&lt;/p&gt;                                            
                ):( 
                //El resto de la tabla
                )}        
            </code></pre>

            <p class="naranja">Calculando el Total a pagar</p>			
            <p>Metemos el párrafo en la parte del ternario que renderiza la tabla. <strong>nos dará error porque necesitamos tener un único elemento en el nivel superior, metemos un fragment que englobe a la tabla+p</strong>. Para calcular el total a pagar vamos a utilizar un array method llamado <span class="destacado">reduce()</span>. Lo utilizamos para construir este state derivado de lo que tenemos en el carrito de compras:</p>

            <pre><code class="language-js">
              const isEmpty = () => cart.length === 0
              const cartTotal = () => cart.reduce( (total, item) => total + (item.quantity * item.price), 0)
            </code></pre>

            <p>Es uno de los pocos array methods que toma dos parámetros, uno es el total ,es decir un acumulado, va a ir iterando sobre cada elemento que tenemos en el carrito; el segundo parámetro <strong>item</strong> es el elemento actual. En el arrow function siguiente al total acumulado le vamos sumando el resultado de multiplicar la cantidad de item * precio de item. el valor <strong>0</strong> es el valor inicial; el carrito inicia en 0 y a apartir de ahí sumamos.</p>

            <p>Si no quisiéramos llamar estas funciones isEmpty() y carTotal() podríamos hacer uso de un Hook que se llama useMemo que también es bastante común</p>

            <p class="naranja">useMemo para mejorar el performance de nuestro código</p>

            <p>Si tenemos experiencia con Vue.js sabremos que hay algo que se llama compute properties y useMemo hace algo bastante similar:</p>
            <ul class="mb-3.75">
              <li>Simplifica los templates un poco</li>
              <li>Es un Hook enfocado al performance porqeu evita que este código se ejecute (los 2 states derivados vistos) si alguna de las dependencias que vamos a deifnir en ese useMemo no ha cambiado.</li>
            </ul>
            <p><strong>Importamos esl Hook useMemo en nuestro componente Header.jsx:</strong> <code class="language-js">import { useMemo } from 'react'</code>. Vamos a usarlo en nuestro state derivado isEmpty. useMemo es una función que toma dos parámetros (un factory que es la función y el array de dependencias), los vemos explicados si nos colocamos en VSC encima de useMemo:</p>
            <img class="my-2.5" src="./src/assets/img/77-useMemo.png" alt="" />
            <pre><code class="language-js">
              const isEmpty = useMemo( () => cart.length === 0, [cart])
            </code></pre>

            <p>Este código no va a cambiar hasta que cambien ciertas partes de nuestro código. ¿Qué imporancia tiene esto? React siempre va ahacer un render completo de nuestra aplicación. Si presionamos en agregar al carrito, hace un render completo donde tengas el state. Eso puede suponer mucho coste en términos de rendimiento, hacer que nuestra aplicación sea más lenta...entonces <span class="destacado">useMemo es una forma de decirle: "no haghas render completo de mi aplicación hasta que no cambie algo que yo te voy a decir qué es; para eso es el arreglo de dependencias y en concreto este código anterior le dice "vuelve a ejecutar este código, a hacer el render cuando cart cambie, cada vez que añadamos, eliminemos, modificamos algo del carrito"</span>. Como isEmpty ya no es una función, eliminamos en nuestro template esto <code class="language-js"> isEmpty() </code>y en su lugar lo llamamos así <code class="language-js"> isEmpty</code></p>

            <p>Hacemos lo mismo con el state derivado carTotal, porque queremos que el Total se calcule solo cuando el carrito cambie:</p>
            <pre><code class="language-js">
              const isEmpty = useMemo( () => cart.length === 0, [cart])
            </code></pre>

            <p>useMemo no es un Hook que vayamos a utilizar en todos sitios, es un Hook enfocado a performance pero por el hecho de que cachea esos resultados entre renders, <strong>a veces puede ser contraproducente cachear tanto. Hay que probar según el caso y vigilar nuestro state. Si no se actualiza como esperamos lo quitamos y/o valorar otras opciones apra trabajar con caché en nuestros componentes</strong>.</p>

            <p class="naranja">Eliminando artículos del carrito</p>

            <p>Lo primero que tenemos que hacer es crear una función. El carrito está en el componente <strong>App.jsx</strong> y el botón para eliminar está en el componente <strong>Header.jsx</strong>. Creemos la función en el componente principal y la pasaremos via <strong>props</strong>. Comprobemos de momento con un console.log() sin más que la comunicación entre nuestro botón eliminar del Header y la nueva función creada es correcta. <span class="destacado">Como ya hemos hecho antes, al pasar el prop lo nombramos igual que nuestra función así nos quitamos de tener que pensar en varios nombres (yo en un ejemplo anterior con el objeto guitar le puse al nombre del prop "propguitar" pero era mientras me acostumbraba  a todo esto para no perder la referencia de lo que estaba haciendo).</span></p>

            <pre><code class="language-js">
              //antes del return
              function removeFromCart(){
                console.log('Eliminando...')
              }
              
              //en el return llamando a nuestro componente
              &lt;Header
              cart = &lcub;cart&rcub;
              removeFromCart = &lcub;removeFromCart&rcub;
            /&gt;      
            </code></pre>

            <p>Nos vamos ahora a nuestro componente Header.jsx y primero vamos a tomar esa función, aplicamos destructuring a esa función:</p>

            <pre><code class="language-js">export default function Header({cart, removeFromCart}){</code></pre>

            <p>la asociamos con el botón de eliminar. Vamos a esperar que el usuario presione en él por tanto colocamos en el un onClick y pasamos el nombre de la función: <code class="language-js"></code></p>

            <pre><code class="language-html">
              &lt;button
                className=&quot;btn btn-danger&quot;
                type=&quot;button&quot;
                onClick=&lcub;removeFromCart&rcub;&gt;
              X
              &lt;/button&gt;
            </code></pre>

            <p>Si pulsamos ya vemos en la consola el mensaje que hemos puesto para verificar que hay comuniación. ¿Cçomo eliminamos elementos? Estamos almacenando todo en este arreglo de cart. <span class="destacado">Vamos a utilizar un array method que nos permita sacar elementos de ese arreglo y uno muy común que no muta nuestro state es .filter()</span> Nos va a permitir filtrar en base a una condición. Por ejemplo pensemos en los id. Para ello tenemos que pasarle un parámetro:</p>
            <ul class="mb-3.75">
              <li>le pasamos un parámetro a la función:
                <pre><code class="language-js">
                  //antes del return
                  function removeFromCart(id){
                    console.log('Eliminando...', id)
                  }
                </code></pre></li>
              <li><span class="destacado">si le pasamos un parámetro en el onclick hay que ponerle un callback y le pasamos guitar.id, y de esa forma vamos a poder identificar qué elemento es el que estamos presionando para eliminarlo de nuestro carrito de compras.</span>
                <pre><code class="language-html">
                  &lt;button
                    className=&quot;btn btn-danger&quot;
                    type=&quot;button&quot;
                    onClick=&lcub;() =&gt; removeFromCart(guitar.id)&rcub;
                  X
                  &lt;/button&gt;
                </code></pre>          
              </li>
            </ul>

            <p>podríamos crear una nueva variable con lo que nos retorna el filter() pero también podemos hacerlo en una sola función: si lo pasamos como callback aquí vamos a tener el valor previo de nuestro carrito. Le aplicamos el método filter() y le indicamos que nos filtre las guitarras cuo id sea diferente al que le pasamos; ello regresa el nuevo arreglo y lo setea en nuestra función.</p>

            <pre><code class="language-js">
              function removeFromCart(id){
                //console.log('Eliminando...', id)      
                setCart(prevCart => prevCart.filter(guitar => guitar.id !== id))
            }
            </code></pre>

            <p>Si probamos a eliminar una guitarra vemos que se elimina del carrito y que además el total se actualiza. Recordemos que <strong>carTotal es un state derivado, tiene un useMemo y como dependencia el cart, también se vuelve a ejecutar y calcula el total a pagar de nuestro carrito de compra.</strong>. Si las eliminamos todas vemos que sale lo de que el carrito está vacío, porque también se ejecuta nuestro otro state derivado <strong>isEmpty</strong>.</p>

            <p>Vemos lo sencillo que es con react mantener sincronizado nuestro state con nuestra interfaz, no hay que llamar a ninguna función para refrescar nuestra interfaz, automáticamente lo hace por nosotros.</p>

            <p class="naranja">Creando una Función para Incrementar las cantidades y RETO 01</p>
            <p>Creamos una nueva función intermedia desriptiva que nos sirva para manejar la lógica. toma un id porque requerimos identificar el elemento. Como está en el Header, la pasamos via prop usando el mismo nombre:</p>

            <pre><code class="language-js">
              function increaseQuantity(id)&lcub;
              console.log(&apos;Incrementando...&apos;&comma; id)
            &rcub;
            
            return (
              &lt;&gt;   
              &lt;Header
                cart = &lcub;cart&rcub;
                removeFromCart = &lcub;removeFromCart&rcub;
                increaseQuantity = &lcub;increaseQuantity&rcub;
              /&gt;
            </code></pre>

            <p>Extraemos la nueva prop en la declaración de la función de nuestro componente Header: <code class="language-js">export default function Header({cart, removeFromCart, increaseQuantity}){</code>. En el código del return donde está el botón "+" para incrementar le añadimos el onClick con su función de flecha que llama a ese prop pasándole como argumento el id de la guitarra que se pulsa:</p>

            <pre><code class="language-js">
              &lt;button
              type=&quot;button&quot;
              className=&quot;btn btn-dark&quot;
              onClick=&lcub;() =&gt; increaseQuantity(guitar.id)&rcub;&gt;
              &plus;
            &lt;/button&gt;
            </code></pre>

            <p>Cada vez que agregábamos un elemento al carrito (ver en nuestro componente App.jsx la función addToCart) estábamos incrementando esta propiedad de cantidad "item.quantity". <strong>Actualicemos nuestra función teniendo esto en mente y que vamos a tener que actualizar esa propiedad de cantidad con cada agregado.</strong> Creamos una variable nueva "updatedCart" y usamos el .map() (recordemos que a diferencia de forEach(), nos va a devolver un array nuevo. Ambos sirven para iterar un arreglo pero .map() nos genera una copia nueva que va a estar en esta variable). Con cart.map( ) accedemos a cada elemento del carrito. También limitamos como número máximo 5 por guitarra. En este punto menciona el libro "Clean Code" y aconseja tanto seguir buenas prácticas ocmo tener preferencias personales; para este caso el es partidario de crear una constante con el valor máximo y es la que llamaremos en nuestra condición <strong>const MAX_ITEMS = 5</strong>:</p>

            <pre><code class="language-js">
              const &lsqb;data&comma; setData&rsqb; = useState(db)
              const &lsqb;cart&comma; setCart&rsqb; = useState(&lsqb;&rsqb;)
              const MAX&lowbar;ITEMS = 5
              const MIN&lowbar;ITEMS = 1

              function increaseQuantity(id){
                //console.log('Incrementando...', id)
                const updatedCart = cart.map ( item => {
                    if(item.id === id &amp;&amp; item.quantity &lt; MAX&lowbar;ITEMS){
                        return{
                            ...item,//ponemos esto porque no queremos perder la referencia de loq ue ya tenemos en el cart
                            quantity: item.quantity + 1 //si pusiéramos solo esto solo nos devolvería la cantidad
                        }
                    }
                    return item //para que mantenga el reto de elementos sobre los que no dimos click en aumentar cantidad
                })
                setCart(updatedCart) //esa variable la seteamos al carrito
            }
            </code></pre>

            <p class="naranja">Reto 01: Decrementar cantidades</p>

            <ul class="mb-3.75">
              <li>Hacer funcional el botón de decrementar cantidades.</li>
              <li>Crear la función, pasarla via props, identificar el elemento a actualizar y añadirlo al state, así como añadir un límite para nunca seleccionar menos de un elemento.</li>
              <li>Seguir la convenciones de nombres de incrementar cantidad.</li>
            </ul>

            <pre><code class="language-js">
              const &lsqb;data&comma; setData&rsqb; = useState(db)
              const &lsqb;cart&comma; setCart&rsqb; = useState(&lsqb;&rsqb;)
              const MAX&lowbar;ITEMS = 5
              const MIN&lowbar;ITEMS = 1
              
              function decreaseQuantity(id){
                //console.log('Decrementando...', id)
                const updatedCart = cart.map( item => {
                    if(item.id === id && item.quantity > MIN_ITEMS){
                        return{
                            ...item,//ponemos esto porque no queremos perder la referencia de lo que ya tenemos en el cart
                            quantity: item.quantity -1 //si pusiéramos solo esto solo nos devolvería la cantidad
                        }
                    }
                    return item //cuando no se cumple la condición: mantiene el resto de elementos sobre los que no dimos click en decrementar cantidad
                })
                setCart(updatedCart)
            }
            </code></pre>

            <p>Si presiono rápidamente en agregar cualquier guitarra podemos ver que nos pasamos del límite máximo de 5 que tenemos establecido por la variable <strong>const MAX_ITEMS = 5</strong>. <span class="destacado">Añadamos una nueva condición a la función addToCart() para que, en caso de que la posición actual de cart su cantidad sea mayor que el límite establecido no ejecute nada</span>. Vemos que en caso de que existiera ejecutábamos el código en el que <strong></strong>creábamos una nueva variables const updatedCart en la que hacíamos copia del cart actual con el spread operator y a continuación incrementábamos la cantidad del item y lo seteábamos en nuestro state de cart</strong>. No queremos que haga eso si en la posición actual del cart la cantidad supera el límite establecido. Añadimos <code class="language-js">if(cart[itemExists].quantity >= MAX_ITEMS) return</code>:</p>

            <pre><code class="language-js">
              function addToCart(item){
                const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                if(itemExists >= 0){//existe en cart
                    if(cart[itemExists].quantity >= MAX_ITEMS) return
                    const updatedCart = [...cart] //copia nueva de mi state, no modifica mi carrito       
                    updatedCart[itemExists].quantity++
                    setCart(updatedCart)
                } else{//NO EXISTE en cart
                    item.quantity = 1
                    setCart(prevCart =>[...prevCart, item])
                }       
            }
            </code></pre>

            <p class="naranja">Agregando la función de Limpiar Carrito</p>

            <p>Poríamos utilizar la función de nuestro state cart <strong>setCart()</strong> pero <span class="destacado">vamos a crear una función intermedia para borrar el carrito <span class="destacado">function clearCart(){}</span> en la que seteamos un arreglo vacío: setCart([])</span>. Esta es una de las grandes ventajas de los Hooks (por ejemplo para un usuario que se encontrara logado haríamos lo mismo seteando a false un supuesto state auth)</p>

            <pre><code class="language-js">
              function clearCart(){
                setCart([]) //seteamos un arreglo vacío
            }
            </code></pre>
            <p>como el botón donde vamos a llamar a esta función está en el componente Header.jsx, pasamos esa función vía props:</p>
            <pre><code class="language-js">
              &lt;Header
              cart = &lcub;cart&rcub;
              removeFromCart = &lcub;removeFromCart&rcub;
              decreaseQuantity = &lcub;decreaseQuantity&rcub;
              increaseQuantity = &lcub;increaseQuantity&rcub;
              clearCart = &lcub;clearCart&rcub;           
            /&gt;
            </code></pre>
          
          </div>
          <!-- Fin bloque desplegable interior-->
      


          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-82').toggle();">	
            <h3>82. Carrito persistente con LocalStorage - Almacenando</h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-82" class="hidden">
            <p class="naranja">Carrito persistente con LocalStorage - Almacenando</p>
            <p>Tener un carrito persistente es un buen truco para mantener los mismos elementos en el carrito aunque recarguemos navegador. ¿Cómo hacemos para tener sincronizado nuestro carrito de compras <code class="language-js">const [cart, setCart] = useState([])</code> con localStorage</p>
            
            <p>localStorage es una API muy sencilla que solo permite almacenar strings (ni objetos ni arrays). Como nuestro carrito es un array lo podemos convertir a string con <span class="destacado">JSON.stringify(cart)</span></p>

            <pre><code class="language-js">
            function saveLocalStorage(){
              localStorage.setItem('cart', JSON.stringify(cart))
            }
            </code></pre>

            <pre data-line="11"><code class="language-js">
              function addToCart(item){
                const itemExists = cart.findIndex(guitar => guitar.id === item.id)
                if(itemExists >= 0){//existe en cart
                    if(cart[itemExists].quantity >= MAX_ITEMS) return
                    const updatedCart = [...cart] //copia nueva de mi state, no modifica mi carrito       
                    updatedCart[itemExists].quantity++
                    setCart(updatedCart)
                } else{//NO EXISTE en cart
                    item.quantity = 1
                    setCart(prevCart =>[...prevCart, item])
                } 
                saveLocalStorage()
            }
            </code></pre>

            <p>Si vamos a las web developer tools, en la pestaña <strong>aplicación>storage</strong> podemos ver el Local Storage. Vemos que si añadimos un primer elemento al carrito agrega algo pero vacío, y ya la segunda vez sí agrega:</p>
            
            <img class="my-2.5" src="./src/assets/img/82-01.png" alt="" />
            
            <p>El estado o state en React ¿es síncrono?¿o es asíncrono y por qué? Pos...es asíncrono, es decir, no se actualiza inmediatamente sino hasta algunos milisegundos después. ¿por qué es asíncrono? Si fuera síncrono (que todas las funciones se ejecuten en orden una tras otra) eso haría que no podríamos interaccionar con la pantalla hasta que no escriba ese estate, lo que nos dejaría sin respuesta en especial si es un state muy grande. <strong>Revisar:</strong> esa función saveLocalStorage() se manda llamar inmediatamente (mientras que el resto de nuestra función addToCart() es síncrona. Es decir cuadno la estamos llamando aún no ha sido escrito el cart por primera vez y es por eso que lo toma como un arreglo vacío</p>

            <p>¿como lo solucionamos? usando el versátil <strong>Hook useEffect()</strong> (similar al watch en vue.js). Vimos su uso cuando el componente está listo pero también tiene el siguiente caso de uso (cuando cambie mi carrito ejecutar cierto código). Es muy útil para manejar los "efectos secundarios" de un cambio en nuestro state. <strong>Eliminamos la función que hemos creado y no obstante la usamos dentro del Hook que va a estar observando por nuestro state cart; cada vez que este cambie, ejecutará lo que le especificamos (lo que antes teníamos en la función).</strong>. React se va a encargar de actualizar el localStorage una vez que ese state haya completado su acción de actualizarse en base a las funciones que teNemos definidas para ese state en lo que llevamos hecho, no hemos de preocuparnos de crear una función. Abrimos chrome y limpiamos el local storage (boton derecho borrar) y podemos comprobar que si añadimos ahora elementos al carrito, ya desde la primera vez se actualiza el local storage.</p>

            <pre><code class="language-js">
              import { useState, useEffect } from "react" // importamos el Hook useEffect
              //lo añadimos tras nuestras variables MIN_ITEMS, MAX_ITEMS
              useEffect(() => {
                localStorage.setItem('cart', JSON.stringify(cart))
              }, [cart])
            </code></pre>                               

            <p class="naranja">Carrito persistente con LocalStorage - Recuperar los productos y mostrarlos</p>

            <p>Si recargo me aparece el carrito vacío, veamos cómo hacemos que persista. Esto pasa porque el useEffect que empleo para el almacenamiento local cada vez que carrito cambie también se ejecuta por primera vez cuando el componente esta listo, es decir de manera similar a cuando no tiene ninguna dependencia. Debemos revisar si hay algo en localStorage ese va a ser nuestro valor inicial y si no colocamos un arreglo vacio. <strong>const inicialCart</strong> (en algunos ejemplos la nombran como inicialState pero no lo recomienda en caso de tener varios states)</p> 

            <p>vamos a comprobar si hay algo en este elemento <strong>localStorageCart</strong>. (Si no hay nada devuelve un null) Si tiene algo lo convertimos de string a arreglo con JSON.parse()</p>

              <pre data-line="5"><code class="language-js">
                const initialCart = () => {
                  const localStorageCart = localStorage.getItem('cart') // lo primero es recuperar de localStorage
                  //a continuación comprobamos si hay algo en esa variable:
                  return localStorageCart ? JSON.parse(localStorageCart): []
              }
              const [data, setData] = useState(db)    
              const [cart, setCart] = useState(initialCart)
              </code></pre>
            
          </div>
          <!-- Fin bloque desplegable interior-->


          <!-- Bloque desplegable interior-->
          <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion6-84').toggle();">	
            <h3>84. Últimos Ajustes y Deployment</h3>			
            <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
          </div>
          <div id="seccion6-84" class="hidden">
            <p>Veamos los últimos ajustes para realiszar el deployment de nuestro proyecto. Revismoas avisos en la terminal por si tenemos rutas a img mal puestas y también eliminamos funciones y/o variables que no se estén utilizando. En este caso como vemos, la función del state data "setData" no se está usando así que la podemos eliminar: <code class="language-js">const [data, setData] = useState(db) </code></p>

            <img class="my-2.5" src="./src/assets/img/84.png" alt="" />

            <p>¿Como podemos subir este proyecto? <span class="destacado">Este tipo de proyectos de React.js Vue.js Angular.js se tienen que construir</span>. Si abrimos el <strong>package.json</strong> vemos la línea de "build": "vite build". Todo loque tenemos está en desarrollo pero cuando construimos, este comando se va a encargar de realizar una serie de mejoras, de performance (subir versiones minificadas, más ligera...). Vamos a la terminal y escribimos <span class="destacado">npm run build</span> nos genera la carpeta <span class="destacado">dist</span>. En la consola nos da una serie de información "convertí 34 módulos" incluyendo nuestros componentes, nuestros archivos y también algunas d elas dependencias que imporamos en la parte superior, entonces Vite en automático se encarga de hacerlo. En esa carpeta dist genera nuestro index.html, la hoja de estilos y la js que contiene una versión de React. Pero si damos doble click a ese html eso no funciona, hay que subirlo a algún sitio. La mejor versión hoy día es Netlify. Si nos logamos de nuevas comenta que si la cuenta es muy nueva en Github va a haber errores (lo hacen para protegerse del spam) y presionamos en iniciar sesión con email.</p>

            <p>A continuación veamos cómo crear nuestros propios Hooks y por qué es bueno hacerlo. Lo haremos con uno que centralice todas las funciones de nuestro carrito de compra.</p>
            
          </div>
          <!-- Fin bloque desplegable interior-->
                     
        </div>
        <!-- Fin div colapsable-->
      
      </div>	
      <!-- FIN SECCIÓN 6 -->
    
  
      <!-- SECCION 3 y 4-->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
        <div class="row">
          <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion3').toggle();">	
            <h2>Sección 3 y 4: PROYECTO: Carrito de compras. Introducción / Herramientas / Creando el proyecto en Windows</h2>				
            <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
          </div>
          
          <div id="seccion3" class="hidden">
              
            <div class="row">
              <div class="col-12">	
                
                
                
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion3-46').toggle();">	
                  <h3>46. Introducción. El proyecto a construir GuitarLA</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion3-46" class="hidden">
                  <p class="font-bold">Proyecto carrito de compras GuitarLA</p>
      
                  <p>En este proyecto estaremos aprendiendo los fundamentos de React: <span class="destacado">Componentes, Eventos y State</span>, mientras creas un carrito de compras real con cantidades, precios, y más, tomaremos este mismo carrito para mostrarte como crear tus propios Hooks y como transformarlo a código de TypeScript y cuales son sus beneficios. Carrito de compra persistente sincronizando con localStorage (aprenderemos todas esas acciones agregar elementos, cambiarlos, cambiar cantidades, vaciar carrito...)</p>							
                  <img class="my-2.5" src="./src/assets/img/s1-01.jpg" width="" height="" alt=""/> 
                  
                </div>
                <!-- Fin bloque desplegable interior-->
      
      
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion3-47').toggle();">	
                  <h3>47. Herramientas para crear aplicaciones en React.js</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion3-47" class="hidden">
                  <p class="font-bold">Tecnologías para crear aplicaciones en React</p>
                  <p>Permiten Crear una App En React en Minutos. Existen muchas formas de crear una app en React, incluso tu puedes crear tu propio ambiente de desarrollo con herramientas como Babel, Parcel, Webpack, Vite, etc</p>
      
                  <p>Pero también existe una gran cantidad de herramientas ya disponibles para crear aplicaciones en React en minutos sin conocer esta configuración</p>
                  
                  
                  <p class="font-bold">Ventajas de utilizar una herrmaienta ya existente: <strong>La mayoría de Herramientas ya existentes para crear aplicaciones en React son estables y siguen un enfoque muy claro: No tener que preocuparte por la configuración.</strong> Tú puedes crear tu propio ambiente de desarrollo pero tienes que asegurarte de que cada versión nueva de React, cada version de diferentes librerias sea compatible con tu proyecto y despues tienes que encontrar una forma de compilar código de css (sass etc) ...entonces vamos a gasta r más tiempo en solucionar este tipo de cosas que tirando código. Por eso se recomienda usar una herramienta ya existente</p>
      
                  <p>Cada una de estas herramientas ya existentes va desde básicas hasta avanzadas. Requieren tener instalado <span class="destacado">Node.js (NPM) o YARN</span>. Existen otros entornos hoy día como <strong>¿bum?</strong> Node.js con npm es bastante estable y es la que estaremos usando</p>
                  
                  <p>Opciones modernas para crear Apps en React. Los más populares hoy en día son<span class="destacado">Vite</span> y <span class="destacado">Next.js</span>. También Remix Run y Astro (que usaba en versiones anteriores del curso. Remix Run fue adquirido recientemente por shopify y están haciendo muchos cambios y no está listo)</p>
                  
                  <p class="font-bold">Recomendaciones del equipo de React</p>
      
                  <p>En su documentación recomiendan comenzar por Next.js o Remix para nuevos proyectos. Entonces ¿ya no se deben crear proyectos von Vite? Cuando creas proyectos con Vite tendrás que instalar dependencias para Routing, Consultas HTTP y más (herramientas como Next.js y Remix ya lo tienen incluido)</p>
      
                  <p><strong>Usualmente siempre hay que aprender primero la herramienta/lenguage de programación y después el framework por lo que esa recomendación es un poco rara, porque cuando estes creando un proyecto ya sea en Next.js o Remix tal vez estés escribiendo un código y no sabes si eso es React o si eso es Next. Y esa es la explicación de por qué los proyectos en este curso utilizan Vite y al final tendremos un proyecto con Next quedando más claro qué es React y qué es Next.js</strong></p>						
                </div>
                <!-- Fin bloque desplegable interior-->
      
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion4-48').toggle();">	
                  <h3>48. Instalando node y npm</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion4-48" class="hidden">
                  <p><a class="rojo" href="https://nodejs.org/es/" target="_blank">https://nodejs.org/es/</a> Requerimos node para crear nuestros proyectos pero también para instalar dependencias con npm</p>	
                
                  <p>Una vez instalado abrimos la terminal y comprobamos las versiones del entorno(node.js) <span class="destacado">node -v</span> y de las dependencias(npm) <span class="destacado">npm -v</span></p>
                  
                </div>
                <!-- Fin bloque desplegable interior-->
      
      
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion4-49').toggle();">	
                  <h3>49. Creando el primer proyecto</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion4-49" class="hidden">
                  <p>Abrimos terminal, vamos al escritorio (que es donde voy a crear los proyectos) y ponemos <span class="destacado">npm create vite@latest</span> (si es la primera vez nos pedirá instalar la dependencia de vite le decimos que "y"). A continuación nos pide nombre y lo llamamos <strong>guitarla</strong>. A continuación nos pide que elijamos framework (Vanilla, Vue, <strong>React</strong>, Preact, Lit, Svelte, Solid, Qwik, Others) y elegimos React. Nos pide elegir variante, normalmente y como él ha trabajado este curso es <strong>Typescript + SWC</strong>(SWC es un compilador nuevo de los de Vite basado en Ros, muy rápido)  pero al ser el primer proyecto elegiremos <strong>Javascript + SWC</strong>. Remix es una alternativa a Next.JS de los creadores de shopify pero este curso no incluye remix porque la compra fue hace poco y están modificando/agregando muchas cosas</p>
                
                <img class="my-2.5" src="./src/assets/img/49-1.png" alt="" />
      
                <p>ejecutamos los 3 comandos que nos indica para situarnos en la nueva carpeta del proyecto <span class="destacado">cd guitarla</span>, instalar las dependencias <span class="destacado">npm install</span>y arrancar el proyecto <span class="destacado">npm run dev</span></p>
      
                <img class="my-2.5" src="./src/assets/img/49-2.png" alt="" />
      
                <p>Cuando generamos un proyecto en React con Vite vemos que la estructura por defecto es muy simple:</p>					
                <ul class="mb-3.75">
                  <li><strong>carpeta "node_modules":</strong> las dependencias del proyecto. Va creciendo conforme instalamos más dependencias</li>
                  <li><strong>carpeta public:</strong> colocaremos por ej imagenes que seran accesibles para los visitantes de nuestro sitio web o app</li>
                  <li><strong>carpeta src:</strong> colocaremos todo nuestro código. Si revisamos la página de inicio de nuestro proyecto <strong>http://localhost:5173/</strong> nos dice: <strong>Edit src/App.jsx and save to test HMR</strong>. Así que abramos ese jsx, que es la página de inicio. 
                    <img class="my-2.5" src="./src/assets/img/49-3.png" alt="" /><br>
                    En esta carpeta <strong>src</strong> es donde vamos a pasar la mayor parte del tiempo escribiendo código (colocaremos nuestros customs hooks, librerías, componentes...).
                  </li>
                  <li>.gitignore: va a ignorar algunos archivos</li>
                  <li><strong>index.html:</strong> básicamente lo que hace es inyectar React en el div <code class="language-html">&lt;div id="root"&gt;&lt;/div&gt;</code>. Si abrimos el <strong>main.jsx</strong> vemos el siguiente código donde se busca ese div con id="root" donde monta toda la aplicación de React. En el index.html podemos poner algún bg-gray-200, agregar algunos tags mas de html que sean importantes para nuestro proyecto, pero no vamos a escribir código html ahí habitualmente.
                  <pre><code class="language-js">
                    createRoot(document.getElementById(&apos;root&apos;)).render(
                      &lt;StrictMode&gt;
                        &lt;App /&gt;
                      &lt;/StrictMode&gt;&comma;
                      )						
                  </code></pre>
                  </li>
                  <li><strong>package.json:</strong> ahí está el comando de "dev" que ejecutamos para arrancar y tiene algunos comandos para construir proyecto, previsualizarlo, y es donde se instalan las dependencias del proyecto y las de desarrollo. Al tener esas dependencias y sus versiones indicadas nos aseguramos que el equipo de trabajo sepa qué depndencias hay que tener para funcionar correctamente.</li>
                </ul>
                
                  
                </div>
                <!-- Fin bloque desplegable interior-->
      
                    
              </div>			
            </div><!--Fin row-->
      
          </div>
          <!-- Fin div colapsable-->
      
      
        </div>
      </div>	
      <!-- FIN SECCION 3 y 4-->	


      <!-- SECCION 2 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">	
        <div class="row">
          <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion2').toggle();">	
            <h2>Sección 2: Introducción a JavaScript para React</h2>				
            <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
          </div>
          
          <div id="seccion2" class="hidden">
      
            <div class="row">
              <div class="col-12 pl-1.25">	


                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-9').toggle();">
                  <h3>9. Variables creadas con let / 10. Variables creadas con const</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-9" class="hidden"> 

                  <p><span class="destacado">Los nombres de variables han de ser descriptivos y no pueden iniciar con * ni números ni caracteres especiales.</span></p>
                  <p>Podemos usar comillas dobles o simples para asignar valor string a una variable (pero no mezclar tipo de comillas, nos da error)</p>   
                  <p class="naranja">Variables creadas con let</p>               
                                
                  <ul class="mb-3.75">
                    <li>Pueden ser inicializadas con un valor o sin valor:
                      <pre><code class="language-js">
                        /*Podemos inicializarlas con un valor y después reasignarle otro valor. Con const no se puede hacer eso con otros lenguages no podríamos hacer esto pero Javascript es un lenguage de tipo dinámico donde el tipo de dato se asigna por su valor y no por la variable)*/
                        let cliente ="Juan"
                        cliente=30
                      </code></pre>                  
                      <pre><code class="language-js">
                        //Podemos inicializarlas sin valor y asignarlo después
                        let precio
                        precio = 200
                      </code></pre>
                    </li>
                  </ul>             
                  
                  <p>Si la inicializamos y no le asignamos valor y hacemos un console.log vemos que sale <span class="destacado">"Undefined"</span> <strong>es un tipo de dato en Javascript que nos indica que la variable fue inicializada pero nunca tuvo ningún valor</strong></p>
                  <p><strong>si hacemos un console.log de una variable "cantidad" que no hemos definido</strong> nos da el error <span class="destacado">"cantidad is not defined"</span></p>                   
                  <pre><code class="language-js">
                    var //(versiones anteriores, ya no se usan)
                    let
                    const

                    console.log('Hola Mundo')
                    console.log(2+2)
                    
                    let cliente = 30
                    cliente="Juan"                  
                    let calzado
                    
                    console.log(cliente)
                    console.log(calzado)
                    console.log(cantidad)                 
                  </code></pre>

                  <p class="naranja">variables creadas con const</p>
                  <ul class="mb-3.75">
                    <li>Tienen que ser inicializadas con un valor</li>
                    <li>No se pueden reasignar. si lo intentamos en la consola nos sale el error <span class="destacado">"Asignment to constant variable"</span></li>
                  </ul>
                  <p></p>
                    <pre><code class="language-js">
                      const cliente = 30 
                      cliente="Juan" 
                    </code></pre>
                    
                    <p>¿entonces let es mejor porque nos da mas flexibilidad de posibilidades? No.<br>
                    <span class="destacado">
                      Vamos a utilizar mas veces const que let. Lo normal es querer tener en nuestro código variables const
                      y let será una "excepción" cuando queramos inicializar sin valor y/o reasignar
                    </span></p>
                </div>
                <!-- Fin bloque desplegable interior-->
                
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-11').toggle();">
                  <h3>11. Tipos de Datos en JavaScript</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-11" class="hidden">
                  <pre><code class="language-js">
                    /* Tipos de dato

                    Javascript tiene pocos tipos de datos: string, number, 
                    
                    para saber el tipo de dato de una variable, operador typeof antes de la variable
                    console.log (typeof cliente)
                    
                    si nos ponemos encima de esta variable let alumno = "Juan" con el IntelliSense (IS) de Visual Studio si te pones encima de la variable te dice el tipo de dato --&gt; string 
                    (con let, con const no rula esto en Visual Studio code pero usamos el typeof)
                    El Undefined lo marca como any (que es específico de Typescript. Lo veremos y veremos por qué hay que evitarlo)
                    */
                    
                    //Undefined
                    let cliente
                    console.log (cliente)
                    console.log (typeof cliente)
                    
                    //Strings o cadenas de texto. Sirven para representar el nombre de un producto, categoría, reviews....
                    let alumno = "Juan"
                    const producto = 'Monitor 49 pulgadas'
                    console.log(alumno)
                    console.log(typeof alumno)
                    console.log(producto)
                    
                    //Numbers
                    const numero = 40
                    const numero2= 40.40
                    const numero3 = -100
                    console.log(numero)
                    console.log(numero2)
                    console.log(numero3)
                    console.log(typeof numero3)
                    
                    //BigInt
                    const numeroGrande = BigInt(1263472832934827342938427348274)
                    console.log(numeroGrande)
                    
                    //Boolean (true o false) --&gt; El usuario está bloqueado o no / autenticado o no / producto agotado o no....
                    const descuento = true;
                    console.log(typeof descuento)
                    
                    //Null
                    const descuento2 = null 
                    console.log(descuento2) //lo estoy asignando pero no existe no es nada. Es probable que queramos asignar null a una variable
                    
                    let precio
                    console.log(precio)     //--&gt; variable declarada pero no tiene valor
                    
                    //Symbol --&gt; son buenos para librerias. normlamente no los usaremos. Cada Symbol es distinto a otro no hay dos iguales. Son únicos, aunque los comparemos y tengamos el mismo valor, siem,pre son diferentes
                    const primerSymbol = Symbol(30)
                    const segundoSymbol = Symbol(30)
                    console.log(primerSymbol)
                    console.log(primerSymbol == segundoSymbol)
                    
                    //Objetos --&gt; veremos en su propio vídeo. La parte más importante en Javascript y una de las características que más vamos a trabajar sea con React, Node, Vue.js...
                    //Arrays o Arreglos también terminan siendo objetos                  
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-12').toggle();">
                  <h3>12. Objetos y Destructuring / 13. Manipulación de objetos</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-12" class="hidden">
                  <p>Los <span class="destacado">Objetos</span> son la parte más importante en Javascript y una de las características con las que más vamos a trabajar sea con React, Node, Vue.js...  Los Arrays=Arreglos también terminan siendo objetos</p>
                  <ul class="mb-3.75">
                    <li>Un objeto es una colección de propiedades; pueden tener múltiples propiedades SEPARADAS POR ","</li>
                    <li>Una propiedad es una asociación entre un nombre=clave(key) y un valor(value)</li>
                    <li>Sintaxis con llaves --&gt; <code class="language-js">let producto = {  }</code> / <code class="language-js">const producto = {}</code> /</li>
                  </ul>
                  <p>Por tanto siempre que veamos esta sintaxis estaremos viendo un objeto, una colección de propiedades (asociaciones key+value)</p>

                  <p class="mt-1.25 mb-0"><span class="naranja">Generar Objetos:</span> cada <span class="destacado">propiedad</span> de un objeto está formada por una asociación <span class="destacado">clave/valor</span> o pareja key/value. Las propiedades van separadas por comas.</p>
                  <pre><code class="language-js">
                    const producto = {
                        nombre : "Tablet",   // Esto es una propiedad. nombre es "key", "Tablet" es el "value". 
                        precio : 300,
                        disponible : false
                    }
                    console.log(producto); //veamos en la consola como se ven los objetos. dandole al triangulito expandimos y vemos las propiedades del mismo
                    console.log(typeof producto)
                    console.table(producto) //para objetos muy grandes y también para arrays podemos usar console-table para verlos formateados en la consola
                  </code></pre>

                  <p class="mt-1.25 mb-0"><span class="naranja">Acceder a Objetos:</span> Una de las características de los objetos es que podemos <span class="destacado">acceder a cada una de las propiedades de un objeto usando la sintaxis de "."</span> y vemos como nos aparece el autocompletado de VSCode y podemos elegir la propiedad (asociación key/value) que queramos. <strong>Si tratamos de acceder a una propiedad que no existe nos devuelve un Undefined</strong>.</p>
                  <pre><code class="language-js">                   
                    console.log(producto.nombre)
                    console.log(producto.precio)
                    console.log(producto.autenticado) // si tratamos de acceder a una propiedad que no existe nos devuelve Undefined
                  </code></pre>
                
                  <p class="mt-1.25 mb-0"><span class="naranja">Destructuring:</span> en versiones recientes de JS desde ECMAS6 agregaron "Destructuring" lo que nos permite en una sola línea de código extraer un valor y generar una variable. Está pensado para reducir código y usarlo siempre que podamos. Antes, en versiones anteriores de JS era muy común crear una variable y asignarle la propiedad de un objeto, por ejemplo:</p>
                  <pre><code class="language-js">                     
                    const nombre = producto.nombre
                    const precio = producto.precio
                    const disponible = producto.disponible
                    console.log(nombre)
                    console.log(precio)
                    console.log(disponible)                  

                    //Con "Destructuring" una sola línea de código extraemos un valor del objeto que hay tras el = y generamos variable.
                    const {} = //lo que hay detrás del igual es el objeto sobre el cual queremos aplicar destructuring, extraer un valor
                    const { nombre } = producto //nombre es la variable
                    console.log(nombre)
                  </code></pre>
                  
                  <pre><code class="language-js">
                    //La sintaxis del Destructuring
                    const { nombre, precio, disponible } = producto // aquí lo estamos haciendo en una sola línea, extrayendo el valor y generando las variables 
                    console.log(nombre)
                    console.log(precio)
                    console.log(disponible)
                  </code></pre> 

                  <p class="mt-1.25 mb-0"><span class="naranja">Object Literal Enhacement:</span> también pensado para reducir código. Sirve para colocar dentro de un objeto. ¿En qué casos es util? cuando tenemos una función que realiza ciertas operaciones y en lugar de devolver un monton de variables, devuelves un objeto con todo agrupado. Supongamos que tenemos las dos variables siguientes:</p>
                  <pre><code class="language-js">
                    const autenticado2 = true
                    const usuario = "Juan"

                    const nuevoObjeto = {
                        autenticado2 : autenticado2,
                        usuario: usuario
                    }

                    //si el key y el value se llaman igual puedo hacer esto
                    const nuevoObjeto = {
                        autenticado2 
                        usuario
                    }
                    console.log(nuevoObjeto)
                  </code></pre> 

                  <p class="mt-1.25 mb-0"><span class="naranja">Manipulación de objetos</span> El object de JS es muy grande y si abrimos la documentación de MDN vemos todos los métodos que podemos usar con el constructor de object <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object</a>
                </p>

                  <pre><code class="language-js">
                    //¿Como evitamos que se pueda manipular un objeto? Con TS es fácil, con JS usemos un par de métodos
                    Object.freeze(producto) //Evita que se manipule ninguna propiedad del objeto (ni ninguna existente, ni añadir una nueva ni eliminar ninguna)
                    Object.seal(producto) //Permite modificar las existentes en el objeto pero ni añadir ni eliminar ninguna propiedad

                    //Reescribir un valor
                    producto.disponible = true

                    //Si no existe la propiedad la va a añadir
                    producto.imagen = 'image.jpg'

                    //Eliminamos propiedad
                    delete producto.precio

                    console.log(producto)
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-14').toggle();">
                  <h3>14. Destructuring de 2 o más objetos</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-14" class="hidden">
                  <pre><code class="language-js">
                    // OBJETOS Destructuring de dos o más objetos:
                    const producto = {
                        nombre : "Tablet",   // Esto es una propiedad. nombre es "key" "Tablet" es el "value". las propiedades van separadas por comas
                        precio : 300,
                        disponible : false
                    }
                    
                    const cliente = {
                        nombre: "Juan",
                        premium: true,
                        direccion: {
                            calle: "Calle Nuevo Mexico"
                        }
                    }
                    
                    const { nombre } = producto
                    //const { nombre } = cliente //-->esto nos daba error. veamos a continuación como renombramos ese valor para evitar colisión de nombres
                    //const { nombre: nombreCliente, direccion: calle } = cliente
                    const { nombre: nombreCliente, direccion: { calle } } = cliente
                    
                    /*analizando la notación anterior:
                    
                        nombre: nombreCliente --> renombra la variable
                        direccion: { calle } --> entra a ese objeto y entra a calle
                    */
                    
                    
                    console.log(nombre)
                    console.log(nombreCliente)
                    console.log(calle)
                    
                    // Muchas veces instalaremos varias dependencias y cuando devuelven valores, resulta que las variables se llaman igual. Para evitar colisión de nombres 
                    // Viene bien saber como poder renombrarlas de esta manera.
                  </code></pre>
                

                </div>
                <!-- Fin bloque desplegable interior-->
              
                
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-15').toggle();">
                  <h3>15. Unir dos o más objetos</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-15" class="hidden">
                  <pre><code class="language-js">
                    // OBJETOS unir dos o mas objetos, técnicas y sintaxis que marca diferencia. Le dedica mucho tiempo a losobjetos porque es lo que más se utiliza en React:
                    const producto = {
                        nombre : "Tablet",   // Esto es una propiedad. nombre es "key" "Tablet" es el "value". las propiedades van separadas por comas
                        precio : 300,
                        disponible : false
                    }
                    
                    const cliente = {
                        nombre: "Juan",
                        premium: true    
                    }
                    
                    //supongamos que añadimos el objeto producto a un carrito
                    const carrito = {
                        cantidad: 1,
                        //si lo hacemos así nos agrega el objeto producto DENTRO de este objeto carrito, pero queremos unirlo
                        //producto 
                        // para que las key del objeto producto sean key de este objeto carrito (que el objeto carrito sea plano) Usamos para ello el "spread operator":
                        ...producto 
                    }
                    console.log(carrito)
                    
                    //este código tiene 2 objetos dentro (obtiene una copia)
                    const nuevoObjeto = {
                        producto: {...producto},
                        cliente: {...cliente},
                    }
                    console.log(nuevoObjeto)
                    
                    //podríamos obtener exactamente lo mismo que antes simplificando la sintaxis usando el 'object literal enhancement' diciendo:
                    // 'genérame un key de producto con el objeto producto y un key de cliente con el objeto cliente':
                    const nuevoObjeto2 = {
                        producto,
                        cliente
                    }
                    console.log(nuevoObjeto2)
                    
                    //si hago esto va a ser completamente diferente, un objeto plano pero ¡OJO! el key nombre del objeto producto no está!!!! porque el key nombre del objeto cliente reescribe el anterior
                    const nuevoObjeto3 = {
                        ...producto,
                        ...cliente
                    }
                    console.log(nuevoObjeto3)
                    
                    //lo anterior lo podemos hacer con menos código usando el Object.assign
                    const nuevoObjeto4 = Object.assign(producto, cliente)
                    console.log(nuevoObjeto4)
                    
                    //En react existe el término "inmutabilidad" es decir, no modificas directamente un objeto sino en base a ciertas funciones.
                    //Es importante entender las diferentes funciones que nos ofrece para poder cambiar algunos valores. Eso nos va a quedar más claro con los proyectos de React.
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-16').toggle();">
                  <h3>16. Template Strings y Concatenación</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-16" class="hidden">
                  <pre><code class="language-js">
                    //Template Strings y Concatenación

                    const producto = "Tablet de 12 pulgadas"
                    const precio = 400
                    const marca = "Orange"
                    
                    //como se hacía antes en js este tipo de concatenación (con + o ,)
                    console.log('El producto es: ' + producto) 
                    console.log(producto + "$" + precio + " Dolares, marca " + marca) 
                    
                    //hagamos este mismo código con los Template Strings como se hace ahora (con ``)
                    console.log(`El producto es ${producto}`)
                    console.log(`${producto} ${precio} Dolares, marca ${marca} `)
                    
                    //En React se utiliza básicamente así. Algo muy similar: "jsx" que nos permite mezclar html con js en React
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-17-19').toggle();">
                  <h3>17. Arrays / 18. Modificar Arrays / 19. Destructuring de Arrays</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-17-19" class="hidden">
                  <p>Los Arrays (Arreglos) junto con objetos es de lo que más se utiliza en nuestro código. Es un objeto similar a un listado que tiene métodos para realizar varias operaciones. Diferencias: </p>                
                  <ul class="mb-3.75">
                    <li>corchetes en vez de llaves</li>
                    <li>no tienen clave/valor sino solo valor</li>
                    <li>su llave va a ser el índice que se asigna automáticamente en base a su posición en el arreglo</li>
                  </ul>
                  <p>Los arreglos pueden mezclar tipos de datos en su interior pero se recomienda que un arreglo contenga estructura y que sea acorde para tener un mejor orden en el código</p>

                  <pre><code class="language-js">
                    const tecnologias = [20,30,40]

                    console.log(tecnologias)
                    console.table(tecnologias)
                    
                    console.log(tecnologias[1])                  
                  </code></pre>

                  <p class="mt-1.25 mb-0"><span class="naranja">Modificar Arrays</span></p>

                  <pre><code class="language-js">
                    const tecnologias = ['HTML','CSS','Javascript','React.js','Node.js']

                    tecnologias[5] = 'Nest.js'
                    tecnologias.push('Nest.js')
                    console.log(`tecnologias:`)
                    console.table(tecnologias)                  
                  </code></pre>

                  <p><strong>si vamos al navegador consola y desplegamos el [[prototype]] vemos todos los métodos disponibles para ese array</strong>. Cada tipo de datos tiene sus métodos. <span class="destacado">¡¡¡¡IMPORTANTE!!!!</span> En React siempre hemos de escribir nuestro código con funciones que no modifiquen directamente los valores de lo que se conoce como el "state". En esta página <a href="https://doesitmutate.xyz/" target="blank">https://doesitmutate.xyz/</a> podemos consultar si los métdos que nos aparecen en <strong>[[prototype]]</strong> de la consola del navegador modifican o no nuestro array. Como vemos si buscamos ahí por ejemplo el método "push()", sí modifica (mutates) nuestro arreglo por lo que no se recomienda utilizar push() con react. </p>

                  <p class="font-bold">Alternativa a push</p>
                  <pre><code class="language-js">
                    const nuevoArreglo = [...tecnologias, 'Nest.js'] // básicamente esos "..." copian tecnologías y a continuación indicamos optro valor más que es  'Nest.js'
                    //si lo quisiéramos al inicio --&gt; const nuevoArreglo = ['Nest.js', ...tecnologias]
                    console.log(`nuevoArreglo: alternativa a push() ${nuevoArreglo}`)                  
                  </code></pre>
                  
                  <p class="font-bold">método shift() elimina el primer elemento de un array. Modifica el array</p>
                  <pre><code class="language-js">
                    const tecnologias2 = ['HTML','CSS','Javascript','React.js','Node.js']
                    tecnologias2.shift();
                    console.table(`tecnologias2: usamos shift para eliminar primer valor ${tecnologias2}`)
                  </code></pre>  
                  
                    <p class="font-bold">alternativa a shift() --&gt; usamos filter() que no modifica nuestro arreglo</p>
                    <pre><code class="language-js">
                    console.log(`tecnologias3: alternativa a shift, uso de filter()`)
                    const tecnologias3 = tecnologias.filter(function(tech){
                        //console.log(tech)
                        if(tech!=='HTML'){ 
                            return tech 
                        }
                    })
                    console.table(tecnologias3)
                    </code></pre>
                    
                    <p class="font-bold">map() que itera sobre TODOS los elementos de nuestra colección</p>

                    <pre><code class="language-js">
                    //veamos como modificar un valor sin cambiar el array original, por ejemplo tecnologias[5] = 'Nest.js'. 
                    // Usamos map() que itera sobre TODOS los elementos de nuestra colección
                    console.log(`tecnologias4: uso de map()`)
                    const tecnologias4 = tecnologias.map(function(tech){
                        //console.log(tech)
                        //Queremos buscar el valor 'Node.js' para modificarlo por 'Nest.js' pero queremos mantener el resto
                        if(tech === 'Node.js'){
                            return 'Nest.js'
                        } else { // si no ponemos este else, vemos en consola que cuando no se cumple la condición devuelve undefined
                            return tech
                        }
                    })
                    console.table(tecnologias4)
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-19').toggle();">
                  <h3>19. destructuring arrays</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-19" class="hidden">
                  <pre><code class="language-js">
                    const tecnologias = ['HTML','CSS','Javascript','React.js','Node.js']

                    //variable con la posicion 3 del array
                    
                    const react = tecnologias[3]
                    console.log(react)
                    
                    // El destructuring de arrays los va a ir extrayendo en base a la posición
                    const [html, estilos, script] = tecnologias
                    console.log(html) //--> HTML
                    console.log(estilos) // --> CSS
                    //si quisiéramos sacar el valor de una única posición, por ej 'React.js' usando esta sintaxis de destructuring hemos de usar comas dejando los espacios
                    //(contar como en las tablas de colaboradores!!!! :D)
                    
                    const [ , , , reactjs] = tecnologias
                    console.log(reactjs)
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-20').toggle();">
                  <h3>20. Recorriendo arrays con for / 21. Recorriendo arrays con forEach, map y for ... of</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-20" class="hidden">
                  <pre><code class="language-js">
                    //recorriendo/iterar arrays

                    const tecnologias = ['HTML','CSS','Javascript','React.js','Node.js']
                    
                    // console.log(tecnologias[0])
                    // console.log(tecnologias[1])
                    // console.log(tecnologias[2])
                    // console.log(tecnologias[3])
                    // console.log(tecnologias[4])
                    
                    //igual que map() para iterar un array o filter() para sacar o mantener elementos de un arreglo existen métodos/funciones para iterar una array fácilmente
                        // for(let i = 0; i &lt; 5; i++) { 
                        //     //console.log(i) 
                        //     console.log(tecnologias[i]) 
                        // }
                    
                    /*si añadiéramos un nuevo valor al array sin modificar el bucle, por ejemplo al final vemos que no nos sale.
                    un arreglo va a crecer o ser mas pequeño en fcn de lo que el usuario haga en nuestra App. por ejemplo un carrito de compras, que se inicia con un arreglo vacío,
                    en función de lo que haga un usuario u otro se han podido añadir 3 elementos, 8, ninguno...
                    por tanto SIEMPRE TENEMOS QUE ESCRIBIR NUESTRO CÓDIGO DE FORMA DINÁMICA, QUE SE ADPATE A TODOS LOS ESCENARIOS*/
                    
                    //revisemos cuántos elementos hay en el arreglo para que el iterador se ejecute esa cantidad de veces
                    
                        // for(let i = 0; i &lt; tecnologias.length; i++) { 
                        //     //console.log(i) 
                        //     console.log(tecnologias[i]) 
                        // }
                    
                    //aunque un for (que se usa en C#, php, Java) no tiene nada de malo, js ha hecho 3 iteradores que son mas sencillos y claros de usar
                    
                    //forEach()  --&gt; MÉTODO QUE EJECUTA UNA FUNCIÓN INDICADA POR CADA ELEMENTO DEL ARREGLO
                    
                        // tecnologias.forEach(function(){
                        //     console.log('Desde la función')
                        // })
                    
                        //dentro de ese function podemos pasarle lo que queramos como parámetro, antes usamos 'tech' but podemos ponerle por ejemplo la letra 'a' y veremos que aparecen cada uno de esos valores
                        // tecnologias.forEach(function(a){
                        //     console.log(a)
                        // })
                    
                        //normalmente el nombre del parámetro ha de ser descriptivo de los valores que contenga el array, por ejemplo array de automóviles--&gt;parámetro 'automovil'. 
                        // Así que en este caso lo dejamos en 'tech'. Como vemos es mas sencillo que el bucle loop. Ya sabe cuantas veces ejecutarse porqeu ya sabe la extensión del
                        //array sobre el que se está ejecutando
                        // tecnologias.forEach(function(tech){
                        //     console.log(tech)
                        // })
                    
                    //map() --&gt; sirve para iterar pero su característica ppal es que CREA UN NUEVO ARREGLO, en base a las condiciones de la fcn. 
                    
                        // tecnologias.map(function(tech){
                        //     console.log(tech)
                        // })
                    
                        //Veamos esta característica diferencial con el siguiente código. El primer console.log (en el que intentamos return tech usandi forEach) nos dará un undefined
                        const arrayforEach = tecnologias.forEach(function(tech){
                            //return tech
                            console.log(tech)
                        })
                        const arrayMap = tecnologias.map(function(tech){
                            return tech
                        })
                    
                        console.log(arrayforEach)
                        console.log(arrayMap)
                    
                        // map() es el más utilizado con React. Por tanto DIFERENCIA:
                        /*
                        forEach() ejecuta una función dada tantas veces como valores  tiene un arreglo
                        map() genera un array nuevo en base a la condicion/fcn que le estás pasando
                        */
                    
                    // for ... of --&gt; EJECUTA UN BLOQUE DE CÓDIGO POR CADA ELEMENTO DE UN ARREGLO. Se parece mucho al for y tiene algo del forEach
                    
                    for(let tech of tecnologias){
                        console.log(tech)
                    }
                    // for(let i = 0; i &lt; tecnologias.length; i++) { 
                    //     console.log(tecnologias[i]) 
                    // }
                    
                    //tecnologias.forEach(function(){
                    //     console.log('Desde la función')
                    // })//recorriendo/iterar arrays
                  </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-22').toggle();">
                  <h3>22. Funciones: Function declaration / Function Expression / Arrow Functions</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-22" class="hidden">
                  <p>Las funciones nos van a permitir escribir código reutilizable en js y en cualquier lenguage de programación. Vamos a separar el código en pequeñas funciones con su propósito. <strong>Ojo con los nombres (mismas restricciones que nombres de variables, no empezar por números, guiones...)</strong></p>
                  <p class="mt-1.25 mb-0"><span class="naranja">Funciones - Function declaration:</span> </p>
                  <pre><code class="language-js">
                    function sumar(){
                          console.log(1+1)
                      }
                    //Llamamos a la fcn, y además como son reutilizables, tantas veces como queramos. Se la puede llamar antes de declararla.
                      sumar()
                      sumar()
                    
                      function sumar(){
                          console.log(1+1)
                      }
                  </code></pre>

                  <p>Hemos de escribir funciones "inteligentes" que manejen <span class="destacado">parámetros:</span> es una variable especial que se utiliza en una función y cuyo valor se refiere a valores que vienen del exterior. <span class="destacado">En el ejemplo siguiente: numero1 y numero2 es un parámetro mientras que '10' es un argumento</span></p>
                  <pre><code class="language-js">
                    function sumar(numero1, numero2){   
                      console.log(numero1)
                      console.log(numero2)
                      console.log(numero1+numero2)
                    }
                    sumar(10, 20)
                    sumar(100, 131)
                  </code></pre>
                  <p>Hemos de saber qué tipo y cuantos argumentos mandarle a nuestra función (tanto conociendo la librería que importemos como haciedo uso del helper=Intellisense de Visual Studio) por ejemplo si a la fcn anterior le mandamos un único argumento numérico, como espera 2 números trata de sumar un número con NADA y devuelve 'NaN' (Not a Number). Para estos casos podríamos utilizar los <strong>parámetros por default</strong>, cuando un valor no está presente utilizar esos valores.</p> 
                    <pre><code class="language-js">
                      function sumar(numero1 = 0, numero2 = 0){
                        console.log(numero1+numero2)
                      }                   
                    </code></pre>
                  
                  <p class="mt-1.25 mb-0"><span class="naranja">Funciones - Function Expression:</span> Sintaxis similar, hacen lo mismo, but en este caso si intentamos llamar a la función antes de declararla nos devuelve error</p>

                  <pre><code class="language-js">
                    sumar(10, 20)
                    // sumar(300, 1)
                    // sumar(100)

                    const sumar = function (numero1 = 0, numero2 = 0){   
                      console.log(numero1+numero2)
                    }
                  </code></pre>
                  <pre><code class="language-js">
                  // En este caso podemos sí podemos llamar a la función antes de declararla. No están ni mucho menos deprecadas y se siguen utilizando mucho.
                  sumar(10, 20)
                  sumar(300, 1)
                  sumar(100)

                  function sumar(numero1 = 0, numero2 = 0){ 
                    console.log(numero1+numero2)
                  }
                  </code></pre>

                  <p class="mt-1.25 mb-0"><span class="naranja">Funciones - Arrow function:</span> Al igual que las function expressions si intentamos llamarla antes de declararla nos da error. La sintaxis es como las function expressions sin la palabra "function" y añadiendo "=>" entre el ")" y la "{"</p>

                  <pre><code class="language-js">
                    //const sumar = function(numero1 = 0, numero2 = 0) {

                    const sumar = (numero1 = 0, numero2 = 0) => {
                        console.log(numero1 + numero2)
                    }
                  
                    sumar(10, 20)
                    sumar(300, 1)
                    sumar(100)
                  </code></pre>

                  <p>Si nuestras funciones solo tienen una línea, podemos eliminar las llaves:</p>
                  <pre><code class="language-js">
                    const sumar = (numero1 = 0, numero2 = 0) => console.log(numero1 + numero2)
                  </code></pre>

                  <p><span class="destacado">Todas las fcnes que hemos visto devuelven valores</span>. A continuación veremos la otra característica que tienen las arrow functions y funciones que devuelven valores</p>
                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-25').toggle();">
                  <h3>25. Funciones que retornan valores</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-25" class="hidden">
                  <p>A continuación veremos la otra característica que tienen las arrow functions y funciones que devuelven valores</p>
                  <pre><code class="language-js">
                    // Funciones que devuelven valores. Veámoslo con los 3 tipos de funciones
                    const sumar = function (numero1 = 0, numero2 = 0){   
                        //console.log(numero1 + numero2)
                        return numero1 + numero2
                    }
                
                    function sumar(numero1 = 0, numero2 = 0){ 
                        //console.log(numero1+numero2)
                        return numero1 + numero2
                    }
                
                    //const sumar = (numero1 = 0, numero2 = 0) => console.log(numero1 + numero2)
                    const sumar = (numero1 = 0, numero2 = 0) => numero1 + numero2 //cuando solo tienen una línea no hace falta que usemos "return"
                
                    /* si tenemos múltiples líneas en la arrow function usamos return 
                    
                    const sumar = (numero1 = 0, numero2 = 0) => {
                        return numero1 + numero2
                    }                  
                    */              
                    const resultado = sumar(10, 20)
                    console.log(resultado)
                  </code></pre>
                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-26').toggle();">
                  <h3>26. Array Methods</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-26" class="hidden">
                <pre><code class="language-js">
                  //Array methods
                  const tecnologias = ['HTML','CSS','Javascript','React.js','Node.js']
                  const numeros = [10, 20, 30]
                  
                  //Filter
                      const nuevoArray = tecnologias.filter(function(tec) {
                          console.log(tec)
                      })
                  
                      // const nuevoArray2 = numeros.filter(function (nume) {
                      //     console.log(nume)
                      // })
                  
                      //también podríamos hacerlo así (sacando la función que va entre "()" fuera):
                  
                      // function ejemploFilter(nume) {
                      //     console.log(nume)
                      // }
                  
                      //esta sintaxis normalmente no se usa, no se crean funciones aparte
                      // const ejemploFilter = (nume) => console.log(nume)    
                      // const nuevoArray2 = numeros.filter(ejemploFilter)
                  
                      //Estos array methods se utilizan mucho y lo que hacen es iterar sobre cada uno de los elementos del array. 
                      //En base a ciertas condiciones podemos hacer algunas operaciones con ellos
                  
                      //IMPORTANTE --&gt; ventajas de uso de arrow function:
                      // (no usamos "function", como es una línea quitamos "{}", no usamos "return" porque se da por implícito que es return en base a la condición indicada
                  
                          // const nuevoArray2 = tecnologias.filter((tech) => tech === 'HTML' )
                          const nuevoArray2 = tecnologias.filter((tech) => tech !== 'HTML' )
                          console.log(nuevoArray2)
                  
                          //recuperando el ejemplo que vimos en 18.js, vemos que hacíamos lo miosmo sin arrow functions
                          const tecnologias2 = tecnologias.filter(function(tech){
                              //console.log(tech)
                              if(tech!=='HTML'){ 
                                  return tech 
                              }
                          })
                          console.log(tecnologias2)
                  
                      //Otra característica de los arrow functions es que si solo es un parámetro podemos eliminar los "()"
                      const nuevoArray3 = tecnologias.filter(tech => tech === 'HTML')
                      console.log(nuevoArray3)
                      //Filter también se puede usar para arrays de tipo numérico
                      const resultado = numeros.filter( num => num !== 10 )
                      console.log(resultado)
                  
                  //Includes --&gt; va a revisar si existe un elemento en un arreglo. En este caso como vemos la implementación es más sencilla, y en consola vemos que devuelve true
                  const resultado2 = tecnologias.includes('CSS')
                  console.log(resultado2)
                  
                      //Podemos ver todos los que hay tanto en la documentación https://developer.mozilla.org/es/docs/Web/JavaScript/Reference/Global_Objects/Array
                      //como en el prototype de la consola
                  
                      //Veamos más array methods. Algunos de ellos tienen un "callback" (una función de order superior=higher order function)
                  
                      //Some --&gt; devuelve si cumple la condición
                      const resultado3 = numeros.some( num => num > 15 ) //revisa si al menos uno de los valores del array numeros cumple la condición. Tengo dos de hecho. decuelve true
                      console.log(resultado3)
                  
                      /*usando este método reducimos código si por ejemplo quisiéamos mostrar un texto cuando se cumple condición, frente a por ejemplo el código a usar si tiramos del método filter
                              if(resultado.length>0){ 
                                  console.log('Si hay elementos')
                          
                              if(resultado3){ 
                                  console.log('Si hay elementos')
                              }
                      */
                  
                  //Find --&gt; devuelve el primer elemento que cumple una condición
                      const resultado4 = numeros.find( num => num > 15 )
                      console.log(resultado4)
                      
                  //Every --&gt; devuelve true o false si todos cumplen la condición
                      const resultado5 = numeros.every( num => num > 8 )
                      const resultado6 = numeros.every( num => num > 15 )
                      console.log(resultado5)
                      console.log(resultado6)
                  
                  //Reduce --&gt; devuelve un acumulado del total. Es de los mas complejos. Toma 2 parámetros.
                      //nos va a permitir hacer el cálculo en carritos de la compra de manera muy simple
                    const resultado7 = numeros.reduce( (total, numero) => { // total y numero(numero actual). El total va a servir como un acumulado
                          console.log('total iteracion: '+total) // solo con esta línea, en consola nos sale 0 y 2 undefined, porque tras el valor inicial no sabe que hacer la vez siguiente
                          console.log('numero iteracion: '+numero) // añadiendo esta línea ya aparecen los números del array alternados con un undefined
                  
                          //console.log(total) funciona como un acumulado. Hagamos por ejemplo que sume el primer valor del array a mi valor inicial 0, y a ese resultado le sume el siguiente valor....
                          //útil si construimos un carrito de compra, para mostrarle al usuario cual es el total a pagar de todos los elementos que tiene en el carrito
                          return total+numero // en 'total' va acumulando y 'numero' es el valor numérico actual del elemento del array numérico en cada iteración 
                    }, 0) //entre las llaves y el paréntesis ponemos un valor inicial de 0
                  
                    //También podríamos escribirla así: 
                    const resultado8 = numeros.reduce( (total, numero) => total + numero, 0 )
                  
                    console.log('resultado7: '+resultado7)     
                    console.log('resultado8: '+resultado8)  
                  
                </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-28-30').toggle();">
                  <h3>28. Condicionales en JavaScript / 29. Comparando con Comprador Estricto / 30. Logical Or y Logical And</h3>
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-28-30" class="hidden">
                <pre><code class="language-js">
                  //Condicionales
                  const disponible = 4000
                  const retirar = 200
                  
                  const auth = true
                  
                  if (auth){
                      //se cumple la condición
                      console.log('Acceso al sistema..')
                  } else {
                      //no se cumple la condición
                      console.log('No tienes permiso, inicia sesión')
                  }
                  
                  /*
                  &gt; mayor&comma; &lt; menor&comma; &gt;= mayor o igual&comma; &lt;= menor o igual&comma; == igual&comma; === igual estricto&comma; !==diferente a 
                  */
                  
                  if (disponible > retirar){
                      //se cumple la condición
                      console.log('Puedes sacar dinero')
                  } else {
                      //no se cumple la condición
                      console.log('No puedes sacar dinero')
                  }
                  
                  const numero1 = 20
                  const numero2 = 20
                  const numero3 = "20"
                  
                  console.log(typeof numero1,typeof numero2)
                  if (numero1 == numero2){
                      console.log('Son iguales')
                  } else {
                      console.log('No son iguales')
                  }
                  
                  console.log(typeof numero1,typeof numero3)
                  if (numero1 == numero3){
                      console.log('Son iguales')
                  } else {
                      console.log('No son iguales')
                  }
                  
                  //SIEMPRE VAMOS A QUERER UTILIZAR EL OPERADOR TRIPLE --> el operador estricto revisa tanto el valor como el tipo de dato. 
                  //Como vemos en ambos casos devuelve que sí se cumple porque el operador que no es estricto revisa el valor 20 y 20
                  console.log(typeof numero1,typeof numero3)
                  if (numero1 === numero3){
                      console.log('Son iguales')
                  } else {
                      console.log('No son iguales')
                  }
                  
                  //Logical Or '||' y Logical And '&&'
                  const saldo = 1000
                  const pagar = 500
                  const tarjeta = false
                  
                  // if( saldo > pagar){ //si mi saldo es mayor
                  //     console.log('Puedes pagar')
                  // } else if (tarjeta) { //si llevo mi tarjeta
                  //     console.log('Puedes pagar')
                  // } else {
                  //     console.log('No puedes pagar')
                  // }
                  /*se ejecuta la primera que se cumpla*/
                  
                  if( saldo > pagar || tarjeta){ //si se cumple una de las dos
                      console.log('Puedes pagar')
                  } else {
                      console.log('No, no puedes pagar')
                  }                
                </code></pre>

                </div>
                <!-- Fin bloque desplegable interior-->
              
                
              



      
      <!-- Bloque desplegable interior -->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-31').toggle();">	
                  <h3>31. Ternarios</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-31" class="hidden">
                  <p></p>
                  <pre>
                    <code class="language-js">
                      /*Ternarios --&gt; un if en una versión mas corta. En React se usa mucho porque en los templates no podemos escribir un if en la poarte que se muestra en pantalla
                      pero sí un ternario*/
                      
                      const auth = true
                      
                      const saldo = 1000
                      const pagar = 1200
                      const tarjeta = false
                      
                      // if (auth){
                      //     console.log('User autenticado..')
                      // } else {
                      //     console.log('No auntenticado, ir a Login')
                      // }
                      
                      //con un operador ternario vamos a poder tener todo lo anterior en una línea. Sintaxis algo compleja
                      
                      auth ? 
                        console.log('User autenticado..') : 
                        console.log('No auntenticado, ir a Login')
                      
                      //otra manera combinando operadores que vimos antes
                      
                      saldo > pagar ?
                        console.log('sí puedes pagar') :
                        console.log('no, no puedes pagar')
                      
                      //ternario anidado (al igual que los if se ejecuta la primera condición que se cumpla). 
                      saldo > pagar ?
                        console.log('sí puedes pagar') :
                        tarjeta ?
                          console.log('puedes pagar con tarjeta') :
                          console.log('no, no puedes pagar')
                      
                      //PERO MEJOR QUE TERNARIOS ANIDADOS ES HACER USO DE OPERADORES PARA MEJOR MANTENIMIENTO DE CÓDIGO
                      saldo > pagar || tarjeta ?
                        console.log('sí puedes pagar') :    
                        console.log('no, no puedes pagar')
                    </code>
                  </pre>						
                </div>
      <!-- Fin bloque desplegable interior -->
      
      <!-- Bloque desplegable interior -->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-32').toggle();">	
                  <h3>32. Optional chaining (?) y Nullish coolescing operator (??)</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-32" class="hidden">
                  <p>Son un par de características de las más nuevas que han añadido a js</p>
                  <p><strong class="text-[#609ad2]">Optional chaining (?) :</strong></p> 
                  <ul class="mb-3.75">
                    <li>permite llamar las propiedades de un objeto o llamar métodos sin tener que verificar si existen o no</li>
                    <li>además de ahorrarnos código, se usa mucho en respuestas rest API o repsuestas de BBDD en las uqe mkuchas veces no está todo relleno como esperamos</li>
                    
                  </ul>
                  <pre>
                    <code class="language-js">								
                      //Optional chaining (?) 
                        
                        const alumno = {
                          nombre: 'Juan',
                          clase: 'Programación 1',
                          aprobado: true,
                          examenes: {
                            examen1: 9
                          }
                        }
                        console.log(alumno)
                        console.log('Despues de ALUMNO')
      
                        //si hiciera esto me daría error porque esa propiedad examen1 no está definida, y el resto de mi js deja de funcionar (no saca lo de 'después de ALUMNO'):
                          //console.log(alumno.examenes.examen1)
                        
                        //para esto utilizamos el optional chaining, para ver si existe la propiedad examenes y entonces que nos imprima examen1 (evitamos usar ifs y más código)
                          console.log(alumno.examenes?.examen1)
                          console.log('Despues de ALUMNO')
                      </code>
                    </pre>
                    <p><strong class="text-[#609ad2]">Nullish coolescing operator (??):</strong> operador lógico que devuelve el valor del lado dcho cuando el valor izdo es nulo o undefined</p> 
                    <pre>
                      <code class="language-js">	
                      //Nullish coolescing operator (??) 
                        // por ejemplo se usa mucho cuadno se trabaja con un paginador desde la url. Cuando en la urlpage no tenemos esto: "?page=1"
                        const pagina = null ?? 1
                        // si tuviéramos este ejemplo "?page=10" 
                        // const pagina = 10 ?? 1 --&gt; este nos devolveria 10
                        console.log(pagina)
                      </code>
                    </pre>
                </div>
      <!-- Fin bloque desplegable interior -->
      
                
      <!-- Bloque desplegable interior -->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-34').toggle();">	
                  <h3>34-36. Introducción a ECMAScript Modules, más sobre módules y export default</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>					
                <div id="seccion2-34" class="hidden">						
                  <p>Se utilizan mucho en React y en el desarrollo web hoy en día ya que normalmente cuando instalas una dependencia/librería, esa dep. te permite importar ciertas funciones
                    el mismo React te permite importar sus funciones para que puedas utilizarlas en tu código
                    Supongamos que estamos creando un proyecto y vamos teniendo cada vez más y más funciones (pone el ejemplo de los tropecientos .js en nuestro html) --> eso se soluciona con los 
                    módulos de ECMAScript, que nos permiten separar nuestro código.</p>
        
                  <p>creamos un nuevo "funciones.js" donde metemos nuestras funciones y en nuestro html le indicamos al js que es de type module, y ello nos va a habilitar el poder importar.
                  dentro de nuestro .js de funciones le añadimos un "export" antes de cada función. En el .js donde queramos usar las funciones usamos un import</p>
                  
                  <pre>
                    <code class="language-js">
                      //ESTOS MODULOS ESTAN PRESENTES EN TODAS LAS TECNOLOGÍAS DE JS VUE, NODE, REACT... NOS PERMITEN SEPARAR NUESTRO CÓDIGO Y UN MEJOR MANTENIMIENTO
                      // export function sumar (n1, n2){
                        //     return n1 + n2
                        // }
                        // export function restar (n1, n2){
                        //     return n1 - n2
                        // }
                        // export default function multiplicar (n1, n2){
                        //     return n1 * n2
                        // }
                        // export function dividir (n1, n2){
                        //     return n1 / n2
                        // }
                        
                        export const sumar = ( n1, n2 ) => n1 + n2
                        export const restar = ( n1, n2 ) => n1 - n2 
                        
                        const multiplicar = ( n1, n2 ) => n1 * n2 
                        export default multiplicar
                        
                        export const dividir = ( n1, n2 ) => n1 / n2 
      
                        /* Ambos tipos de export requieren que al importarlos se llamen entre llaves y con el mismo nombre (salvo que usemos un alias)
                        Como vamos a importar muchas funciones, variables... de muchas librerias ¿como hacemos para evitar la colisión de nombres? utilizamo "alias" --> import {sumar as funcionSumar} 
      
                        Existe otro export que es el export default: solo puede haber uno por archivo. Lo importas sin llaves y nombras como queramos
      
                        export default function multiplicar (n1, n2){
                          return n1 * n2
                        }
                        */
                    </code>
                  </pre>   
                  
                  <pre>
                    <code class="language-js">
                  import agusmultiplica, { sumar, restar, dividir } from './funciones.js' // esta es la mejor manera de importar las funciones que nos ofrecen las dependencias/librerías
      
                  const resultadoSumar = sumar(25, 30)
                  const resultadoRestar = restar(25, 30)
                  const resultadoMultiplicar = agusmultiplica(25, 30)
                  const resultadoDividir = dividir(100, 10)
                  console.log(resultadoSumar + '\n' + resultadoRestar + '\n' + resultadoMultiplicar + '\n' + resultadoDividir);
                    </code>
                  </pre>   								
                </div>
      <!-- Fin bloque desplegable interior -->
      
      <!-- Bloque desplegable interior -->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-37').toggle();">	
                  <h3>37. Fetch API con Promises</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-37" class="hidden">
                  <p>Proporciona una interfaz para poder recuperar recursos y obtener datos a través de la red. Es la versión moderna de las dos tecnologías 
                    XMLHttpRequest(sintaxis muy difícil) y $.ajax. Usaremos esta herramienta {JSON Placeholder} 
                    <a class="text-[#cc3333]" href="https://jsonplaceholder.typicode.com" target="_blank">https://jsonplaceholder.typicode.com</a>. Podemos ver este ejemplo de uso en esa misma url:</p>
                  <pre>
                    <code class="language-js">
                      fetch('https://jsonplaceholder.typicode.com/todos/1')
                      .then(response => response.json())
                      .then(json => console.log(json))
                    </code>
                  </pre>
                  
                  <p>Vamos a trabajar con el json de 'Comments' <a href="https://jsonplaceholder.typicode.com/comments" class="blank">https://jsonplaceholder.typicode.com/comments</a>. Un json es muy parecido a un XML nos da unos datos con una estructura que podemos renderizar en nuestras aplicaciones.</p>
                  <p>También con FetchAPI es posible obtener datos de un archivo .txt</p>
                  <p>Para usarlo tenemos dos opciones, o ponerlo directamente en el código o meterlo en una función y mandarla llamar.<br>
                  fetch() utiliza promises, que fueron agregados en la versión de js moderno ECMAScript6. Podemos pensar en los promises como un objeto que va a estar disponible a futuro o no. Los promises cuentan con varios pasos y también con varios estados. Esos pasos se representan por una sintaxis que es <span class="destacado">.then()</span> siendo la lectura algo como "quiero obtener los datos de esta url, entonces tengo mi respuesta...voy a hacer..." El .then toma automáticamente un callback, una función que podemos nombrar como queramos <strong>then((response) => {})</strong></p>
                  <pre>
                    <code class="language-js">								
                      fetch(url)
                        .then((response) => {
                          console.log(response)
                        })
                    </code>
                  </pre>
                  <p>En la respuesta de la consola vemos en el Response que el ok es true y el status 200 --> la url existe (si no existiera tendríamos false y 404). Type cors lo veremos mas adelante, es complicado. Podremos ver como personalizar nuestros estados. Las APIS se comunican entre sí con estados numéricos, también los veremos en detalle.</p>
      
                  <img class="my-2.5" src="./src/assets/img/37-1.png" alt="" />
      
                  <p>Vemos qe no aparecen los datos por ningún sitio, pero si abrimos el prototype sí vemos los métodos <strong>json() y text()</strong>, que sirven apra decirle qué tipo de datos es el que estoy obteniendo (o un txt o un json). Como es un json le especificamos en el callback que retorne la respuesta como json <span class="destacado">return response.json()</span> lo cual nos dará acceso a otro promise con el que obtendremos los datos:</p>
      
                  <pre><code class="language-js">
                    fetch(url)
                      .then((response) => {									
                        return response.json()
                      })
                      .then(data => {
                        console.log(data)
                      })							
                  </code></pre>
                  
                  <p>Como vemos tenemos un .then() y otro .then() y así funcionan los promises, estamos llamando a esa url y no sabemos si vamos a poder obtener los datos o no. En este caso esta url que estamos usando es pública para aprender pero no podemos obtener los datos de por ejemplo instagram, youtubbe... solo haciendo un llamado a una url, en esos casos va a fallar la petición. Como no sabemos el tipo de respuesta que vamos a tener por eso tenemos estos pasos: </p>
                  <ul class="mb-3.75">
                    <li>trato de conectarme a un servidor</li>
                    <li>entonces, si tengo respuesta la quiero como json y estos comentarios son 500 (el tiempo de respuesta no va a ser igual si tengo 2 respuestas que si tengo 500)</li>
                    <li>una vez que finalice de ejecutarse el código del primer promise, tengo acceso a los datos con el segundo</li>
                  </ul>	
      
                  <p>Si la url fuera incorrecta, recordemos que el ok saldrá a false, response 200 y tendremos un segundo objeto vacío (del 2º promise). Podemos añadir un catch para intentar especificar algo en caso de error, sin embargo como veremos en la consola no se ejecuta el console log del catch ¿por qué? porque con el fetch() así especificado, el catch solo se ejecuta cuando hay problemas de red (podemos forzarlo quitando la wifi).</p>
      
                  <pre><code class="language-js">
                    const url = 'https://jsonplaceholder.typicode.com/urlerronea'
                    fetch(url)
                      .then((response) => {	
                        //console.log(response)								
                        return response.json()
                      })
                      .then((data) => {
                        console.log(data)
                      })	
                      .catch(error=>{
                        console.log(error)
                      })
                  </code></pre>
      
                  <p>Hagamos lo siguiente mejor (if para cuando hay respuesta y un throw new Error para cuando falle) y como veremos, el nuevo error pasará al .catch(). Aprovechamos las funciones de flecha para simplificar la sintaxis del 2º promise y el catch:</p>
      
                  <pre><code class="language-js">
                    fetch(url)
                      .then((response) => {	
                        //console.log(response)
                        if(response.ok){								
                          return response.json()
                        } 
                        throw new Error('Hubo un error')
                      })
                      .then(data => console.log(data))	
                      .catch(error=> console.log(error))								
                  </code></pre>
      
                  <img class="my-2.5" src="./src/assets/img/37-2.png" alt="" />
      
                  <p>Como decíamos podemos usarlo sin función como acabamos de ver en el ejemplo anterior o también dentro de una función que mandaremos llamar. Funcionaría igual y este sería el código:</p>
                  <pre>
                    <code class="language-js">
                      const url = 'https://jsonplaceholder.typicode.com/comments'
      
                      const consultarAPI = () => {
                        fetch(url)
                          .then((response) => {	
                            //console.log(response)
                            if(response.ok){								
                              return response.json()
                            } 
                            throw new Error('Hubo un error')
                          })
                          .then(data => console.log(data))	
                          .catch(error=> console.log(error.message))
                      }
                      consultarAPI()
                    </code>
                  </pre>
      
                  <p>Fetch API con promises es una gran mejora pero Async Await lo hace aún más simple</p>						
                </div>
      <!-- Fin bloque desplegable interior -->
      
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-38').toggle();">	
                  <h3>38. Fetch API con Async / Await</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-38" class="hidden">
                  <p class="font-bold">Fetch con Async / Await <strong>sí requiere una función</strong>, que puede ser un arrow function o un function declaration. A continuación escribiremos código con ambas. En este caso ha de ser asíncrona (por eso requiere una función). Para el caso de función de flecha colocamos la palabra <span class="destacado">async</span> antes de los paréntesis, lo que convierte a la función en asíncrona y nos da acceso a la otra propiedad: <span class="destacado">await</span> que son los que reemplazan a los .then() del ejemplo anterior.</p>
                  
                  <p>El await (como antes los then) espera a que se realice la petición, ocurra una respuesta y vuelve a utilizar otro await para obtener los datos. Tengamos en cuenta que la conexión a una API externa dependerá del tipo de servidor (servidor gratis vs servidor de 1000$/mes) y la conexión que tengamos; y como decíamos leer los datos no va a ser lo mismo leer 2 registros que 500. Los await esperan que finalice de ejecutarse ese código para ir a la siguiente línea.</p>		
      
                  <p>La sintaxis es un poco diferente y se lee más como "de derecha a izquierda"</p>
      
                  <pre><code class="language-js">
                    const url = 'https://jsonplaceholder.typicode.com/comments'
                    /*
                    fetch(url)
                      .then((response) => {	
                        //console.log(response)
                        if(response.ok){								
                          return response.json()
                        } 
                        throw new Error('Hubo un error')
                      })
                      .then(data => console.log(data))	
                      .catch(error=> console.log(error.message))
                    */
                    const consultarAPI = async () => {
                      const response = await fetch(url)
                      const data = await response.json()
                      console.log(data)
                    }
                    consultarAPI()
                  </code></pre>
      
                  <p>Estos dos códigos hacen lo mismo, pero hay un detalle. Con Async / Await no hay forma de catchear un posible error. Por lo que normalmente cuando usamos Async / Await se usa junto a algo llamado Try Catch. En el caso de que cualquiera de las acciones indicadas en el Try falle, ejecuta lo que especifiquemos en el catch:</p>
      
                  <pre><code class="language-js">
                    const url = 'https://jsonplaceholder.typicode.com/comments'
                    const consultarAPI = async () => {
                      try {
                        const response = await fetch(url)
                        if(!response.ok){
                          throw new Error('Hubo un error')
                        }
                        const data = await response.json()
                        console.log(data)
                      } catch (error) {
                        console.log(error)
                      }
                    }
                    consultarAPI()
                  </code></pre>						
                </div>
      <!-- Fin bloque desplegable interior-->
      
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-39').toggle();">	
                  <h3>39. Medir performance y cómo manejar múltiples consultas</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-39" class="hidden">
                  <p>JS tiene una API para medir la performance de nuestro código. Más de una vez vamos a tener distintos códigos que hagan lo mismo y vamos a querer medir cual es la versión más rápida. Utilizamos para ello <span class="destacado">performance.now()</span>. Lo usamos al principio y al final de nuestro try y sacamos por consola la diferencia en ms. Veremos que en función de la url que usemos (que carga más o menos datos) ese rendimiento en ms varía.</p>
                  <pre>
                    <code class="language-js">
                      //Performance y múltiple Async Await
                      const url = 'https://jsonplaceholder.typicode.com/comments'
                      const url2 = 'https://jsonplaceholder.typicode.com/todos'
                      const url3 = 'https://jsonplaceholder.typicode.com/photos'
                      const consultarAPI = async () => {
                        try {
                          const inicio = performance.now()			
                          const response = await fetch(url3)
                          if(!response.ok){
                            throw new Error('Hubo un error')
                          }
                          const data = await response.json()
                          console.log(data)
                      
                          const fin = performance.now()			
                          console.log(`El resultado es: ${fin - inicio} ms`)
                        } catch (error) {
                          console.log(error)
                        }
                      }
                      consultarAPI()
                    </code>
                  </pre>
                  <p>Una aplicación real obtiene datos de muchos sitios distintos. Tal vez nuestra empresa tenga un rp, crm, e-commerce, sistemas de facturación... tal vez estamos creando algo que consume datos de diferentes lugares. Un error muy común es hacer lo siguiente, supongamos que consumimos los 3 "endpoints" de esta manera, vemos la consola (izquierda):</p>
                  <pre>
                    <code class="language-js">
                      //Performance y múltiple Async Await
                      const url = 'https://jsonplaceholder.typicode.com/comments'
                      const url2 = 'https://jsonplaceholder.typicode.com/todos'
                      const url3 = 'https://jsonplaceholder.typicode.com/photos'
                      const consultarAPI = async () => {
                        try {
                          const inicio = performance.now()	
      
                          const response = await fetch(url)				
                          const data = await response.json()
                          console.log(data)
                      
                          const response2 = await fetch(url2)				
                          const data2 = await response2.json()
                          console.log(data2)
                      
                          const response3 = await fetch(url3)				
                          const data3 = await response3.json()
                          console.log(data3)
                      
                          const fin = performance.now()			
                          console.log(`El resultado es: ${fin - inicio} ms`)
                        } catch (error) {
                          console.log(error)
                        }
                      }
                      consultarAPI()
                    </code>
                  </pre>
                  <p>usar así los awaits esperando a que cada llamada anterior se resuelva va a hacer que nuestras apps sean más lentas. <strong>¡OJO! va a a habver ocasiones en que realmente querramos llamarlas así secuencialmente porque el siguiente procesado necesite los datos anteriores</strong>. Pero veamos cómo hacerlo en caso de que queramos procesar a la vez todas las llamadas y no secuencialmente. Emplearemos <span class="destacado">Promise.all()</span>:</p>
      
                  <pre><code class="language-js">
                    const consultarAPI2 = async () =>{
                      try {
                        const inicio = performance.now()
                    
                        const [response, response2, response3] = await Promise.all([fetch(url),fetch(url2),fetch(url3)])
                        const [data, data2, data3] = await Promise.all([response.json(),response2.json(),response3.json()])			  
                        console.log(data)     
                        console.log(data2)    
                        console.log(data3)		
                    
                        const fin = performance.now()
                    
                        console.log(`El resultado de la SEGUNDA función es: ${fin - inicio} ms`)
                      } catch (error) {
                        console.log(error)
                      }
                    }
                    consultarAPI2()
                  </code></pre>
      
                  <p>Si vemos en la consola (derecha) el resultado de ejecutar las dos funciones <strong>(ver 39-performance.js)</strong> veremos que siempre en cada ejecución, la primera que termina (por tanto con mejor rendimiento, termina en menos ms) es la segunda función.</p>	
                  
                  <img class="my-2.5" src="./src/assets/img/39-1.png" alt="" />
      
                  
                </div>
      <!-- Fin bloque desplegable interior-->
      
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-40').toggle();">	
          <h3>40. DOM - Selectores</h3>			
          <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-40" class="hidden">
                  <p>Va a ser corto porque de hecho la forma de escribir código de DOM en JS es un poco diferente a como React lo maneja porque tiene algo llamado JSX que simplifica mucho. Pero siempre viene bien aprender o refrescar. Abrimos el DOM.html y colocamos el script:</p>
                  <pre>
                    <code class="language-html">
                      &lt;script src=&quot;js/40-DOM-selectores.js&quot;&gt;&lt;/script&gt;
                    </code>
                  </pre>
      
                  <p><strong>Selectores</strong>. Todas las interacciones que haces en el DOM con js requieren un selector. Es como en CSS seleccionas un elemento y empiezas a aplicar propiedades css para cambiar apariencia. En JS vas a aseleccionar algún elemento de tu página y vas a regresar operaciones por medio de js para agregar, modificar o eliminar atributos.</p>		
      
                  <p>queremos seleccionar este elemento del DOM.html:</p>
      
                  <pre><code class="language-html">
                    &lt;h1 class=&quot;text-4xl font-black heading&quot;&gt;JavaScript Intermedio - Manipulaci&oacute;n de DOM &lt;/h1&gt;
                  </code></pre>
      
                  <p>iniciamos con <span class="destacado">document</span>(podemos poner en consola document y vemos que es el documento entero.) De hecho podemos poner en consola document.title y vemos que saca el título de la página. pero para otro tipo de elementos de dentro del html hemos de utilizar <span class="destacado">querySelector()</span>. También comenta los que conocemos <strong>.getElementById</strong>, <strong>.getElementsByTagName</strong>, etc... pero hoy día se recomienda utilizar más la sintaxis con querySelector() porque tenemos acceso a selectores muy similares a los de css (.clase, #id, :last-of-type, :nth-child(),...), y sabiendo css los mismos selectores aplican para seleccionar elementos en js. Como hay selectores muy complejos, podremos seleccionar prácticamente cualquier elemento.</p>
      
                  <p>Si hacemos un console.log(heading), vemos que nos pone el elemento h1 como está con todo lo que contiene tanto el tag en sí como su contenido. Así seleccionado un elemento tenemos acceso a sus atributos, lo que conocemos como el DOM. El DOM podemos modificarlo y recorrerlo.</p>
      
                  <div class="flex">
                    <pre><code class="language-js">
                      const heading = document.querySelector('.heading')
                      console.log(heading)
                      console.log(heading.tagName)
                      console.log(heading.textContent)
                      console.log(heading.classList)
                    </code></pre>
      
                    <img class="my-2.5" src="./src/assets/img/40-1.png" alt="" />
                  </div>
      
                  <p>Veamos ahora el <span class="destacado">querySelectorAll()</span>. La principal diferencia es que trae <strong>TODOS</strong> los elementos que tengan correspondencia con ese selector, mientras que querySelector() solo trae uno (aunque haya más que correspondan con el selector indicado entre paréntesis, solo trae el primero que encuentra)</p> 
                  <pre><code class="language-html">
                    &lt;nav class=&quot;navegacion my-5 flex gap-5&quot;&gt;
                      &lt;a href=&quot;&num;&quot;&gt;Enlace 1&lt;/a&gt;
                      &lt;a href=&quot;&num;&quot;&gt;Enlace 2&lt;/a&gt;
                      &lt;a href=&quot;&num;&quot;&gt;Enlace 3&lt;/a&gt;
                      &lt;a href=&quot;&num;&quot;&gt;Enlace 4&lt;/a&gt;
                    &lt;/nav&gt;		
                  </code></pre>
      
                  <div class="flex">
                    <pre><code class="language-js">
                      const enlaces = document.querySelectorAll('.navegacion a')
                      console.log(enlaces)
                    </code></pre>
      
                    <img class="my-2.5" src="./src/assets/img/40-2.png" alt="" />
                  </div>
      
                  
                </div>
      <!-- Fin bloque desplegable interior-->
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-41').toggle();">	
                  <h3>41. Manipular elementos HTML con JS</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-41" class="hidden">
                  <p>Veamos algunos ejemplos</p>
                  <pre>
                    <code class="language-js">
                      const heading = document.querySelector('.heading')
                      const enlaces = document.querySelectorAll('.navegacion a')
                      //console.log(heading.textContent)
                      
                      heading.textContent = 'Un nuevo Heading'
                      heading.id = 'Un nuevo id'
                      heading.removeAttribute('id')
                      heading.removeAttribute('class')
                    </code>
                  </pre>
      
                  <p>Es muy comun que muchos formularios tengan ya un value por default:</p>		
      
                  <pre><code class="language-js">
                    const inputNombre = document.querySelector('#nombre')
      
                    //normalmente los atributos de los tags HTML se llaman igual los atributos de JS
                    inputNombre.value = 'Un nuevo valor'
                    //aunque no siempre, por ejemplo las clases o los atributos personalizados data-nombre="input"
                    console.log(inputNombre.classList)
                    inputNombre.dataset.nombre = "input"
                    
                    //Veamos como manipular colecciones. hemos de pasarle la posición o iterar sobre los elementos
                    console.log(enlaces)
                    enlaces.forEach( enlace => enlace.textContent = 'Nuevo Enlace')
                  </code></pre>
                </div>
      <!-- Fin bloque desplegable interior-->
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-42').toggle();">	
                  <h3>42. DOM eventos con click - <a href="https://developer.mozilla.org/es/docs/Web/API/Element" class="text-[#000000]" target="blank">Enlace MDN Element</a></h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-42" class="hidden">
                  <p>Una de las características ppales de JS es que podamos añadir interacción a nuestras aplicaciones/sitios web. Veamos algunos eventos que nos van a permitir eso.</p>
                  <pre>
                    <code class="language-js">
                    const heading = document.querySelector('.heading')
                    //vimos como podemos cambiar por ejemplo el contenido del tag por un nuevo título
                    heading.textContent = 'nuevo título'
                    </code>
                  </pre>
                  <p>Supongamos que quiero esperar a que por ejemplo alguien presione en el titulo para modificarlo. <strong>Una vez que seleccionas un elemento tienes acceso a registrarle un evento con el evento <span class="destacado">addEventListener()</span></strong>. Veamos el siguiente link https://developer.mozilla.org/es/docs/Web/API/Element, en la parte derecha podemos ver los eventos. Los hay de todo tipo, del mouse, de animaciones, eventos cuando copias algo con el teclado,... </p>	
                  
                  <p>esto es lo que se conoce como un callback, espera que ocurra el evento del primer argumento y cuando ocurre se dispara la función indicada en el segundo argumento.</p>
      
                  <pre><code class="language-js">
                    heading.addEventListener('click', () => {
                      heading.textContent = 'Al dar click'
                    })
                    heading.addEventListener('dblclick', () => {
                      heading.textContent = 'Al dar doble click'
                    })
                    heading.addEventListener('mouseenter', () => {
                      heading.textContent = 'Al entrar'
                    })
                    heading.addEventListener('mouseleave', () => {
                      heading.textContent = 'Al salir'
                    })
                  </code></pre>
      
                  <p>Para añadir addEventListener a los integrantes de un document.querySelectorAll utilizamos el forEach:</p> 
      
                  <pre><code class="language-js">
                    const enlaces = document.querySelectorAll('.navegacion a')
                    enlaces.forEach( enlace => {
                      enlace.addEventListener('click', () => {
                        console.log('diste click en un enlace')
                      })
                    })
                  </code></pre>	
      
                  <p>Vemos que al pulsar cada link la página nos da un salto. El elemento enlace tiene una acción por default que es intentar ir la url indicada en el href pero en nuestro caso no hay nada tenemos un #. Veamos. A la función que se dispara al realizar el evento le podemos pasar un parámetro que llamamos <strong>e, evento, evt, ...</strong> como queramos, y si hacemos un console log de ello vemos que aparece una gran cantida de información sobre el evento que se está llevando a cabo. Si scrolleamos un poco hacia abajo llegamos al "target" que nos da la información de qué es lo que ha disparado ese evento. Hacemos un console.log de e.target y nos da información de qué es a lo que hemos dado click:</p>
                  <pre><code class="language-js">
                    const enlaces = document.querySelectorAll('.navegacion a')
                    enlaces.forEach( enlace => {
                      enlace.addEventListener('click', (e) => {
                        console.log(e.target)
                        console.log('diste click en un enlace')
                        e.preventDefault()
                        e.target.textContent="diste click"
                      })
                    })
                  </code></pre>
                  <img class="my-2.5" src="./src/assets/img/42-1.png" alt="" />
      
                  <p>cuadno enviamos un formulario hay una acción por default, cuando haces click en un botón hay una acción por default, si presionas un heading o una imagen no hay una acción por default... pero los links es uno d elos elementos que sí tiene una acción por default. usamos <span class="destacado">e.preventDefault()</span> que básicamente le dice al link "ok, tú tines un comportamiento que es abrir una url. No lo hagas.</p>
      
                  <p>Por tanto nosotros mediante código podemos modificar las acciones a realizar, por ejemplo en un formulario, que en vez de enviarse haga validaciones. Importante:</p>
                  <ul class="mb-3.75">
                    <li><span class="destacado">e.preventDefault()</span> nos va a permitir <strong>prevenir la accion por defecto de algún elemento html que realiza algo</strong></li>
                    <li>ese <span class="destacado">e</span> reporta <strong>el evento que se está registrando</strong>, en nuestro ejemplo el click </li>
                    <li>el <span class="destacado">e.target</span> es <strong>lo que dispara ese evento</strong>, en nuestro ejemplo un enlace</li>
                  </ul>
                </div>
      <!-- Fin bloque desplegable interior-->
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-43').toggle();">	
                  <h3>43. DOM eventos en inputs</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-43" class="hidden">
                  <p>En nuestro DOM.html tenemos estos dos inputs:</p>
                  <pre>
                    <code class="language-html">
                      &lt;input type=&quot;text&quot; placeholder=&quot;Tu Nombre&quot; id=&quot;nombre&quot; class=&quot;p-2 rounded-lg text-sm&quot;&gt;
      
                      &lt;input type=&quot;password&quot; placeholder=&quot;Tu Password&quot; id=&quot;password&quot; class=&quot;p-2 rounded-lg text-sm&quot;&gt;
                    </code>
                  </pre>
      
                  <p>Queremos leer lo que el usuario va escribiendo en el input de nombre. registramos un addEventListener()</p>		
                  <pre>
                    <code class="language-js">
                      const inputNombre = document.querySelector('#nombre')
                      inputNombre.addEventListener('input', (e) => {
                        console.log('escribiendo')
                        console.log(e.target)
                        console.log(e.target.value)
                        console.log(e.target.value.length)
                      })		
                    </code>
                  </pre>
                  <p>Por defecto en un input de tipo password el contenido sale ofuscado. Queremos ver lo que escribimos durante poco tiempo y luego que se vuelva a ofuscar.</p>
                  <pre>
                    <code class="language-js">
                      const inputPassword = document.querySelector('#password')
                      inputPassword.addEventListener('input', functionPassword)
                      function functionPassword() {
                        inputPassword.type = "text"
                        setTimeout(() => {
                          inputPassword.type = "password"
                        }, 500)
                      }		
                    </code>
                  </pre>
                  
                </div>
      <!-- Fin bloque desplegable interior-->
      
      
      <!-- Bloque desplegable interior-->
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion2-44').toggle();">	
                  <h3>44. Eventos en Submit. 45. Validando formulario y mostrando alertas.</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                <div id="seccion2-44" class="hidden">
                  <p>En nuestro formulario tenemos este input de tipo submit. El evento de submit se llama cuando alguien presiona sobre el formulario para enviarlo:</p>
                  <pre>
                    <code class="language-html">
                      &lt;input type=&quot;submit&quot; value=&quot;Iniciar Sesi&oacute;n&quot;
                      class=&quot;bg-cyan-500 hover:bg-cyan-600 text-sm uppercase p-2 font-black text-white cursor-pointer&quot;&gt;
                    </code>
                  </pre>
      
                  <p>Veamos un ejemplo de una validación sencilla:</p>
                  <pre>
                    <code class="language-js">
                      const formulario = document.querySelector('#formulario')
                      formulario.addEventListener('submit', e => {
                        e.preventDefault
                      
                        const nombre = document.querySelector('#nombre').value
                        const password = document.querySelector('#password').value
                      
                        if(nombre === '' || password === ''){
                          console.log('Todos los campos son obligatorios')
                        } else {
                          console.log('Todo bien, iniciando sesión')
                        }
                        // console.log('Enviando formulario')
                        // console.log(nombre)
                        // console.log(password)    
                      })
                    </code>
                  </pre>
      
                  <p>Creamos con JS un elemento html div al que vamos a añadir unas clases de tailwindcss para darle formato.</p>
      
                  <p>Hemos de seleccionar siempre un elemento de nuestro document en el que queremos renderizar lo que estamos creando. Como estamos creando un div de alerta de validación, tiene sentido que lo queramos mostrar en el formulario. Por tanto agregamos la alerta como un hijo del formulario <span class="destacado">formulario.appendChild(alerta)</span></p>
                  <pre>
                    <code class="language-js">
                      const formulario = document.querySelector('#formulario')
                      formulario.addEventListener('submit', e => {
                        e.preventDefault
                        const nombre = document.querySelector('#nombre').value
                        const password = document.querySelector('#password').value
                        
                        //Prevenir nuevas alertas
                        const alertaPrevia = document.querySelector('.alerta')
                        /*if (alertaPrevia){
                          alertaPrevia.remove();
                        }*/
                        alertaPrevia?.remove(); //comprobamos si existe con el optional chaining
      
                        const alerta = document.createElement('DIV')
                        //alerta.textContent = 'contenido de alerta'
                        //alerta.classList = 'clase-1 clase-2' //se pueden añadir así clases de estilo pero se recomienda hacerlo usando .add()
                        //alerta.classList.add('clase-1','clase-2','clase-3')
                        //añadamos clases de Tailwind css
                        alerta.classList.add('alerta','text-white','uppercase', 'text-sm', 'text-center', 'p-2', 'font-black')   
                    
                        if(nombre === '' || password === ''){
                          alerta.textContent = 'Todos los campos son obligatorios'
                          alerta.classList.add('bg-red-500')
                        } else {
                          alerta.textContent = 'Todo bien, iniciando sesión'
                          alerta.classList.add('bg-green-500')
                        }
                        //para eliminar la alerta pasados 2sg
                        setTimeout(() => {
                          alerta.remove()
                        }, 2000);
                        //console.log(alerta)
                        formulario.appendChild(alerta)
                      })
                    </code>
                  </pre>	
                </div>
      <!-- Fin bloque desplegable interior-->
                
              </div>			
            </div><!--Fin row-->
              
              
            
          </div>
          <!-- Fin div colapsable-->
      
      
        </div>
      </div>	
      <!-- SECCION 2 -->	


      <!-- SECCION 1 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
        <div class="row">
          <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion1').toggle();">	
            <h2>Sección 1: Introducción al Curso - Qué es React, Proyectos que Construiremos y más</h2>				
                    <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
          </div>
          
          <div id="seccion1"  class="hidden">			
            <div class="row">
              <div class="col-12 pl-1.25">	
                
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion1-1').toggle();">	
                  <h3>1. ¿Qué es React?</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>
                
                <div id="seccion1-1" class="hidden">	
                  
                  <p>Es una biblioteca de JS para construir interfaces de usuario</p>
                  <ul class="mb-3.75">
                    <li>Ayuda a crear UI interactivas de forma muy sencilla (tiene muchas funciones y eventos para disparar fcnes en base a las interacciones del usuario)</li>
                    <li>Se encarga de actualizar y renderizar de manera eficiente los componentes de tu aplicación</li>
                    <li>Esta basado en componentes: no son mas que fiunciones en JS utilizados para renderizar el diseño de tu aplicación o sitio web</li>
                    <li>Creado por Meta (antiguo Facebook). También la empresa Versell apoya su desarrollo.</li>
                  </ul>
    
                  <p class="font-bold">Ventajas de React</p>			
                  <ul class="mb-3.75">
                    <li>Excelente documentación con muchos ejemplos</li>
                    <li>Una gran comunidad y muchas librerias que puedes incorporar a tus proyectos</li>
                    <li>Tecnología con mucha demanda: La mayoría de vacantes solicitan React, tanto para fornt end como para full stack</li>
                  </ul>
    
                  <p class="font-bold">¿Qué necesito para aprender React?</p>
                  <ul class="mb-3.75">
                    <li>Dominar HTML y CSS</li>
                    <li>Conocer la sintaxis Moderna de Javascript (ES6(2015)EcmaScript6 y cada añao hay nuevas que añaden unas cuantas funciones más)</li>
                    <li>Tener instalado Node.js para crear nuestros proyectos</li>
                  </ul>
                  
                </div><!-- Fin seccion colapsable interior  -->
                
                
              </div>			
            </div><!--Fin row-->
              
            <div class="row">
              <div class="col-12 pl-1.25">	
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion1-2').toggle();">	
                  <h3>2. Proyectos 01 a 04 del Curso - Fundamentos de React y TypeScript</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>						
                
                <div id="seccion1-2" class="hidden">	
                  
                  <p class="font-bold">Proyecto carrito de compras GuitarLA</p>
                  <p>En este proyecto estaremos aprendiendo los fundamentos de React: <span class="destacado">Componentes, Eventos y State</span>, mientras creas un carrito de compras real con cantidades, precios, y más, tomaremos este mismo carrito para mostrarte como crear tus propios Hooks y como transformarlo a código de TypeScript y cuales son sus beneficios. Carrito de compra persistente sincronizando con localStorage (aprenderemos todas esas acciones agregar elementos, cambiarlos, cambiar cantidades, vaciar carrito...)</p>							
                  <img class="my-2.5" src="./src/assets/img/s1-01.jpg" width="" height="" alt=""/> 
    
                  <p class="font-bold">Calculadora de propinas y consumos. Un proyecto ideal para restaurantes donde se podrá generar una orden con consumos y la persona podrá elegir la propina que desea dejar.</p>							
                  <img class="my-2.5" src="./src/assets/img/s1-02.jpg" width="" height="" alt=""/> 
    
                  <p class="font-bold">Contador de Calorías y Ejercicios</p>	
                  <p> Una de las tareas que más vas a realizar en tu vida como Developer es procesar formularios; en este proyecto tendremos un formulario, leeremos sus datos, lo vamos a procesar y realizar algunas operaciones como validación y mucho más, además aprenderás que es <span class="destacado">useReducer</span> para manejar estados complejos en tus apps. Veremos cómo funciona este patrón, es un hook especial cuando tenemos un state un poco más complejo.</p>
                  <img class="my-2.5" src="./src/assets/img/s1-03.jpg" width="" height="" alt=""/> 
                  
                  
                  <p class="font-bold">Control de Gastos y Presupuestos:</p>	
                  <p>En este proyecto estaremos viendo que es <span class="destacado">Context API</span> para tener un estado global sin dependencias; Context API va a ayudarte a no pasar props por cada componente, completamos el curso con filtrar gastos por categoría, calendario de fechas de gastos, gráficas y mucho más! Por tanto también usaremos reducers, context Api para comenzar a trabajar con un estado global y un custom hook.</p>
                  <img class="my-2.5" src="./src/assets/img/s1-04.jpg" width="" height="" alt=""/> 
                  
                </div><!-- Fin seccion colapsable interior  -->
              </div>
            </div><!--Fin row-->
            
            
            
            
            <div class="row">
              <div class="col-12 pl-1.25">	
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccion1-3').toggle();">	
                  <h3>3. Proyectos 05 a 08 del Curso - React Intermedio y API's</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>						
                
                <div id="seccion1-3" class="hidden">	
                  
                  <p class="font-bold">Administrador de pacientes de veterinaria</p>
                  <p>Introduce dos herramientas nuevas: Este proyecto añade dos herramientas nuevas: <span class="destacado">Zustand</span> para manejar un estado global de forma muy simple y <span class="destacado">React Hook Form</span>, una librería para para la parte de validación y procesamiento de nuestros formularios de manera bastante sencilla.</p>														
                  <img class="my-2.5" src="./src/assets/img/s1-05.jpg" width="" height="" alt=""/> 
                  
                  <p class="font-bold">Buscador de clima</p>
                  <p>Esta será nuestra primera aplicación que obtiene datos de una <span class="destacado">API externa</span>, como React Developer vas a trabajar en muchos proyectos que incluyen API's; estaremos viendo como validar y enviar peticiones hacia API, como leer las respuestas y como mostrar esa información. La parte de APIS es muy importante en el mundo de React.</p>							
                  <img class="my-2.5" src="./src/assets/img/s1-06.jpg" width="" height="" alt=""/> 
                  
                  <p class="font-bold">Cotizador de Criptomonedas</p>
                  <p>Este proyecto al igual que el anterior se conecta a una API para obtener el precio de una Criptomoneda en dólares, pesos mexicanos y otras monedas; Este proyecto incluye Zustand y Zod para validar las respuestas que obtenemos de nuestra API.</p>							
                  <!-- <img class="my-2.5" src="./src/assets/img/s1-07.jpg" width="" height="" alt=""/>  -->
    
                  <p>Proyecto 04: Migrar Carrito de Compras a useReducer: En este capítulo estaremos viendo como tomar el proyecto de carrito de compras y convertirlo hacia useReducer; cuando tomas un proyecto que conoces en una tecnología nueva es garantía que podrás entender mejor los conceptos.</p>
                  <p>Proyecto 05: Migrar Calculadora de Propinas hacia useReducer: Veamos como migrar nuestro otro proyecto hacia useReducer.</p>
    
    
                  <p>Proyecto 10: Buscador de Recetas: Este es nuestro primer proyecto que incluye múltiples páginas; lo estaremos realizando con React Router DOM la librería más popular para crear aplicaciones en React de múltiples página, este curso utiliza el Slice Pattern para tener múltiples Stores de Zustand!</p>
                  <p>Proyecto 11: Administrador de Productos: Este es nuestro primer proyecto Full Stack donde estaremos creando tanto frontend como backend utilizando el PERN (PostgreSQL, Node.js, Express y React) este proyecto utiliza una REST API que conectaremos con React, añadiremos temas más avanzados como Testing y Documentación de API's.</p>
                  <p>Proyecto 12: Administrador de Tareas y Proyectos: Este es el Proyecto más avanzado del curso, utiliza el MERN stack que es uno de los más populares hoy en día, este proyecto incluye un sistema robusto de autenticación y registro de usuarios con confirmación de cuentas y resetear el password en caso de olvidarlo; además incluye roles y los usuarios solo pueden realizar ciertas acciones. El curso incluye además una REST API bastante compleja y avanzada, El curso utiliza también React Query, Tailwindcss, React Router, Mongoose, Express, TypeScript y mucho más.</p>
                  <p>Proyecto 13: Quiosco de Comida: Finalizaremos este curso con una introducción a Next.js, utilizaremos la versión 14 con App Router, Server Actions, Prisma, Zod, Zustand, Tailwind, y mucho más, el proyecto incluye subida de archivos, CRUD Completo, paginador, buscador y más.</p>
    
                  
                </div><!-- Fin seccion colapsable interior  -->
    
              </div>
            </div><!--Fin row-->
            
            
            
            
            
            
            
            
            
            
            <!-- 
            <div class="row">
              <div class="col-12 pl-1.25">						
                
                <div class="flex items-center mt-1.25 cursor-pointer desplegable-interior justify-between oscuro" onclick="$('#seccionX-X').toggle();">	
                  <h3>XXXXXXXXXXXXXXXXXXXXXX</h3>			
                  <span class="cambiaicono ico_chevron_down_blanco ico20 mr-1.25" title=""></span>
                </div>						
                
                <div id="seccionX-X" class="hidden">	
                  
                  <p class="font-bold">XXXXXXXXXXXX</p>
                  <p>XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX</p>							
                  <img class="my-2.5" src="./src/assets/img/XXXX.jpg" width="" height="" alt=""/> 
    
                  
                  
                </div>
    
              </div> 
            </div>
            -->
            
            
            
            
            
            
            
              
            <div class="row">
              <div class="col-12">	
    
                
    
              </div>
            </div>
              
            
            
          </div>
          <!-- Fin div colapsable-->
      
      
        </div>
      </div>	
      <!-- FIN SECCION 1 -->	
    
    
      <!-- SECCION 00 -->
      <div class="w-[80%] max-sm:w-[96%] mx-auto bg-gray-200 mb-1.25 py-0.75 pr-0 pl-2.5 rounded-xl">
        <div class="row">
          <div class="flex items-center mt-1.25 cursor-pointer desplegable justify-between pointer" onclick="$('#seccion0').toggle();">
            <h2>Apuntes curso React</h2>
            <span class="cambiaicono ico_chevron_down mr-2.5" title=""></span>
          </div>

          <div id="seccion0" class="hidden">
            <div class="row">
              <div class="col-12">

                <p>Aprende React con TypeScript paso a paso creando proyectos del mundo real.</p>
          
                <p>Aprende React con proyectos del mundo real; Incluso si tus bases de JavaScript no son muy fuertes el curso tiene una introducción con todo lo que debes saber.</p>
                <p>En este curso aprenderemos a crear proyectos reales abarcando todo el ecosistema de React: State, Hooks, crear tus propios hooks, hooks avanzados, estado global, componentes y eventos, consultar API's externas y crear tus propias API's.</p>
                <p>Todos los Proyectos incluyen TypeScript desde el inicio.</p>	

              </div>
            </div><!--Fin row-->
          </div>
          <!-- Fin div colapsable-->

        </div>
      </div>
      <!-- FIN SECCION 00 -->
               
    
    </div>
      
  </body>
</html>
